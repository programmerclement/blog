function qI(n, e) {
    for (var t = 0; t < e.length; t++) {
        const i = e[t];
        if (typeof i != "string" && !Array.isArray(i)) {
            for (const r in i)
                if (r !== "default" && !(r in n)) {
                    const s = Object.getOwnPropertyDescriptor(i, r);
                    s && Object.defineProperty(n, r, s.get ? s : {
                        enumerable: !0,
                        get: ()=>i[r]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, {
        value: "Module"
    }))
}
(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const r of document.querySelectorAll('link[rel="modulepreload"]'))
        i(r);
    new MutationObserver(r=>{
        for (const s of r)
            if (s.type === "childList")
                for (const o of s.addedNodes)
                    o.tagName === "LINK" && o.rel === "modulepreload" && i(o)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function t(r) {
        const s = {};
        return r.integrity && (s.integrity = r.integrity),
        r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
        r.crossOrigin === "use-credentials" ? s.credentials = "include" : r.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin",
        s
    }
    function i(r) {
        if (r.ep)
            return;
        r.ep = !0;
        const s = t(r);
        fetch(r.href, s)
    }
}
)();
function zb(n) {
    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
}
function $I(n) {
    if (n.__esModule)
        return n;
    var e = n.default;
    if (typeof e == "function") {
        var t = function i() {
            if (this instanceof i) {
                var r = [null];
                r.push.apply(r, arguments);
                var s = Function.bind.apply(e, r);
                return new s
            }
            return e.apply(this, arguments)
        };
        t.prototype = e.prototype
    } else
        t = {};
    return Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    Object.keys(n).forEach(function(i) {
        var r = Object.getOwnPropertyDescriptor(n, i);
        Object.defineProperty(t, i, r.get ? r : {
            enumerable: !0,
            get: function() {
                return n[i]
            }
        })
    }),
    t
}
var Rf = {}
  , eD = {
    get exports() {
        return Rf
    },
    set exports(n) {
        Rf = n
    }
}
  , wg = {}
  , O = {}
  , tD = {
    get exports() {
        return O
    },
    set exports(n) {
        O = n
    }
}
  , wt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var vd = Symbol.for("react.element")
  , nD = Symbol.for("react.portal")
  , iD = Symbol.for("react.fragment")
  , rD = Symbol.for("react.strict_mode")
  , sD = Symbol.for("react.profiler")
  , oD = Symbol.for("react.provider")
  , aD = Symbol.for("react.context")
  , lD = Symbol.for("react.forward_ref")
  , uD = Symbol.for("react.suspense")
  , cD = Symbol.for("react.memo")
  , fD = Symbol.for("react.lazy")
  , gS = Symbol.iterator;
function dD(n) {
    return n === null || typeof n != "object" ? null : (n = gS && n[gS] || n["@@iterator"],
    typeof n == "function" ? n : null)
}
var Gb = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , Hb = Object.assign
  , Vb = {};
function Ku(n, e, t) {
    this.props = n,
    this.context = e,
    this.refs = Vb,
    this.updater = t || Gb
}
Ku.prototype.isReactComponent = {};
Ku.prototype.setState = function(n, e) {
    if (typeof n != "object" && typeof n != "function" && n != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, n, e, "setState")
}
;
Ku.prototype.forceUpdate = function(n) {
    this.updater.enqueueForceUpdate(this, n, "forceUpdate")
}
;
function Wb() {}
Wb.prototype = Ku.prototype;
function y_(n, e, t) {
    this.props = n,
    this.context = e,
    this.refs = Vb,
    this.updater = t || Gb
}
var v_ = y_.prototype = new Wb;
v_.constructor = y_;
Hb(v_, Ku.prototype);
v_.isPureReactComponent = !0;
var yS = Array.isArray
  , jb = Object.prototype.hasOwnProperty
  , x_ = {
    current: null
}
  , Jb = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function Xb(n, e, t) {
    var i, r = {}, s = null, o = null;
    if (e != null)
        for (i in e.ref !== void 0 && (o = e.ref),
        e.key !== void 0 && (s = "" + e.key),
        e)
            jb.call(e, i) && !Jb.hasOwnProperty(i) && (r[i] = e[i]);
    var a = arguments.length - 2;
    if (a === 1)
        r.children = t;
    else if (1 < a) {
        for (var l = Array(a), c = 0; c < a; c++)
            l[c] = arguments[c + 2];
        r.children = l
    }
    if (n && n.defaultProps)
        for (i in a = n.defaultProps,
        a)
            r[i] === void 0 && (r[i] = a[i]);
    return {
        $$typeof: vd,
        type: n,
        key: s,
        ref: o,
        props: r,
        _owner: x_.current
    }
}
function hD(n, e) {
    return {
        $$typeof: vd,
        type: n.type,
        key: e,
        ref: n.ref,
        props: n.props,
        _owner: n._owner
    }
}
function __(n) {
    return typeof n == "object" && n !== null && n.$$typeof === vd
}
function pD(n) {
    var e = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + n.replace(/[=:]/g, function(t) {
        return e[t]
    })
}
var vS = /\/+/g;
function My(n, e) {
    return typeof n == "object" && n !== null && n.key != null ? pD("" + n.key) : e.toString(36)
}
function um(n, e, t, i, r) {
    var s = typeof n;
    (s === "undefined" || s === "boolean") && (n = null);
    var o = !1;
    if (n === null)
        o = !0;
    else
        switch (s) {
        case "string":
        case "number":
            o = !0;
            break;
        case "object":
            switch (n.$$typeof) {
            case vd:
            case nD:
                o = !0
            }
        }
    if (o)
        return o = n,
        r = r(o),
        n = i === "" ? "." + My(o, 0) : i,
        yS(r) ? (t = "",
        n != null && (t = n.replace(vS, "$&/") + "/"),
        um(r, e, t, "", function(c) {
            return c
        })) : r != null && (__(r) && (r = hD(r, t + (!r.key || o && o.key === r.key ? "" : ("" + r.key).replace(vS, "$&/") + "/") + n)),
        e.push(r)),
        1;
    if (o = 0,
    i = i === "" ? "." : i + ":",
    yS(n))
        for (var a = 0; a < n.length; a++) {
            s = n[a];
            var l = i + My(s, a);
            o += um(s, e, t, l, r)
        }
    else if (l = dD(n),
    typeof l == "function")
        for (n = l.call(n),
        a = 0; !(s = n.next()).done; )
            s = s.value,
            l = i + My(s, a++),
            o += um(s, e, t, l, r);
    else if (s === "object")
        throw e = String(n),
        Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
    return o
}
function Yh(n, e, t) {
    if (n == null)
        return n;
    var i = []
      , r = 0;
    return um(n, i, "", "", function(s) {
        return e.call(t, s, r++)
    }),
    i
}
function mD(n) {
    if (n._status === -1) {
        var e = n._result;
        e = e(),
        e.then(function(t) {
            (n._status === 0 || n._status === -1) && (n._status = 1,
            n._result = t)
        }, function(t) {
            (n._status === 0 || n._status === -1) && (n._status = 2,
            n._result = t)
        }),
        n._status === -1 && (n._status = 0,
        n._result = e)
    }
    if (n._status === 1)
        return n._result.default;
    throw n._result
}
var gi = {
    current: null
}
  , cm = {
    transition: null
}
  , gD = {
    ReactCurrentDispatcher: gi,
    ReactCurrentBatchConfig: cm,
    ReactCurrentOwner: x_
};
wt.Children = {
    map: Yh,
    forEach: function(n, e, t) {
        Yh(n, function() {
            e.apply(this, arguments)
        }, t)
    },
    count: function(n) {
        var e = 0;
        return Yh(n, function() {
            e++
        }),
        e
    },
    toArray: function(n) {
        return Yh(n, function(e) {
            return e
        }) || []
    },
    only: function(n) {
        if (!__(n))
            throw Error("React.Children.only expected to receive a single React element child.");
        return n
    }
};
wt.Component = Ku;
wt.Fragment = iD;
wt.Profiler = sD;
wt.PureComponent = y_;
wt.StrictMode = rD;
wt.Suspense = uD;
wt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = gD;
wt.cloneElement = function(n, e, t) {
    if (n == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + n + ".");
    var i = Hb({}, n.props)
      , r = n.key
      , s = n.ref
      , o = n._owner;
    if (e != null) {
        if (e.ref !== void 0 && (s = e.ref,
        o = x_.current),
        e.key !== void 0 && (r = "" + e.key),
        n.type && n.type.defaultProps)
            var a = n.type.defaultProps;
        for (l in e)
            jb.call(e, l) && !Jb.hasOwnProperty(l) && (i[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l])
    }
    var l = arguments.length - 2;
    if (l === 1)
        i.children = t;
    else if (1 < l) {
        a = Array(l);
        for (var c = 0; c < l; c++)
            a[c] = arguments[c + 2];
        i.children = a
    }
    return {
        $$typeof: vd,
        type: n.type,
        key: r,
        ref: s,
        props: i,
        _owner: o
    }
}
;
wt.createContext = function(n) {
    return n = {
        $$typeof: aD,
        _currentValue: n,
        _currentValue2: n,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    n.Provider = {
        $$typeof: oD,
        _context: n
    },
    n.Consumer = n
}
;
wt.createElement = Xb;
wt.createFactory = function(n) {
    var e = Xb.bind(null, n);
    return e.type = n,
    e
}
;
wt.createRef = function() {
    return {
        current: null
    }
}
;
wt.forwardRef = function(n) {
    return {
        $$typeof: lD,
        render: n
    }
}
;
wt.isValidElement = __;
wt.lazy = function(n) {
    return {
        $$typeof: fD,
        _payload: {
            _status: -1,
            _result: n
        },
        _init: mD
    }
}
;
wt.memo = function(n, e) {
    return {
        $$typeof: cD,
        type: n,
        compare: e === void 0 ? null : e
    }
}
;
wt.startTransition = function(n) {
    var e = cm.transition;
    cm.transition = {};
    try {
        n()
    } finally {
        cm.transition = e
    }
}
;
wt.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.")
}
;
wt.useCallback = function(n, e) {
    return gi.current.useCallback(n, e)
}
;
wt.useContext = function(n) {
    return gi.current.useContext(n)
}
;
wt.useDebugValue = function() {}
;
wt.useDeferredValue = function(n) {
    return gi.current.useDeferredValue(n)
}
;
wt.useEffect = function(n, e) {
    return gi.current.useEffect(n, e)
}
;
wt.useId = function() {
    return gi.current.useId()
}
;
wt.useImperativeHandle = function(n, e, t) {
    return gi.current.useImperativeHandle(n, e, t)
}
;
wt.useInsertionEffect = function(n, e) {
    return gi.current.useInsertionEffect(n, e)
}
;
wt.useLayoutEffect = function(n, e) {
    return gi.current.useLayoutEffect(n, e)
}
;
wt.useMemo = function(n, e) {
    return gi.current.useMemo(n, e)
}
;
wt.useReducer = function(n, e, t) {
    return gi.current.useReducer(n, e, t)
}
;
wt.useRef = function(n) {
    return gi.current.useRef(n)
}
;
wt.useState = function(n) {
    return gi.current.useState(n)
}
;
wt.useSyncExternalStore = function(n, e, t) {
    return gi.current.useSyncExternalStore(n, e, t)
}
;
wt.useTransition = function() {
    return gi.current.useTransition()
}
;
wt.version = "18.2.0";
(function(n) {
    n.exports = wt
}
)(tD);
const lt = zb(O)
  , $v = qI({
    __proto__: null,
    default: lt
}, [O]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yD = O
  , vD = Symbol.for("react.element")
  , xD = Symbol.for("react.fragment")
  , _D = Object.prototype.hasOwnProperty
  , AD = yD.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , MD = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function Kb(n, e, t) {
    var i, r = {}, s = null, o = null;
    t !== void 0 && (s = "" + t),
    e.key !== void 0 && (s = "" + e.key),
    e.ref !== void 0 && (o = e.ref);
    for (i in e)
        _D.call(e, i) && !MD.hasOwnProperty(i) && (r[i] = e[i]);
    if (n && n.defaultProps)
        for (i in e = n.defaultProps,
        e)
            r[i] === void 0 && (r[i] = e[i]);
    return {
        $$typeof: vD,
        type: n,
        key: s,
        ref: o,
        props: r,
        _owner: AD.current
    }
}
wg.Fragment = xD;
wg.jsx = Kb;
wg.jsxs = Kb;
(function(n) {
    n.exports = wg
}
)(eD);
const xd = Rf.Fragment
  , xe = Rf.jsx
  , ut = Rf.jsxs;
var ex = {}
  , tx = {}
  , wD = {
    get exports() {
        return tx
    },
    set exports(n) {
        tx = n
    }
}
  , Xi = {}
  , nx = {}
  , SD = {
    get exports() {
        return nx
    },
    set exports(n) {
        nx = n
    }
}
  , Yb = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(n) {
    function e(F, V) {
        var j = F.length;
        F.push(V);
        e: for (; 0 < j; ) {
            var re = j - 1 >>> 1
              , H = F[re];
            if (0 < r(H, V))
                F[re] = V,
                F[j] = H,
                j = re;
            else
                break e
        }
    }
    function t(F) {
        return F.length === 0 ? null : F[0]
    }
    function i(F) {
        if (F.length === 0)
            return null;
        var V = F[0]
          , j = F.pop();
        if (j !== V) {
            F[0] = j;
            e: for (var re = 0, H = F.length, se = H >>> 1; re < se; ) {
                var ye = 2 * (re + 1) - 1
                  , ve = F[ye]
                  , q = ye + 1
                  , Ie = F[q];
                if (0 > r(ve, j))
                    q < H && 0 > r(Ie, ve) ? (F[re] = Ie,
                    F[q] = j,
                    re = q) : (F[re] = ve,
                    F[ye] = j,
                    re = ye);
                else if (q < H && 0 > r(Ie, j))
                    F[re] = Ie,
                    F[q] = j,
                    re = q;
                else
                    break e
            }
        }
        return V
    }
    function r(F, V) {
        var j = F.sortIndex - V.sortIndex;
        return j !== 0 ? j : F.id - V.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        n.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date
          , a = o.now();
        n.unstable_now = function() {
            return o.now() - a
        }
    }
    var l = []
      , c = []
      , d = 1
      , h = null
      , p = 3
      , m = !1
      , y = !1
      , v = !1
      , _ = typeof setTimeout == "function" ? setTimeout : null
      , x = typeof clearTimeout == "function" ? clearTimeout : null
      , A = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function M(F) {
        for (var V = t(c); V !== null; ) {
            if (V.callback === null)
                i(c);
            else if (V.startTime <= F)
                i(c),
                V.sortIndex = V.expirationTime,
                e(l, V);
            else
                break;
            V = t(c)
        }
    }
    function S(F) {
        if (v = !1,
        M(F),
        !y)
            if (t(l) !== null)
                y = !0,
                ee(T);
            else {
                var V = t(c);
                V !== null && ie(S, V.startTime - F)
            }
    }
    function T(F, V) {
        y = !1,
        v && (v = !1,
        x(E),
        E = -1),
        m = !0;
        var j = p;
        try {
            for (M(V),
            h = t(l); h !== null && (!(h.expirationTime > V) || F && !z()); ) {
                var re = h.callback;
                if (typeof re == "function") {
                    h.callback = null,
                    p = h.priorityLevel;
                    var H = re(h.expirationTime <= V);
                    V = n.unstable_now(),
                    typeof H == "function" ? h.callback = H : h === t(l) && i(l),
                    M(V)
                } else
                    i(l);
                h = t(l)
            }
            if (h !== null)
                var se = !0;
            else {
                var ye = t(c);
                ye !== null && ie(S, ye.startTime - V),
                se = !1
            }
            return se
        } finally {
            h = null,
            p = j,
            m = !1
        }
    }
    var P = !1
      , R = null
      , E = -1
      , B = 5
      , L = -1;
    function z() {
        return !(n.unstable_now() - L < B)
    }
    function Z() {
        if (R !== null) {
            var F = n.unstable_now();
            L = F;
            var V = !0;
            try {
                V = R(!0, F)
            } finally {
                V ? J() : (P = !1,
                R = null)
            }
        } else
            P = !1
    }
    var J;
    if (typeof A == "function")
        J = function() {
            A(Z)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var G = new MessageChannel
          , X = G.port2;
        G.port1.onmessage = Z,
        J = function() {
            X.postMessage(null)
        }
    } else
        J = function() {
            _(Z, 0)
        }
        ;
    function ee(F) {
        R = F,
        P || (P = !0,
        J())
    }
    function ie(F, V) {
        E = _(function() {
            F(n.unstable_now())
        }, V)
    }
    n.unstable_IdlePriority = 5,
    n.unstable_ImmediatePriority = 1,
    n.unstable_LowPriority = 4,
    n.unstable_NormalPriority = 3,
    n.unstable_Profiling = null,
    n.unstable_UserBlockingPriority = 2,
    n.unstable_cancelCallback = function(F) {
        F.callback = null
    }
    ,
    n.unstable_continueExecution = function() {
        y || m || (y = !0,
        ee(T))
    }
    ,
    n.unstable_forceFrameRate = function(F) {
        0 > F || 125 < F ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : B = 0 < F ? Math.floor(1e3 / F) : 5
    }
    ,
    n.unstable_getCurrentPriorityLevel = function() {
        return p
    }
    ,
    n.unstable_getFirstCallbackNode = function() {
        return t(l)
    }
    ,
    n.unstable_next = function(F) {
        switch (p) {
        case 1:
        case 2:
        case 3:
            var V = 3;
            break;
        default:
            V = p
        }
        var j = p;
        p = V;
        try {
            return F()
        } finally {
            p = j
        }
    }
    ,
    n.unstable_pauseExecution = function() {}
    ,
    n.unstable_requestPaint = function() {}
    ,
    n.unstable_runWithPriority = function(F, V) {
        switch (F) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            F = 3
        }
        var j = p;
        p = F;
        try {
            return V()
        } finally {
            p = j
        }
    }
    ,
    n.unstable_scheduleCallback = function(F, V, j) {
        var re = n.unstable_now();
        switch (typeof j == "object" && j !== null ? (j = j.delay,
        j = typeof j == "number" && 0 < j ? re + j : re) : j = re,
        F) {
        case 1:
            var H = -1;
            break;
        case 2:
            H = 250;
            break;
        case 5:
            H = 1073741823;
            break;
        case 4:
            H = 1e4;
            break;
        default:
            H = 5e3
        }
        return H = j + H,
        F = {
            id: d++,
            callback: V,
            priorityLevel: F,
            startTime: j,
            expirationTime: H,
            sortIndex: -1
        },
        j > re ? (F.sortIndex = j,
        e(c, F),
        t(l) === null && F === t(c) && (v ? (x(E),
        E = -1) : v = !0,
        ie(S, j - re))) : (F.sortIndex = H,
        e(l, F),
        y || m || (y = !0,
        ee(T))),
        F
    }
    ,
    n.unstable_shouldYield = z,
    n.unstable_wrapCallback = function(F) {
        var V = p;
        return function() {
            var j = p;
            p = V;
            try {
                return F.apply(this, arguments)
            } finally {
                p = j
            }
        }
    }
}
)(Yb);
(function(n) {
    n.exports = Yb
}
)(SD);
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Qb = O
  , Wi = nx;
function Se(n) {
    for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, t = 1; t < arguments.length; t++)
        e += "&args[]=" + encodeURIComponent(arguments[t]);
    return "Minified React error #" + n + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var Zb = new Set
  , Lf = {};
function cl(n, e) {
    Pu(n, e),
    Pu(n + "Capture", e)
}
function Pu(n, e) {
    for (Lf[n] = e,
    n = 0; n < e.length; n++)
        Zb.add(e[n])
}
var Hs = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , ix = Object.prototype.hasOwnProperty
  , CD = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , xS = {}
  , _S = {};
function ED(n) {
    return ix.call(_S, n) ? !0 : ix.call(xS, n) ? !1 : CD.test(n) ? _S[n] = !0 : (xS[n] = !0,
    !1)
}
function TD(n, e, t, i) {
    if (t !== null && t.type === 0)
        return !1;
    switch (typeof e) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return i ? !1 : t !== null ? !t.acceptsBooleans : (n = n.toLowerCase().slice(0, 5),
        n !== "data-" && n !== "aria-");
    default:
        return !1
    }
}
function bD(n, e, t, i) {
    if (e === null || typeof e > "u" || TD(n, e, t, i))
        return !0;
    if (i)
        return !1;
    if (t !== null)
        switch (t.type) {
        case 3:
            return !e;
        case 4:
            return e === !1;
        case 5:
            return isNaN(e);
        case 6:
            return isNaN(e) || 1 > e
        }
    return !1
}
function yi(n, e, t, i, r, s, o) {
    this.acceptsBooleans = e === 2 || e === 3 || e === 4,
    this.attributeName = i,
    this.attributeNamespace = r,
    this.mustUseProperty = t,
    this.propertyName = n,
    this.type = e,
    this.sanitizeURL = s,
    this.removeEmptyString = o
}
var Jn = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(n) {
    Jn[n] = new yi(n,0,!1,n,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(n) {
    var e = n[0];
    Jn[e] = new yi(e,1,!1,n[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(n) {
    Jn[n] = new yi(n,2,!1,n.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(n) {
    Jn[n] = new yi(n,2,!1,n,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(n) {
    Jn[n] = new yi(n,3,!1,n.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(n) {
    Jn[n] = new yi(n,3,!0,n,null,!1,!1)
});
["capture", "download"].forEach(function(n) {
    Jn[n] = new yi(n,4,!1,n,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(n) {
    Jn[n] = new yi(n,6,!1,n,null,!1,!1)
});
["rowSpan", "start"].forEach(function(n) {
    Jn[n] = new yi(n,5,!1,n.toLowerCase(),null,!1,!1)
});
var A_ = /[\-:]([a-z])/g;
function M_(n) {
    return n[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(n) {
    var e = n.replace(A_, M_);
    Jn[e] = new yi(e,1,!1,n,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(n) {
    var e = n.replace(A_, M_);
    Jn[e] = new yi(e,1,!1,n,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(n) {
    var e = n.replace(A_, M_);
    Jn[e] = new yi(e,1,!1,n,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(n) {
    Jn[n] = new yi(n,1,!1,n.toLowerCase(),null,!1,!1)
});
Jn.xlinkHref = new yi("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(n) {
    Jn[n] = new yi(n,1,!1,n.toLowerCase(),null,!0,!0)
});
function w_(n, e, t, i) {
    var r = Jn.hasOwnProperty(e) ? Jn[e] : null;
    (r !== null ? r.type !== 0 : i || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (bD(e, t, r, i) && (t = null),
    i || r === null ? ED(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t)) : r.mustUseProperty ? n[r.propertyName] = t === null ? r.type === 3 ? !1 : "" : t : (e = r.attributeName,
    i = r.attributeNamespace,
    t === null ? n.removeAttribute(e) : (r = r.type,
    t = r === 3 || r === 4 && t === !0 ? "" : "" + t,
    i ? n.setAttributeNS(i, e, t) : n.setAttribute(e, t))))
}
var Ys = Qb.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , Qh = Symbol.for("react.element")
  , tu = Symbol.for("react.portal")
  , nu = Symbol.for("react.fragment")
  , S_ = Symbol.for("react.strict_mode")
  , rx = Symbol.for("react.profiler")
  , qb = Symbol.for("react.provider")
  , $b = Symbol.for("react.context")
  , C_ = Symbol.for("react.forward_ref")
  , sx = Symbol.for("react.suspense")
  , ox = Symbol.for("react.suspense_list")
  , E_ = Symbol.for("react.memo")
  , vo = Symbol.for("react.lazy")
  , e2 = Symbol.for("react.offscreen")
  , AS = Symbol.iterator;
function Ec(n) {
    return n === null || typeof n != "object" ? null : (n = AS && n[AS] || n["@@iterator"],
    typeof n == "function" ? n : null)
}
var an = Object.assign, wy;
function sf(n) {
    if (wy === void 0)
        try {
            throw Error()
        } catch (t) {
            var e = t.stack.trim().match(/\n( *(at )?)/);
            wy = e && e[1] || ""
        }
    return `
` + wy + n
}
var Sy = !1;
function Cy(n, e) {
    if (!n || Sy)
        return "";
    Sy = !0;
    var t = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (e)
            if (e = function() {
                throw Error()
            }
            ,
            Object.defineProperty(e.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(e, [])
                } catch (c) {
                    var i = c
                }
                Reflect.construct(n, [], e)
            } else {
                try {
                    e.call()
                } catch (c) {
                    i = c
                }
                n.call(e.prototype)
            }
        else {
            try {
                throw Error()
            } catch (c) {
                i = c
            }
            n()
        }
    } catch (c) {
        if (c && i && typeof c.stack == "string") {
            for (var r = c.stack.split(`
`), s = i.stack.split(`
`), o = r.length - 1, a = s.length - 1; 1 <= o && 0 <= a && r[o] !== s[a]; )
                a--;
            for (; 1 <= o && 0 <= a; o--,
            a--)
                if (r[o] !== s[a]) {
                    if (o !== 1 || a !== 1)
                        do
                            if (o--,
                            a--,
                            0 > a || r[o] !== s[a]) {
                                var l = `
` + r[o].replace(" at new ", " at ");
                                return n.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", n.displayName)),
                                l
                            }
                        while (1 <= o && 0 <= a);
                    break
                }
        }
    } finally {
        Sy = !1,
        Error.prepareStackTrace = t
    }
    return (n = n ? n.displayName || n.name : "") ? sf(n) : ""
}
function PD(n) {
    switch (n.tag) {
    case 5:
        return sf(n.type);
    case 16:
        return sf("Lazy");
    case 13:
        return sf("Suspense");
    case 19:
        return sf("SuspenseList");
    case 0:
    case 2:
    case 15:
        return n = Cy(n.type, !1),
        n;
    case 11:
        return n = Cy(n.type.render, !1),
        n;
    case 1:
        return n = Cy(n.type, !0),
        n;
    default:
        return ""
    }
}
function ax(n) {
    if (n == null)
        return null;
    if (typeof n == "function")
        return n.displayName || n.name || null;
    if (typeof n == "string")
        return n;
    switch (n) {
    case nu:
        return "Fragment";
    case tu:
        return "Portal";
    case rx:
        return "Profiler";
    case S_:
        return "StrictMode";
    case sx:
        return "Suspense";
    case ox:
        return "SuspenseList"
    }
    if (typeof n == "object")
        switch (n.$$typeof) {
        case $b:
            return (n.displayName || "Context") + ".Consumer";
        case qb:
            return (n._context.displayName || "Context") + ".Provider";
        case C_:
            var e = n.render;
            return n = n.displayName,
            n || (n = e.displayName || e.name || "",
            n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"),
            n;
        case E_:
            return e = n.displayName || null,
            e !== null ? e : ax(n.type) || "Memo";
        case vo:
            e = n._payload,
            n = n._init;
            try {
                return ax(n(e))
            } catch {}
        }
    return null
}
function BD(n) {
    var e = n.type;
    switch (n.tag) {
    case 24:
        return "Cache";
    case 9:
        return (e.displayName || "Context") + ".Consumer";
    case 10:
        return (e._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return n = e.render,
        n = n.displayName || n.name || "",
        e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return e;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return ax(e);
    case 8:
        return e === S_ ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof e == "function")
            return e.displayName || e.name || null;
        if (typeof e == "string")
            return e
    }
    return null
}
function Go(n) {
    switch (typeof n) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return n;
    case "object":
        return n;
    default:
        return ""
    }
}
function t2(n) {
    var e = n.type;
    return (n = n.nodeName) && n.toLowerCase() === "input" && (e === "checkbox" || e === "radio")
}
function RD(n) {
    var e = t2(n) ? "checked" : "value"
      , t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e)
      , i = "" + n[e];
    if (!n.hasOwnProperty(e) && typeof t < "u" && typeof t.get == "function" && typeof t.set == "function") {
        var r = t.get
          , s = t.set;
        return Object.defineProperty(n, e, {
            configurable: !0,
            get: function() {
                return r.call(this)
            },
            set: function(o) {
                i = "" + o,
                s.call(this, o)
            }
        }),
        Object.defineProperty(n, e, {
            enumerable: t.enumerable
        }),
        {
            getValue: function() {
                return i
            },
            setValue: function(o) {
                i = "" + o
            },
            stopTracking: function() {
                n._valueTracker = null,
                delete n[e]
            }
        }
    }
}
function Zh(n) {
    n._valueTracker || (n._valueTracker = RD(n))
}
function n2(n) {
    if (!n)
        return !1;
    var e = n._valueTracker;
    if (!e)
        return !0;
    var t = e.getValue()
      , i = "";
    return n && (i = t2(n) ? n.checked ? "true" : "false" : n.value),
    n = i,
    n !== t ? (e.setValue(n),
    !0) : !1
}
function Im(n) {
    if (n = n || (typeof document < "u" ? document : void 0),
    typeof n > "u")
        return null;
    try {
        return n.activeElement || n.body
    } catch {
        return n.body
    }
}
function lx(n, e) {
    var t = e.checked;
    return an({}, e, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: t ?? n._wrapperState.initialChecked
    })
}
function MS(n, e) {
    var t = e.defaultValue == null ? "" : e.defaultValue
      , i = e.checked != null ? e.checked : e.defaultChecked;
    t = Go(e.value != null ? e.value : t),
    n._wrapperState = {
        initialChecked: i,
        initialValue: t,
        controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
    }
}
function i2(n, e) {
    e = e.checked,
    e != null && w_(n, "checked", e, !1)
}
function ux(n, e) {
    i2(n, e);
    var t = Go(e.value)
      , i = e.type;
    if (t != null)
        i === "number" ? (t === 0 && n.value === "" || n.value != t) && (n.value = "" + t) : n.value !== "" + t && (n.value = "" + t);
    else if (i === "submit" || i === "reset") {
        n.removeAttribute("value");
        return
    }
    e.hasOwnProperty("value") ? cx(n, e.type, t) : e.hasOwnProperty("defaultValue") && cx(n, e.type, Go(e.defaultValue)),
    e.checked == null && e.defaultChecked != null && (n.defaultChecked = !!e.defaultChecked)
}
function wS(n, e, t) {
    if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
        var i = e.type;
        if (!(i !== "submit" && i !== "reset" || e.value !== void 0 && e.value !== null))
            return;
        e = "" + n._wrapperState.initialValue,
        t || e === n.value || (n.value = e),
        n.defaultValue = e
    }
    t = n.name,
    t !== "" && (n.name = ""),
    n.defaultChecked = !!n._wrapperState.initialChecked,
    t !== "" && (n.name = t)
}
function cx(n, e, t) {
    (e !== "number" || Im(n.ownerDocument) !== n) && (t == null ? n.defaultValue = "" + n._wrapperState.initialValue : n.defaultValue !== "" + t && (n.defaultValue = "" + t))
}
var of = Array.isArray;
function _u(n, e, t, i) {
    if (n = n.options,
    e) {
        e = {};
        for (var r = 0; r < t.length; r++)
            e["$" + t[r]] = !0;
        for (t = 0; t < n.length; t++)
            r = e.hasOwnProperty("$" + n[t].value),
            n[t].selected !== r && (n[t].selected = r),
            r && i && (n[t].defaultSelected = !0)
    } else {
        for (t = "" + Go(t),
        e = null,
        r = 0; r < n.length; r++) {
            if (n[r].value === t) {
                n[r].selected = !0,
                i && (n[r].defaultSelected = !0);
                return
            }
            e !== null || n[r].disabled || (e = n[r])
        }
        e !== null && (e.selected = !0)
    }
}
function fx(n, e) {
    if (e.dangerouslySetInnerHTML != null)
        throw Error(Se(91));
    return an({}, e, {
        value: void 0,
        defaultValue: void 0,
        children: "" + n._wrapperState.initialValue
    })
}
function SS(n, e) {
    var t = e.value;
    if (t == null) {
        if (t = e.children,
        e = e.defaultValue,
        t != null) {
            if (e != null)
                throw Error(Se(92));
            if (of(t)) {
                if (1 < t.length)
                    throw Error(Se(93));
                t = t[0]
            }
            e = t
        }
        e == null && (e = ""),
        t = e
    }
    n._wrapperState = {
        initialValue: Go(t)
    }
}
function r2(n, e) {
    var t = Go(e.value)
      , i = Go(e.defaultValue);
    t != null && (t = "" + t,
    t !== n.value && (n.value = t),
    e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)),
    i != null && (n.defaultValue = "" + i)
}
function CS(n) {
    var e = n.textContent;
    e === n._wrapperState.initialValue && e !== "" && e !== null && (n.value = e)
}
function s2(n) {
    switch (n) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function dx(n, e) {
    return n == null || n === "http://www.w3.org/1999/xhtml" ? s2(e) : n === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : n
}
var qh, o2 = function(n) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, t, i, r) {
        MSApp.execUnsafeLocalFunction(function() {
            return n(e, t, i, r)
        })
    }
    : n
}(function(n, e) {
    if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in n)
        n.innerHTML = e;
    else {
        for (qh = qh || document.createElement("div"),
        qh.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
        e = qh.firstChild; n.firstChild; )
            n.removeChild(n.firstChild);
        for (; e.firstChild; )
            n.appendChild(e.firstChild)
    }
});
function If(n, e) {
    if (e) {
        var t = n.firstChild;
        if (t && t === n.lastChild && t.nodeType === 3) {
            t.nodeValue = e;
            return
        }
    }
    n.textContent = e
}
var ff = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , LD = ["Webkit", "ms", "Moz", "O"];
Object.keys(ff).forEach(function(n) {
    LD.forEach(function(e) {
        e = e + n.charAt(0).toUpperCase() + n.substring(1),
        ff[e] = ff[n]
    })
});
function a2(n, e, t) {
    return e == null || typeof e == "boolean" || e === "" ? "" : t || typeof e != "number" || e === 0 || ff.hasOwnProperty(n) && ff[n] ? ("" + e).trim() : e + "px"
}
function l2(n, e) {
    n = n.style;
    for (var t in e)
        if (e.hasOwnProperty(t)) {
            var i = t.indexOf("--") === 0
              , r = a2(t, e[t], i);
            t === "float" && (t = "cssFloat"),
            i ? n.setProperty(t, r) : n[t] = r
        }
}
var ID = an({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function hx(n, e) {
    if (e) {
        if (ID[n] && (e.children != null || e.dangerouslySetInnerHTML != null))
            throw Error(Se(137, n));
        if (e.dangerouslySetInnerHTML != null) {
            if (e.children != null)
                throw Error(Se(60));
            if (typeof e.dangerouslySetInnerHTML != "object" || !("__html"in e.dangerouslySetInnerHTML))
                throw Error(Se(61))
        }
        if (e.style != null && typeof e.style != "object")
            throw Error(Se(62))
    }
}
function px(n, e) {
    if (n.indexOf("-") === -1)
        return typeof e.is == "string";
    switch (n) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var mx = null;
function T_(n) {
    return n = n.target || n.srcElement || window,
    n.correspondingUseElement && (n = n.correspondingUseElement),
    n.nodeType === 3 ? n.parentNode : n
}
var gx = null
  , Au = null
  , Mu = null;
function ES(n) {
    if (n = Md(n)) {
        if (typeof gx != "function")
            throw Error(Se(280));
        var e = n.stateNode;
        e && (e = bg(e),
        gx(n.stateNode, n.type, e))
    }
}
function u2(n) {
    Au ? Mu ? Mu.push(n) : Mu = [n] : Au = n
}
function c2() {
    if (Au) {
        var n = Au
          , e = Mu;
        if (Mu = Au = null,
        ES(n),
        e)
            for (n = 0; n < e.length; n++)
                ES(e[n])
    }
}
function f2(n, e) {
    return n(e)
}
function d2() {}
var Ey = !1;
function h2(n, e, t) {
    if (Ey)
        return n(e, t);
    Ey = !0;
    try {
        return f2(n, e, t)
    } finally {
        Ey = !1,
        (Au !== null || Mu !== null) && (d2(),
        c2())
    }
}
function Df(n, e) {
    var t = n.stateNode;
    if (t === null)
        return null;
    var i = bg(t);
    if (i === null)
        return null;
    t = i[e];
    e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (i = !i.disabled) || (n = n.type,
        i = !(n === "button" || n === "input" || n === "select" || n === "textarea")),
        n = !i;
        break e;
    default:
        n = !1
    }
    if (n)
        return null;
    if (t && typeof t != "function")
        throw Error(Se(231, e, typeof t));
    return t
}
var yx = !1;
if (Hs)
    try {
        var Tc = {};
        Object.defineProperty(Tc, "passive", {
            get: function() {
                yx = !0
            }
        }),
        window.addEventListener("test", Tc, Tc),
        window.removeEventListener("test", Tc, Tc)
    } catch {
        yx = !1
    }
function DD(n, e, t, i, r, s, o, a, l) {
    var c = Array.prototype.slice.call(arguments, 3);
    try {
        e.apply(t, c)
    } catch (d) {
        this.onError(d)
    }
}
var df = !1
  , Dm = null
  , Fm = !1
  , vx = null
  , FD = {
    onError: function(n) {
        df = !0,
        Dm = n
    }
};
function kD(n, e, t, i, r, s, o, a, l) {
    df = !1,
    Dm = null,
    DD.apply(FD, arguments)
}
function ND(n, e, t, i, r, s, o, a, l) {
    if (kD.apply(this, arguments),
    df) {
        if (df) {
            var c = Dm;
            df = !1,
            Dm = null
        } else
            throw Error(Se(198));
        Fm || (Fm = !0,
        vx = c)
    }
}
function fl(n) {
    var e = n
      , t = n;
    if (n.alternate)
        for (; e.return; )
            e = e.return;
    else {
        n = e;
        do
            e = n,
            e.flags & 4098 && (t = e.return),
            n = e.return;
        while (n)
    }
    return e.tag === 3 ? t : null
}
function p2(n) {
    if (n.tag === 13) {
        var e = n.memoizedState;
        if (e === null && (n = n.alternate,
        n !== null && (e = n.memoizedState)),
        e !== null)
            return e.dehydrated
    }
    return null
}
function TS(n) {
    if (fl(n) !== n)
        throw Error(Se(188))
}
function OD(n) {
    var e = n.alternate;
    if (!e) {
        if (e = fl(n),
        e === null)
            throw Error(Se(188));
        return e !== n ? null : n
    }
    for (var t = n, i = e; ; ) {
        var r = t.return;
        if (r === null)
            break;
        var s = r.alternate;
        if (s === null) {
            if (i = r.return,
            i !== null) {
                t = i;
                continue
            }
            break
        }
        if (r.child === s.child) {
            for (s = r.child; s; ) {
                if (s === t)
                    return TS(r),
                    n;
                if (s === i)
                    return TS(r),
                    e;
                s = s.sibling
            }
            throw Error(Se(188))
        }
        if (t.return !== i.return)
            t = r,
            i = s;
        else {
            for (var o = !1, a = r.child; a; ) {
                if (a === t) {
                    o = !0,
                    t = r,
                    i = s;
                    break
                }
                if (a === i) {
                    o = !0,
                    i = r,
                    t = s;
                    break
                }
                a = a.sibling
            }
            if (!o) {
                for (a = s.child; a; ) {
                    if (a === t) {
                        o = !0,
                        t = s,
                        i = r;
                        break
                    }
                    if (a === i) {
                        o = !0,
                        i = s,
                        t = r;
                        break
                    }
                    a = a.sibling
                }
                if (!o)
                    throw Error(Se(189))
            }
        }
        if (t.alternate !== i)
            throw Error(Se(190))
    }
    if (t.tag !== 3)
        throw Error(Se(188));
    return t.stateNode.current === t ? n : e
}
function m2(n) {
    return n = OD(n),
    n !== null ? g2(n) : null
}
function g2(n) {
    if (n.tag === 5 || n.tag === 6)
        return n;
    for (n = n.child; n !== null; ) {
        var e = g2(n);
        if (e !== null)
            return e;
        n = n.sibling
    }
    return null
}
var y2 = Wi.unstable_scheduleCallback
  , bS = Wi.unstable_cancelCallback
  , UD = Wi.unstable_shouldYield
  , zD = Wi.unstable_requestPaint
  , yn = Wi.unstable_now
  , GD = Wi.unstable_getCurrentPriorityLevel
  , b_ = Wi.unstable_ImmediatePriority
  , v2 = Wi.unstable_UserBlockingPriority
  , km = Wi.unstable_NormalPriority
  , HD = Wi.unstable_LowPriority
  , x2 = Wi.unstable_IdlePriority
  , Sg = null
  , ns = null;
function VD(n) {
    if (ns && typeof ns.onCommitFiberRoot == "function")
        try {
            ns.onCommitFiberRoot(Sg, n, void 0, (n.current.flags & 128) === 128)
        } catch {}
}
var Dr = Math.clz32 ? Math.clz32 : JD
  , WD = Math.log
  , jD = Math.LN2;
function JD(n) {
    return n >>>= 0,
    n === 0 ? 32 : 31 - (WD(n) / jD | 0) | 0
}
var $h = 64
  , ep = 4194304;
function af(n) {
    switch (n & -n) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return n & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return n & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return n
    }
}
function Nm(n, e) {
    var t = n.pendingLanes;
    if (t === 0)
        return 0;
    var i = 0
      , r = n.suspendedLanes
      , s = n.pingedLanes
      , o = t & 268435455;
    if (o !== 0) {
        var a = o & ~r;
        a !== 0 ? i = af(a) : (s &= o,
        s !== 0 && (i = af(s)))
    } else
        o = t & ~r,
        o !== 0 ? i = af(o) : s !== 0 && (i = af(s));
    if (i === 0)
        return 0;
    if (e !== 0 && e !== i && !(e & r) && (r = i & -i,
    s = e & -e,
    r >= s || r === 16 && (s & 4194240) !== 0))
        return e;
    if (i & 4 && (i |= t & 16),
    e = n.entangledLanes,
    e !== 0)
        for (n = n.entanglements,
        e &= i; 0 < e; )
            t = 31 - Dr(e),
            r = 1 << t,
            i |= n[t],
            e &= ~r;
    return i
}
function XD(n, e) {
    switch (n) {
    case 1:
    case 2:
    case 4:
        return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function KD(n, e) {
    for (var t = n.suspendedLanes, i = n.pingedLanes, r = n.expirationTimes, s = n.pendingLanes; 0 < s; ) {
        var o = 31 - Dr(s)
          , a = 1 << o
          , l = r[o];
        l === -1 ? (!(a & t) || a & i) && (r[o] = XD(a, e)) : l <= e && (n.expiredLanes |= a),
        s &= ~a
    }
}
function xx(n) {
    return n = n.pendingLanes & -1073741825,
    n !== 0 ? n : n & 1073741824 ? 1073741824 : 0
}
function _2() {
    var n = $h;
    return $h <<= 1,
    !($h & 4194240) && ($h = 64),
    n
}
function Ty(n) {
    for (var e = [], t = 0; 31 > t; t++)
        e.push(n);
    return e
}
function _d(n, e, t) {
    n.pendingLanes |= e,
    e !== 536870912 && (n.suspendedLanes = 0,
    n.pingedLanes = 0),
    n = n.eventTimes,
    e = 31 - Dr(e),
    n[e] = t
}
function YD(n, e) {
    var t = n.pendingLanes & ~e;
    n.pendingLanes = e,
    n.suspendedLanes = 0,
    n.pingedLanes = 0,
    n.expiredLanes &= e,
    n.mutableReadLanes &= e,
    n.entangledLanes &= e,
    e = n.entanglements;
    var i = n.eventTimes;
    for (n = n.expirationTimes; 0 < t; ) {
        var r = 31 - Dr(t)
          , s = 1 << r;
        e[r] = 0,
        i[r] = -1,
        n[r] = -1,
        t &= ~s
    }
}
function P_(n, e) {
    var t = n.entangledLanes |= e;
    for (n = n.entanglements; t; ) {
        var i = 31 - Dr(t)
          , r = 1 << i;
        r & e | n[i] & e && (n[i] |= e),
        t &= ~r
    }
}
var Ot = 0;
function A2(n) {
    return n &= -n,
    1 < n ? 4 < n ? n & 268435455 ? 16 : 536870912 : 4 : 1
}
var M2, B_, w2, S2, C2, _x = !1, tp = [], Bo = null, Ro = null, Lo = null, Ff = new Map, kf = new Map, Mo = [], QD = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function PS(n, e) {
    switch (n) {
    case "focusin":
    case "focusout":
        Bo = null;
        break;
    case "dragenter":
    case "dragleave":
        Ro = null;
        break;
    case "mouseover":
    case "mouseout":
        Lo = null;
        break;
    case "pointerover":
    case "pointerout":
        Ff.delete(e.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        kf.delete(e.pointerId)
    }
}
function bc(n, e, t, i, r, s) {
    return n === null || n.nativeEvent !== s ? (n = {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: i,
        nativeEvent: s,
        targetContainers: [r]
    },
    e !== null && (e = Md(e),
    e !== null && B_(e)),
    n) : (n.eventSystemFlags |= i,
    e = n.targetContainers,
    r !== null && e.indexOf(r) === -1 && e.push(r),
    n)
}
function ZD(n, e, t, i, r) {
    switch (e) {
    case "focusin":
        return Bo = bc(Bo, n, e, t, i, r),
        !0;
    case "dragenter":
        return Ro = bc(Ro, n, e, t, i, r),
        !0;
    case "mouseover":
        return Lo = bc(Lo, n, e, t, i, r),
        !0;
    case "pointerover":
        var s = r.pointerId;
        return Ff.set(s, bc(Ff.get(s) || null, n, e, t, i, r)),
        !0;
    case "gotpointercapture":
        return s = r.pointerId,
        kf.set(s, bc(kf.get(s) || null, n, e, t, i, r)),
        !0
    }
    return !1
}
function E2(n) {
    var e = ka(n.target);
    if (e !== null) {
        var t = fl(e);
        if (t !== null) {
            if (e = t.tag,
            e === 13) {
                if (e = p2(t),
                e !== null) {
                    n.blockedOn = e,
                    C2(n.priority, function() {
                        w2(t)
                    });
                    return
                }
            } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
                n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
                return
            }
        }
    }
    n.blockedOn = null
}
function fm(n) {
    if (n.blockedOn !== null)
        return !1;
    for (var e = n.targetContainers; 0 < e.length; ) {
        var t = Ax(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent);
        if (t === null) {
            t = n.nativeEvent;
            var i = new t.constructor(t.type,t);
            mx = i,
            t.target.dispatchEvent(i),
            mx = null
        } else
            return e = Md(t),
            e !== null && B_(e),
            n.blockedOn = t,
            !1;
        e.shift()
    }
    return !0
}
function BS(n, e, t) {
    fm(n) && t.delete(e)
}
function qD() {
    _x = !1,
    Bo !== null && fm(Bo) && (Bo = null),
    Ro !== null && fm(Ro) && (Ro = null),
    Lo !== null && fm(Lo) && (Lo = null),
    Ff.forEach(BS),
    kf.forEach(BS)
}
function Pc(n, e) {
    n.blockedOn === e && (n.blockedOn = null,
    _x || (_x = !0,
    Wi.unstable_scheduleCallback(Wi.unstable_NormalPriority, qD)))
}
function Nf(n) {
    function e(r) {
        return Pc(r, n)
    }
    if (0 < tp.length) {
        Pc(tp[0], n);
        for (var t = 1; t < tp.length; t++) {
            var i = tp[t];
            i.blockedOn === n && (i.blockedOn = null)
        }
    }
    for (Bo !== null && Pc(Bo, n),
    Ro !== null && Pc(Ro, n),
    Lo !== null && Pc(Lo, n),
    Ff.forEach(e),
    kf.forEach(e),
    t = 0; t < Mo.length; t++)
        i = Mo[t],
        i.blockedOn === n && (i.blockedOn = null);
    for (; 0 < Mo.length && (t = Mo[0],
    t.blockedOn === null); )
        E2(t),
        t.blockedOn === null && Mo.shift()
}
var wu = Ys.ReactCurrentBatchConfig
  , Om = !0;
function $D(n, e, t, i) {
    var r = Ot
      , s = wu.transition;
    wu.transition = null;
    try {
        Ot = 1,
        R_(n, e, t, i)
    } finally {
        Ot = r,
        wu.transition = s
    }
}
function eF(n, e, t, i) {
    var r = Ot
      , s = wu.transition;
    wu.transition = null;
    try {
        Ot = 4,
        R_(n, e, t, i)
    } finally {
        Ot = r,
        wu.transition = s
    }
}
function R_(n, e, t, i) {
    if (Om) {
        var r = Ax(n, e, t, i);
        if (r === null)
            Ny(n, e, i, Um, t),
            PS(n, i);
        else if (ZD(r, n, e, t, i))
            i.stopPropagation();
        else if (PS(n, i),
        e & 4 && -1 < QD.indexOf(n)) {
            for (; r !== null; ) {
                var s = Md(r);
                if (s !== null && M2(s),
                s = Ax(n, e, t, i),
                s === null && Ny(n, e, i, Um, t),
                s === r)
                    break;
                r = s
            }
            r !== null && i.stopPropagation()
        } else
            Ny(n, e, i, null, t)
    }
}
var Um = null;
function Ax(n, e, t, i) {
    if (Um = null,
    n = T_(i),
    n = ka(n),
    n !== null)
        if (e = fl(n),
        e === null)
            n = null;
        else if (t = e.tag,
        t === 13) {
            if (n = p2(e),
            n !== null)
                return n;
            n = null
        } else if (t === 3) {
            if (e.stateNode.current.memoizedState.isDehydrated)
                return e.tag === 3 ? e.stateNode.containerInfo : null;
            n = null
        } else
            e !== n && (n = null);
    return Um = n,
    null
}
function T2(n) {
    switch (n) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (GD()) {
        case b_:
            return 1;
        case v2:
            return 4;
        case km:
        case HD:
            return 16;
        case x2:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var So = null
  , L_ = null
  , dm = null;
function b2() {
    if (dm)
        return dm;
    var n, e = L_, t = e.length, i, r = "value"in So ? So.value : So.textContent, s = r.length;
    for (n = 0; n < t && e[n] === r[n]; n++)
        ;
    var o = t - n;
    for (i = 1; i <= o && e[t - i] === r[s - i]; i++)
        ;
    return dm = r.slice(n, 1 < i ? 1 - i : void 0)
}
function hm(n) {
    var e = n.keyCode;
    return "charCode"in n ? (n = n.charCode,
    n === 0 && e === 13 && (n = 13)) : n = e,
    n === 10 && (n = 13),
    32 <= n || n === 13 ? n : 0
}
function np() {
    return !0
}
function RS() {
    return !1
}
function Ki(n) {
    function e(t, i, r, s, o) {
        this._reactName = t,
        this._targetInst = r,
        this.type = i,
        this.nativeEvent = s,
        this.target = o,
        this.currentTarget = null;
        for (var a in n)
            n.hasOwnProperty(a) && (t = n[a],
            this[a] = t ? t(s) : s[a]);
        return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? np : RS,
        this.isPropagationStopped = RS,
        this
    }
    return an(e.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var t = this.nativeEvent;
            t && (t.preventDefault ? t.preventDefault() : typeof t.returnValue != "unknown" && (t.returnValue = !1),
            this.isDefaultPrevented = np)
        },
        stopPropagation: function() {
            var t = this.nativeEvent;
            t && (t.stopPropagation ? t.stopPropagation() : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0),
            this.isPropagationStopped = np)
        },
        persist: function() {},
        isPersistent: np
    }),
    e
}
var Yu = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(n) {
        return n.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, I_ = Ki(Yu), Ad = an({}, Yu, {
    view: 0,
    detail: 0
}), tF = Ki(Ad), by, Py, Bc, Cg = an({}, Ad, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: D_,
    button: 0,
    buttons: 0,
    relatedTarget: function(n) {
        return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget
    },
    movementX: function(n) {
        return "movementX"in n ? n.movementX : (n !== Bc && (Bc && n.type === "mousemove" ? (by = n.screenX - Bc.screenX,
        Py = n.screenY - Bc.screenY) : Py = by = 0,
        Bc = n),
        by)
    },
    movementY: function(n) {
        return "movementY"in n ? n.movementY : Py
    }
}), LS = Ki(Cg), nF = an({}, Cg, {
    dataTransfer: 0
}), iF = Ki(nF), rF = an({}, Ad, {
    relatedTarget: 0
}), By = Ki(rF), sF = an({}, Yu, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), oF = Ki(sF), aF = an({}, Yu, {
    clipboardData: function(n) {
        return "clipboardData"in n ? n.clipboardData : window.clipboardData
    }
}), lF = Ki(aF), uF = an({}, Yu, {
    data: 0
}), IS = Ki(uF), cF = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, fF = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, dF = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function hF(n) {
    var e = this.nativeEvent;
    return e.getModifierState ? e.getModifierState(n) : (n = dF[n]) ? !!e[n] : !1
}
function D_() {
    return hF
}
var pF = an({}, Ad, {
    key: function(n) {
        if (n.key) {
            var e = cF[n.key] || n.key;
            if (e !== "Unidentified")
                return e
        }
        return n.type === "keypress" ? (n = hm(n),
        n === 13 ? "Enter" : String.fromCharCode(n)) : n.type === "keydown" || n.type === "keyup" ? fF[n.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: D_,
    charCode: function(n) {
        return n.type === "keypress" ? hm(n) : 0
    },
    keyCode: function(n) {
        return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0
    },
    which: function(n) {
        return n.type === "keypress" ? hm(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0
    }
})
  , mF = Ki(pF)
  , gF = an({}, Cg, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , DS = Ki(gF)
  , yF = an({}, Ad, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: D_
})
  , vF = Ki(yF)
  , xF = an({}, Yu, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , _F = Ki(xF)
  , AF = an({}, Cg, {
    deltaX: function(n) {
        return "deltaX"in n ? n.deltaX : "wheelDeltaX"in n ? -n.wheelDeltaX : 0
    },
    deltaY: function(n) {
        return "deltaY"in n ? n.deltaY : "wheelDeltaY"in n ? -n.wheelDeltaY : "wheelDelta"in n ? -n.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , MF = Ki(AF)
  , wF = [9, 13, 27, 32]
  , F_ = Hs && "CompositionEvent"in window
  , hf = null;
Hs && "documentMode"in document && (hf = document.documentMode);
var SF = Hs && "TextEvent"in window && !hf
  , P2 = Hs && (!F_ || hf && 8 < hf && 11 >= hf)
  , FS = String.fromCharCode(32)
  , kS = !1;
function B2(n, e) {
    switch (n) {
    case "keyup":
        return wF.indexOf(e.keyCode) !== -1;
    case "keydown":
        return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function R2(n) {
    return n = n.detail,
    typeof n == "object" && "data"in n ? n.data : null
}
var iu = !1;
function CF(n, e) {
    switch (n) {
    case "compositionend":
        return R2(e);
    case "keypress":
        return e.which !== 32 ? null : (kS = !0,
        FS);
    case "textInput":
        return n = e.data,
        n === FS && kS ? null : n;
    default:
        return null
    }
}
function EF(n, e) {
    if (iu)
        return n === "compositionend" || !F_ && B2(n, e) ? (n = b2(),
        dm = L_ = So = null,
        iu = !1,
        n) : null;
    switch (n) {
    case "paste":
        return null;
    case "keypress":
        if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
            if (e.char && 1 < e.char.length)
                return e.char;
            if (e.which)
                return String.fromCharCode(e.which)
        }
        return null;
    case "compositionend":
        return P2 && e.locale !== "ko" ? null : e.data;
    default:
        return null
    }
}
var TF = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function NS(n) {
    var e = n && n.nodeName && n.nodeName.toLowerCase();
    return e === "input" ? !!TF[n.type] : e === "textarea"
}
function L2(n, e, t, i) {
    u2(i),
    e = zm(e, "onChange"),
    0 < e.length && (t = new I_("onChange","change",null,t,i),
    n.push({
        event: t,
        listeners: e
    }))
}
var pf = null
  , Of = null;
function bF(n) {
    V2(n, 0)
}
function Eg(n) {
    var e = ou(n);
    if (n2(e))
        return n
}
function PF(n, e) {
    if (n === "change")
        return e
}
var I2 = !1;
if (Hs) {
    var Ry;
    if (Hs) {
        var Ly = "oninput"in document;
        if (!Ly) {
            var OS = document.createElement("div");
            OS.setAttribute("oninput", "return;"),
            Ly = typeof OS.oninput == "function"
        }
        Ry = Ly
    } else
        Ry = !1;
    I2 = Ry && (!document.documentMode || 9 < document.documentMode)
}
function US() {
    pf && (pf.detachEvent("onpropertychange", D2),
    Of = pf = null)
}
function D2(n) {
    if (n.propertyName === "value" && Eg(Of)) {
        var e = [];
        L2(e, Of, n, T_(n)),
        h2(bF, e)
    }
}
function BF(n, e, t) {
    n === "focusin" ? (US(),
    pf = e,
    Of = t,
    pf.attachEvent("onpropertychange", D2)) : n === "focusout" && US()
}
function RF(n) {
    if (n === "selectionchange" || n === "keyup" || n === "keydown")
        return Eg(Of)
}
function LF(n, e) {
    if (n === "click")
        return Eg(e)
}
function IF(n, e) {
    if (n === "input" || n === "change")
        return Eg(e)
}
function DF(n, e) {
    return n === e && (n !== 0 || 1 / n === 1 / e) || n !== n && e !== e
}
var Or = typeof Object.is == "function" ? Object.is : DF;
function Uf(n, e) {
    if (Or(n, e))
        return !0;
    if (typeof n != "object" || n === null || typeof e != "object" || e === null)
        return !1;
    var t = Object.keys(n)
      , i = Object.keys(e);
    if (t.length !== i.length)
        return !1;
    for (i = 0; i < t.length; i++) {
        var r = t[i];
        if (!ix.call(e, r) || !Or(n[r], e[r]))
            return !1
    }
    return !0
}
function zS(n) {
    for (; n && n.firstChild; )
        n = n.firstChild;
    return n
}
function GS(n, e) {
    var t = zS(n);
    n = 0;
    for (var i; t; ) {
        if (t.nodeType === 3) {
            if (i = n + t.textContent.length,
            n <= e && i >= e)
                return {
                    node: t,
                    offset: e - n
                };
            n = i
        }
        e: {
            for (; t; ) {
                if (t.nextSibling) {
                    t = t.nextSibling;
                    break e
                }
                t = t.parentNode
            }
            t = void 0
        }
        t = zS(t)
    }
}
function F2(n, e) {
    return n && e ? n === e ? !0 : n && n.nodeType === 3 ? !1 : e && e.nodeType === 3 ? F2(n, e.parentNode) : "contains"in n ? n.contains(e) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(e) & 16) : !1 : !1
}
function k2() {
    for (var n = window, e = Im(); e instanceof n.HTMLIFrameElement; ) {
        try {
            var t = typeof e.contentWindow.location.href == "string"
        } catch {
            t = !1
        }
        if (t)
            n = e.contentWindow;
        else
            break;
        e = Im(n.document)
    }
    return e
}
function k_(n) {
    var e = n && n.nodeName && n.nodeName.toLowerCase();
    return e && (e === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || e === "textarea" || n.contentEditable === "true")
}
function FF(n) {
    var e = k2()
      , t = n.focusedElem
      , i = n.selectionRange;
    if (e !== t && t && t.ownerDocument && F2(t.ownerDocument.documentElement, t)) {
        if (i !== null && k_(t)) {
            if (e = i.start,
            n = i.end,
            n === void 0 && (n = e),
            "selectionStart"in t)
                t.selectionStart = e,
                t.selectionEnd = Math.min(n, t.value.length);
            else if (n = (e = t.ownerDocument || document) && e.defaultView || window,
            n.getSelection) {
                n = n.getSelection();
                var r = t.textContent.length
                  , s = Math.min(i.start, r);
                i = i.end === void 0 ? s : Math.min(i.end, r),
                !n.extend && s > i && (r = i,
                i = s,
                s = r),
                r = GS(t, s);
                var o = GS(t, i);
                r && o && (n.rangeCount !== 1 || n.anchorNode !== r.node || n.anchorOffset !== r.offset || n.focusNode !== o.node || n.focusOffset !== o.offset) && (e = e.createRange(),
                e.setStart(r.node, r.offset),
                n.removeAllRanges(),
                s > i ? (n.addRange(e),
                n.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset),
                n.addRange(e)))
            }
        }
        for (e = [],
        n = t; n = n.parentNode; )
            n.nodeType === 1 && e.push({
                element: n,
                left: n.scrollLeft,
                top: n.scrollTop
            });
        for (typeof t.focus == "function" && t.focus(),
        t = 0; t < e.length; t++)
            n = e[t],
            n.element.scrollLeft = n.left,
            n.element.scrollTop = n.top
    }
}
var kF = Hs && "documentMode"in document && 11 >= document.documentMode
  , ru = null
  , Mx = null
  , mf = null
  , wx = !1;
function HS(n, e, t) {
    var i = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
    wx || ru == null || ru !== Im(i) || (i = ru,
    "selectionStart"in i && k_(i) ? i = {
        start: i.selectionStart,
        end: i.selectionEnd
    } : (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection(),
    i = {
        anchorNode: i.anchorNode,
        anchorOffset: i.anchorOffset,
        focusNode: i.focusNode,
        focusOffset: i.focusOffset
    }),
    mf && Uf(mf, i) || (mf = i,
    i = zm(Mx, "onSelect"),
    0 < i.length && (e = new I_("onSelect","select",null,e,t),
    n.push({
        event: e,
        listeners: i
    }),
    e.target = ru)))
}
function ip(n, e) {
    var t = {};
    return t[n.toLowerCase()] = e.toLowerCase(),
    t["Webkit" + n] = "webkit" + e,
    t["Moz" + n] = "moz" + e,
    t
}
var su = {
    animationend: ip("Animation", "AnimationEnd"),
    animationiteration: ip("Animation", "AnimationIteration"),
    animationstart: ip("Animation", "AnimationStart"),
    transitionend: ip("Transition", "TransitionEnd")
}
  , Iy = {}
  , N2 = {};
Hs && (N2 = document.createElement("div").style,
"AnimationEvent"in window || (delete su.animationend.animation,
delete su.animationiteration.animation,
delete su.animationstart.animation),
"TransitionEvent"in window || delete su.transitionend.transition);
function Tg(n) {
    if (Iy[n])
        return Iy[n];
    if (!su[n])
        return n;
    var e = su[n], t;
    for (t in e)
        if (e.hasOwnProperty(t) && t in N2)
            return Iy[n] = e[t];
    return n
}
var O2 = Tg("animationend")
  , U2 = Tg("animationiteration")
  , z2 = Tg("animationstart")
  , G2 = Tg("transitionend")
  , H2 = new Map
  , VS = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function Zo(n, e) {
    H2.set(n, e),
    cl(e, [n])
}
for (var Dy = 0; Dy < VS.length; Dy++) {
    var Fy = VS[Dy]
      , NF = Fy.toLowerCase()
      , OF = Fy[0].toUpperCase() + Fy.slice(1);
    Zo(NF, "on" + OF)
}
Zo(O2, "onAnimationEnd");
Zo(U2, "onAnimationIteration");
Zo(z2, "onAnimationStart");
Zo("dblclick", "onDoubleClick");
Zo("focusin", "onFocus");
Zo("focusout", "onBlur");
Zo(G2, "onTransitionEnd");
Pu("onMouseEnter", ["mouseout", "mouseover"]);
Pu("onMouseLeave", ["mouseout", "mouseover"]);
Pu("onPointerEnter", ["pointerout", "pointerover"]);
Pu("onPointerLeave", ["pointerout", "pointerover"]);
cl("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
cl("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
cl("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
cl("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
cl("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
cl("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , UF = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function WS(n, e, t) {
    var i = n.type || "unknown-event";
    n.currentTarget = t,
    ND(i, e, void 0, n),
    n.currentTarget = null
}
function V2(n, e) {
    e = (e & 4) !== 0;
    for (var t = 0; t < n.length; t++) {
        var i = n[t]
          , r = i.event;
        i = i.listeners;
        e: {
            var s = void 0;
            if (e)
                for (var o = i.length - 1; 0 <= o; o--) {
                    var a = i[o]
                      , l = a.instance
                      , c = a.currentTarget;
                    if (a = a.listener,
                    l !== s && r.isPropagationStopped())
                        break e;
                    WS(r, a, c),
                    s = l
                }
            else
                for (o = 0; o < i.length; o++) {
                    if (a = i[o],
                    l = a.instance,
                    c = a.currentTarget,
                    a = a.listener,
                    l !== s && r.isPropagationStopped())
                        break e;
                    WS(r, a, c),
                    s = l
                }
        }
    }
    if (Fm)
        throw n = vx,
        Fm = !1,
        vx = null,
        n
}
function jt(n, e) {
    var t = e[bx];
    t === void 0 && (t = e[bx] = new Set);
    var i = n + "__bubble";
    t.has(i) || (W2(e, n, 2, !1),
    t.add(i))
}
function ky(n, e, t) {
    var i = 0;
    e && (i |= 4),
    W2(t, n, i, e)
}
var rp = "_reactListening" + Math.random().toString(36).slice(2);
function zf(n) {
    if (!n[rp]) {
        n[rp] = !0,
        Zb.forEach(function(t) {
            t !== "selectionchange" && (UF.has(t) || ky(t, !1, n),
            ky(t, !0, n))
        });
        var e = n.nodeType === 9 ? n : n.ownerDocument;
        e === null || e[rp] || (e[rp] = !0,
        ky("selectionchange", !1, e))
    }
}
function W2(n, e, t, i) {
    switch (T2(e)) {
    case 1:
        var r = $D;
        break;
    case 4:
        r = eF;
        break;
    default:
        r = R_
    }
    t = r.bind(null, e, t, n),
    r = void 0,
    !yx || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (r = !0),
    i ? r !== void 0 ? n.addEventListener(e, t, {
        capture: !0,
        passive: r
    }) : n.addEventListener(e, t, !0) : r !== void 0 ? n.addEventListener(e, t, {
        passive: r
    }) : n.addEventListener(e, t, !1)
}
function Ny(n, e, t, i, r) {
    var s = i;
    if (!(e & 1) && !(e & 2) && i !== null)
        e: for (; ; ) {
            if (i === null)
                return;
            var o = i.tag;
            if (o === 3 || o === 4) {
                var a = i.stateNode.containerInfo;
                if (a === r || a.nodeType === 8 && a.parentNode === r)
                    break;
                if (o === 4)
                    for (o = i.return; o !== null; ) {
                        var l = o.tag;
                        if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo,
                        l === r || l.nodeType === 8 && l.parentNode === r))
                            return;
                        o = o.return
                    }
                for (; a !== null; ) {
                    if (o = ka(a),
                    o === null)
                        return;
                    if (l = o.tag,
                    l === 5 || l === 6) {
                        i = s = o;
                        continue e
                    }
                    a = a.parentNode
                }
            }
            i = i.return
        }
    h2(function() {
        var c = s
          , d = T_(t)
          , h = [];
        e: {
            var p = H2.get(n);
            if (p !== void 0) {
                var m = I_
                  , y = n;
                switch (n) {
                case "keypress":
                    if (hm(t) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    m = mF;
                    break;
                case "focusin":
                    y = "focus",
                    m = By;
                    break;
                case "focusout":
                    y = "blur",
                    m = By;
                    break;
                case "beforeblur":
                case "afterblur":
                    m = By;
                    break;
                case "click":
                    if (t.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    m = LS;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    m = iF;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    m = vF;
                    break;
                case O2:
                case U2:
                case z2:
                    m = oF;
                    break;
                case G2:
                    m = _F;
                    break;
                case "scroll":
                    m = tF;
                    break;
                case "wheel":
                    m = MF;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    m = lF;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    m = DS
                }
                var v = (e & 4) !== 0
                  , _ = !v && n === "scroll"
                  , x = v ? p !== null ? p + "Capture" : null : p;
                v = [];
                for (var A = c, M; A !== null; ) {
                    M = A;
                    var S = M.stateNode;
                    if (M.tag === 5 && S !== null && (M = S,
                    x !== null && (S = Df(A, x),
                    S != null && v.push(Gf(A, S, M)))),
                    _)
                        break;
                    A = A.return
                }
                0 < v.length && (p = new m(p,y,null,t,d),
                h.push({
                    event: p,
                    listeners: v
                }))
            }
        }
        if (!(e & 7)) {
            e: {
                if (p = n === "mouseover" || n === "pointerover",
                m = n === "mouseout" || n === "pointerout",
                p && t !== mx && (y = t.relatedTarget || t.fromElement) && (ka(y) || y[Vs]))
                    break e;
                if ((m || p) && (p = d.window === d ? d : (p = d.ownerDocument) ? p.defaultView || p.parentWindow : window,
                m ? (y = t.relatedTarget || t.toElement,
                m = c,
                y = y ? ka(y) : null,
                y !== null && (_ = fl(y),
                y !== _ || y.tag !== 5 && y.tag !== 6) && (y = null)) : (m = null,
                y = c),
                m !== y)) {
                    if (v = LS,
                    S = "onMouseLeave",
                    x = "onMouseEnter",
                    A = "mouse",
                    (n === "pointerout" || n === "pointerover") && (v = DS,
                    S = "onPointerLeave",
                    x = "onPointerEnter",
                    A = "pointer"),
                    _ = m == null ? p : ou(m),
                    M = y == null ? p : ou(y),
                    p = new v(S,A + "leave",m,t,d),
                    p.target = _,
                    p.relatedTarget = M,
                    S = null,
                    ka(d) === c && (v = new v(x,A + "enter",y,t,d),
                    v.target = M,
                    v.relatedTarget = _,
                    S = v),
                    _ = S,
                    m && y)
                        t: {
                            for (v = m,
                            x = y,
                            A = 0,
                            M = v; M; M = Ll(M))
                                A++;
                            for (M = 0,
                            S = x; S; S = Ll(S))
                                M++;
                            for (; 0 < A - M; )
                                v = Ll(v),
                                A--;
                            for (; 0 < M - A; )
                                x = Ll(x),
                                M--;
                            for (; A--; ) {
                                if (v === x || x !== null && v === x.alternate)
                                    break t;
                                v = Ll(v),
                                x = Ll(x)
                            }
                            v = null
                        }
                    else
                        v = null;
                    m !== null && jS(h, p, m, v, !1),
                    y !== null && _ !== null && jS(h, _, y, v, !0)
                }
            }
            e: {
                if (p = c ? ou(c) : window,
                m = p.nodeName && p.nodeName.toLowerCase(),
                m === "select" || m === "input" && p.type === "file")
                    var T = PF;
                else if (NS(p))
                    if (I2)
                        T = IF;
                    else {
                        T = RF;
                        var P = BF
                    }
                else
                    (m = p.nodeName) && m.toLowerCase() === "input" && (p.type === "checkbox" || p.type === "radio") && (T = LF);
                if (T && (T = T(n, c))) {
                    L2(h, T, t, d);
                    break e
                }
                P && P(n, p, c),
                n === "focusout" && (P = p._wrapperState) && P.controlled && p.type === "number" && cx(p, "number", p.value)
            }
            switch (P = c ? ou(c) : window,
            n) {
            case "focusin":
                (NS(P) || P.contentEditable === "true") && (ru = P,
                Mx = c,
                mf = null);
                break;
            case "focusout":
                mf = Mx = ru = null;
                break;
            case "mousedown":
                wx = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                wx = !1,
                HS(h, t, d);
                break;
            case "selectionchange":
                if (kF)
                    break;
            case "keydown":
            case "keyup":
                HS(h, t, d)
            }
            var R;
            if (F_)
                e: {
                    switch (n) {
                    case "compositionstart":
                        var E = "onCompositionStart";
                        break e;
                    case "compositionend":
                        E = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        E = "onCompositionUpdate";
                        break e
                    }
                    E = void 0
                }
            else
                iu ? B2(n, t) && (E = "onCompositionEnd") : n === "keydown" && t.keyCode === 229 && (E = "onCompositionStart");
            E && (P2 && t.locale !== "ko" && (iu || E !== "onCompositionStart" ? E === "onCompositionEnd" && iu && (R = b2()) : (So = d,
            L_ = "value"in So ? So.value : So.textContent,
            iu = !0)),
            P = zm(c, E),
            0 < P.length && (E = new IS(E,n,null,t,d),
            h.push({
                event: E,
                listeners: P
            }),
            R ? E.data = R : (R = R2(t),
            R !== null && (E.data = R)))),
            (R = SF ? CF(n, t) : EF(n, t)) && (c = zm(c, "onBeforeInput"),
            0 < c.length && (d = new IS("onBeforeInput","beforeinput",null,t,d),
            h.push({
                event: d,
                listeners: c
            }),
            d.data = R))
        }
        V2(h, e)
    })
}
function Gf(n, e, t) {
    return {
        instance: n,
        listener: e,
        currentTarget: t
    }
}
function zm(n, e) {
    for (var t = e + "Capture", i = []; n !== null; ) {
        var r = n
          , s = r.stateNode;
        r.tag === 5 && s !== null && (r = s,
        s = Df(n, t),
        s != null && i.unshift(Gf(n, s, r)),
        s = Df(n, e),
        s != null && i.push(Gf(n, s, r))),
        n = n.return
    }
    return i
}
function Ll(n) {
    if (n === null)
        return null;
    do
        n = n.return;
    while (n && n.tag !== 5);
    return n || null
}
function jS(n, e, t, i, r) {
    for (var s = e._reactName, o = []; t !== null && t !== i; ) {
        var a = t
          , l = a.alternate
          , c = a.stateNode;
        if (l !== null && l === i)
            break;
        a.tag === 5 && c !== null && (a = c,
        r ? (l = Df(t, s),
        l != null && o.unshift(Gf(t, l, a))) : r || (l = Df(t, s),
        l != null && o.push(Gf(t, l, a)))),
        t = t.return
    }
    o.length !== 0 && n.push({
        event: e,
        listeners: o
    })
}
var zF = /\r\n?/g
  , GF = /\u0000|\uFFFD/g;
function JS(n) {
    return (typeof n == "string" ? n : "" + n).replace(zF, `
`).replace(GF, "")
}
function sp(n, e, t) {
    if (e = JS(e),
    JS(n) !== e && t)
        throw Error(Se(425))
}
function Gm() {}
var Sx = null
  , Cx = null;
function Ex(n, e) {
    return n === "textarea" || n === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null
}
var Tx = typeof setTimeout == "function" ? setTimeout : void 0
  , HF = typeof clearTimeout == "function" ? clearTimeout : void 0
  , XS = typeof Promise == "function" ? Promise : void 0
  , VF = typeof queueMicrotask == "function" ? queueMicrotask : typeof XS < "u" ? function(n) {
    return XS.resolve(null).then(n).catch(WF)
}
: Tx;
function WF(n) {
    setTimeout(function() {
        throw n
    })
}
function Oy(n, e) {
    var t = e
      , i = 0;
    do {
        var r = t.nextSibling;
        if (n.removeChild(t),
        r && r.nodeType === 8)
            if (t = r.data,
            t === "/$") {
                if (i === 0) {
                    n.removeChild(r),
                    Nf(e);
                    return
                }
                i--
            } else
                t !== "$" && t !== "$?" && t !== "$!" || i++;
        t = r
    } while (t);
    Nf(e)
}
function Io(n) {
    for (; n != null; n = n.nextSibling) {
        var e = n.nodeType;
        if (e === 1 || e === 3)
            break;
        if (e === 8) {
            if (e = n.data,
            e === "$" || e === "$!" || e === "$?")
                break;
            if (e === "/$")
                return null
        }
    }
    return n
}
function KS(n) {
    n = n.previousSibling;
    for (var e = 0; n; ) {
        if (n.nodeType === 8) {
            var t = n.data;
            if (t === "$" || t === "$!" || t === "$?") {
                if (e === 0)
                    return n;
                e--
            } else
                t === "/$" && e++
        }
        n = n.previousSibling
    }
    return null
}
var Qu = Math.random().toString(36).slice(2)
  , ts = "__reactFiber$" + Qu
  , Hf = "__reactProps$" + Qu
  , Vs = "__reactContainer$" + Qu
  , bx = "__reactEvents$" + Qu
  , jF = "__reactListeners$" + Qu
  , JF = "__reactHandles$" + Qu;
function ka(n) {
    var e = n[ts];
    if (e)
        return e;
    for (var t = n.parentNode; t; ) {
        if (e = t[Vs] || t[ts]) {
            if (t = e.alternate,
            e.child !== null || t !== null && t.child !== null)
                for (n = KS(n); n !== null; ) {
                    if (t = n[ts])
                        return t;
                    n = KS(n)
                }
            return e
        }
        n = t,
        t = n.parentNode
    }
    return null
}
function Md(n) {
    return n = n[ts] || n[Vs],
    !n || n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3 ? null : n
}
function ou(n) {
    if (n.tag === 5 || n.tag === 6)
        return n.stateNode;
    throw Error(Se(33))
}
function bg(n) {
    return n[Hf] || null
}
var Px = []
  , au = -1;
function qo(n) {
    return {
        current: n
    }
}
function Xt(n) {
    0 > au || (n.current = Px[au],
    Px[au] = null,
    au--)
}
function Vt(n, e) {
    au++,
    Px[au] = n.current,
    n.current = e
}
var Ho = {}
  , ii = qo(Ho)
  , Ti = qo(!1)
  , tl = Ho;
function Bu(n, e) {
    var t = n.type.contextTypes;
    if (!t)
        return Ho;
    var i = n.stateNode;
    if (i && i.__reactInternalMemoizedUnmaskedChildContext === e)
        return i.__reactInternalMemoizedMaskedChildContext;
    var r = {}, s;
    for (s in t)
        r[s] = e[s];
    return i && (n = n.stateNode,
    n.__reactInternalMemoizedUnmaskedChildContext = e,
    n.__reactInternalMemoizedMaskedChildContext = r),
    r
}
function bi(n) {
    return n = n.childContextTypes,
    n != null
}
function Hm() {
    Xt(Ti),
    Xt(ii)
}
function YS(n, e, t) {
    if (ii.current !== Ho)
        throw Error(Se(168));
    Vt(ii, e),
    Vt(Ti, t)
}
function j2(n, e, t) {
    var i = n.stateNode;
    if (e = e.childContextTypes,
    typeof i.getChildContext != "function")
        return t;
    i = i.getChildContext();
    for (var r in i)
        if (!(r in e))
            throw Error(Se(108, BD(n) || "Unknown", r));
    return an({}, t, i)
}
function Vm(n) {
    return n = (n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext || Ho,
    tl = ii.current,
    Vt(ii, n),
    Vt(Ti, Ti.current),
    !0
}
function QS(n, e, t) {
    var i = n.stateNode;
    if (!i)
        throw Error(Se(169));
    t ? (n = j2(n, e, tl),
    i.__reactInternalMemoizedMergedChildContext = n,
    Xt(Ti),
    Xt(ii),
    Vt(ii, n)) : Xt(Ti),
    Vt(Ti, t)
}
var Ps = null
  , Pg = !1
  , Uy = !1;
function J2(n) {
    Ps === null ? Ps = [n] : Ps.push(n)
}
function XF(n) {
    Pg = !0,
    J2(n)
}
function $o() {
    if (!Uy && Ps !== null) {
        Uy = !0;
        var n = 0
          , e = Ot;
        try {
            var t = Ps;
            for (Ot = 1; n < t.length; n++) {
                var i = t[n];
                do
                    i = i(!0);
                while (i !== null)
            }
            Ps = null,
            Pg = !1
        } catch (r) {
            throw Ps !== null && (Ps = Ps.slice(n + 1)),
            y2(b_, $o),
            r
        } finally {
            Ot = e,
            Uy = !1
        }
    }
    return null
}
var lu = []
  , uu = 0
  , Wm = null
  , jm = 0
  , dr = []
  , hr = 0
  , nl = null
  , Ls = 1
  , Is = "";
function Ea(n, e) {
    lu[uu++] = jm,
    lu[uu++] = Wm,
    Wm = n,
    jm = e
}
function X2(n, e, t) {
    dr[hr++] = Ls,
    dr[hr++] = Is,
    dr[hr++] = nl,
    nl = n;
    var i = Ls;
    n = Is;
    var r = 32 - Dr(i) - 1;
    i &= ~(1 << r),
    t += 1;
    var s = 32 - Dr(e) + r;
    if (30 < s) {
        var o = r - r % 5;
        s = (i & (1 << o) - 1).toString(32),
        i >>= o,
        r -= o,
        Ls = 1 << 32 - Dr(e) + r | t << r | i,
        Is = s + n
    } else
        Ls = 1 << s | t << r | i,
        Is = n
}
function N_(n) {
    n.return !== null && (Ea(n, 1),
    X2(n, 1, 0))
}
function O_(n) {
    for (; n === Wm; )
        Wm = lu[--uu],
        lu[uu] = null,
        jm = lu[--uu],
        lu[uu] = null;
    for (; n === nl; )
        nl = dr[--hr],
        dr[hr] = null,
        Is = dr[--hr],
        dr[hr] = null,
        Ls = dr[--hr],
        dr[hr] = null
}
var Hi = null
  , Ui = null
  , Zt = !1
  , Rr = null;
function K2(n, e) {
    var t = mr(5, null, null, 0);
    t.elementType = "DELETED",
    t.stateNode = e,
    t.return = n,
    e = n.deletions,
    e === null ? (n.deletions = [t],
    n.flags |= 16) : e.push(t)
}
function ZS(n, e) {
    switch (n.tag) {
    case 5:
        var t = n.type;
        return e = e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase() ? null : e,
        e !== null ? (n.stateNode = e,
        Hi = n,
        Ui = Io(e.firstChild),
        !0) : !1;
    case 6:
        return e = n.pendingProps === "" || e.nodeType !== 3 ? null : e,
        e !== null ? (n.stateNode = e,
        Hi = n,
        Ui = null,
        !0) : !1;
    case 13:
        return e = e.nodeType !== 8 ? null : e,
        e !== null ? (t = nl !== null ? {
            id: Ls,
            overflow: Is
        } : null,
        n.memoizedState = {
            dehydrated: e,
            treeContext: t,
            retryLane: 1073741824
        },
        t = mr(18, null, null, 0),
        t.stateNode = e,
        t.return = n,
        n.child = t,
        Hi = n,
        Ui = null,
        !0) : !1;
    default:
        return !1
    }
}
function Bx(n) {
    return (n.mode & 1) !== 0 && (n.flags & 128) === 0
}
function Rx(n) {
    if (Zt) {
        var e = Ui;
        if (e) {
            var t = e;
            if (!ZS(n, e)) {
                if (Bx(n))
                    throw Error(Se(418));
                e = Io(t.nextSibling);
                var i = Hi;
                e && ZS(n, e) ? K2(i, t) : (n.flags = n.flags & -4097 | 2,
                Zt = !1,
                Hi = n)
            }
        } else {
            if (Bx(n))
                throw Error(Se(418));
            n.flags = n.flags & -4097 | 2,
            Zt = !1,
            Hi = n
        }
    }
}
function qS(n) {
    for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13; )
        n = n.return;
    Hi = n
}
function op(n) {
    if (n !== Hi)
        return !1;
    if (!Zt)
        return qS(n),
        Zt = !0,
        !1;
    var e;
    if ((e = n.tag !== 3) && !(e = n.tag !== 5) && (e = n.type,
    e = e !== "head" && e !== "body" && !Ex(n.type, n.memoizedProps)),
    e && (e = Ui)) {
        if (Bx(n))
            throw Y2(),
            Error(Se(418));
        for (; e; )
            K2(n, e),
            e = Io(e.nextSibling)
    }
    if (qS(n),
    n.tag === 13) {
        if (n = n.memoizedState,
        n = n !== null ? n.dehydrated : null,
        !n)
            throw Error(Se(317));
        e: {
            for (n = n.nextSibling,
            e = 0; n; ) {
                if (n.nodeType === 8) {
                    var t = n.data;
                    if (t === "/$") {
                        if (e === 0) {
                            Ui = Io(n.nextSibling);
                            break e
                        }
                        e--
                    } else
                        t !== "$" && t !== "$!" && t !== "$?" || e++
                }
                n = n.nextSibling
            }
            Ui = null
        }
    } else
        Ui = Hi ? Io(n.stateNode.nextSibling) : null;
    return !0
}
function Y2() {
    for (var n = Ui; n; )
        n = Io(n.nextSibling)
}
function Ru() {
    Ui = Hi = null,
    Zt = !1
}
function U_(n) {
    Rr === null ? Rr = [n] : Rr.push(n)
}
var KF = Ys.ReactCurrentBatchConfig;
function br(n, e) {
    if (n && n.defaultProps) {
        e = an({}, e),
        n = n.defaultProps;
        for (var t in n)
            e[t] === void 0 && (e[t] = n[t]);
        return e
    }
    return e
}
var Jm = qo(null)
  , Xm = null
  , cu = null
  , z_ = null;
function G_() {
    z_ = cu = Xm = null
}
function H_(n) {
    var e = Jm.current;
    Xt(Jm),
    n._currentValue = e
}
function Lx(n, e, t) {
    for (; n !== null; ) {
        var i = n.alternate;
        if ((n.childLanes & e) !== e ? (n.childLanes |= e,
        i !== null && (i.childLanes |= e)) : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e),
        n === t)
            break;
        n = n.return
    }
}
function Su(n, e) {
    Xm = n,
    z_ = cu = null,
    n = n.dependencies,
    n !== null && n.firstContext !== null && (n.lanes & e && (Ei = !0),
    n.firstContext = null)
}
function vr(n) {
    var e = n._currentValue;
    if (z_ !== n)
        if (n = {
            context: n,
            memoizedValue: e,
            next: null
        },
        cu === null) {
            if (Xm === null)
                throw Error(Se(308));
            cu = n,
            Xm.dependencies = {
                lanes: 0,
                firstContext: n
            }
        } else
            cu = cu.next = n;
    return e
}
var Na = null;
function V_(n) {
    Na === null ? Na = [n] : Na.push(n)
}
function Q2(n, e, t, i) {
    var r = e.interleaved;
    return r === null ? (t.next = t,
    V_(e)) : (t.next = r.next,
    r.next = t),
    e.interleaved = t,
    Ws(n, i)
}
function Ws(n, e) {
    n.lanes |= e;
    var t = n.alternate;
    for (t !== null && (t.lanes |= e),
    t = n,
    n = n.return; n !== null; )
        n.childLanes |= e,
        t = n.alternate,
        t !== null && (t.childLanes |= e),
        t = n,
        n = n.return;
    return t.tag === 3 ? t.stateNode : null
}
var xo = !1;
function W_(n) {
    n.updateQueue = {
        baseState: n.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function Z2(n, e) {
    n = n.updateQueue,
    e.updateQueue === n && (e.updateQueue = {
        baseState: n.baseState,
        firstBaseUpdate: n.firstBaseUpdate,
        lastBaseUpdate: n.lastBaseUpdate,
        shared: n.shared,
        effects: n.effects
    })
}
function Os(n, e) {
    return {
        eventTime: n,
        lane: e,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function Do(n, e, t) {
    var i = n.updateQueue;
    if (i === null)
        return null;
    if (i = i.shared,
    Bt & 2) {
        var r = i.pending;
        return r === null ? e.next = e : (e.next = r.next,
        r.next = e),
        i.pending = e,
        Ws(n, t)
    }
    return r = i.interleaved,
    r === null ? (e.next = e,
    V_(i)) : (e.next = r.next,
    r.next = e),
    i.interleaved = e,
    Ws(n, t)
}
function pm(n, e, t) {
    if (e = e.updateQueue,
    e !== null && (e = e.shared,
    (t & 4194240) !== 0)) {
        var i = e.lanes;
        i &= n.pendingLanes,
        t |= i,
        e.lanes = t,
        P_(n, t)
    }
}
function $S(n, e) {
    var t = n.updateQueue
      , i = n.alternate;
    if (i !== null && (i = i.updateQueue,
    t === i)) {
        var r = null
          , s = null;
        if (t = t.firstBaseUpdate,
        t !== null) {
            do {
                var o = {
                    eventTime: t.eventTime,
                    lane: t.lane,
                    tag: t.tag,
                    payload: t.payload,
                    callback: t.callback,
                    next: null
                };
                s === null ? r = s = o : s = s.next = o,
                t = t.next
            } while (t !== null);
            s === null ? r = s = e : s = s.next = e
        } else
            r = s = e;
        t = {
            baseState: i.baseState,
            firstBaseUpdate: r,
            lastBaseUpdate: s,
            shared: i.shared,
            effects: i.effects
        },
        n.updateQueue = t;
        return
    }
    n = t.lastBaseUpdate,
    n === null ? t.firstBaseUpdate = e : n.next = e,
    t.lastBaseUpdate = e
}
function Km(n, e, t, i) {
    var r = n.updateQueue;
    xo = !1;
    var s = r.firstBaseUpdate
      , o = r.lastBaseUpdate
      , a = r.shared.pending;
    if (a !== null) {
        r.shared.pending = null;
        var l = a
          , c = l.next;
        l.next = null,
        o === null ? s = c : o.next = c,
        o = l;
        var d = n.alternate;
        d !== null && (d = d.updateQueue,
        a = d.lastBaseUpdate,
        a !== o && (a === null ? d.firstBaseUpdate = c : a.next = c,
        d.lastBaseUpdate = l))
    }
    if (s !== null) {
        var h = r.baseState;
        o = 0,
        d = c = l = null,
        a = s;
        do {
            var p = a.lane
              , m = a.eventTime;
            if ((i & p) === p) {
                d !== null && (d = d.next = {
                    eventTime: m,
                    lane: 0,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                });
                e: {
                    var y = n
                      , v = a;
                    switch (p = e,
                    m = t,
                    v.tag) {
                    case 1:
                        if (y = v.payload,
                        typeof y == "function") {
                            h = y.call(m, h, p);
                            break e
                        }
                        h = y;
                        break e;
                    case 3:
                        y.flags = y.flags & -65537 | 128;
                    case 0:
                        if (y = v.payload,
                        p = typeof y == "function" ? y.call(m, h, p) : y,
                        p == null)
                            break e;
                        h = an({}, h, p);
                        break e;
                    case 2:
                        xo = !0
                    }
                }
                a.callback !== null && a.lane !== 0 && (n.flags |= 64,
                p = r.effects,
                p === null ? r.effects = [a] : p.push(a))
            } else
                m = {
                    eventTime: m,
                    lane: p,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                },
                d === null ? (c = d = m,
                l = h) : d = d.next = m,
                o |= p;
            if (a = a.next,
            a === null) {
                if (a = r.shared.pending,
                a === null)
                    break;
                p = a,
                a = p.next,
                p.next = null,
                r.lastBaseUpdate = p,
                r.shared.pending = null
            }
        } while (1);
        if (d === null && (l = h),
        r.baseState = l,
        r.firstBaseUpdate = c,
        r.lastBaseUpdate = d,
        e = r.shared.interleaved,
        e !== null) {
            r = e;
            do
                o |= r.lane,
                r = r.next;
            while (r !== e)
        } else
            s === null && (r.shared.lanes = 0);
        rl |= o,
        n.lanes = o,
        n.memoizedState = h
    }
}
function eC(n, e, t) {
    if (n = e.effects,
    e.effects = null,
    n !== null)
        for (e = 0; e < n.length; e++) {
            var i = n[e]
              , r = i.callback;
            if (r !== null) {
                if (i.callback = null,
                i = t,
                typeof r != "function")
                    throw Error(Se(191, r));
                r.call(i)
            }
        }
}
var q2 = new Qb.Component().refs;
function Ix(n, e, t, i) {
    e = n.memoizedState,
    t = t(i, e),
    t = t == null ? e : an({}, e, t),
    n.memoizedState = t,
    n.lanes === 0 && (n.updateQueue.baseState = t)
}
var Bg = {
    isMounted: function(n) {
        return (n = n._reactInternals) ? fl(n) === n : !1
    },
    enqueueSetState: function(n, e, t) {
        n = n._reactInternals;
        var i = pi()
          , r = ko(n)
          , s = Os(i, r);
        s.payload = e,
        t != null && (s.callback = t),
        e = Do(n, s, r),
        e !== null && (Fr(e, n, r, i),
        pm(e, n, r))
    },
    enqueueReplaceState: function(n, e, t) {
        n = n._reactInternals;
        var i = pi()
          , r = ko(n)
          , s = Os(i, r);
        s.tag = 1,
        s.payload = e,
        t != null && (s.callback = t),
        e = Do(n, s, r),
        e !== null && (Fr(e, n, r, i),
        pm(e, n, r))
    },
    enqueueForceUpdate: function(n, e) {
        n = n._reactInternals;
        var t = pi()
          , i = ko(n)
          , r = Os(t, i);
        r.tag = 2,
        e != null && (r.callback = e),
        e = Do(n, r, i),
        e !== null && (Fr(e, n, i, t),
        pm(e, n, i))
    }
};
function tC(n, e, t, i, r, s, o) {
    return n = n.stateNode,
    typeof n.shouldComponentUpdate == "function" ? n.shouldComponentUpdate(i, s, o) : e.prototype && e.prototype.isPureReactComponent ? !Uf(t, i) || !Uf(r, s) : !0
}
function $2(n, e, t) {
    var i = !1
      , r = Ho
      , s = e.contextType;
    return typeof s == "object" && s !== null ? s = vr(s) : (r = bi(e) ? tl : ii.current,
    i = e.contextTypes,
    s = (i = i != null) ? Bu(n, r) : Ho),
    e = new e(t,s),
    n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null,
    e.updater = Bg,
    n.stateNode = e,
    e._reactInternals = n,
    i && (n = n.stateNode,
    n.__reactInternalMemoizedUnmaskedChildContext = r,
    n.__reactInternalMemoizedMaskedChildContext = s),
    e
}
function nC(n, e, t, i) {
    n = e.state,
    typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(t, i),
    typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(t, i),
    e.state !== n && Bg.enqueueReplaceState(e, e.state, null)
}
function Dx(n, e, t, i) {
    var r = n.stateNode;
    r.props = t,
    r.state = n.memoizedState,
    r.refs = q2,
    W_(n);
    var s = e.contextType;
    typeof s == "object" && s !== null ? r.context = vr(s) : (s = bi(e) ? tl : ii.current,
    r.context = Bu(n, s)),
    r.state = n.memoizedState,
    s = e.getDerivedStateFromProps,
    typeof s == "function" && (Ix(n, e, s, t),
    r.state = n.memoizedState),
    typeof e.getDerivedStateFromProps == "function" || typeof r.getSnapshotBeforeUpdate == "function" || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (e = r.state,
    typeof r.componentWillMount == "function" && r.componentWillMount(),
    typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(),
    e !== r.state && Bg.enqueueReplaceState(r, r.state, null),
    Km(n, t, r, i),
    r.state = n.memoizedState),
    typeof r.componentDidMount == "function" && (n.flags |= 4194308)
}
function Rc(n, e, t) {
    if (n = t.ref,
    n !== null && typeof n != "function" && typeof n != "object") {
        if (t._owner) {
            if (t = t._owner,
            t) {
                if (t.tag !== 1)
                    throw Error(Se(309));
                var i = t.stateNode
            }
            if (!i)
                throw Error(Se(147, n));
            var r = i
              , s = "" + n;
            return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function(o) {
                var a = r.refs;
                a === q2 && (a = r.refs = {}),
                o === null ? delete a[s] : a[s] = o
            }
            ,
            e._stringRef = s,
            e)
        }
        if (typeof n != "string")
            throw Error(Se(284));
        if (!t._owner)
            throw Error(Se(290, n))
    }
    return n
}
function ap(n, e) {
    throw n = Object.prototype.toString.call(e),
    Error(Se(31, n === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : n))
}
function iC(n) {
    var e = n._init;
    return e(n._payload)
}
function eP(n) {
    function e(x, A) {
        if (n) {
            var M = x.deletions;
            M === null ? (x.deletions = [A],
            x.flags |= 16) : M.push(A)
        }
    }
    function t(x, A) {
        if (!n)
            return null;
        for (; A !== null; )
            e(x, A),
            A = A.sibling;
        return null
    }
    function i(x, A) {
        for (x = new Map; A !== null; )
            A.key !== null ? x.set(A.key, A) : x.set(A.index, A),
            A = A.sibling;
        return x
    }
    function r(x, A) {
        return x = No(x, A),
        x.index = 0,
        x.sibling = null,
        x
    }
    function s(x, A, M) {
        return x.index = M,
        n ? (M = x.alternate,
        M !== null ? (M = M.index,
        M < A ? (x.flags |= 2,
        A) : M) : (x.flags |= 2,
        A)) : (x.flags |= 1048576,
        A)
    }
    function o(x) {
        return n && x.alternate === null && (x.flags |= 2),
        x
    }
    function a(x, A, M, S) {
        return A === null || A.tag !== 6 ? (A = Jy(M, x.mode, S),
        A.return = x,
        A) : (A = r(A, M),
        A.return = x,
        A)
    }
    function l(x, A, M, S) {
        var T = M.type;
        return T === nu ? d(x, A, M.props.children, S, M.key) : A !== null && (A.elementType === T || typeof T == "object" && T !== null && T.$$typeof === vo && iC(T) === A.type) ? (S = r(A, M.props),
        S.ref = Rc(x, A, M),
        S.return = x,
        S) : (S = _m(M.type, M.key, M.props, null, x.mode, S),
        S.ref = Rc(x, A, M),
        S.return = x,
        S)
    }
    function c(x, A, M, S) {
        return A === null || A.tag !== 4 || A.stateNode.containerInfo !== M.containerInfo || A.stateNode.implementation !== M.implementation ? (A = Xy(M, x.mode, S),
        A.return = x,
        A) : (A = r(A, M.children || []),
        A.return = x,
        A)
    }
    function d(x, A, M, S, T) {
        return A === null || A.tag !== 7 ? (A = Ja(M, x.mode, S, T),
        A.return = x,
        A) : (A = r(A, M),
        A.return = x,
        A)
    }
    function h(x, A, M) {
        if (typeof A == "string" && A !== "" || typeof A == "number")
            return A = Jy("" + A, x.mode, M),
            A.return = x,
            A;
        if (typeof A == "object" && A !== null) {
            switch (A.$$typeof) {
            case Qh:
                return M = _m(A.type, A.key, A.props, null, x.mode, M),
                M.ref = Rc(x, null, A),
                M.return = x,
                M;
            case tu:
                return A = Xy(A, x.mode, M),
                A.return = x,
                A;
            case vo:
                var S = A._init;
                return h(x, S(A._payload), M)
            }
            if (of(A) || Ec(A))
                return A = Ja(A, x.mode, M, null),
                A.return = x,
                A;
            ap(x, A)
        }
        return null
    }
    function p(x, A, M, S) {
        var T = A !== null ? A.key : null;
        if (typeof M == "string" && M !== "" || typeof M == "number")
            return T !== null ? null : a(x, A, "" + M, S);
        if (typeof M == "object" && M !== null) {
            switch (M.$$typeof) {
            case Qh:
                return M.key === T ? l(x, A, M, S) : null;
            case tu:
                return M.key === T ? c(x, A, M, S) : null;
            case vo:
                return T = M._init,
                p(x, A, T(M._payload), S)
            }
            if (of(M) || Ec(M))
                return T !== null ? null : d(x, A, M, S, null);
            ap(x, M)
        }
        return null
    }
    function m(x, A, M, S, T) {
        if (typeof S == "string" && S !== "" || typeof S == "number")
            return x = x.get(M) || null,
            a(A, x, "" + S, T);
        if (typeof S == "object" && S !== null) {
            switch (S.$$typeof) {
            case Qh:
                return x = x.get(S.key === null ? M : S.key) || null,
                l(A, x, S, T);
            case tu:
                return x = x.get(S.key === null ? M : S.key) || null,
                c(A, x, S, T);
            case vo:
                var P = S._init;
                return m(x, A, M, P(S._payload), T)
            }
            if (of(S) || Ec(S))
                return x = x.get(M) || null,
                d(A, x, S, T, null);
            ap(A, S)
        }
        return null
    }
    function y(x, A, M, S) {
        for (var T = null, P = null, R = A, E = A = 0, B = null; R !== null && E < M.length; E++) {
            R.index > E ? (B = R,
            R = null) : B = R.sibling;
            var L = p(x, R, M[E], S);
            if (L === null) {
                R === null && (R = B);
                break
            }
            n && R && L.alternate === null && e(x, R),
            A = s(L, A, E),
            P === null ? T = L : P.sibling = L,
            P = L,
            R = B
        }
        if (E === M.length)
            return t(x, R),
            Zt && Ea(x, E),
            T;
        if (R === null) {
            for (; E < M.length; E++)
                R = h(x, M[E], S),
                R !== null && (A = s(R, A, E),
                P === null ? T = R : P.sibling = R,
                P = R);
            return Zt && Ea(x, E),
            T
        }
        for (R = i(x, R); E < M.length; E++)
            B = m(R, x, E, M[E], S),
            B !== null && (n && B.alternate !== null && R.delete(B.key === null ? E : B.key),
            A = s(B, A, E),
            P === null ? T = B : P.sibling = B,
            P = B);
        return n && R.forEach(function(z) {
            return e(x, z)
        }),
        Zt && Ea(x, E),
        T
    }
    function v(x, A, M, S) {
        var T = Ec(M);
        if (typeof T != "function")
            throw Error(Se(150));
        if (M = T.call(M),
        M == null)
            throw Error(Se(151));
        for (var P = T = null, R = A, E = A = 0, B = null, L = M.next(); R !== null && !L.done; E++,
        L = M.next()) {
            R.index > E ? (B = R,
            R = null) : B = R.sibling;
            var z = p(x, R, L.value, S);
            if (z === null) {
                R === null && (R = B);
                break
            }
            n && R && z.alternate === null && e(x, R),
            A = s(z, A, E),
            P === null ? T = z : P.sibling = z,
            P = z,
            R = B
        }
        if (L.done)
            return t(x, R),
            Zt && Ea(x, E),
            T;
        if (R === null) {
            for (; !L.done; E++,
            L = M.next())
                L = h(x, L.value, S),
                L !== null && (A = s(L, A, E),
                P === null ? T = L : P.sibling = L,
                P = L);
            return Zt && Ea(x, E),
            T
        }
        for (R = i(x, R); !L.done; E++,
        L = M.next())
            L = m(R, x, E, L.value, S),
            L !== null && (n && L.alternate !== null && R.delete(L.key === null ? E : L.key),
            A = s(L, A, E),
            P === null ? T = L : P.sibling = L,
            P = L);
        return n && R.forEach(function(Z) {
            return e(x, Z)
        }),
        Zt && Ea(x, E),
        T
    }
    function _(x, A, M, S) {
        if (typeof M == "object" && M !== null && M.type === nu && M.key === null && (M = M.props.children),
        typeof M == "object" && M !== null) {
            switch (M.$$typeof) {
            case Qh:
                e: {
                    for (var T = M.key, P = A; P !== null; ) {
                        if (P.key === T) {
                            if (T = M.type,
                            T === nu) {
                                if (P.tag === 7) {
                                    t(x, P.sibling),
                                    A = r(P, M.props.children),
                                    A.return = x,
                                    x = A;
                                    break e
                                }
                            } else if (P.elementType === T || typeof T == "object" && T !== null && T.$$typeof === vo && iC(T) === P.type) {
                                t(x, P.sibling),
                                A = r(P, M.props),
                                A.ref = Rc(x, P, M),
                                A.return = x,
                                x = A;
                                break e
                            }
                            t(x, P);
                            break
                        } else
                            e(x, P);
                        P = P.sibling
                    }
                    M.type === nu ? (A = Ja(M.props.children, x.mode, S, M.key),
                    A.return = x,
                    x = A) : (S = _m(M.type, M.key, M.props, null, x.mode, S),
                    S.ref = Rc(x, A, M),
                    S.return = x,
                    x = S)
                }
                return o(x);
            case tu:
                e: {
                    for (P = M.key; A !== null; ) {
                        if (A.key === P)
                            if (A.tag === 4 && A.stateNode.containerInfo === M.containerInfo && A.stateNode.implementation === M.implementation) {
                                t(x, A.sibling),
                                A = r(A, M.children || []),
                                A.return = x,
                                x = A;
                                break e
                            } else {
                                t(x, A);
                                break
                            }
                        else
                            e(x, A);
                        A = A.sibling
                    }
                    A = Xy(M, x.mode, S),
                    A.return = x,
                    x = A
                }
                return o(x);
            case vo:
                return P = M._init,
                _(x, A, P(M._payload), S)
            }
            if (of(M))
                return y(x, A, M, S);
            if (Ec(M))
                return v(x, A, M, S);
            ap(x, M)
        }
        return typeof M == "string" && M !== "" || typeof M == "number" ? (M = "" + M,
        A !== null && A.tag === 6 ? (t(x, A.sibling),
        A = r(A, M),
        A.return = x,
        x = A) : (t(x, A),
        A = Jy(M, x.mode, S),
        A.return = x,
        x = A),
        o(x)) : t(x, A)
    }
    return _
}
var Lu = eP(!0)
  , tP = eP(!1)
  , wd = {}
  , is = qo(wd)
  , Vf = qo(wd)
  , Wf = qo(wd);
function Oa(n) {
    if (n === wd)
        throw Error(Se(174));
    return n
}
function j_(n, e) {
    switch (Vt(Wf, e),
    Vt(Vf, n),
    Vt(is, wd),
    n = e.nodeType,
    n) {
    case 9:
    case 11:
        e = (e = e.documentElement) ? e.namespaceURI : dx(null, "");
        break;
    default:
        n = n === 8 ? e.parentNode : e,
        e = n.namespaceURI || null,
        n = n.tagName,
        e = dx(e, n)
    }
    Xt(is),
    Vt(is, e)
}
function Iu() {
    Xt(is),
    Xt(Vf),
    Xt(Wf)
}
function nP(n) {
    Oa(Wf.current);
    var e = Oa(is.current)
      , t = dx(e, n.type);
    e !== t && (Vt(Vf, n),
    Vt(is, t))
}
function J_(n) {
    Vf.current === n && (Xt(is),
    Xt(Vf))
}
var tn = qo(0);
function Ym(n) {
    for (var e = n; e !== null; ) {
        if (e.tag === 13) {
            var t = e.memoizedState;
            if (t !== null && (t = t.dehydrated,
            t === null || t.data === "$?" || t.data === "$!"))
                return e
        } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
            if (e.flags & 128)
                return e
        } else if (e.child !== null) {
            e.child.return = e,
            e = e.child;
            continue
        }
        if (e === n)
            break;
        for (; e.sibling === null; ) {
            if (e.return === null || e.return === n)
                return null;
            e = e.return
        }
        e.sibling.return = e.return,
        e = e.sibling
    }
    return null
}
var zy = [];
function X_() {
    for (var n = 0; n < zy.length; n++)
        zy[n]._workInProgressVersionPrimary = null;
    zy.length = 0
}
var mm = Ys.ReactCurrentDispatcher
  , Gy = Ys.ReactCurrentBatchConfig
  , il = 0
  , on = null
  , Tn = null
  , On = null
  , Qm = !1
  , gf = !1
  , jf = 0
  , YF = 0;
function Zn() {
    throw Error(Se(321))
}
function K_(n, e) {
    if (e === null)
        return !1;
    for (var t = 0; t < e.length && t < n.length; t++)
        if (!Or(n[t], e[t]))
            return !1;
    return !0
}
function Y_(n, e, t, i, r, s) {
    if (il = s,
    on = e,
    e.memoizedState = null,
    e.updateQueue = null,
    e.lanes = 0,
    mm.current = n === null || n.memoizedState === null ? $F : ek,
    n = t(i, r),
    gf) {
        s = 0;
        do {
            if (gf = !1,
            jf = 0,
            25 <= s)
                throw Error(Se(301));
            s += 1,
            On = Tn = null,
            e.updateQueue = null,
            mm.current = tk,
            n = t(i, r)
        } while (gf)
    }
    if (mm.current = Zm,
    e = Tn !== null && Tn.next !== null,
    il = 0,
    On = Tn = on = null,
    Qm = !1,
    e)
        throw Error(Se(300));
    return n
}
function Q_() {
    var n = jf !== 0;
    return jf = 0,
    n
}
function $r() {
    var n = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return On === null ? on.memoizedState = On = n : On = On.next = n,
    On
}
function xr() {
    if (Tn === null) {
        var n = on.alternate;
        n = n !== null ? n.memoizedState : null
    } else
        n = Tn.next;
    var e = On === null ? on.memoizedState : On.next;
    if (e !== null)
        On = e,
        Tn = n;
    else {
        if (n === null)
            throw Error(Se(310));
        Tn = n,
        n = {
            memoizedState: Tn.memoizedState,
            baseState: Tn.baseState,
            baseQueue: Tn.baseQueue,
            queue: Tn.queue,
            next: null
        },
        On === null ? on.memoizedState = On = n : On = On.next = n
    }
    return On
}
function Jf(n, e) {
    return typeof e == "function" ? e(n) : e
}
function Hy(n) {
    var e = xr()
      , t = e.queue;
    if (t === null)
        throw Error(Se(311));
    t.lastRenderedReducer = n;
    var i = Tn
      , r = i.baseQueue
      , s = t.pending;
    if (s !== null) {
        if (r !== null) {
            var o = r.next;
            r.next = s.next,
            s.next = o
        }
        i.baseQueue = r = s,
        t.pending = null
    }
    if (r !== null) {
        s = r.next,
        i = i.baseState;
        var a = o = null
          , l = null
          , c = s;
        do {
            var d = c.lane;
            if ((il & d) === d)
                l !== null && (l = l.next = {
                    lane: 0,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                }),
                i = c.hasEagerState ? c.eagerState : n(i, c.action);
            else {
                var h = {
                    lane: d,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                };
                l === null ? (a = l = h,
                o = i) : l = l.next = h,
                on.lanes |= d,
                rl |= d
            }
            c = c.next
        } while (c !== null && c !== s);
        l === null ? o = i : l.next = a,
        Or(i, e.memoizedState) || (Ei = !0),
        e.memoizedState = i,
        e.baseState = o,
        e.baseQueue = l,
        t.lastRenderedState = i
    }
    if (n = t.interleaved,
    n !== null) {
        r = n;
        do
            s = r.lane,
            on.lanes |= s,
            rl |= s,
            r = r.next;
        while (r !== n)
    } else
        r === null && (t.lanes = 0);
    return [e.memoizedState, t.dispatch]
}
function Vy(n) {
    var e = xr()
      , t = e.queue;
    if (t === null)
        throw Error(Se(311));
    t.lastRenderedReducer = n;
    var i = t.dispatch
      , r = t.pending
      , s = e.memoizedState;
    if (r !== null) {
        t.pending = null;
        var o = r = r.next;
        do
            s = n(s, o.action),
            o = o.next;
        while (o !== r);
        Or(s, e.memoizedState) || (Ei = !0),
        e.memoizedState = s,
        e.baseQueue === null && (e.baseState = s),
        t.lastRenderedState = s
    }
    return [s, i]
}
function iP() {}
function rP(n, e) {
    var t = on
      , i = xr()
      , r = e()
      , s = !Or(i.memoizedState, r);
    if (s && (i.memoizedState = r,
    Ei = !0),
    i = i.queue,
    Z_(aP.bind(null, t, i, n), [n]),
    i.getSnapshot !== e || s || On !== null && On.memoizedState.tag & 1) {
        if (t.flags |= 2048,
        Xf(9, oP.bind(null, t, i, r, e), void 0, null),
        zn === null)
            throw Error(Se(349));
        il & 30 || sP(t, e, r)
    }
    return r
}
function sP(n, e, t) {
    n.flags |= 16384,
    n = {
        getSnapshot: e,
        value: t
    },
    e = on.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    on.updateQueue = e,
    e.stores = [n]) : (t = e.stores,
    t === null ? e.stores = [n] : t.push(n))
}
function oP(n, e, t, i) {
    e.value = t,
    e.getSnapshot = i,
    lP(e) && uP(n)
}
function aP(n, e, t) {
    return t(function() {
        lP(e) && uP(n)
    })
}
function lP(n) {
    var e = n.getSnapshot;
    n = n.value;
    try {
        var t = e();
        return !Or(n, t)
    } catch {
        return !0
    }
}
function uP(n) {
    var e = Ws(n, 1);
    e !== null && Fr(e, n, 1, -1)
}
function rC(n) {
    var e = $r();
    return typeof n == "function" && (n = n()),
    e.memoizedState = e.baseState = n,
    n = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Jf,
        lastRenderedState: n
    },
    e.queue = n,
    n = n.dispatch = qF.bind(null, on, n),
    [e.memoizedState, n]
}
function Xf(n, e, t, i) {
    return n = {
        tag: n,
        create: e,
        destroy: t,
        deps: i,
        next: null
    },
    e = on.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    on.updateQueue = e,
    e.lastEffect = n.next = n) : (t = e.lastEffect,
    t === null ? e.lastEffect = n.next = n : (i = t.next,
    t.next = n,
    n.next = i,
    e.lastEffect = n)),
    n
}
function cP() {
    return xr().memoizedState
}
function gm(n, e, t, i) {
    var r = $r();
    on.flags |= n,
    r.memoizedState = Xf(1 | e, t, void 0, i === void 0 ? null : i)
}
function Rg(n, e, t, i) {
    var r = xr();
    i = i === void 0 ? null : i;
    var s = void 0;
    if (Tn !== null) {
        var o = Tn.memoizedState;
        if (s = o.destroy,
        i !== null && K_(i, o.deps)) {
            r.memoizedState = Xf(e, t, s, i);
            return
        }
    }
    on.flags |= n,
    r.memoizedState = Xf(1 | e, t, s, i)
}
function sC(n, e) {
    return gm(8390656, 8, n, e)
}
function Z_(n, e) {
    return Rg(2048, 8, n, e)
}
function fP(n, e) {
    return Rg(4, 2, n, e)
}
function dP(n, e) {
    return Rg(4, 4, n, e)
}
function hP(n, e) {
    if (typeof e == "function")
        return n = n(),
        e(n),
        function() {
            e(null)
        }
        ;
    if (e != null)
        return n = n(),
        e.current = n,
        function() {
            e.current = null
        }
}
function pP(n, e, t) {
    return t = t != null ? t.concat([n]) : null,
    Rg(4, 4, hP.bind(null, e, n), t)
}
function q_() {}
function mP(n, e) {
    var t = xr();
    e = e === void 0 ? null : e;
    var i = t.memoizedState;
    return i !== null && e !== null && K_(e, i[1]) ? i[0] : (t.memoizedState = [n, e],
    n)
}
function gP(n, e) {
    var t = xr();
    e = e === void 0 ? null : e;
    var i = t.memoizedState;
    return i !== null && e !== null && K_(e, i[1]) ? i[0] : (n = n(),
    t.memoizedState = [n, e],
    n)
}
function yP(n, e, t) {
    return il & 21 ? (Or(t, e) || (t = _2(),
    on.lanes |= t,
    rl |= t,
    n.baseState = !0),
    e) : (n.baseState && (n.baseState = !1,
    Ei = !0),
    n.memoizedState = t)
}
function QF(n, e) {
    var t = Ot;
    Ot = t !== 0 && 4 > t ? t : 4,
    n(!0);
    var i = Gy.transition;
    Gy.transition = {};
    try {
        n(!1),
        e()
    } finally {
        Ot = t,
        Gy.transition = i
    }
}
function vP() {
    return xr().memoizedState
}
function ZF(n, e, t) {
    var i = ko(n);
    if (t = {
        lane: i,
        action: t,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    xP(n))
        _P(e, t);
    else if (t = Q2(n, e, t, i),
    t !== null) {
        var r = pi();
        Fr(t, n, i, r),
        AP(t, e, i)
    }
}
function qF(n, e, t) {
    var i = ko(n)
      , r = {
        lane: i,
        action: t,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (xP(n))
        _P(e, r);
    else {
        var s = n.alternate;
        if (n.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer,
        s !== null))
            try {
                var o = e.lastRenderedState
                  , a = s(o, t);
                if (r.hasEagerState = !0,
                r.eagerState = a,
                Or(a, o)) {
                    var l = e.interleaved;
                    l === null ? (r.next = r,
                    V_(e)) : (r.next = l.next,
                    l.next = r),
                    e.interleaved = r;
                    return
                }
            } catch {} finally {}
        t = Q2(n, e, r, i),
        t !== null && (r = pi(),
        Fr(t, n, i, r),
        AP(t, e, i))
    }
}
function xP(n) {
    var e = n.alternate;
    return n === on || e !== null && e === on
}
function _P(n, e) {
    gf = Qm = !0;
    var t = n.pending;
    t === null ? e.next = e : (e.next = t.next,
    t.next = e),
    n.pending = e
}
function AP(n, e, t) {
    if (t & 4194240) {
        var i = e.lanes;
        i &= n.pendingLanes,
        t |= i,
        e.lanes = t,
        P_(n, t)
    }
}
var Zm = {
    readContext: vr,
    useCallback: Zn,
    useContext: Zn,
    useEffect: Zn,
    useImperativeHandle: Zn,
    useInsertionEffect: Zn,
    useLayoutEffect: Zn,
    useMemo: Zn,
    useReducer: Zn,
    useRef: Zn,
    useState: Zn,
    useDebugValue: Zn,
    useDeferredValue: Zn,
    useTransition: Zn,
    useMutableSource: Zn,
    useSyncExternalStore: Zn,
    useId: Zn,
    unstable_isNewReconciler: !1
}
  , $F = {
    readContext: vr,
    useCallback: function(n, e) {
        return $r().memoizedState = [n, e === void 0 ? null : e],
        n
    },
    useContext: vr,
    useEffect: sC,
    useImperativeHandle: function(n, e, t) {
        return t = t != null ? t.concat([n]) : null,
        gm(4194308, 4, hP.bind(null, e, n), t)
    },
    useLayoutEffect: function(n, e) {
        return gm(4194308, 4, n, e)
    },
    useInsertionEffect: function(n, e) {
        return gm(4, 2, n, e)
    },
    useMemo: function(n, e) {
        var t = $r();
        return e = e === void 0 ? null : e,
        n = n(),
        t.memoizedState = [n, e],
        n
    },
    useReducer: function(n, e, t) {
        var i = $r();
        return e = t !== void 0 ? t(e) : e,
        i.memoizedState = i.baseState = e,
        n = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: n,
            lastRenderedState: e
        },
        i.queue = n,
        n = n.dispatch = ZF.bind(null, on, n),
        [i.memoizedState, n]
    },
    useRef: function(n) {
        var e = $r();
        return n = {
            current: n
        },
        e.memoizedState = n
    },
    useState: rC,
    useDebugValue: q_,
    useDeferredValue: function(n) {
        return $r().memoizedState = n
    },
    useTransition: function() {
        var n = rC(!1)
          , e = n[0];
        return n = QF.bind(null, n[1]),
        $r().memoizedState = n,
        [e, n]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(n, e, t) {
        var i = on
          , r = $r();
        if (Zt) {
            if (t === void 0)
                throw Error(Se(407));
            t = t()
        } else {
            if (t = e(),
            zn === null)
                throw Error(Se(349));
            il & 30 || sP(i, e, t)
        }
        r.memoizedState = t;
        var s = {
            value: t,
            getSnapshot: e
        };
        return r.queue = s,
        sC(aP.bind(null, i, s, n), [n]),
        i.flags |= 2048,
        Xf(9, oP.bind(null, i, s, t, e), void 0, null),
        t
    },
    useId: function() {
        var n = $r()
          , e = zn.identifierPrefix;
        if (Zt) {
            var t = Is
              , i = Ls;
            t = (i & ~(1 << 32 - Dr(i) - 1)).toString(32) + t,
            e = ":" + e + "R" + t,
            t = jf++,
            0 < t && (e += "H" + t.toString(32)),
            e += ":"
        } else
            t = YF++,
            e = ":" + e + "r" + t.toString(32) + ":";
        return n.memoizedState = e
    },
    unstable_isNewReconciler: !1
}
  , ek = {
    readContext: vr,
    useCallback: mP,
    useContext: vr,
    useEffect: Z_,
    useImperativeHandle: pP,
    useInsertionEffect: fP,
    useLayoutEffect: dP,
    useMemo: gP,
    useReducer: Hy,
    useRef: cP,
    useState: function() {
        return Hy(Jf)
    },
    useDebugValue: q_,
    useDeferredValue: function(n) {
        var e = xr();
        return yP(e, Tn.memoizedState, n)
    },
    useTransition: function() {
        var n = Hy(Jf)[0]
          , e = xr().memoizedState;
        return [n, e]
    },
    useMutableSource: iP,
    useSyncExternalStore: rP,
    useId: vP,
    unstable_isNewReconciler: !1
}
  , tk = {
    readContext: vr,
    useCallback: mP,
    useContext: vr,
    useEffect: Z_,
    useImperativeHandle: pP,
    useInsertionEffect: fP,
    useLayoutEffect: dP,
    useMemo: gP,
    useReducer: Vy,
    useRef: cP,
    useState: function() {
        return Vy(Jf)
    },
    useDebugValue: q_,
    useDeferredValue: function(n) {
        var e = xr();
        return Tn === null ? e.memoizedState = n : yP(e, Tn.memoizedState, n)
    },
    useTransition: function() {
        var n = Vy(Jf)[0]
          , e = xr().memoizedState;
        return [n, e]
    },
    useMutableSource: iP,
    useSyncExternalStore: rP,
    useId: vP,
    unstable_isNewReconciler: !1
};
function Du(n, e) {
    try {
        var t = ""
          , i = e;
        do
            t += PD(i),
            i = i.return;
        while (i);
        var r = t
    } catch (s) {
        r = `
Error generating stack: ` + s.message + `
` + s.stack
    }
    return {
        value: n,
        source: e,
        stack: r,
        digest: null
    }
}
function Wy(n, e, t) {
    return {
        value: n,
        source: null,
        stack: t ?? null,
        digest: e ?? null
    }
}
function Fx(n, e) {
    try {
        console.error(e.value)
    } catch (t) {
        setTimeout(function() {
            throw t
        })
    }
}
var nk = typeof WeakMap == "function" ? WeakMap : Map;
function MP(n, e, t) {
    t = Os(-1, t),
    t.tag = 3,
    t.payload = {
        element: null
    };
    var i = e.value;
    return t.callback = function() {
        $m || ($m = !0,
        jx = i),
        Fx(n, e)
    }
    ,
    t
}
function wP(n, e, t) {
    t = Os(-1, t),
    t.tag = 3;
    var i = n.type.getDerivedStateFromError;
    if (typeof i == "function") {
        var r = e.value;
        t.payload = function() {
            return i(r)
        }
        ,
        t.callback = function() {
            Fx(n, e)
        }
    }
    var s = n.stateNode;
    return s !== null && typeof s.componentDidCatch == "function" && (t.callback = function() {
        Fx(n, e),
        typeof i != "function" && (Fo === null ? Fo = new Set([this]) : Fo.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
            componentStack: o !== null ? o : ""
        })
    }
    ),
    t
}
function oC(n, e, t) {
    var i = n.pingCache;
    if (i === null) {
        i = n.pingCache = new nk;
        var r = new Set;
        i.set(e, r)
    } else
        r = i.get(e),
        r === void 0 && (r = new Set,
        i.set(e, r));
    r.has(t) || (r.add(t),
    n = gk.bind(null, n, e, t),
    e.then(n, n))
}
function aC(n) {
    do {
        var e;
        if ((e = n.tag === 13) && (e = n.memoizedState,
        e = e !== null ? e.dehydrated !== null : !0),
        e)
            return n;
        n = n.return
    } while (n !== null);
    return null
}
function lC(n, e, t, i, r) {
    return n.mode & 1 ? (n.flags |= 65536,
    n.lanes = r,
    n) : (n === e ? n.flags |= 65536 : (n.flags |= 128,
    t.flags |= 131072,
    t.flags &= -52805,
    t.tag === 1 && (t.alternate === null ? t.tag = 17 : (e = Os(-1, 1),
    e.tag = 2,
    Do(t, e, 1))),
    t.lanes |= 1),
    n)
}
var ik = Ys.ReactCurrentOwner
  , Ei = !1;
function fi(n, e, t, i) {
    e.child = n === null ? tP(e, null, t, i) : Lu(e, n.child, t, i)
}
function uC(n, e, t, i, r) {
    t = t.render;
    var s = e.ref;
    return Su(e, r),
    i = Y_(n, e, t, i, s, r),
    t = Q_(),
    n !== null && !Ei ? (e.updateQueue = n.updateQueue,
    e.flags &= -2053,
    n.lanes &= ~r,
    js(n, e, r)) : (Zt && t && N_(e),
    e.flags |= 1,
    fi(n, e, i, r),
    e.child)
}
function cC(n, e, t, i, r) {
    if (n === null) {
        var s = t.type;
        return typeof s == "function" && !oA(s) && s.defaultProps === void 0 && t.compare === null && t.defaultProps === void 0 ? (e.tag = 15,
        e.type = s,
        SP(n, e, s, i, r)) : (n = _m(t.type, null, i, e, e.mode, r),
        n.ref = e.ref,
        n.return = e,
        e.child = n)
    }
    if (s = n.child,
    !(n.lanes & r)) {
        var o = s.memoizedProps;
        if (t = t.compare,
        t = t !== null ? t : Uf,
        t(o, i) && n.ref === e.ref)
            return js(n, e, r)
    }
    return e.flags |= 1,
    n = No(s, i),
    n.ref = e.ref,
    n.return = e,
    e.child = n
}
function SP(n, e, t, i, r) {
    if (n !== null) {
        var s = n.memoizedProps;
        if (Uf(s, i) && n.ref === e.ref)
            if (Ei = !1,
            e.pendingProps = i = s,
            (n.lanes & r) !== 0)
                n.flags & 131072 && (Ei = !0);
            else
                return e.lanes = n.lanes,
                js(n, e, r)
    }
    return kx(n, e, t, i, r)
}
function CP(n, e, t) {
    var i = e.pendingProps
      , r = i.children
      , s = n !== null ? n.memoizedState : null;
    if (i.mode === "hidden")
        if (!(e.mode & 1))
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            Vt(du, Oi),
            Oi |= t;
        else {
            if (!(t & 1073741824))
                return n = s !== null ? s.baseLanes | t : t,
                e.lanes = e.childLanes = 1073741824,
                e.memoizedState = {
                    baseLanes: n,
                    cachePool: null,
                    transitions: null
                },
                e.updateQueue = null,
                Vt(du, Oi),
                Oi |= n,
                null;
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            i = s !== null ? s.baseLanes : t,
            Vt(du, Oi),
            Oi |= i
        }
    else
        s !== null ? (i = s.baseLanes | t,
        e.memoizedState = null) : i = t,
        Vt(du, Oi),
        Oi |= i;
    return fi(n, e, r, t),
    e.child
}
function EP(n, e) {
    var t = e.ref;
    (n === null && t !== null || n !== null && n.ref !== t) && (e.flags |= 512,
    e.flags |= 2097152)
}
function kx(n, e, t, i, r) {
    var s = bi(t) ? tl : ii.current;
    return s = Bu(e, s),
    Su(e, r),
    t = Y_(n, e, t, i, s, r),
    i = Q_(),
    n !== null && !Ei ? (e.updateQueue = n.updateQueue,
    e.flags &= -2053,
    n.lanes &= ~r,
    js(n, e, r)) : (Zt && i && N_(e),
    e.flags |= 1,
    fi(n, e, t, r),
    e.child)
}
function fC(n, e, t, i, r) {
    if (bi(t)) {
        var s = !0;
        Vm(e)
    } else
        s = !1;
    if (Su(e, r),
    e.stateNode === null)
        ym(n, e),
        $2(e, t, i),
        Dx(e, t, i, r),
        i = !0;
    else if (n === null) {
        var o = e.stateNode
          , a = e.memoizedProps;
        o.props = a;
        var l = o.context
          , c = t.contextType;
        typeof c == "object" && c !== null ? c = vr(c) : (c = bi(t) ? tl : ii.current,
        c = Bu(e, c));
        var d = t.getDerivedStateFromProps
          , h = typeof d == "function" || typeof o.getSnapshotBeforeUpdate == "function";
        h || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== i || l !== c) && nC(e, o, i, c),
        xo = !1;
        var p = e.memoizedState;
        o.state = p,
        Km(e, i, o, r),
        l = e.memoizedState,
        a !== i || p !== l || Ti.current || xo ? (typeof d == "function" && (Ix(e, t, d, i),
        l = e.memoizedState),
        (a = xo || tC(e, t, a, i, p, l, c)) ? (h || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(),
        typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()),
        typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
        e.memoizedProps = i,
        e.memoizedState = l),
        o.props = i,
        o.state = l,
        o.context = c,
        i = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
        i = !1)
    } else {
        o = e.stateNode,
        Z2(n, e),
        a = e.memoizedProps,
        c = e.type === e.elementType ? a : br(e.type, a),
        o.props = c,
        h = e.pendingProps,
        p = o.context,
        l = t.contextType,
        typeof l == "object" && l !== null ? l = vr(l) : (l = bi(t) ? tl : ii.current,
        l = Bu(e, l));
        var m = t.getDerivedStateFromProps;
        (d = typeof m == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== h || p !== l) && nC(e, o, i, l),
        xo = !1,
        p = e.memoizedState,
        o.state = p,
        Km(e, i, o, r);
        var y = e.memoizedState;
        a !== h || p !== y || Ti.current || xo ? (typeof m == "function" && (Ix(e, t, m, i),
        y = e.memoizedState),
        (c = xo || tC(e, t, c, i, p, y, l) || !1) ? (d || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(i, y, l),
        typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(i, y, l)),
        typeof o.componentDidUpdate == "function" && (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 1024),
        e.memoizedProps = i,
        e.memoizedState = y),
        o.props = i,
        o.state = y,
        o.context = l,
        i = c) : (typeof o.componentDidUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 1024),
        i = !1)
    }
    return Nx(n, e, t, i, s, r)
}
function Nx(n, e, t, i, r, s) {
    EP(n, e);
    var o = (e.flags & 128) !== 0;
    if (!i && !o)
        return r && QS(e, t, !1),
        js(n, e, s);
    i = e.stateNode,
    ik.current = e;
    var a = o && typeof t.getDerivedStateFromError != "function" ? null : i.render();
    return e.flags |= 1,
    n !== null && o ? (e.child = Lu(e, n.child, null, s),
    e.child = Lu(e, null, a, s)) : fi(n, e, a, s),
    e.memoizedState = i.state,
    r && QS(e, t, !0),
    e.child
}
function TP(n) {
    var e = n.stateNode;
    e.pendingContext ? YS(n, e.pendingContext, e.pendingContext !== e.context) : e.context && YS(n, e.context, !1),
    j_(n, e.containerInfo)
}
function dC(n, e, t, i, r) {
    return Ru(),
    U_(r),
    e.flags |= 256,
    fi(n, e, t, i),
    e.child
}
var Ox = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function Ux(n) {
    return {
        baseLanes: n,
        cachePool: null,
        transitions: null
    }
}
function bP(n, e, t) {
    var i = e.pendingProps, r = tn.current, s = !1, o = (e.flags & 128) !== 0, a;
    if ((a = o) || (a = n !== null && n.memoizedState === null ? !1 : (r & 2) !== 0),
    a ? (s = !0,
    e.flags &= -129) : (n === null || n.memoizedState !== null) && (r |= 1),
    Vt(tn, r & 1),
    n === null)
        return Rx(e),
        n = e.memoizedState,
        n !== null && (n = n.dehydrated,
        n !== null) ? (e.mode & 1 ? n.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1,
        null) : (o = i.children,
        n = i.fallback,
        s ? (i = e.mode,
        s = e.child,
        o = {
            mode: "hidden",
            children: o
        },
        !(i & 1) && s !== null ? (s.childLanes = 0,
        s.pendingProps = o) : s = Dg(o, i, 0, null),
        n = Ja(n, i, t, null),
        s.return = e,
        n.return = e,
        s.sibling = n,
        e.child = s,
        e.child.memoizedState = Ux(t),
        e.memoizedState = Ox,
        n) : $_(e, o));
    if (r = n.memoizedState,
    r !== null && (a = r.dehydrated,
    a !== null))
        return rk(n, e, o, i, a, r, t);
    if (s) {
        s = i.fallback,
        o = e.mode,
        r = n.child,
        a = r.sibling;
        var l = {
            mode: "hidden",
            children: i.children
        };
        return !(o & 1) && e.child !== r ? (i = e.child,
        i.childLanes = 0,
        i.pendingProps = l,
        e.deletions = null) : (i = No(r, l),
        i.subtreeFlags = r.subtreeFlags & 14680064),
        a !== null ? s = No(a, s) : (s = Ja(s, o, t, null),
        s.flags |= 2),
        s.return = e,
        i.return = e,
        i.sibling = s,
        e.child = i,
        i = s,
        s = e.child,
        o = n.child.memoizedState,
        o = o === null ? Ux(t) : {
            baseLanes: o.baseLanes | t,
            cachePool: null,
            transitions: o.transitions
        },
        s.memoizedState = o,
        s.childLanes = n.childLanes & ~t,
        e.memoizedState = Ox,
        i
    }
    return s = n.child,
    n = s.sibling,
    i = No(s, {
        mode: "visible",
        children: i.children
    }),
    !(e.mode & 1) && (i.lanes = t),
    i.return = e,
    i.sibling = null,
    n !== null && (t = e.deletions,
    t === null ? (e.deletions = [n],
    e.flags |= 16) : t.push(n)),
    e.child = i,
    e.memoizedState = null,
    i
}
function $_(n, e) {
    return e = Dg({
        mode: "visible",
        children: e
    }, n.mode, 0, null),
    e.return = n,
    n.child = e
}
function lp(n, e, t, i) {
    return i !== null && U_(i),
    Lu(e, n.child, null, t),
    n = $_(e, e.pendingProps.children),
    n.flags |= 2,
    e.memoizedState = null,
    n
}
function rk(n, e, t, i, r, s, o) {
    if (t)
        return e.flags & 256 ? (e.flags &= -257,
        i = Wy(Error(Se(422))),
        lp(n, e, o, i)) : e.memoizedState !== null ? (e.child = n.child,
        e.flags |= 128,
        null) : (s = i.fallback,
        r = e.mode,
        i = Dg({
            mode: "visible",
            children: i.children
        }, r, 0, null),
        s = Ja(s, r, o, null),
        s.flags |= 2,
        i.return = e,
        s.return = e,
        i.sibling = s,
        e.child = i,
        e.mode & 1 && Lu(e, n.child, null, o),
        e.child.memoizedState = Ux(o),
        e.memoizedState = Ox,
        s);
    if (!(e.mode & 1))
        return lp(n, e, o, null);
    if (r.data === "$!") {
        if (i = r.nextSibling && r.nextSibling.dataset,
        i)
            var a = i.dgst;
        return i = a,
        s = Error(Se(419)),
        i = Wy(s, i, void 0),
        lp(n, e, o, i)
    }
    if (a = (o & n.childLanes) !== 0,
    Ei || a) {
        if (i = zn,
        i !== null) {
            switch (o & -o) {
            case 4:
                r = 2;
                break;
            case 16:
                r = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                r = 32;
                break;
            case 536870912:
                r = 268435456;
                break;
            default:
                r = 0
            }
            r = r & (i.suspendedLanes | o) ? 0 : r,
            r !== 0 && r !== s.retryLane && (s.retryLane = r,
            Ws(n, r),
            Fr(i, n, r, -1))
        }
        return sA(),
        i = Wy(Error(Se(421))),
        lp(n, e, o, i)
    }
    return r.data === "$?" ? (e.flags |= 128,
    e.child = n.child,
    e = yk.bind(null, n),
    r._reactRetry = e,
    null) : (n = s.treeContext,
    Ui = Io(r.nextSibling),
    Hi = e,
    Zt = !0,
    Rr = null,
    n !== null && (dr[hr++] = Ls,
    dr[hr++] = Is,
    dr[hr++] = nl,
    Ls = n.id,
    Is = n.overflow,
    nl = e),
    e = $_(e, i.children),
    e.flags |= 4096,
    e)
}
function hC(n, e, t) {
    n.lanes |= e;
    var i = n.alternate;
    i !== null && (i.lanes |= e),
    Lx(n.return, e, t)
}
function jy(n, e, t, i, r) {
    var s = n.memoizedState;
    s === null ? n.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: i,
        tail: t,
        tailMode: r
    } : (s.isBackwards = e,
    s.rendering = null,
    s.renderingStartTime = 0,
    s.last = i,
    s.tail = t,
    s.tailMode = r)
}
function PP(n, e, t) {
    var i = e.pendingProps
      , r = i.revealOrder
      , s = i.tail;
    if (fi(n, e, i.children, t),
    i = tn.current,
    i & 2)
        i = i & 1 | 2,
        e.flags |= 128;
    else {
        if (n !== null && n.flags & 128)
            e: for (n = e.child; n !== null; ) {
                if (n.tag === 13)
                    n.memoizedState !== null && hC(n, t, e);
                else if (n.tag === 19)
                    hC(n, t, e);
                else if (n.child !== null) {
                    n.child.return = n,
                    n = n.child;
                    continue
                }
                if (n === e)
                    break e;
                for (; n.sibling === null; ) {
                    if (n.return === null || n.return === e)
                        break e;
                    n = n.return
                }
                n.sibling.return = n.return,
                n = n.sibling
            }
        i &= 1
    }
    if (Vt(tn, i),
    !(e.mode & 1))
        e.memoizedState = null;
    else
        switch (r) {
        case "forwards":
            for (t = e.child,
            r = null; t !== null; )
                n = t.alternate,
                n !== null && Ym(n) === null && (r = t),
                t = t.sibling;
            t = r,
            t === null ? (r = e.child,
            e.child = null) : (r = t.sibling,
            t.sibling = null),
            jy(e, !1, r, t, s);
            break;
        case "backwards":
            for (t = null,
            r = e.child,
            e.child = null; r !== null; ) {
                if (n = r.alternate,
                n !== null && Ym(n) === null) {
                    e.child = r;
                    break
                }
                n = r.sibling,
                r.sibling = t,
                t = r,
                r = n
            }
            jy(e, !0, t, null, s);
            break;
        case "together":
            jy(e, !1, null, null, void 0);
            break;
        default:
            e.memoizedState = null
        }
    return e.child
}
function ym(n, e) {
    !(e.mode & 1) && n !== null && (n.alternate = null,
    e.alternate = null,
    e.flags |= 2)
}
function js(n, e, t) {
    if (n !== null && (e.dependencies = n.dependencies),
    rl |= e.lanes,
    !(t & e.childLanes))
        return null;
    if (n !== null && e.child !== n.child)
        throw Error(Se(153));
    if (e.child !== null) {
        for (n = e.child,
        t = No(n, n.pendingProps),
        e.child = t,
        t.return = e; n.sibling !== null; )
            n = n.sibling,
            t = t.sibling = No(n, n.pendingProps),
            t.return = e;
        t.sibling = null
    }
    return e.child
}
function sk(n, e, t) {
    switch (e.tag) {
    case 3:
        TP(e),
        Ru();
        break;
    case 5:
        nP(e);
        break;
    case 1:
        bi(e.type) && Vm(e);
        break;
    case 4:
        j_(e, e.stateNode.containerInfo);
        break;
    case 10:
        var i = e.type._context
          , r = e.memoizedProps.value;
        Vt(Jm, i._currentValue),
        i._currentValue = r;
        break;
    case 13:
        if (i = e.memoizedState,
        i !== null)
            return i.dehydrated !== null ? (Vt(tn, tn.current & 1),
            e.flags |= 128,
            null) : t & e.child.childLanes ? bP(n, e, t) : (Vt(tn, tn.current & 1),
            n = js(n, e, t),
            n !== null ? n.sibling : null);
        Vt(tn, tn.current & 1);
        break;
    case 19:
        if (i = (t & e.childLanes) !== 0,
        n.flags & 128) {
            if (i)
                return PP(n, e, t);
            e.flags |= 128
        }
        if (r = e.memoizedState,
        r !== null && (r.rendering = null,
        r.tail = null,
        r.lastEffect = null),
        Vt(tn, tn.current),
        i)
            break;
        return null;
    case 22:
    case 23:
        return e.lanes = 0,
        CP(n, e, t)
    }
    return js(n, e, t)
}
var BP, zx, RP, LP;
BP = function(n, e) {
    for (var t = e.child; t !== null; ) {
        if (t.tag === 5 || t.tag === 6)
            n.appendChild(t.stateNode);
        else if (t.tag !== 4 && t.child !== null) {
            t.child.return = t,
            t = t.child;
            continue
        }
        if (t === e)
            break;
        for (; t.sibling === null; ) {
            if (t.return === null || t.return === e)
                return;
            t = t.return
        }
        t.sibling.return = t.return,
        t = t.sibling
    }
}
;
zx = function() {}
;
RP = function(n, e, t, i) {
    var r = n.memoizedProps;
    if (r !== i) {
        n = e.stateNode,
        Oa(is.current);
        var s = null;
        switch (t) {
        case "input":
            r = lx(n, r),
            i = lx(n, i),
            s = [];
            break;
        case "select":
            r = an({}, r, {
                value: void 0
            }),
            i = an({}, i, {
                value: void 0
            }),
            s = [];
            break;
        case "textarea":
            r = fx(n, r),
            i = fx(n, i),
            s = [];
            break;
        default:
            typeof r.onClick != "function" && typeof i.onClick == "function" && (n.onclick = Gm)
        }
        hx(t, i);
        var o;
        t = null;
        for (c in r)
            if (!i.hasOwnProperty(c) && r.hasOwnProperty(c) && r[c] != null)
                if (c === "style") {
                    var a = r[c];
                    for (o in a)
                        a.hasOwnProperty(o) && (t || (t = {}),
                        t[o] = "")
                } else
                    c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (Lf.hasOwnProperty(c) ? s || (s = []) : (s = s || []).push(c, null));
        for (c in i) {
            var l = i[c];
            if (a = r != null ? r[c] : void 0,
            i.hasOwnProperty(c) && l !== a && (l != null || a != null))
                if (c === "style")
                    if (a) {
                        for (o in a)
                            !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (t || (t = {}),
                            t[o] = "");
                        for (o in l)
                            l.hasOwnProperty(o) && a[o] !== l[o] && (t || (t = {}),
                            t[o] = l[o])
                    } else
                        t || (s || (s = []),
                        s.push(c, t)),
                        t = l;
                else
                    c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                    a = a ? a.__html : void 0,
                    l != null && a !== l && (s = s || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (Lf.hasOwnProperty(c) ? (l != null && c === "onScroll" && jt("scroll", n),
                    s || a === l || (s = [])) : (s = s || []).push(c, l))
        }
        t && (s = s || []).push("style", t);
        var c = s;
        (e.updateQueue = c) && (e.flags |= 4)
    }
}
;
LP = function(n, e, t, i) {
    t !== i && (e.flags |= 4)
}
;
function Lc(n, e) {
    if (!Zt)
        switch (n.tailMode) {
        case "hidden":
            e = n.tail;
            for (var t = null; e !== null; )
                e.alternate !== null && (t = e),
                e = e.sibling;
            t === null ? n.tail = null : t.sibling = null;
            break;
        case "collapsed":
            t = n.tail;
            for (var i = null; t !== null; )
                t.alternate !== null && (i = t),
                t = t.sibling;
            i === null ? e || n.tail === null ? n.tail = null : n.tail.sibling = null : i.sibling = null
        }
}
function qn(n) {
    var e = n.alternate !== null && n.alternate.child === n.child
      , t = 0
      , i = 0;
    if (e)
        for (var r = n.child; r !== null; )
            t |= r.lanes | r.childLanes,
            i |= r.subtreeFlags & 14680064,
            i |= r.flags & 14680064,
            r.return = n,
            r = r.sibling;
    else
        for (r = n.child; r !== null; )
            t |= r.lanes | r.childLanes,
            i |= r.subtreeFlags,
            i |= r.flags,
            r.return = n,
            r = r.sibling;
    return n.subtreeFlags |= i,
    n.childLanes = t,
    e
}
function ok(n, e, t) {
    var i = e.pendingProps;
    switch (O_(e),
    e.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return qn(e),
        null;
    case 1:
        return bi(e.type) && Hm(),
        qn(e),
        null;
    case 3:
        return i = e.stateNode,
        Iu(),
        Xt(Ti),
        Xt(ii),
        X_(),
        i.pendingContext && (i.context = i.pendingContext,
        i.pendingContext = null),
        (n === null || n.child === null) && (op(e) ? e.flags |= 4 : n === null || n.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024,
        Rr !== null && (Kx(Rr),
        Rr = null))),
        zx(n, e),
        qn(e),
        null;
    case 5:
        J_(e);
        var r = Oa(Wf.current);
        if (t = e.type,
        n !== null && e.stateNode != null)
            RP(n, e, t, i, r),
            n.ref !== e.ref && (e.flags |= 512,
            e.flags |= 2097152);
        else {
            if (!i) {
                if (e.stateNode === null)
                    throw Error(Se(166));
                return qn(e),
                null
            }
            if (n = Oa(is.current),
            op(e)) {
                i = e.stateNode,
                t = e.type;
                var s = e.memoizedProps;
                switch (i[ts] = e,
                i[Hf] = s,
                n = (e.mode & 1) !== 0,
                t) {
                case "dialog":
                    jt("cancel", i),
                    jt("close", i);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    jt("load", i);
                    break;
                case "video":
                case "audio":
                    for (r = 0; r < lf.length; r++)
                        jt(lf[r], i);
                    break;
                case "source":
                    jt("error", i);
                    break;
                case "img":
                case "image":
                case "link":
                    jt("error", i),
                    jt("load", i);
                    break;
                case "details":
                    jt("toggle", i);
                    break;
                case "input":
                    MS(i, s),
                    jt("invalid", i);
                    break;
                case "select":
                    i._wrapperState = {
                        wasMultiple: !!s.multiple
                    },
                    jt("invalid", i);
                    break;
                case "textarea":
                    SS(i, s),
                    jt("invalid", i)
                }
                hx(t, s),
                r = null;
                for (var o in s)
                    if (s.hasOwnProperty(o)) {
                        var a = s[o];
                        o === "children" ? typeof a == "string" ? i.textContent !== a && (s.suppressHydrationWarning !== !0 && sp(i.textContent, a, n),
                        r = ["children", a]) : typeof a == "number" && i.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && sp(i.textContent, a, n),
                        r = ["children", "" + a]) : Lf.hasOwnProperty(o) && a != null && o === "onScroll" && jt("scroll", i)
                    }
                switch (t) {
                case "input":
                    Zh(i),
                    wS(i, s, !0);
                    break;
                case "textarea":
                    Zh(i),
                    CS(i);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof s.onClick == "function" && (i.onclick = Gm)
                }
                i = r,
                e.updateQueue = i,
                i !== null && (e.flags |= 4)
            } else {
                o = r.nodeType === 9 ? r : r.ownerDocument,
                n === "http://www.w3.org/1999/xhtml" && (n = s2(t)),
                n === "http://www.w3.org/1999/xhtml" ? t === "script" ? (n = o.createElement("div"),
                n.innerHTML = "<script><\/script>",
                n = n.removeChild(n.firstChild)) : typeof i.is == "string" ? n = o.createElement(t, {
                    is: i.is
                }) : (n = o.createElement(t),
                t === "select" && (o = n,
                i.multiple ? o.multiple = !0 : i.size && (o.size = i.size))) : n = o.createElementNS(n, t),
                n[ts] = e,
                n[Hf] = i,
                BP(n, e, !1, !1),
                e.stateNode = n;
                e: {
                    switch (o = px(t, i),
                    t) {
                    case "dialog":
                        jt("cancel", n),
                        jt("close", n),
                        r = i;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        jt("load", n),
                        r = i;
                        break;
                    case "video":
                    case "audio":
                        for (r = 0; r < lf.length; r++)
                            jt(lf[r], n);
                        r = i;
                        break;
                    case "source":
                        jt("error", n),
                        r = i;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        jt("error", n),
                        jt("load", n),
                        r = i;
                        break;
                    case "details":
                        jt("toggle", n),
                        r = i;
                        break;
                    case "input":
                        MS(n, i),
                        r = lx(n, i),
                        jt("invalid", n);
                        break;
                    case "option":
                        r = i;
                        break;
                    case "select":
                        n._wrapperState = {
                            wasMultiple: !!i.multiple
                        },
                        r = an({}, i, {
                            value: void 0
                        }),
                        jt("invalid", n);
                        break;
                    case "textarea":
                        SS(n, i),
                        r = fx(n, i),
                        jt("invalid", n);
                        break;
                    default:
                        r = i
                    }
                    hx(t, r),
                    a = r;
                    for (s in a)
                        if (a.hasOwnProperty(s)) {
                            var l = a[s];
                            s === "style" ? l2(n, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                            l != null && o2(n, l)) : s === "children" ? typeof l == "string" ? (t !== "textarea" || l !== "") && If(n, l) : typeof l == "number" && If(n, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (Lf.hasOwnProperty(s) ? l != null && s === "onScroll" && jt("scroll", n) : l != null && w_(n, s, l, o))
                        }
                    switch (t) {
                    case "input":
                        Zh(n),
                        wS(n, i, !1);
                        break;
                    case "textarea":
                        Zh(n),
                        CS(n);
                        break;
                    case "option":
                        i.value != null && n.setAttribute("value", "" + Go(i.value));
                        break;
                    case "select":
                        n.multiple = !!i.multiple,
                        s = i.value,
                        s != null ? _u(n, !!i.multiple, s, !1) : i.defaultValue != null && _u(n, !!i.multiple, i.defaultValue, !0);
                        break;
                    default:
                        typeof r.onClick == "function" && (n.onclick = Gm)
                    }
                    switch (t) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        i = !!i.autoFocus;
                        break e;
                    case "img":
                        i = !0;
                        break e;
                    default:
                        i = !1
                    }
                }
                i && (e.flags |= 4)
            }
            e.ref !== null && (e.flags |= 512,
            e.flags |= 2097152)
        }
        return qn(e),
        null;
    case 6:
        if (n && e.stateNode != null)
            LP(n, e, n.memoizedProps, i);
        else {
            if (typeof i != "string" && e.stateNode === null)
                throw Error(Se(166));
            if (t = Oa(Wf.current),
            Oa(is.current),
            op(e)) {
                if (i = e.stateNode,
                t = e.memoizedProps,
                i[ts] = e,
                (s = i.nodeValue !== t) && (n = Hi,
                n !== null))
                    switch (n.tag) {
                    case 3:
                        sp(i.nodeValue, t, (n.mode & 1) !== 0);
                        break;
                    case 5:
                        n.memoizedProps.suppressHydrationWarning !== !0 && sp(i.nodeValue, t, (n.mode & 1) !== 0)
                    }
                s && (e.flags |= 4)
            } else
                i = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(i),
                i[ts] = e,
                e.stateNode = i
        }
        return qn(e),
        null;
    case 13:
        if (Xt(tn),
        i = e.memoizedState,
        n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) {
            if (Zt && Ui !== null && e.mode & 1 && !(e.flags & 128))
                Y2(),
                Ru(),
                e.flags |= 98560,
                s = !1;
            else if (s = op(e),
            i !== null && i.dehydrated !== null) {
                if (n === null) {
                    if (!s)
                        throw Error(Se(318));
                    if (s = e.memoizedState,
                    s = s !== null ? s.dehydrated : null,
                    !s)
                        throw Error(Se(317));
                    s[ts] = e
                } else
                    Ru(),
                    !(e.flags & 128) && (e.memoizedState = null),
                    e.flags |= 4;
                qn(e),
                s = !1
            } else
                Rr !== null && (Kx(Rr),
                Rr = null),
                s = !0;
            if (!s)
                return e.flags & 65536 ? e : null
        }
        return e.flags & 128 ? (e.lanes = t,
        e) : (i = i !== null,
        i !== (n !== null && n.memoizedState !== null) && i && (e.child.flags |= 8192,
        e.mode & 1 && (n === null || tn.current & 1 ? bn === 0 && (bn = 3) : sA())),
        e.updateQueue !== null && (e.flags |= 4),
        qn(e),
        null);
    case 4:
        return Iu(),
        zx(n, e),
        n === null && zf(e.stateNode.containerInfo),
        qn(e),
        null;
    case 10:
        return H_(e.type._context),
        qn(e),
        null;
    case 17:
        return bi(e.type) && Hm(),
        qn(e),
        null;
    case 19:
        if (Xt(tn),
        s = e.memoizedState,
        s === null)
            return qn(e),
            null;
        if (i = (e.flags & 128) !== 0,
        o = s.rendering,
        o === null)
            if (i)
                Lc(s, !1);
            else {
                if (bn !== 0 || n !== null && n.flags & 128)
                    for (n = e.child; n !== null; ) {
                        if (o = Ym(n),
                        o !== null) {
                            for (e.flags |= 128,
                            Lc(s, !1),
                            i = o.updateQueue,
                            i !== null && (e.updateQueue = i,
                            e.flags |= 4),
                            e.subtreeFlags = 0,
                            i = t,
                            t = e.child; t !== null; )
                                s = t,
                                n = i,
                                s.flags &= 14680066,
                                o = s.alternate,
                                o === null ? (s.childLanes = 0,
                                s.lanes = n,
                                s.child = null,
                                s.subtreeFlags = 0,
                                s.memoizedProps = null,
                                s.memoizedState = null,
                                s.updateQueue = null,
                                s.dependencies = null,
                                s.stateNode = null) : (s.childLanes = o.childLanes,
                                s.lanes = o.lanes,
                                s.child = o.child,
                                s.subtreeFlags = 0,
                                s.deletions = null,
                                s.memoizedProps = o.memoizedProps,
                                s.memoizedState = o.memoizedState,
                                s.updateQueue = o.updateQueue,
                                s.type = o.type,
                                n = o.dependencies,
                                s.dependencies = n === null ? null : {
                                    lanes: n.lanes,
                                    firstContext: n.firstContext
                                }),
                                t = t.sibling;
                            return Vt(tn, tn.current & 1 | 2),
                            e.child
                        }
                        n = n.sibling
                    }
                s.tail !== null && yn() > Fu && (e.flags |= 128,
                i = !0,
                Lc(s, !1),
                e.lanes = 4194304)
            }
        else {
            if (!i)
                if (n = Ym(o),
                n !== null) {
                    if (e.flags |= 128,
                    i = !0,
                    t = n.updateQueue,
                    t !== null && (e.updateQueue = t,
                    e.flags |= 4),
                    Lc(s, !0),
                    s.tail === null && s.tailMode === "hidden" && !o.alternate && !Zt)
                        return qn(e),
                        null
                } else
                    2 * yn() - s.renderingStartTime > Fu && t !== 1073741824 && (e.flags |= 128,
                    i = !0,
                    Lc(s, !1),
                    e.lanes = 4194304);
            s.isBackwards ? (o.sibling = e.child,
            e.child = o) : (t = s.last,
            t !== null ? t.sibling = o : e.child = o,
            s.last = o)
        }
        return s.tail !== null ? (e = s.tail,
        s.rendering = e,
        s.tail = e.sibling,
        s.renderingStartTime = yn(),
        e.sibling = null,
        t = tn.current,
        Vt(tn, i ? t & 1 | 2 : t & 1),
        e) : (qn(e),
        null);
    case 22:
    case 23:
        return rA(),
        i = e.memoizedState !== null,
        n !== null && n.memoizedState !== null !== i && (e.flags |= 8192),
        i && e.mode & 1 ? Oi & 1073741824 && (qn(e),
        e.subtreeFlags & 6 && (e.flags |= 8192)) : qn(e),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(Se(156, e.tag))
}
function ak(n, e) {
    switch (O_(e),
    e.tag) {
    case 1:
        return bi(e.type) && Hm(),
        n = e.flags,
        n & 65536 ? (e.flags = n & -65537 | 128,
        e) : null;
    case 3:
        return Iu(),
        Xt(Ti),
        Xt(ii),
        X_(),
        n = e.flags,
        n & 65536 && !(n & 128) ? (e.flags = n & -65537 | 128,
        e) : null;
    case 5:
        return J_(e),
        null;
    case 13:
        if (Xt(tn),
        n = e.memoizedState,
        n !== null && n.dehydrated !== null) {
            if (e.alternate === null)
                throw Error(Se(340));
            Ru()
        }
        return n = e.flags,
        n & 65536 ? (e.flags = n & -65537 | 128,
        e) : null;
    case 19:
        return Xt(tn),
        null;
    case 4:
        return Iu(),
        null;
    case 10:
        return H_(e.type._context),
        null;
    case 22:
    case 23:
        return rA(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var up = !1
  , ti = !1
  , lk = typeof WeakSet == "function" ? WeakSet : Set
  , Ge = null;
function fu(n, e) {
    var t = n.ref;
    if (t !== null)
        if (typeof t == "function")
            try {
                t(null)
            } catch (i) {
                dn(n, e, i)
            }
        else
            t.current = null
}
function Gx(n, e, t) {
    try {
        t()
    } catch (i) {
        dn(n, e, i)
    }
}
var pC = !1;
function uk(n, e) {
    if (Sx = Om,
    n = k2(),
    k_(n)) {
        if ("selectionStart"in n)
            var t = {
                start: n.selectionStart,
                end: n.selectionEnd
            };
        else
            e: {
                t = (t = n.ownerDocument) && t.defaultView || window;
                var i = t.getSelection && t.getSelection();
                if (i && i.rangeCount !== 0) {
                    t = i.anchorNode;
                    var r = i.anchorOffset
                      , s = i.focusNode;
                    i = i.focusOffset;
                    try {
                        t.nodeType,
                        s.nodeType
                    } catch {
                        t = null;
                        break e
                    }
                    var o = 0
                      , a = -1
                      , l = -1
                      , c = 0
                      , d = 0
                      , h = n
                      , p = null;
                    t: for (; ; ) {
                        for (var m; h !== t || r !== 0 && h.nodeType !== 3 || (a = o + r),
                        h !== s || i !== 0 && h.nodeType !== 3 || (l = o + i),
                        h.nodeType === 3 && (o += h.nodeValue.length),
                        (m = h.firstChild) !== null; )
                            p = h,
                            h = m;
                        for (; ; ) {
                            if (h === n)
                                break t;
                            if (p === t && ++c === r && (a = o),
                            p === s && ++d === i && (l = o),
                            (m = h.nextSibling) !== null)
                                break;
                            h = p,
                            p = h.parentNode
                        }
                        h = m
                    }
                    t = a === -1 || l === -1 ? null : {
                        start: a,
                        end: l
                    }
                } else
                    t = null
            }
        t = t || {
            start: 0,
            end: 0
        }
    } else
        t = null;
    for (Cx = {
        focusedElem: n,
        selectionRange: t
    },
    Om = !1,
    Ge = e; Ge !== null; )
        if (e = Ge,
        n = e.child,
        (e.subtreeFlags & 1028) !== 0 && n !== null)
            n.return = e,
            Ge = n;
        else
            for (; Ge !== null; ) {
                e = Ge;
                try {
                    var y = e.alternate;
                    if (e.flags & 1024)
                        switch (e.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (y !== null) {
                                var v = y.memoizedProps
                                  , _ = y.memoizedState
                                  , x = e.stateNode
                                  , A = x.getSnapshotBeforeUpdate(e.elementType === e.type ? v : br(e.type, v), _);
                                x.__reactInternalSnapshotBeforeUpdate = A
                            }
                            break;
                        case 3:
                            var M = e.stateNode.containerInfo;
                            M.nodeType === 1 ? M.textContent = "" : M.nodeType === 9 && M.documentElement && M.removeChild(M.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(Se(163))
                        }
                } catch (S) {
                    dn(e, e.return, S)
                }
                if (n = e.sibling,
                n !== null) {
                    n.return = e.return,
                    Ge = n;
                    break
                }
                Ge = e.return
            }
    return y = pC,
    pC = !1,
    y
}
function yf(n, e, t) {
    var i = e.updateQueue;
    if (i = i !== null ? i.lastEffect : null,
    i !== null) {
        var r = i = i.next;
        do {
            if ((r.tag & n) === n) {
                var s = r.destroy;
                r.destroy = void 0,
                s !== void 0 && Gx(e, t, s)
            }
            r = r.next
        } while (r !== i)
    }
}
function Lg(n, e) {
    if (e = e.updateQueue,
    e = e !== null ? e.lastEffect : null,
    e !== null) {
        var t = e = e.next;
        do {
            if ((t.tag & n) === n) {
                var i = t.create;
                t.destroy = i()
            }
            t = t.next
        } while (t !== e)
    }
}
function Hx(n) {
    var e = n.ref;
    if (e !== null) {
        var t = n.stateNode;
        switch (n.tag) {
        case 5:
            n = t;
            break;
        default:
            n = t
        }
        typeof e == "function" ? e(n) : e.current = n
    }
}
function IP(n) {
    var e = n.alternate;
    e !== null && (n.alternate = null,
    IP(e)),
    n.child = null,
    n.deletions = null,
    n.sibling = null,
    n.tag === 5 && (e = n.stateNode,
    e !== null && (delete e[ts],
    delete e[Hf],
    delete e[bx],
    delete e[jF],
    delete e[JF])),
    n.stateNode = null,
    n.return = null,
    n.dependencies = null,
    n.memoizedProps = null,
    n.memoizedState = null,
    n.pendingProps = null,
    n.stateNode = null,
    n.updateQueue = null
}
function DP(n) {
    return n.tag === 5 || n.tag === 3 || n.tag === 4
}
function mC(n) {
    e: for (; ; ) {
        for (; n.sibling === null; ) {
            if (n.return === null || DP(n.return))
                return null;
            n = n.return
        }
        for (n.sibling.return = n.return,
        n = n.sibling; n.tag !== 5 && n.tag !== 6 && n.tag !== 18; ) {
            if (n.flags & 2 || n.child === null || n.tag === 4)
                continue e;
            n.child.return = n,
            n = n.child
        }
        if (!(n.flags & 2))
            return n.stateNode
    }
}
function Vx(n, e, t) {
    var i = n.tag;
    if (i === 5 || i === 6)
        n = n.stateNode,
        e ? t.nodeType === 8 ? t.parentNode.insertBefore(n, e) : t.insertBefore(n, e) : (t.nodeType === 8 ? (e = t.parentNode,
        e.insertBefore(n, t)) : (e = t,
        e.appendChild(n)),
        t = t._reactRootContainer,
        t != null || e.onclick !== null || (e.onclick = Gm));
    else if (i !== 4 && (n = n.child,
    n !== null))
        for (Vx(n, e, t),
        n = n.sibling; n !== null; )
            Vx(n, e, t),
            n = n.sibling
}
function Wx(n, e, t) {
    var i = n.tag;
    if (i === 5 || i === 6)
        n = n.stateNode,
        e ? t.insertBefore(n, e) : t.appendChild(n);
    else if (i !== 4 && (n = n.child,
    n !== null))
        for (Wx(n, e, t),
        n = n.sibling; n !== null; )
            Wx(n, e, t),
            n = n.sibling
}
var Hn = null
  , Pr = !1;
function ao(n, e, t) {
    for (t = t.child; t !== null; )
        FP(n, e, t),
        t = t.sibling
}
function FP(n, e, t) {
    if (ns && typeof ns.onCommitFiberUnmount == "function")
        try {
            ns.onCommitFiberUnmount(Sg, t)
        } catch {}
    switch (t.tag) {
    case 5:
        ti || fu(t, e);
    case 6:
        var i = Hn
          , r = Pr;
        Hn = null,
        ao(n, e, t),
        Hn = i,
        Pr = r,
        Hn !== null && (Pr ? (n = Hn,
        t = t.stateNode,
        n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t)) : Hn.removeChild(t.stateNode));
        break;
    case 18:
        Hn !== null && (Pr ? (n = Hn,
        t = t.stateNode,
        n.nodeType === 8 ? Oy(n.parentNode, t) : n.nodeType === 1 && Oy(n, t),
        Nf(n)) : Oy(Hn, t.stateNode));
        break;
    case 4:
        i = Hn,
        r = Pr,
        Hn = t.stateNode.containerInfo,
        Pr = !0,
        ao(n, e, t),
        Hn = i,
        Pr = r;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!ti && (i = t.updateQueue,
        i !== null && (i = i.lastEffect,
        i !== null))) {
            r = i = i.next;
            do {
                var s = r
                  , o = s.destroy;
                s = s.tag,
                o !== void 0 && (s & 2 || s & 4) && Gx(t, e, o),
                r = r.next
            } while (r !== i)
        }
        ao(n, e, t);
        break;
    case 1:
        if (!ti && (fu(t, e),
        i = t.stateNode,
        typeof i.componentWillUnmount == "function"))
            try {
                i.props = t.memoizedProps,
                i.state = t.memoizedState,
                i.componentWillUnmount()
            } catch (a) {
                dn(t, e, a)
            }
        ao(n, e, t);
        break;
    case 21:
        ao(n, e, t);
        break;
    case 22:
        t.mode & 1 ? (ti = (i = ti) || t.memoizedState !== null,
        ao(n, e, t),
        ti = i) : ao(n, e, t);
        break;
    default:
        ao(n, e, t)
    }
}
function gC(n) {
    var e = n.updateQueue;
    if (e !== null) {
        n.updateQueue = null;
        var t = n.stateNode;
        t === null && (t = n.stateNode = new lk),
        e.forEach(function(i) {
            var r = vk.bind(null, n, i);
            t.has(i) || (t.add(i),
            i.then(r, r))
        })
    }
}
function Sr(n, e) {
    var t = e.deletions;
    if (t !== null)
        for (var i = 0; i < t.length; i++) {
            var r = t[i];
            try {
                var s = n
                  , o = e
                  , a = o;
                e: for (; a !== null; ) {
                    switch (a.tag) {
                    case 5:
                        Hn = a.stateNode,
                        Pr = !1;
                        break e;
                    case 3:
                        Hn = a.stateNode.containerInfo,
                        Pr = !0;
                        break e;
                    case 4:
                        Hn = a.stateNode.containerInfo,
                        Pr = !0;
                        break e
                    }
                    a = a.return
                }
                if (Hn === null)
                    throw Error(Se(160));
                FP(s, o, r),
                Hn = null,
                Pr = !1;
                var l = r.alternate;
                l !== null && (l.return = null),
                r.return = null
            } catch (c) {
                dn(r, e, c)
            }
        }
    if (e.subtreeFlags & 12854)
        for (e = e.child; e !== null; )
            kP(e, n),
            e = e.sibling
}
function kP(n, e) {
    var t = n.alternate
      , i = n.flags;
    switch (n.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (Sr(e, n),
        qr(n),
        i & 4) {
            try {
                yf(3, n, n.return),
                Lg(3, n)
            } catch (v) {
                dn(n, n.return, v)
            }
            try {
                yf(5, n, n.return)
            } catch (v) {
                dn(n, n.return, v)
            }
        }
        break;
    case 1:
        Sr(e, n),
        qr(n),
        i & 512 && t !== null && fu(t, t.return);
        break;
    case 5:
        if (Sr(e, n),
        qr(n),
        i & 512 && t !== null && fu(t, t.return),
        n.flags & 32) {
            var r = n.stateNode;
            try {
                If(r, "")
            } catch (v) {
                dn(n, n.return, v)
            }
        }
        if (i & 4 && (r = n.stateNode,
        r != null)) {
            var s = n.memoizedProps
              , o = t !== null ? t.memoizedProps : s
              , a = n.type
              , l = n.updateQueue;
            if (n.updateQueue = null,
            l !== null)
                try {
                    a === "input" && s.type === "radio" && s.name != null && i2(r, s),
                    px(a, o);
                    var c = px(a, s);
                    for (o = 0; o < l.length; o += 2) {
                        var d = l[o]
                          , h = l[o + 1];
                        d === "style" ? l2(r, h) : d === "dangerouslySetInnerHTML" ? o2(r, h) : d === "children" ? If(r, h) : w_(r, d, h, c)
                    }
                    switch (a) {
                    case "input":
                        ux(r, s);
                        break;
                    case "textarea":
                        r2(r, s);
                        break;
                    case "select":
                        var p = r._wrapperState.wasMultiple;
                        r._wrapperState.wasMultiple = !!s.multiple;
                        var m = s.value;
                        m != null ? _u(r, !!s.multiple, m, !1) : p !== !!s.multiple && (s.defaultValue != null ? _u(r, !!s.multiple, s.defaultValue, !0) : _u(r, !!s.multiple, s.multiple ? [] : "", !1))
                    }
                    r[Hf] = s
                } catch (v) {
                    dn(n, n.return, v)
                }
        }
        break;
    case 6:
        if (Sr(e, n),
        qr(n),
        i & 4) {
            if (n.stateNode === null)
                throw Error(Se(162));
            r = n.stateNode,
            s = n.memoizedProps;
            try {
                r.nodeValue = s
            } catch (v) {
                dn(n, n.return, v)
            }
        }
        break;
    case 3:
        if (Sr(e, n),
        qr(n),
        i & 4 && t !== null && t.memoizedState.isDehydrated)
            try {
                Nf(e.containerInfo)
            } catch (v) {
                dn(n, n.return, v)
            }
        break;
    case 4:
        Sr(e, n),
        qr(n);
        break;
    case 13:
        Sr(e, n),
        qr(n),
        r = n.child,
        r.flags & 8192 && (s = r.memoizedState !== null,
        r.stateNode.isHidden = s,
        !s || r.alternate !== null && r.alternate.memoizedState !== null || (nA = yn())),
        i & 4 && gC(n);
        break;
    case 22:
        if (d = t !== null && t.memoizedState !== null,
        n.mode & 1 ? (ti = (c = ti) || d,
        Sr(e, n),
        ti = c) : Sr(e, n),
        qr(n),
        i & 8192) {
            if (c = n.memoizedState !== null,
            (n.stateNode.isHidden = c) && !d && n.mode & 1)
                for (Ge = n,
                d = n.child; d !== null; ) {
                    for (h = Ge = d; Ge !== null; ) {
                        switch (p = Ge,
                        m = p.child,
                        p.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            yf(4, p, p.return);
                            break;
                        case 1:
                            fu(p, p.return);
                            var y = p.stateNode;
                            if (typeof y.componentWillUnmount == "function") {
                                i = p,
                                t = p.return;
                                try {
                                    e = i,
                                    y.props = e.memoizedProps,
                                    y.state = e.memoizedState,
                                    y.componentWillUnmount()
                                } catch (v) {
                                    dn(i, t, v)
                                }
                            }
                            break;
                        case 5:
                            fu(p, p.return);
                            break;
                        case 22:
                            if (p.memoizedState !== null) {
                                vC(h);
                                continue
                            }
                        }
                        m !== null ? (m.return = p,
                        Ge = m) : vC(h)
                    }
                    d = d.sibling
                }
            e: for (d = null,
            h = n; ; ) {
                if (h.tag === 5) {
                    if (d === null) {
                        d = h;
                        try {
                            r = h.stateNode,
                            c ? (s = r.style,
                            typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = h.stateNode,
                            l = h.memoizedProps.style,
                            o = l != null && l.hasOwnProperty("display") ? l.display : null,
                            a.style.display = a2("display", o))
                        } catch (v) {
                            dn(n, n.return, v)
                        }
                    }
                } else if (h.tag === 6) {
                    if (d === null)
                        try {
                            h.stateNode.nodeValue = c ? "" : h.memoizedProps
                        } catch (v) {
                            dn(n, n.return, v)
                        }
                } else if ((h.tag !== 22 && h.tag !== 23 || h.memoizedState === null || h === n) && h.child !== null) {
                    h.child.return = h,
                    h = h.child;
                    continue
                }
                if (h === n)
                    break e;
                for (; h.sibling === null; ) {
                    if (h.return === null || h.return === n)
                        break e;
                    d === h && (d = null),
                    h = h.return
                }
                d === h && (d = null),
                h.sibling.return = h.return,
                h = h.sibling
            }
        }
        break;
    case 19:
        Sr(e, n),
        qr(n),
        i & 4 && gC(n);
        break;
    case 21:
        break;
    default:
        Sr(e, n),
        qr(n)
    }
}
function qr(n) {
    var e = n.flags;
    if (e & 2) {
        try {
            e: {
                for (var t = n.return; t !== null; ) {
                    if (DP(t)) {
                        var i = t;
                        break e
                    }
                    t = t.return
                }
                throw Error(Se(160))
            }
            switch (i.tag) {
            case 5:
                var r = i.stateNode;
                i.flags & 32 && (If(r, ""),
                i.flags &= -33);
                var s = mC(n);
                Wx(n, s, r);
                break;
            case 3:
            case 4:
                var o = i.stateNode.containerInfo
                  , a = mC(n);
                Vx(n, a, o);
                break;
            default:
                throw Error(Se(161))
            }
        } catch (l) {
            dn(n, n.return, l)
        }
        n.flags &= -3
    }
    e & 4096 && (n.flags &= -4097)
}
function ck(n, e, t) {
    Ge = n,
    NP(n)
}
function NP(n, e, t) {
    for (var i = (n.mode & 1) !== 0; Ge !== null; ) {
        var r = Ge
          , s = r.child;
        if (r.tag === 22 && i) {
            var o = r.memoizedState !== null || up;
            if (!o) {
                var a = r.alternate
                  , l = a !== null && a.memoizedState !== null || ti;
                a = up;
                var c = ti;
                if (up = o,
                (ti = l) && !c)
                    for (Ge = r; Ge !== null; )
                        o = Ge,
                        l = o.child,
                        o.tag === 22 && o.memoizedState !== null ? xC(r) : l !== null ? (l.return = o,
                        Ge = l) : xC(r);
                for (; s !== null; )
                    Ge = s,
                    NP(s),
                    s = s.sibling;
                Ge = r,
                up = a,
                ti = c
            }
            yC(n)
        } else
            r.subtreeFlags & 8772 && s !== null ? (s.return = r,
            Ge = s) : yC(n)
    }
}
function yC(n) {
    for (; Ge !== null; ) {
        var e = Ge;
        if (e.flags & 8772) {
            var t = e.alternate;
            try {
                if (e.flags & 8772)
                    switch (e.tag) {
                    case 0:
                    case 11:
                    case 15:
                        ti || Lg(5, e);
                        break;
                    case 1:
                        var i = e.stateNode;
                        if (e.flags & 4 && !ti)
                            if (t === null)
                                i.componentDidMount();
                            else {
                                var r = e.elementType === e.type ? t.memoizedProps : br(e.type, t.memoizedProps);
                                i.componentDidUpdate(r, t.memoizedState, i.__reactInternalSnapshotBeforeUpdate)
                            }
                        var s = e.updateQueue;
                        s !== null && eC(e, s, i);
                        break;
                    case 3:
                        var o = e.updateQueue;
                        if (o !== null) {
                            if (t = null,
                            e.child !== null)
                                switch (e.child.tag) {
                                case 5:
                                    t = e.child.stateNode;
                                    break;
                                case 1:
                                    t = e.child.stateNode
                                }
                            eC(e, o, t)
                        }
                        break;
                    case 5:
                        var a = e.stateNode;
                        if (t === null && e.flags & 4) {
                            t = a;
                            var l = e.memoizedProps;
                            switch (e.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                l.autoFocus && t.focus();
                                break;
                            case "img":
                                l.src && (t.src = l.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (e.memoizedState === null) {
                            var c = e.alternate;
                            if (c !== null) {
                                var d = c.memoizedState;
                                if (d !== null) {
                                    var h = d.dehydrated;
                                    h !== null && Nf(h)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(Se(163))
                    }
                ti || e.flags & 512 && Hx(e)
            } catch (p) {
                dn(e, e.return, p)
            }
        }
        if (e === n) {
            Ge = null;
            break
        }
        if (t = e.sibling,
        t !== null) {
            t.return = e.return,
            Ge = t;
            break
        }
        Ge = e.return
    }
}
function vC(n) {
    for (; Ge !== null; ) {
        var e = Ge;
        if (e === n) {
            Ge = null;
            break
        }
        var t = e.sibling;
        if (t !== null) {
            t.return = e.return,
            Ge = t;
            break
        }
        Ge = e.return
    }
}
function xC(n) {
    for (; Ge !== null; ) {
        var e = Ge;
        try {
            switch (e.tag) {
            case 0:
            case 11:
            case 15:
                var t = e.return;
                try {
                    Lg(4, e)
                } catch (l) {
                    dn(e, t, l)
                }
                break;
            case 1:
                var i = e.stateNode;
                if (typeof i.componentDidMount == "function") {
                    var r = e.return;
                    try {
                        i.componentDidMount()
                    } catch (l) {
                        dn(e, r, l)
                    }
                }
                var s = e.return;
                try {
                    Hx(e)
                } catch (l) {
                    dn(e, s, l)
                }
                break;
            case 5:
                var o = e.return;
                try {
                    Hx(e)
                } catch (l) {
                    dn(e, o, l)
                }
            }
        } catch (l) {
            dn(e, e.return, l)
        }
        if (e === n) {
            Ge = null;
            break
        }
        var a = e.sibling;
        if (a !== null) {
            a.return = e.return,
            Ge = a;
            break
        }
        Ge = e.return
    }
}
var fk = Math.ceil
  , qm = Ys.ReactCurrentDispatcher
  , eA = Ys.ReactCurrentOwner
  , gr = Ys.ReactCurrentBatchConfig
  , Bt = 0
  , zn = null
  , wn = null
  , Wn = 0
  , Oi = 0
  , du = qo(0)
  , bn = 0
  , Kf = null
  , rl = 0
  , Ig = 0
  , tA = 0
  , vf = null
  , Si = null
  , nA = 0
  , Fu = 1 / 0
  , bs = null
  , $m = !1
  , jx = null
  , Fo = null
  , cp = !1
  , Co = null
  , eg = 0
  , xf = 0
  , Jx = null
  , vm = -1
  , xm = 0;
function pi() {
    return Bt & 6 ? yn() : vm !== -1 ? vm : vm = yn()
}
function ko(n) {
    return n.mode & 1 ? Bt & 2 && Wn !== 0 ? Wn & -Wn : KF.transition !== null ? (xm === 0 && (xm = _2()),
    xm) : (n = Ot,
    n !== 0 || (n = window.event,
    n = n === void 0 ? 16 : T2(n.type)),
    n) : 1
}
function Fr(n, e, t, i) {
    if (50 < xf)
        throw xf = 0,
        Jx = null,
        Error(Se(185));
    _d(n, t, i),
    (!(Bt & 2) || n !== zn) && (n === zn && (!(Bt & 2) && (Ig |= t),
    bn === 4 && wo(n, Wn)),
    Pi(n, i),
    t === 1 && Bt === 0 && !(e.mode & 1) && (Fu = yn() + 500,
    Pg && $o()))
}
function Pi(n, e) {
    var t = n.callbackNode;
    KD(n, e);
    var i = Nm(n, n === zn ? Wn : 0);
    if (i === 0)
        t !== null && bS(t),
        n.callbackNode = null,
        n.callbackPriority = 0;
    else if (e = i & -i,
    n.callbackPriority !== e) {
        if (t != null && bS(t),
        e === 1)
            n.tag === 0 ? XF(_C.bind(null, n)) : J2(_C.bind(null, n)),
            VF(function() {
                !(Bt & 6) && $o()
            }),
            t = null;
        else {
            switch (A2(i)) {
            case 1:
                t = b_;
                break;
            case 4:
                t = v2;
                break;
            case 16:
                t = km;
                break;
            case 536870912:
                t = x2;
                break;
            default:
                t = km
            }
            t = jP(t, OP.bind(null, n))
        }
        n.callbackPriority = e,
        n.callbackNode = t
    }
}
function OP(n, e) {
    if (vm = -1,
    xm = 0,
    Bt & 6)
        throw Error(Se(327));
    var t = n.callbackNode;
    if (Cu() && n.callbackNode !== t)
        return null;
    var i = Nm(n, n === zn ? Wn : 0);
    if (i === 0)
        return null;
    if (i & 30 || i & n.expiredLanes || e)
        e = tg(n, i);
    else {
        e = i;
        var r = Bt;
        Bt |= 2;
        var s = zP();
        (zn !== n || Wn !== e) && (bs = null,
        Fu = yn() + 500,
        ja(n, e));
        do
            try {
                pk();
                break
            } catch (a) {
                UP(n, a)
            }
        while (1);
        G_(),
        qm.current = s,
        Bt = r,
        wn !== null ? e = 0 : (zn = null,
        Wn = 0,
        e = bn)
    }
    if (e !== 0) {
        if (e === 2 && (r = xx(n),
        r !== 0 && (i = r,
        e = Xx(n, r))),
        e === 1)
            throw t = Kf,
            ja(n, 0),
            wo(n, i),
            Pi(n, yn()),
            t;
        if (e === 6)
            wo(n, i);
        else {
            if (r = n.current.alternate,
            !(i & 30) && !dk(r) && (e = tg(n, i),
            e === 2 && (s = xx(n),
            s !== 0 && (i = s,
            e = Xx(n, s))),
            e === 1))
                throw t = Kf,
                ja(n, 0),
                wo(n, i),
                Pi(n, yn()),
                t;
            switch (n.finishedWork = r,
            n.finishedLanes = i,
            e) {
            case 0:
            case 1:
                throw Error(Se(345));
            case 2:
                Ta(n, Si, bs);
                break;
            case 3:
                if (wo(n, i),
                (i & 130023424) === i && (e = nA + 500 - yn(),
                10 < e)) {
                    if (Nm(n, 0) !== 0)
                        break;
                    if (r = n.suspendedLanes,
                    (r & i) !== i) {
                        pi(),
                        n.pingedLanes |= n.suspendedLanes & r;
                        break
                    }
                    n.timeoutHandle = Tx(Ta.bind(null, n, Si, bs), e);
                    break
                }
                Ta(n, Si, bs);
                break;
            case 4:
                if (wo(n, i),
                (i & 4194240) === i)
                    break;
                for (e = n.eventTimes,
                r = -1; 0 < i; ) {
                    var o = 31 - Dr(i);
                    s = 1 << o,
                    o = e[o],
                    o > r && (r = o),
                    i &= ~s
                }
                if (i = r,
                i = yn() - i,
                i = (120 > i ? 120 : 480 > i ? 480 : 1080 > i ? 1080 : 1920 > i ? 1920 : 3e3 > i ? 3e3 : 4320 > i ? 4320 : 1960 * fk(i / 1960)) - i,
                10 < i) {
                    n.timeoutHandle = Tx(Ta.bind(null, n, Si, bs), i);
                    break
                }
                Ta(n, Si, bs);
                break;
            case 5:
                Ta(n, Si, bs);
                break;
            default:
                throw Error(Se(329))
            }
        }
    }
    return Pi(n, yn()),
    n.callbackNode === t ? OP.bind(null, n) : null
}
function Xx(n, e) {
    var t = vf;
    return n.current.memoizedState.isDehydrated && (ja(n, e).flags |= 256),
    n = tg(n, e),
    n !== 2 && (e = Si,
    Si = t,
    e !== null && Kx(e)),
    n
}
function Kx(n) {
    Si === null ? Si = n : Si.push.apply(Si, n)
}
function dk(n) {
    for (var e = n; ; ) {
        if (e.flags & 16384) {
            var t = e.updateQueue;
            if (t !== null && (t = t.stores,
            t !== null))
                for (var i = 0; i < t.length; i++) {
                    var r = t[i]
                      , s = r.getSnapshot;
                    r = r.value;
                    try {
                        if (!Or(s(), r))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (t = e.child,
        e.subtreeFlags & 16384 && t !== null)
            t.return = e,
            e = t;
        else {
            if (e === n)
                break;
            for (; e.sibling === null; ) {
                if (e.return === null || e.return === n)
                    return !0;
                e = e.return
            }
            e.sibling.return = e.return,
            e = e.sibling
        }
    }
    return !0
}
function wo(n, e) {
    for (e &= ~tA,
    e &= ~Ig,
    n.suspendedLanes |= e,
    n.pingedLanes &= ~e,
    n = n.expirationTimes; 0 < e; ) {
        var t = 31 - Dr(e)
          , i = 1 << t;
        n[t] = -1,
        e &= ~i
    }
}
function _C(n) {
    if (Bt & 6)
        throw Error(Se(327));
    Cu();
    var e = Nm(n, 0);
    if (!(e & 1))
        return Pi(n, yn()),
        null;
    var t = tg(n, e);
    if (n.tag !== 0 && t === 2) {
        var i = xx(n);
        i !== 0 && (e = i,
        t = Xx(n, i))
    }
    if (t === 1)
        throw t = Kf,
        ja(n, 0),
        wo(n, e),
        Pi(n, yn()),
        t;
    if (t === 6)
        throw Error(Se(345));
    return n.finishedWork = n.current.alternate,
    n.finishedLanes = e,
    Ta(n, Si, bs),
    Pi(n, yn()),
    null
}
function iA(n, e) {
    var t = Bt;
    Bt |= 1;
    try {
        return n(e)
    } finally {
        Bt = t,
        Bt === 0 && (Fu = yn() + 500,
        Pg && $o())
    }
}
function sl(n) {
    Co !== null && Co.tag === 0 && !(Bt & 6) && Cu();
    var e = Bt;
    Bt |= 1;
    var t = gr.transition
      , i = Ot;
    try {
        if (gr.transition = null,
        Ot = 1,
        n)
            return n()
    } finally {
        Ot = i,
        gr.transition = t,
        Bt = e,
        !(Bt & 6) && $o()
    }
}
function rA() {
    Oi = du.current,
    Xt(du)
}
function ja(n, e) {
    n.finishedWork = null,
    n.finishedLanes = 0;
    var t = n.timeoutHandle;
    if (t !== -1 && (n.timeoutHandle = -1,
    HF(t)),
    wn !== null)
        for (t = wn.return; t !== null; ) {
            var i = t;
            switch (O_(i),
            i.tag) {
            case 1:
                i = i.type.childContextTypes,
                i != null && Hm();
                break;
            case 3:
                Iu(),
                Xt(Ti),
                Xt(ii),
                X_();
                break;
            case 5:
                J_(i);
                break;
            case 4:
                Iu();
                break;
            case 13:
                Xt(tn);
                break;
            case 19:
                Xt(tn);
                break;
            case 10:
                H_(i.type._context);
                break;
            case 22:
            case 23:
                rA()
            }
            t = t.return
        }
    if (zn = n,
    wn = n = No(n.current, null),
    Wn = Oi = e,
    bn = 0,
    Kf = null,
    tA = Ig = rl = 0,
    Si = vf = null,
    Na !== null) {
        for (e = 0; e < Na.length; e++)
            if (t = Na[e],
            i = t.interleaved,
            i !== null) {
                t.interleaved = null;
                var r = i.next
                  , s = t.pending;
                if (s !== null) {
                    var o = s.next;
                    s.next = r,
                    i.next = o
                }
                t.pending = i
            }
        Na = null
    }
    return n
}
function UP(n, e) {
    do {
        var t = wn;
        try {
            if (G_(),
            mm.current = Zm,
            Qm) {
                for (var i = on.memoizedState; i !== null; ) {
                    var r = i.queue;
                    r !== null && (r.pending = null),
                    i = i.next
                }
                Qm = !1
            }
            if (il = 0,
            On = Tn = on = null,
            gf = !1,
            jf = 0,
            eA.current = null,
            t === null || t.return === null) {
                bn = 1,
                Kf = e,
                wn = null;
                break
            }
            e: {
                var s = n
                  , o = t.return
                  , a = t
                  , l = e;
                if (e = Wn,
                a.flags |= 32768,
                l !== null && typeof l == "object" && typeof l.then == "function") {
                    var c = l
                      , d = a
                      , h = d.tag;
                    if (!(d.mode & 1) && (h === 0 || h === 11 || h === 15)) {
                        var p = d.alternate;
                        p ? (d.updateQueue = p.updateQueue,
                        d.memoizedState = p.memoizedState,
                        d.lanes = p.lanes) : (d.updateQueue = null,
                        d.memoizedState = null)
                    }
                    var m = aC(o);
                    if (m !== null) {
                        m.flags &= -257,
                        lC(m, o, a, s, e),
                        m.mode & 1 && oC(s, c, e),
                        e = m,
                        l = c;
                        var y = e.updateQueue;
                        if (y === null) {
                            var v = new Set;
                            v.add(l),
                            e.updateQueue = v
                        } else
                            y.add(l);
                        break e
                    } else {
                        if (!(e & 1)) {
                            oC(s, c, e),
                            sA();
                            break e
                        }
                        l = Error(Se(426))
                    }
                } else if (Zt && a.mode & 1) {
                    var _ = aC(o);
                    if (_ !== null) {
                        !(_.flags & 65536) && (_.flags |= 256),
                        lC(_, o, a, s, e),
                        U_(Du(l, a));
                        break e
                    }
                }
                s = l = Du(l, a),
                bn !== 4 && (bn = 2),
                vf === null ? vf = [s] : vf.push(s),
                s = o;
                do {
                    switch (s.tag) {
                    case 3:
                        s.flags |= 65536,
                        e &= -e,
                        s.lanes |= e;
                        var x = MP(s, l, e);
                        $S(s, x);
                        break e;
                    case 1:
                        a = l;
                        var A = s.type
                          , M = s.stateNode;
                        if (!(s.flags & 128) && (typeof A.getDerivedStateFromError == "function" || M !== null && typeof M.componentDidCatch == "function" && (Fo === null || !Fo.has(M)))) {
                            s.flags |= 65536,
                            e &= -e,
                            s.lanes |= e;
                            var S = wP(s, a, e);
                            $S(s, S);
                            break e
                        }
                    }
                    s = s.return
                } while (s !== null)
            }
            HP(t)
        } catch (T) {
            e = T,
            wn === t && t !== null && (wn = t = t.return);
            continue
        }
        break
    } while (1)
}
function zP() {
    var n = qm.current;
    return qm.current = Zm,
    n === null ? Zm : n
}
function sA() {
    (bn === 0 || bn === 3 || bn === 2) && (bn = 4),
    zn === null || !(rl & 268435455) && !(Ig & 268435455) || wo(zn, Wn)
}
function tg(n, e) {
    var t = Bt;
    Bt |= 2;
    var i = zP();
    (zn !== n || Wn !== e) && (bs = null,
    ja(n, e));
    do
        try {
            hk();
            break
        } catch (r) {
            UP(n, r)
        }
    while (1);
    if (G_(),
    Bt = t,
    qm.current = i,
    wn !== null)
        throw Error(Se(261));
    return zn = null,
    Wn = 0,
    bn
}
function hk() {
    for (; wn !== null; )
        GP(wn)
}
function pk() {
    for (; wn !== null && !UD(); )
        GP(wn)
}
function GP(n) {
    var e = WP(n.alternate, n, Oi);
    n.memoizedProps = n.pendingProps,
    e === null ? HP(n) : wn = e,
    eA.current = null
}
function HP(n) {
    var e = n;
    do {
        var t = e.alternate;
        if (n = e.return,
        e.flags & 32768) {
            if (t = ak(t, e),
            t !== null) {
                t.flags &= 32767,
                wn = t;
                return
            }
            if (n !== null)
                n.flags |= 32768,
                n.subtreeFlags = 0,
                n.deletions = null;
            else {
                bn = 6,
                wn = null;
                return
            }
        } else if (t = ok(t, e, Oi),
        t !== null) {
            wn = t;
            return
        }
        if (e = e.sibling,
        e !== null) {
            wn = e;
            return
        }
        wn = e = n
    } while (e !== null);
    bn === 0 && (bn = 5)
}
function Ta(n, e, t) {
    var i = Ot
      , r = gr.transition;
    try {
        gr.transition = null,
        Ot = 1,
        mk(n, e, t, i)
    } finally {
        gr.transition = r,
        Ot = i
    }
    return null
}
function mk(n, e, t, i) {
    do
        Cu();
    while (Co !== null);
    if (Bt & 6)
        throw Error(Se(327));
    t = n.finishedWork;
    var r = n.finishedLanes;
    if (t === null)
        return null;
    if (n.finishedWork = null,
    n.finishedLanes = 0,
    t === n.current)
        throw Error(Se(177));
    n.callbackNode = null,
    n.callbackPriority = 0;
    var s = t.lanes | t.childLanes;
    if (YD(n, s),
    n === zn && (wn = zn = null,
    Wn = 0),
    !(t.subtreeFlags & 2064) && !(t.flags & 2064) || cp || (cp = !0,
    jP(km, function() {
        return Cu(),
        null
    })),
    s = (t.flags & 15990) !== 0,
    t.subtreeFlags & 15990 || s) {
        s = gr.transition,
        gr.transition = null;
        var o = Ot;
        Ot = 1;
        var a = Bt;
        Bt |= 4,
        eA.current = null,
        uk(n, t),
        kP(t, n),
        FF(Cx),
        Om = !!Sx,
        Cx = Sx = null,
        n.current = t,
        ck(t),
        zD(),
        Bt = a,
        Ot = o,
        gr.transition = s
    } else
        n.current = t;
    if (cp && (cp = !1,
    Co = n,
    eg = r),
    s = n.pendingLanes,
    s === 0 && (Fo = null),
    VD(t.stateNode),
    Pi(n, yn()),
    e !== null)
        for (i = n.onRecoverableError,
        t = 0; t < e.length; t++)
            r = e[t],
            i(r.value, {
                componentStack: r.stack,
                digest: r.digest
            });
    if ($m)
        throw $m = !1,
        n = jx,
        jx = null,
        n;
    return eg & 1 && n.tag !== 0 && Cu(),
    s = n.pendingLanes,
    s & 1 ? n === Jx ? xf++ : (xf = 0,
    Jx = n) : xf = 0,
    $o(),
    null
}
function Cu() {
    if (Co !== null) {
        var n = A2(eg)
          , e = gr.transition
          , t = Ot;
        try {
            if (gr.transition = null,
            Ot = 16 > n ? 16 : n,
            Co === null)
                var i = !1;
            else {
                if (n = Co,
                Co = null,
                eg = 0,
                Bt & 6)
                    throw Error(Se(331));
                var r = Bt;
                for (Bt |= 4,
                Ge = n.current; Ge !== null; ) {
                    var s = Ge
                      , o = s.child;
                    if (Ge.flags & 16) {
                        var a = s.deletions;
                        if (a !== null) {
                            for (var l = 0; l < a.length; l++) {
                                var c = a[l];
                                for (Ge = c; Ge !== null; ) {
                                    var d = Ge;
                                    switch (d.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        yf(8, d, s)
                                    }
                                    var h = d.child;
                                    if (h !== null)
                                        h.return = d,
                                        Ge = h;
                                    else
                                        for (; Ge !== null; ) {
                                            d = Ge;
                                            var p = d.sibling
                                              , m = d.return;
                                            if (IP(d),
                                            d === c) {
                                                Ge = null;
                                                break
                                            }
                                            if (p !== null) {
                                                p.return = m,
                                                Ge = p;
                                                break
                                            }
                                            Ge = m
                                        }
                                }
                            }
                            var y = s.alternate;
                            if (y !== null) {
                                var v = y.child;
                                if (v !== null) {
                                    y.child = null;
                                    do {
                                        var _ = v.sibling;
                                        v.sibling = null,
                                        v = _
                                    } while (v !== null)
                                }
                            }
                            Ge = s
                        }
                    }
                    if (s.subtreeFlags & 2064 && o !== null)
                        o.return = s,
                        Ge = o;
                    else
                        e: for (; Ge !== null; ) {
                            if (s = Ge,
                            s.flags & 2048)
                                switch (s.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    yf(9, s, s.return)
                                }
                            var x = s.sibling;
                            if (x !== null) {
                                x.return = s.return,
                                Ge = x;
                                break e
                            }
                            Ge = s.return
                        }
                }
                var A = n.current;
                for (Ge = A; Ge !== null; ) {
                    o = Ge;
                    var M = o.child;
                    if (o.subtreeFlags & 2064 && M !== null)
                        M.return = o,
                        Ge = M;
                    else
                        e: for (o = A; Ge !== null; ) {
                            if (a = Ge,
                            a.flags & 2048)
                                try {
                                    switch (a.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Lg(9, a)
                                    }
                                } catch (T) {
                                    dn(a, a.return, T)
                                }
                            if (a === o) {
                                Ge = null;
                                break e
                            }
                            var S = a.sibling;
                            if (S !== null) {
                                S.return = a.return,
                                Ge = S;
                                break e
                            }
                            Ge = a.return
                        }
                }
                if (Bt = r,
                $o(),
                ns && typeof ns.onPostCommitFiberRoot == "function")
                    try {
                        ns.onPostCommitFiberRoot(Sg, n)
                    } catch {}
                i = !0
            }
            return i
        } finally {
            Ot = t,
            gr.transition = e
        }
    }
    return !1
}
function AC(n, e, t) {
    e = Du(t, e),
    e = MP(n, e, 1),
    n = Do(n, e, 1),
    e = pi(),
    n !== null && (_d(n, 1, e),
    Pi(n, e))
}
function dn(n, e, t) {
    if (n.tag === 3)
        AC(n, n, t);
    else
        for (; e !== null; ) {
            if (e.tag === 3) {
                AC(e, n, t);
                break
            } else if (e.tag === 1) {
                var i = e.stateNode;
                if (typeof e.type.getDerivedStateFromError == "function" || typeof i.componentDidCatch == "function" && (Fo === null || !Fo.has(i))) {
                    n = Du(t, n),
                    n = wP(e, n, 1),
                    e = Do(e, n, 1),
                    n = pi(),
                    e !== null && (_d(e, 1, n),
                    Pi(e, n));
                    break
                }
            }
            e = e.return
        }
}
function gk(n, e, t) {
    var i = n.pingCache;
    i !== null && i.delete(e),
    e = pi(),
    n.pingedLanes |= n.suspendedLanes & t,
    zn === n && (Wn & t) === t && (bn === 4 || bn === 3 && (Wn & 130023424) === Wn && 500 > yn() - nA ? ja(n, 0) : tA |= t),
    Pi(n, e)
}
function VP(n, e) {
    e === 0 && (n.mode & 1 ? (e = ep,
    ep <<= 1,
    !(ep & 130023424) && (ep = 4194304)) : e = 1);
    var t = pi();
    n = Ws(n, e),
    n !== null && (_d(n, e, t),
    Pi(n, t))
}
function yk(n) {
    var e = n.memoizedState
      , t = 0;
    e !== null && (t = e.retryLane),
    VP(n, t)
}
function vk(n, e) {
    var t = 0;
    switch (n.tag) {
    case 13:
        var i = n.stateNode
          , r = n.memoizedState;
        r !== null && (t = r.retryLane);
        break;
    case 19:
        i = n.stateNode;
        break;
    default:
        throw Error(Se(314))
    }
    i !== null && i.delete(e),
    VP(n, t)
}
var WP;
WP = function(n, e, t) {
    if (n !== null)
        if (n.memoizedProps !== e.pendingProps || Ti.current)
            Ei = !0;
        else {
            if (!(n.lanes & t) && !(e.flags & 128))
                return Ei = !1,
                sk(n, e, t);
            Ei = !!(n.flags & 131072)
        }
    else
        Ei = !1,
        Zt && e.flags & 1048576 && X2(e, jm, e.index);
    switch (e.lanes = 0,
    e.tag) {
    case 2:
        var i = e.type;
        ym(n, e),
        n = e.pendingProps;
        var r = Bu(e, ii.current);
        Su(e, t),
        r = Y_(null, e, i, n, r, t);
        var s = Q_();
        return e.flags |= 1,
        typeof r == "object" && r !== null && typeof r.render == "function" && r.$$typeof === void 0 ? (e.tag = 1,
        e.memoizedState = null,
        e.updateQueue = null,
        bi(i) ? (s = !0,
        Vm(e)) : s = !1,
        e.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null,
        W_(e),
        r.updater = Bg,
        e.stateNode = r,
        r._reactInternals = e,
        Dx(e, i, n, t),
        e = Nx(null, e, i, !0, s, t)) : (e.tag = 0,
        Zt && s && N_(e),
        fi(null, e, r, t),
        e = e.child),
        e;
    case 16:
        i = e.elementType;
        e: {
            switch (ym(n, e),
            n = e.pendingProps,
            r = i._init,
            i = r(i._payload),
            e.type = i,
            r = e.tag = _k(i),
            n = br(i, n),
            r) {
            case 0:
                e = kx(null, e, i, n, t);
                break e;
            case 1:
                e = fC(null, e, i, n, t);
                break e;
            case 11:
                e = uC(null, e, i, n, t);
                break e;
            case 14:
                e = cC(null, e, i, br(i.type, n), t);
                break e
            }
            throw Error(Se(306, i, ""))
        }
        return e;
    case 0:
        return i = e.type,
        r = e.pendingProps,
        r = e.elementType === i ? r : br(i, r),
        kx(n, e, i, r, t);
    case 1:
        return i = e.type,
        r = e.pendingProps,
        r = e.elementType === i ? r : br(i, r),
        fC(n, e, i, r, t);
    case 3:
        e: {
            if (TP(e),
            n === null)
                throw Error(Se(387));
            i = e.pendingProps,
            s = e.memoizedState,
            r = s.element,
            Z2(n, e),
            Km(e, i, null, t);
            var o = e.memoizedState;
            if (i = o.element,
            s.isDehydrated)
                if (s = {
                    element: i,
                    isDehydrated: !1,
                    cache: o.cache,
                    pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                    transitions: o.transitions
                },
                e.updateQueue.baseState = s,
                e.memoizedState = s,
                e.flags & 256) {
                    r = Du(Error(Se(423)), e),
                    e = dC(n, e, i, t, r);
                    break e
                } else if (i !== r) {
                    r = Du(Error(Se(424)), e),
                    e = dC(n, e, i, t, r);
                    break e
                } else
                    for (Ui = Io(e.stateNode.containerInfo.firstChild),
                    Hi = e,
                    Zt = !0,
                    Rr = null,
                    t = tP(e, null, i, t),
                    e.child = t; t; )
                        t.flags = t.flags & -3 | 4096,
                        t = t.sibling;
            else {
                if (Ru(),
                i === r) {
                    e = js(n, e, t);
                    break e
                }
                fi(n, e, i, t)
            }
            e = e.child
        }
        return e;
    case 5:
        return nP(e),
        n === null && Rx(e),
        i = e.type,
        r = e.pendingProps,
        s = n !== null ? n.memoizedProps : null,
        o = r.children,
        Ex(i, r) ? o = null : s !== null && Ex(i, s) && (e.flags |= 32),
        EP(n, e),
        fi(n, e, o, t),
        e.child;
    case 6:
        return n === null && Rx(e),
        null;
    case 13:
        return bP(n, e, t);
    case 4:
        return j_(e, e.stateNode.containerInfo),
        i = e.pendingProps,
        n === null ? e.child = Lu(e, null, i, t) : fi(n, e, i, t),
        e.child;
    case 11:
        return i = e.type,
        r = e.pendingProps,
        r = e.elementType === i ? r : br(i, r),
        uC(n, e, i, r, t);
    case 7:
        return fi(n, e, e.pendingProps, t),
        e.child;
    case 8:
        return fi(n, e, e.pendingProps.children, t),
        e.child;
    case 12:
        return fi(n, e, e.pendingProps.children, t),
        e.child;
    case 10:
        e: {
            if (i = e.type._context,
            r = e.pendingProps,
            s = e.memoizedProps,
            o = r.value,
            Vt(Jm, i._currentValue),
            i._currentValue = o,
            s !== null)
                if (Or(s.value, o)) {
                    if (s.children === r.children && !Ti.current) {
                        e = js(n, e, t);
                        break e
                    }
                } else
                    for (s = e.child,
                    s !== null && (s.return = e); s !== null; ) {
                        var a = s.dependencies;
                        if (a !== null) {
                            o = s.child;
                            for (var l = a.firstContext; l !== null; ) {
                                if (l.context === i) {
                                    if (s.tag === 1) {
                                        l = Os(-1, t & -t),
                                        l.tag = 2;
                                        var c = s.updateQueue;
                                        if (c !== null) {
                                            c = c.shared;
                                            var d = c.pending;
                                            d === null ? l.next = l : (l.next = d.next,
                                            d.next = l),
                                            c.pending = l
                                        }
                                    }
                                    s.lanes |= t,
                                    l = s.alternate,
                                    l !== null && (l.lanes |= t),
                                    Lx(s.return, t, e),
                                    a.lanes |= t;
                                    break
                                }
                                l = l.next
                            }
                        } else if (s.tag === 10)
                            o = s.type === e.type ? null : s.child;
                        else if (s.tag === 18) {
                            if (o = s.return,
                            o === null)
                                throw Error(Se(341));
                            o.lanes |= t,
                            a = o.alternate,
                            a !== null && (a.lanes |= t),
                            Lx(o, t, e),
                            o = s.sibling
                        } else
                            o = s.child;
                        if (o !== null)
                            o.return = s;
                        else
                            for (o = s; o !== null; ) {
                                if (o === e) {
                                    o = null;
                                    break
                                }
                                if (s = o.sibling,
                                s !== null) {
                                    s.return = o.return,
                                    o = s;
                                    break
                                }
                                o = o.return
                            }
                        s = o
                    }
            fi(n, e, r.children, t),
            e = e.child
        }
        return e;
    case 9:
        return r = e.type,
        i = e.pendingProps.children,
        Su(e, t),
        r = vr(r),
        i = i(r),
        e.flags |= 1,
        fi(n, e, i, t),
        e.child;
    case 14:
        return i = e.type,
        r = br(i, e.pendingProps),
        r = br(i.type, r),
        cC(n, e, i, r, t);
    case 15:
        return SP(n, e, e.type, e.pendingProps, t);
    case 17:
        return i = e.type,
        r = e.pendingProps,
        r = e.elementType === i ? r : br(i, r),
        ym(n, e),
        e.tag = 1,
        bi(i) ? (n = !0,
        Vm(e)) : n = !1,
        Su(e, t),
        $2(e, i, r),
        Dx(e, i, r, t),
        Nx(null, e, i, !0, n, t);
    case 19:
        return PP(n, e, t);
    case 22:
        return CP(n, e, t)
    }
    throw Error(Se(156, e.tag))
}
;
function jP(n, e) {
    return y2(n, e)
}
function xk(n, e, t, i) {
    this.tag = n,
    this.key = t,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = e,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = i,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function mr(n, e, t, i) {
    return new xk(n,e,t,i)
}
function oA(n) {
    return n = n.prototype,
    !(!n || !n.isReactComponent)
}
function _k(n) {
    if (typeof n == "function")
        return oA(n) ? 1 : 0;
    if (n != null) {
        if (n = n.$$typeof,
        n === C_)
            return 11;
        if (n === E_)
            return 14
    }
    return 2
}
function No(n, e) {
    var t = n.alternate;
    return t === null ? (t = mr(n.tag, e, n.key, n.mode),
    t.elementType = n.elementType,
    t.type = n.type,
    t.stateNode = n.stateNode,
    t.alternate = n,
    n.alternate = t) : (t.pendingProps = e,
    t.type = n.type,
    t.flags = 0,
    t.subtreeFlags = 0,
    t.deletions = null),
    t.flags = n.flags & 14680064,
    t.childLanes = n.childLanes,
    t.lanes = n.lanes,
    t.child = n.child,
    t.memoizedProps = n.memoizedProps,
    t.memoizedState = n.memoizedState,
    t.updateQueue = n.updateQueue,
    e = n.dependencies,
    t.dependencies = e === null ? null : {
        lanes: e.lanes,
        firstContext: e.firstContext
    },
    t.sibling = n.sibling,
    t.index = n.index,
    t.ref = n.ref,
    t
}
function _m(n, e, t, i, r, s) {
    var o = 2;
    if (i = n,
    typeof n == "function")
        oA(n) && (o = 1);
    else if (typeof n == "string")
        o = 5;
    else
        e: switch (n) {
        case nu:
            return Ja(t.children, r, s, e);
        case S_:
            o = 8,
            r |= 8;
            break;
        case rx:
            return n = mr(12, t, e, r | 2),
            n.elementType = rx,
            n.lanes = s,
            n;
        case sx:
            return n = mr(13, t, e, r),
            n.elementType = sx,
            n.lanes = s,
            n;
        case ox:
            return n = mr(19, t, e, r),
            n.elementType = ox,
            n.lanes = s,
            n;
        case e2:
            return Dg(t, r, s, e);
        default:
            if (typeof n == "object" && n !== null)
                switch (n.$$typeof) {
                case qb:
                    o = 10;
                    break e;
                case $b:
                    o = 9;
                    break e;
                case C_:
                    o = 11;
                    break e;
                case E_:
                    o = 14;
                    break e;
                case vo:
                    o = 16,
                    i = null;
                    break e
                }
            throw Error(Se(130, n == null ? n : typeof n, ""))
        }
    return e = mr(o, t, e, r),
    e.elementType = n,
    e.type = i,
    e.lanes = s,
    e
}
function Ja(n, e, t, i) {
    return n = mr(7, n, i, e),
    n.lanes = t,
    n
}
function Dg(n, e, t, i) {
    return n = mr(22, n, i, e),
    n.elementType = e2,
    n.lanes = t,
    n.stateNode = {
        isHidden: !1
    },
    n
}
function Jy(n, e, t) {
    return n = mr(6, n, null, e),
    n.lanes = t,
    n
}
function Xy(n, e, t) {
    return e = mr(4, n.children !== null ? n.children : [], n.key, e),
    e.lanes = t,
    e.stateNode = {
        containerInfo: n.containerInfo,
        pendingChildren: null,
        implementation: n.implementation
    },
    e
}
function Ak(n, e, t, i, r) {
    this.tag = e,
    this.containerInfo = n,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = Ty(0),
    this.expirationTimes = Ty(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = Ty(0),
    this.identifierPrefix = i,
    this.onRecoverableError = r,
    this.mutableSourceEagerHydrationData = null
}
function aA(n, e, t, i, r, s, o, a, l) {
    return n = new Ak(n,e,t,a,l),
    e === 1 ? (e = 1,
    s === !0 && (e |= 8)) : e = 0,
    s = mr(3, null, null, e),
    n.current = s,
    s.stateNode = n,
    s.memoizedState = {
        element: i,
        isDehydrated: t,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    W_(s),
    n
}
function Mk(n, e, t) {
    var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: tu,
        key: i == null ? null : "" + i,
        children: n,
        containerInfo: e,
        implementation: t
    }
}
function JP(n) {
    if (!n)
        return Ho;
    n = n._reactInternals;
    e: {
        if (fl(n) !== n || n.tag !== 1)
            throw Error(Se(170));
        var e = n;
        do {
            switch (e.tag) {
            case 3:
                e = e.stateNode.context;
                break e;
            case 1:
                if (bi(e.type)) {
                    e = e.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            e = e.return
        } while (e !== null);
        throw Error(Se(171))
    }
    if (n.tag === 1) {
        var t = n.type;
        if (bi(t))
            return j2(n, t, e)
    }
    return e
}
function XP(n, e, t, i, r, s, o, a, l) {
    return n = aA(t, i, !0, n, r, s, o, a, l),
    n.context = JP(null),
    t = n.current,
    i = pi(),
    r = ko(t),
    s = Os(i, r),
    s.callback = e ?? null,
    Do(t, s, r),
    n.current.lanes = r,
    _d(n, r, i),
    Pi(n, i),
    n
}
function Fg(n, e, t, i) {
    var r = e.current
      , s = pi()
      , o = ko(r);
    return t = JP(t),
    e.context === null ? e.context = t : e.pendingContext = t,
    e = Os(s, o),
    e.payload = {
        element: n
    },
    i = i === void 0 ? null : i,
    i !== null && (e.callback = i),
    n = Do(r, e, o),
    n !== null && (Fr(n, r, o, s),
    pm(n, r, o)),
    o
}
function ng(n) {
    if (n = n.current,
    !n.child)
        return null;
    switch (n.child.tag) {
    case 5:
        return n.child.stateNode;
    default:
        return n.child.stateNode
    }
}
function MC(n, e) {
    if (n = n.memoizedState,
    n !== null && n.dehydrated !== null) {
        var t = n.retryLane;
        n.retryLane = t !== 0 && t < e ? t : e
    }
}
function lA(n, e) {
    MC(n, e),
    (n = n.alternate) && MC(n, e)
}
function wk() {
    return null
}
var KP = typeof reportError == "function" ? reportError : function(n) {
    console.error(n)
}
;
function uA(n) {
    this._internalRoot = n
}
kg.prototype.render = uA.prototype.render = function(n) {
    var e = this._internalRoot;
    if (e === null)
        throw Error(Se(409));
    Fg(n, e, null, null)
}
;
kg.prototype.unmount = uA.prototype.unmount = function() {
    var n = this._internalRoot;
    if (n !== null) {
        this._internalRoot = null;
        var e = n.containerInfo;
        sl(function() {
            Fg(null, n, null, null)
        }),
        e[Vs] = null
    }
}
;
function kg(n) {
    this._internalRoot = n
}
kg.prototype.unstable_scheduleHydration = function(n) {
    if (n) {
        var e = S2();
        n = {
            blockedOn: null,
            target: n,
            priority: e
        };
        for (var t = 0; t < Mo.length && e !== 0 && e < Mo[t].priority; t++)
            ;
        Mo.splice(t, 0, n),
        t === 0 && E2(n)
    }
}
;
function cA(n) {
    return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11)
}
function Ng(n) {
    return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11 && (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable "))
}
function wC() {}
function Sk(n, e, t, i, r) {
    if (r) {
        if (typeof i == "function") {
            var s = i;
            i = function() {
                var c = ng(o);
                s.call(c)
            }
        }
        var o = XP(e, i, n, 0, null, !1, !1, "", wC);
        return n._reactRootContainer = o,
        n[Vs] = o.current,
        zf(n.nodeType === 8 ? n.parentNode : n),
        sl(),
        o
    }
    for (; r = n.lastChild; )
        n.removeChild(r);
    if (typeof i == "function") {
        var a = i;
        i = function() {
            var c = ng(l);
            a.call(c)
        }
    }
    var l = aA(n, 0, !1, null, null, !1, !1, "", wC);
    return n._reactRootContainer = l,
    n[Vs] = l.current,
    zf(n.nodeType === 8 ? n.parentNode : n),
    sl(function() {
        Fg(e, l, t, i)
    }),
    l
}
function Og(n, e, t, i, r) {
    var s = t._reactRootContainer;
    if (s) {
        var o = s;
        if (typeof r == "function") {
            var a = r;
            r = function() {
                var l = ng(o);
                a.call(l)
            }
        }
        Fg(e, o, n, r)
    } else
        o = Sk(t, e, n, r, i);
    return ng(o)
}
M2 = function(n) {
    switch (n.tag) {
    case 3:
        var e = n.stateNode;
        if (e.current.memoizedState.isDehydrated) {
            var t = af(e.pendingLanes);
            t !== 0 && (P_(e, t | 1),
            Pi(e, yn()),
            !(Bt & 6) && (Fu = yn() + 500,
            $o()))
        }
        break;
    case 13:
        sl(function() {
            var i = Ws(n, 1);
            if (i !== null) {
                var r = pi();
                Fr(i, n, 1, r)
            }
        }),
        lA(n, 1)
    }
}
;
B_ = function(n) {
    if (n.tag === 13) {
        var e = Ws(n, 134217728);
        if (e !== null) {
            var t = pi();
            Fr(e, n, 134217728, t)
        }
        lA(n, 134217728)
    }
}
;
w2 = function(n) {
    if (n.tag === 13) {
        var e = ko(n)
          , t = Ws(n, e);
        if (t !== null) {
            var i = pi();
            Fr(t, n, e, i)
        }
        lA(n, e)
    }
}
;
S2 = function() {
    return Ot
}
;
C2 = function(n, e) {
    var t = Ot;
    try {
        return Ot = n,
        e()
    } finally {
        Ot = t
    }
}
;
gx = function(n, e, t) {
    switch (e) {
    case "input":
        if (ux(n, t),
        e = t.name,
        t.type === "radio" && e != null) {
            for (t = n; t.parentNode; )
                t = t.parentNode;
            for (t = t.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'),
            e = 0; e < t.length; e++) {
                var i = t[e];
                if (i !== n && i.form === n.form) {
                    var r = bg(i);
                    if (!r)
                        throw Error(Se(90));
                    n2(i),
                    ux(i, r)
                }
            }
        }
        break;
    case "textarea":
        r2(n, t);
        break;
    case "select":
        e = t.value,
        e != null && _u(n, !!t.multiple, e, !1)
    }
}
;
f2 = iA;
d2 = sl;
var Ck = {
    usingClientEntryPoint: !1,
    Events: [Md, ou, bg, u2, c2, iA]
}
  , Ic = {
    findFiberByHostInstance: ka,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom"
}
  , Ek = {
    bundleType: Ic.bundleType,
    version: Ic.version,
    rendererPackageName: Ic.rendererPackageName,
    rendererConfig: Ic.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: Ys.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(n) {
        return n = m2(n),
        n === null ? null : n.stateNode
    },
    findFiberByHostInstance: Ic.findFiberByHostInstance || wk,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var fp = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!fp.isDisabled && fp.supportsFiber)
        try {
            Sg = fp.inject(Ek),
            ns = fp
        } catch {}
}
Xi.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Ck;
Xi.createPortal = function(n, e) {
    var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!cA(e))
        throw Error(Se(200));
    return Mk(n, e, null, t)
}
;
Xi.createRoot = function(n, e) {
    if (!cA(n))
        throw Error(Se(299));
    var t = !1
      , i = ""
      , r = KP;
    return e != null && (e.unstable_strictMode === !0 && (t = !0),
    e.identifierPrefix !== void 0 && (i = e.identifierPrefix),
    e.onRecoverableError !== void 0 && (r = e.onRecoverableError)),
    e = aA(n, 1, !1, null, null, t, !1, i, r),
    n[Vs] = e.current,
    zf(n.nodeType === 8 ? n.parentNode : n),
    new uA(e)
}
;
Xi.findDOMNode = function(n) {
    if (n == null)
        return null;
    if (n.nodeType === 1)
        return n;
    var e = n._reactInternals;
    if (e === void 0)
        throw typeof n.render == "function" ? Error(Se(188)) : (n = Object.keys(n).join(","),
        Error(Se(268, n)));
    return n = m2(e),
    n = n === null ? null : n.stateNode,
    n
}
;
Xi.flushSync = function(n) {
    return sl(n)
}
;
Xi.hydrate = function(n, e, t) {
    if (!Ng(e))
        throw Error(Se(200));
    return Og(null, n, e, !0, t)
}
;
Xi.hydrateRoot = function(n, e, t) {
    if (!cA(n))
        throw Error(Se(405));
    var i = t != null && t.hydratedSources || null
      , r = !1
      , s = ""
      , o = KP;
    if (t != null && (t.unstable_strictMode === !0 && (r = !0),
    t.identifierPrefix !== void 0 && (s = t.identifierPrefix),
    t.onRecoverableError !== void 0 && (o = t.onRecoverableError)),
    e = XP(e, null, n, 1, t ?? null, r, !1, s, o),
    n[Vs] = e.current,
    zf(n),
    i)
        for (n = 0; n < i.length; n++)
            t = i[n],
            r = t._getVersion,
            r = r(t._source),
            e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [t, r] : e.mutableSourceEagerHydrationData.push(t, r);
    return new kg(e)
}
;
Xi.render = function(n, e, t) {
    if (!Ng(e))
        throw Error(Se(200));
    return Og(null, n, e, !1, t)
}
;
Xi.unmountComponentAtNode = function(n) {
    if (!Ng(n))
        throw Error(Se(40));
    return n._reactRootContainer ? (sl(function() {
        Og(null, null, n, !1, function() {
            n._reactRootContainer = null,
            n[Vs] = null
        })
    }),
    !0) : !1
}
;
Xi.unstable_batchedUpdates = iA;
Xi.unstable_renderSubtreeIntoContainer = function(n, e, t, i) {
    if (!Ng(t))
        throw Error(Se(200));
    if (n == null || n._reactInternals === void 0)
        throw Error(Se(38));
    return Og(n, e, t, !1, i)
}
;
Xi.version = "18.2.0-next-9e3b772b8-20220608";
(function(n) {
    function e() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
            } catch (t) {
                console.error(t)
            }
    }
    e(),
    n.exports = Xi
}
)(wD);
var YP, SC = tx;
YP = ex.createRoot = SC.createRoot,
ex.hydrateRoot = SC.hydrateRoot;
const Tk = "modulepreload"
  , bk = function(n, e) {
    return new URL(n,e).href
}
  , CC = {}
  , Ug = function(e, t, i) {
    if (!t || t.length === 0)
        return e();
    const r = document.getElementsByTagName("link");
    return Promise.all(t.map(s=>{
        if (s = bk(s, i),
        s in CC)
            return;
        CC[s] = !0;
        const o = s.endsWith(".css")
          , a = o ? '[rel="stylesheet"]' : "";
        if (!!i)
            for (let d = r.length - 1; d >= 0; d--) {
                const h = r[d];
                if (h.href === s && (!o || h.rel === "stylesheet"))
                    return
            }
        else if (document.querySelector(`link[href="${s}"]${a}`))
            return;
        const c = document.createElement("link");
        if (c.rel = o ? "stylesheet" : Tk,
        o || (c.as = "script",
        c.crossOrigin = ""),
        c.href = s,
        document.head.appendChild(c),
        o)
            return new Promise((d,h)=>{
                c.addEventListener("load", d),
                c.addEventListener("error", ()=>h(new Error(`Unable to preload CSS for ${s}`)))
            }
            )
    }
    )).then(()=>e())
};
/**
 * @remix-run/router v1.3.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function Yf() {
    return Yf = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }
    ,
    Yf.apply(this, arguments)
}
var Eo;
(function(n) {
    n.Pop = "POP",
    n.Push = "PUSH",
    n.Replace = "REPLACE"
}
)(Eo || (Eo = {}));
const EC = "popstate";
function Pk(n) {
    n === void 0 && (n = {});
    function e(i, r) {
        let {pathname: s, search: o, hash: a} = i.location;
        return Yx("", {
            pathname: s,
            search: o,
            hash: a
        }, r.state && r.state.usr || null, r.state && r.state.key || "default")
    }
    function t(i, r) {
        return typeof r == "string" ? r : ig(r)
    }
    return Rk(e, t, null, n)
}
function Pn(n, e) {
    if (n === !1 || n === null || typeof n > "u")
        throw new Error(e)
}
function Bk() {
    return Math.random().toString(36).substr(2, 8)
}
function TC(n, e) {
    return {
        usr: n.state,
        key: n.key,
        idx: e
    }
}
function Yx(n, e, t, i) {
    return t === void 0 && (t = null),
    Yf({
        pathname: typeof n == "string" ? n : n.pathname,
        search: "",
        hash: ""
    }, typeof e == "string" ? Zu(e) : e, {
        state: t,
        key: e && e.key || i || Bk()
    })
}
function ig(n) {
    let {pathname: e="/", search: t="", hash: i=""} = n;
    return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t),
    i && i !== "#" && (e += i.charAt(0) === "#" ? i : "#" + i),
    e
}
function Zu(n) {
    let e = {};
    if (n) {
        let t = n.indexOf("#");
        t >= 0 && (e.hash = n.substr(t),
        n = n.substr(0, t));
        let i = n.indexOf("?");
        i >= 0 && (e.search = n.substr(i),
        n = n.substr(0, i)),
        n && (e.pathname = n)
    }
    return e
}
function Rk(n, e, t, i) {
    i === void 0 && (i = {});
    let {window: r=document.defaultView, v5Compat: s=!1} = i
      , o = r.history
      , a = Eo.Pop
      , l = null
      , c = d();
    c == null && (c = 0,
    o.replaceState(Yf({}, o.state, {
        idx: c
    }), ""));
    function d() {
        return (o.state || {
            idx: null
        }).idx
    }
    function h() {
        a = Eo.Pop;
        let _ = d()
          , x = _ == null ? null : _ - c;
        c = _,
        l && l({
            action: a,
            location: v.location,
            delta: x
        })
    }
    function p(_, x) {
        a = Eo.Push;
        let A = Yx(v.location, _, x);
        t && t(A, _),
        c = d() + 1;
        let M = TC(A, c)
          , S = v.createHref(A);
        try {
            o.pushState(M, "", S)
        } catch {
            r.location.assign(S)
        }
        s && l && l({
            action: a,
            location: v.location,
            delta: 1
        })
    }
    function m(_, x) {
        a = Eo.Replace;
        let A = Yx(v.location, _, x);
        t && t(A, _),
        c = d();
        let M = TC(A, c)
          , S = v.createHref(A);
        o.replaceState(M, "", S),
        s && l && l({
            action: a,
            location: v.location,
            delta: 0
        })
    }
    function y(_) {
        let x = r.location.origin !== "null" ? r.location.origin : r.location.href
          , A = typeof _ == "string" ? _ : ig(_);
        return Pn(x, "No window.location.(origin|href) available to create URL for href: " + A),
        new URL(A,x)
    }
    let v = {
        get action() {
            return a
        },
        get location() {
            return n(r, o)
        },
        listen(_) {
            if (l)
                throw new Error("A history only accepts one active listener");
            return r.addEventListener(EC, h),
            l = _,
            ()=>{
                r.removeEventListener(EC, h),
                l = null
            }
        },
        createHref(_) {
            return e(r, _)
        },
        createURL: y,
        encodeLocation(_) {
            let x = y(_);
            return {
                pathname: x.pathname,
                search: x.search,
                hash: x.hash
            }
        },
        push: p,
        replace: m,
        go(_) {
            return o.go(_)
        }
    };
    return v
}
var bC;
(function(n) {
    n.data = "data",
    n.deferred = "deferred",
    n.redirect = "redirect",
    n.error = "error"
}
)(bC || (bC = {}));
function Lk(n, e, t) {
    t === void 0 && (t = "/");
    let i = typeof e == "string" ? Zu(e) : e
      , r = qP(i.pathname || "/", t);
    if (r == null)
        return null;
    let s = QP(n);
    Ik(s);
    let o = null;
    for (let a = 0; o == null && a < s.length; ++a)
        o = Hk(s[a], jk(r));
    return o
}
function QP(n, e, t, i) {
    e === void 0 && (e = []),
    t === void 0 && (t = []),
    i === void 0 && (i = "");
    let r = (s,o,a)=>{
        let l = {
            relativePath: a === void 0 ? s.path || "" : a,
            caseSensitive: s.caseSensitive === !0,
            childrenIndex: o,
            route: s
        };
        l.relativePath.startsWith("/") && (Pn(l.relativePath.startsWith(i), 'Absolute route path "' + l.relativePath + '" nested under path ' + ('"' + i + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."),
        l.relativePath = l.relativePath.slice(i.length));
        let c = Oo([i, l.relativePath])
          , d = t.concat(l);
        s.children && s.children.length > 0 && (Pn(s.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + c + '".')),
        QP(s.children, e, d, c)),
        !(s.path == null && !s.index) && e.push({
            path: c,
            score: zk(c, s.index),
            routesMeta: d
        })
    }
    ;
    return n.forEach((s,o)=>{
        var a;
        if (s.path === "" || !((a = s.path) != null && a.includes("?")))
            r(s, o);
        else
            for (let l of ZP(s.path))
                r(s, o, l)
    }
    ),
    e
}
function ZP(n) {
    let e = n.split("/");
    if (e.length === 0)
        return [];
    let[t,...i] = e
      , r = t.endsWith("?")
      , s = t.replace(/\?$/, "");
    if (i.length === 0)
        return r ? [s, ""] : [s];
    let o = ZP(i.join("/"))
      , a = [];
    return a.push(...o.map(l=>l === "" ? s : [s, l].join("/"))),
    r && a.push(...o),
    a.map(l=>n.startsWith("/") && l === "" ? "/" : l)
}
function Ik(n) {
    n.sort((e,t)=>e.score !== t.score ? t.score - e.score : Gk(e.routesMeta.map(i=>i.childrenIndex), t.routesMeta.map(i=>i.childrenIndex)))
}
const Dk = /^:\w+$/
  , Fk = 3
  , kk = 2
  , Nk = 1
  , Ok = 10
  , Uk = -2
  , PC = n=>n === "*";
function zk(n, e) {
    let t = n.split("/")
      , i = t.length;
    return t.some(PC) && (i += Uk),
    e && (i += kk),
    t.filter(r=>!PC(r)).reduce((r,s)=>r + (Dk.test(s) ? Fk : s === "" ? Nk : Ok), i)
}
function Gk(n, e) {
    return n.length === e.length && n.slice(0, -1).every((i,r)=>i === e[r]) ? n[n.length - 1] - e[e.length - 1] : 0
}
function Hk(n, e) {
    let {routesMeta: t} = n
      , i = {}
      , r = "/"
      , s = [];
    for (let o = 0; o < t.length; ++o) {
        let a = t[o]
          , l = o === t.length - 1
          , c = r === "/" ? e : e.slice(r.length) || "/"
          , d = Vk({
            path: a.relativePath,
            caseSensitive: a.caseSensitive,
            end: l
        }, c);
        if (!d)
            return null;
        Object.assign(i, d.params);
        let h = a.route;
        s.push({
            params: i,
            pathname: Oo([r, d.pathname]),
            pathnameBase: Yk(Oo([r, d.pathnameBase])),
            route: h
        }),
        d.pathnameBase !== "/" && (r = Oo([r, d.pathnameBase]))
    }
    return s
}
function Vk(n, e) {
    typeof n == "string" && (n = {
        path: n,
        caseSensitive: !1,
        end: !0
    });
    let[t,i] = Wk(n.path, n.caseSensitive, n.end)
      , r = e.match(t);
    if (!r)
        return null;
    let s = r[0]
      , o = s.replace(/(.)\/+$/, "$1")
      , a = r.slice(1);
    return {
        params: i.reduce((c,d,h)=>{
            if (d === "*") {
                let p = a[h] || "";
                o = s.slice(0, s.length - p.length).replace(/(.)\/+$/, "$1")
            }
            return c[d] = Jk(a[h] || "", d),
            c
        }
        , {}),
        pathname: s,
        pathnameBase: o,
        pattern: n
    }
}
function Wk(n, e, t) {
    e === void 0 && (e = !1),
    t === void 0 && (t = !0),
    fA(n === "*" || !n.endsWith("*") || n.endsWith("/*"), 'Route path "' + n + '" will be treated as if it were ' + ('"' + n.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + n.replace(/\*$/, "/*") + '".'));
    let i = []
      , r = "^" + n.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (o,a)=>(i.push(a),
    "/([^\\/]+)"));
    return n.endsWith("*") ? (i.push("*"),
    r += n === "*" || n === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : t ? r += "\\/*$" : n !== "" && n !== "/" && (r += "(?:(?=\\/|$))"),
    [new RegExp(r,e ? void 0 : "i"), i]
}
function jk(n) {
    try {
        return decodeURI(n)
    } catch (e) {
        return fA(!1, 'The URL path "' + n + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + e + ").")),
        n
    }
}
function Jk(n, e) {
    try {
        return decodeURIComponent(n)
    } catch (t) {
        return fA(!1, 'The value for the URL param "' + e + '" will not be decoded because' + (' the string "' + n + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + t + ").")),
        n
    }
}
function qP(n, e) {
    if (e === "/")
        return n;
    if (!n.toLowerCase().startsWith(e.toLowerCase()))
        return null;
    let t = e.endsWith("/") ? e.length - 1 : e.length
      , i = n.charAt(t);
    return i && i !== "/" ? null : n.slice(t) || "/"
}
function fA(n, e) {
    if (!n) {
        typeof console < "u" && console.warn(e);
        try {
            throw new Error(e)
        } catch {}
    }
}
function Xk(n, e) {
    e === void 0 && (e = "/");
    let {pathname: t, search: i="", hash: r=""} = typeof n == "string" ? Zu(n) : n;
    return {
        pathname: t ? t.startsWith("/") ? t : Kk(t, e) : e,
        search: Qk(i),
        hash: Zk(r)
    }
}
function Kk(n, e) {
    let t = e.replace(/\/+$/, "").split("/");
    return n.split("/").forEach(r=>{
        r === ".." ? t.length > 1 && t.pop() : r !== "." && t.push(r)
    }
    ),
    t.length > 1 ? t.join("/") : "/"
}
function Ky(n, e, t, i) {
    return "Cannot include a '" + n + "' character in a manually specified " + ("`to." + e + "` field [" + JSON.stringify(i) + "].  Please separate it out to the ") + ("`to." + t + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.'
}
function $P(n) {
    return n.filter((e,t)=>t === 0 || e.route.path && e.route.path.length > 0)
}
function e3(n, e, t, i) {
    i === void 0 && (i = !1);
    let r;
    typeof n == "string" ? r = Zu(n) : (r = Yf({}, n),
    Pn(!r.pathname || !r.pathname.includes("?"), Ky("?", "pathname", "search", r)),
    Pn(!r.pathname || !r.pathname.includes("#"), Ky("#", "pathname", "hash", r)),
    Pn(!r.search || !r.search.includes("#"), Ky("#", "search", "hash", r)));
    let s = n === "" || r.pathname === "", o = s ? "/" : r.pathname, a;
    if (i || o == null)
        a = t;
    else {
        let h = e.length - 1;
        if (o.startsWith("..")) {
            let p = o.split("/");
            for (; p[0] === ".."; )
                p.shift(),
                h -= 1;
            r.pathname = p.join("/")
        }
        a = h >= 0 ? e[h] : "/"
    }
    let l = Xk(r, a)
      , c = o && o !== "/" && o.endsWith("/")
      , d = (s || o === ".") && t.endsWith("/");
    return !l.pathname.endsWith("/") && (c || d) && (l.pathname += "/"),
    l
}
const Oo = n=>n.join("/").replace(/\/\/+/g, "/")
  , Yk = n=>n.replace(/\/+$/, "").replace(/^\/*/, "/")
  , Qk = n=>!n || n === "?" ? "" : n.startsWith("?") ? n : "?" + n
  , Zk = n=>!n || n === "#" ? "" : n.startsWith("#") ? n : "#" + n;
function qk(n) {
    return n != null && typeof n.status == "number" && typeof n.statusText == "string" && typeof n.internal == "boolean" && "data"in n
}
const $k = ["post", "put", "patch", "delete"];
[...$k];
/**
 * React Router v6.8.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function Qx() {
    return Qx = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }
    ,
    Qx.apply(this, arguments)
}
function eN(n, e) {
    return n === e && (n !== 0 || 1 / n === 1 / e) || n !== n && e !== e
}
const tN = typeof Object.is == "function" ? Object.is : eN
  , {useState: nN, useEffect: iN, useLayoutEffect: rN, useDebugValue: sN} = $v;
function oN(n, e, t) {
    const i = e()
      , [{inst: r},s] = nN({
        inst: {
            value: i,
            getSnapshot: e
        }
    });
    return rN(()=>{
        r.value = i,
        r.getSnapshot = e,
        Yy(r) && s({
            inst: r
        })
    }
    , [n, i, e]),
    iN(()=>(Yy(r) && s({
        inst: r
    }),
    n(()=>{
        Yy(r) && s({
            inst: r
        })
    }
    )), [n]),
    sN(i),
    i
}
function Yy(n) {
    const e = n.getSnapshot
      , t = n.value;
    try {
        const i = e();
        return !tN(t, i)
    } catch {
        return !0
    }
}
function aN(n, e, t) {
    return e()
}
const lN = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"
  , uN = !lN
  , cN = uN ? aN : oN;
"useSyncExternalStore"in $v && (n=>n.useSyncExternalStore)($v);
const t3 = O.createContext(null)
  , n3 = O.createContext(null)
  , zg = O.createContext(null)
  , Gg = O.createContext(null)
  , dl = O.createContext({
    outlet: null,
    matches: []
})
  , i3 = O.createContext(null);
function fN(n, e) {
    let {relative: t} = e === void 0 ? {} : e;
    Sd() || Pn(!1);
    let {basename: i, navigator: r} = O.useContext(zg)
      , {hash: s, pathname: o, search: a} = r3(n, {
        relative: t
    })
      , l = o;
    return i !== "/" && (l = o === "/" ? i : Oo([i, o])),
    r.createHref({
        pathname: l,
        search: a,
        hash: s
    })
}
function Sd() {
    return O.useContext(Gg) != null
}
function Hg() {
    return Sd() || Pn(!1),
    O.useContext(Gg).location
}
function dN() {
    Sd() || Pn(!1);
    let {basename: n, navigator: e} = O.useContext(zg)
      , {matches: t} = O.useContext(dl)
      , {pathname: i} = Hg()
      , r = JSON.stringify($P(t).map(a=>a.pathnameBase))
      , s = O.useRef(!1);
    return O.useEffect(()=>{
        s.current = !0
    }
    ),
    O.useCallback(function(a, l) {
        if (l === void 0 && (l = {}),
        !s.current)
            return;
        if (typeof a == "number") {
            e.go(a);
            return
        }
        let c = e3(a, JSON.parse(r), i, l.relative === "path");
        n !== "/" && (c.pathname = c.pathname === "/" ? n : Oo([n, c.pathname])),
        (l.replace ? e.replace : e.push)(c, l.state, l)
    }, [n, e, r, i])
}
const hN = O.createContext(null);
function pN(n) {
    let e = O.useContext(dl).outlet;
    return e && O.createElement(hN.Provider, {
        value: n
    }, e)
}
function r3(n, e) {
    let {relative: t} = e === void 0 ? {} : e
      , {matches: i} = O.useContext(dl)
      , {pathname: r} = Hg()
      , s = JSON.stringify($P(i).map(o=>o.pathnameBase));
    return O.useMemo(()=>e3(n, JSON.parse(s), r, t === "path"), [n, s, r, t])
}
function mN(n, e) {
    Sd() || Pn(!1);
    let {navigator: t} = O.useContext(zg)
      , i = O.useContext(n3)
      , {matches: r} = O.useContext(dl)
      , s = r[r.length - 1]
      , o = s ? s.params : {};
    s && s.pathname;
    let a = s ? s.pathnameBase : "/";
    s && s.route;
    let l = Hg(), c;
    if (e) {
        var d;
        let v = typeof e == "string" ? Zu(e) : e;
        a === "/" || (d = v.pathname) != null && d.startsWith(a) || Pn(!1),
        c = v
    } else
        c = l;
    let h = c.pathname || "/"
      , p = a === "/" ? h : h.slice(a.length) || "/"
      , m = Lk(n, {
        pathname: p
    })
      , y = xN(m && m.map(v=>Object.assign({}, v, {
        params: Object.assign({}, o, v.params),
        pathname: Oo([a, t.encodeLocation ? t.encodeLocation(v.pathname).pathname : v.pathname]),
        pathnameBase: v.pathnameBase === "/" ? a : Oo([a, t.encodeLocation ? t.encodeLocation(v.pathnameBase).pathname : v.pathnameBase])
    })), r, i || void 0);
    return e && y ? O.createElement(Gg.Provider, {
        value: {
            location: Qx({
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default"
            }, c),
            navigationType: Eo.Pop
        }
    }, y) : y
}
function gN() {
    let n = wN()
      , e = qk(n) ? n.status + " " + n.statusText : n instanceof Error ? n.message : JSON.stringify(n)
      , t = n instanceof Error ? n.stack : null
      , r = {
        padding: "0.5rem",
        backgroundColor: "rgba(200,200,200, 0.5)"
    }
      , s = null;
    return O.createElement(O.Fragment, null, O.createElement("h2", null, "Unexpected Application Error!"), O.createElement("h3", {
        style: {
            fontStyle: "italic"
        }
    }, e), t ? O.createElement("pre", {
        style: r
    }, t) : null, s)
}
class yN extends O.Component {
    constructor(e) {
        super(e),
        this.state = {
            location: e.location,
            error: e.error
        }
    }
    static getDerivedStateFromError(e) {
        return {
            error: e
        }
    }
    static getDerivedStateFromProps(e, t) {
        return t.location !== e.location ? {
            error: e.error,
            location: e.location
        } : {
            error: e.error || t.error,
            location: t.location
        }
    }
    componentDidCatch(e, t) {
        console.error("React Router caught the following error during render", e, t)
    }
    render() {
        return this.state.error ? O.createElement(dl.Provider, {
            value: this.props.routeContext
        }, O.createElement(i3.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
}
function vN(n) {
    let {routeContext: e, match: t, children: i} = n
      , r = O.useContext(t3);
    return r && r.static && r.staticContext && t.route.errorElement && (r.staticContext._deepestRenderedBoundaryId = t.route.id),
    O.createElement(dl.Provider, {
        value: e
    }, i)
}
function xN(n, e, t) {
    if (e === void 0 && (e = []),
    n == null)
        if (t != null && t.errors)
            n = t.matches;
        else
            return null;
    let i = n
      , r = t == null ? void 0 : t.errors;
    if (r != null) {
        let s = i.findIndex(o=>o.route.id && (r == null ? void 0 : r[o.route.id]));
        s >= 0 || Pn(!1),
        i = i.slice(0, Math.min(i.length, s + 1))
    }
    return i.reduceRight((s,o,a)=>{
        let l = o.route.id ? r == null ? void 0 : r[o.route.id] : null
          , c = t ? o.route.errorElement || O.createElement(gN, null) : null
          , d = e.concat(i.slice(0, a + 1))
          , h = ()=>O.createElement(vN, {
            match: o,
            routeContext: {
                outlet: s,
                matches: d
            }
        }, l ? c : o.route.element !== void 0 ? o.route.element : s);
        return t && (o.route.errorElement || a === 0) ? O.createElement(yN, {
            location: t.location,
            component: c,
            error: l,
            children: h(),
            routeContext: {
                outlet: null,
                matches: d
            }
        }) : h()
    }
    , null)
}
var BC;
(function(n) {
    n.UseBlocker = "useBlocker",
    n.UseRevalidator = "useRevalidator"
}
)(BC || (BC = {}));
var rg;
(function(n) {
    n.UseLoaderData = "useLoaderData",
    n.UseActionData = "useActionData",
    n.UseRouteError = "useRouteError",
    n.UseNavigation = "useNavigation",
    n.UseRouteLoaderData = "useRouteLoaderData",
    n.UseMatches = "useMatches",
    n.UseRevalidator = "useRevalidator"
}
)(rg || (rg = {}));
function _N(n) {
    let e = O.useContext(n3);
    return e || Pn(!1),
    e
}
function AN(n) {
    let e = O.useContext(dl);
    return e || Pn(!1),
    e
}
function MN(n) {
    let e = AN()
      , t = e.matches[e.matches.length - 1];
    return t.route.id || Pn(!1),
    t.route.id
}
function wN() {
    var n;
    let e = O.useContext(i3)
      , t = _N(rg.UseRouteError)
      , i = MN(rg.UseRouteError);
    return e || ((n = t.errors) == null ? void 0 : n[i])
}
function YX(n) {
    return pN(n.context)
}
function Zl(n) {
    Pn(!1)
}
function SN(n) {
    let {basename: e="/", children: t=null, location: i, navigationType: r=Eo.Pop, navigator: s, static: o=!1} = n;
    Sd() && Pn(!1);
    let a = e.replace(/^\/*/, "/")
      , l = O.useMemo(()=>({
        basename: a,
        navigator: s,
        static: o
    }), [a, s, o]);
    typeof i == "string" && (i = Zu(i));
    let {pathname: c="/", search: d="", hash: h="", state: p=null, key: m="default"} = i
      , y = O.useMemo(()=>{
        let v = qP(c, a);
        return v == null ? null : {
            pathname: v,
            search: d,
            hash: h,
            state: p,
            key: m
        }
    }
    , [a, c, d, h, p, m]);
    return y == null ? null : O.createElement(zg.Provider, {
        value: l
    }, O.createElement(Gg.Provider, {
        children: t,
        value: {
            location: y,
            navigationType: r
        }
    }))
}
function CN(n) {
    let {children: e, location: t} = n
      , i = O.useContext(t3)
      , r = i && !e ? i.router.routes : Zx(e);
    return mN(r, t)
}
var RC;
(function(n) {
    n[n.pending = 0] = "pending",
    n[n.success = 1] = "success",
    n[n.error = 2] = "error"
}
)(RC || (RC = {}));
new Promise(()=>{}
);
function Zx(n, e) {
    e === void 0 && (e = []);
    let t = [];
    return O.Children.forEach(n, (i,r)=>{
        if (!O.isValidElement(i))
            return;
        if (i.type === O.Fragment) {
            t.push.apply(t, Zx(i.props.children, e));
            return
        }
        i.type !== Zl && Pn(!1),
        !i.props.index || !i.props.children || Pn(!1);
        let s = [...e, r]
          , o = {
            id: i.props.id || s.join("-"),
            caseSensitive: i.props.caseSensitive,
            element: i.props.element,
            index: i.props.index,
            path: i.props.path,
            loader: i.props.loader,
            action: i.props.action,
            errorElement: i.props.errorElement,
            hasErrorBoundary: i.props.errorElement != null,
            shouldRevalidate: i.props.shouldRevalidate,
            handle: i.props.handle
        };
        i.props.children && (o.children = Zx(i.props.children, s)),
        t.push(o)
    }
    ),
    t
}
/**
 * React Router DOM v6.8.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function qx() {
    return qx = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }
    ,
    qx.apply(this, arguments)
}
function EN(n, e) {
    if (n == null)
        return {};
    var t = {}, i = Object.keys(n), r, s;
    for (s = 0; s < i.length; s++)
        r = i[s],
        !(e.indexOf(r) >= 0) && (t[r] = n[r]);
    return t
}
function TN(n) {
    return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey)
}
function bN(n, e) {
    return n.button === 0 && (!e || e === "_self") && !TN(n)
}
const PN = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"];
function BN(n) {
    let {basename: e, children: t, window: i} = n
      , r = O.useRef();
    r.current == null && (r.current = Pk({
        window: i,
        v5Compat: !0
    }));
    let s = r.current
      , [o,a] = O.useState({
        action: s.action,
        location: s.location
    });
    return O.useLayoutEffect(()=>s.listen(a), [s]),
    O.createElement(SN, {
        basename: e,
        children: t,
        location: o.location,
        navigationType: o.action,
        navigator: s
    })
}
const RN = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"
  , QX = O.forwardRef(function(e, t) {
    let {onClick: i, relative: r, reloadDocument: s, replace: o, state: a, target: l, to: c, preventScrollReset: d} = e, h = EN(e, PN), p, m = !1;
    if (RN && typeof c == "string" && /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i.test(c)) {
        p = c;
        let x = new URL(window.location.href)
          , A = c.startsWith("//") ? new URL(x.protocol + c) : new URL(c);
        A.origin === x.origin ? c = A.pathname + A.search + A.hash : m = !0
    }
    let y = fN(c, {
        relative: r
    })
      , v = LN(c, {
        replace: o,
        state: a,
        target: l,
        preventScrollReset: d,
        relative: r
    });
    function _(x) {
        i && i(x),
        x.defaultPrevented || v(x)
    }
    return O.createElement("a", qx({}, h, {
        href: p || y,
        onClick: m || s ? i : _,
        ref: t,
        target: l
    }))
});
var LC;
(function(n) {
    n.UseScrollRestoration = "useScrollRestoration",
    n.UseSubmitImpl = "useSubmitImpl",
    n.UseFetcher = "useFetcher"
}
)(LC || (LC = {}));
var IC;
(function(n) {
    n.UseFetchers = "useFetchers",
    n.UseScrollRestoration = "useScrollRestoration"
}
)(IC || (IC = {}));
function LN(n, e) {
    let {target: t, replace: i, state: r, preventScrollReset: s, relative: o} = e === void 0 ? {} : e
      , a = dN()
      , l = Hg()
      , c = r3(n, {
        relative: o
    });
    return O.useCallback(d=>{
        if (bN(d, t)) {
            d.preventDefault();
            let h = i !== void 0 ? i : ig(l) === ig(c);
            a(n, {
                replace: h,
                state: r,
                preventScrollReset: s,
                relative: o
            })
        }
    }
    , [l, a, c, i, r, t, n, s, o])
}
function s3(n) {
    var e, t, i = "";
    if (typeof n == "string" || typeof n == "number")
        i += n;
    else if (typeof n == "object")
        if (Array.isArray(n)) {
            var r = n.length;
            for (e = 0; e < r; e++)
                n[e] && (t = s3(n[e])) && (i && (i += " "),
                i += t)
        } else
            for (t in n)
                n[t] && (i && (i += " "),
                i += t);
    return i
}
function To() {
    for (var n, e, t = 0, i = "", r = arguments.length; t < r; t++)
        (n = arguments[t]) && (e = s3(n)) && (i && (i += " "),
        i += e);
    return i
}
const Qf = n=>typeof n == "number" && !isNaN(n)
  , Xa = n=>typeof n == "string"
  , zi = n=>typeof n == "function"
  , Am = n=>Xa(n) || zi(n) ? n : null
  , $x = n=>O.isValidElement(n) || Xa(n) || zi(n) || Qf(n);
function IN(n, e, t) {
    t === void 0 && (t = 300);
    const {scrollHeight: i, style: r} = n;
    requestAnimationFrame(()=>{
        r.minHeight = "initial",
        r.height = i + "px",
        r.transition = `all ${t}ms`,
        requestAnimationFrame(()=>{
            r.height = "0",
            r.padding = "0",
            r.margin = "0",
            setTimeout(e, t)
        }
        )
    }
    )
}
function Vg(n) {
    let {enter: e, exit: t, appendPosition: i=!1, collapse: r=!0, collapseDuration: s=300} = n;
    return function(o) {
        let {children: a, position: l, preventExitTransition: c, done: d, nodeRef: h, isIn: p, playToast: m} = o;
        const y = i ? `${e}--${l}` : e
          , v = i ? `${t}--${l}` : t
          , _ = O.useRef(0);
        return O.useLayoutEffect(()=>{
            const x = h.current
              , A = y.split(" ")
              , M = S=>{
                S.target === h.current && (m(),
                x.removeEventListener("animationend", M),
                x.removeEventListener("animationcancel", M),
                _.current === 0 && S.type !== "animationcancel" && x.classList.remove(...A))
            }
            ;
            x.classList.add(...A),
            x.addEventListener("animationend", M),
            x.addEventListener("animationcancel", M)
        }
        , []),
        O.useEffect(()=>{
            const x = h.current
              , A = ()=>{
                x.removeEventListener("animationend", A),
                r ? IN(x, d, s) : d()
            }
            ;
            p || (c ? A() : (_.current = 1,
            x.className += ` ${v}`,
            x.addEventListener("animationend", A)))
        }
        , [p]),
        lt.createElement(lt.Fragment, null, a)
    }
}
function DC(n, e) {
    return n != null ? {
        content: n.content,
        containerId: n.props.containerId,
        id: n.props.toastId,
        theme: n.props.theme,
        type: n.props.type,
        data: n.props.data || {},
        isLoading: n.props.isLoading,
        icon: n.props.icon,
        status: e
    } : {}
}
const di = new Map;
let Zf = [];
const e1 = new Set
  , DN = n=>e1.forEach(e=>e(n))
  , o3 = ()=>di.size > 0;
function a3(n, e) {
    var t;
    if (e)
        return !((t = di.get(e)) == null || !t.isToastActive(n));
    let i = !1;
    return di.forEach(r=>{
        r.isToastActive(n) && (i = !0)
    }
    ),
    i
}
function l3(n, e) {
    $x(n) && (o3() || Zf.push({
        content: n,
        options: e
    }),
    di.forEach(t=>{
        t.buildToast(n, e)
    }
    ))
}
function FC(n, e) {
    di.forEach(t=>{
        e != null && e != null && e.containerId ? (e == null ? void 0 : e.containerId) === t.id && t.toggle(n, e == null ? void 0 : e.id) : t.toggle(n, e == null ? void 0 : e.id)
    }
    )
}
function FN(n) {
    const {subscribe: e, getSnapshot: t, setProps: i} = O.useRef(function(s) {
        const o = s.containerId || 1;
        return {
            subscribe(a) {
                const l = function(d, h, p) {
                    let m = 1
                      , y = 0
                      , v = []
                      , _ = []
                      , x = []
                      , A = h;
                    const M = new Map
                      , S = new Set
                      , T = ()=>{
                        x = Array.from(M.values()),
                        S.forEach(E=>E())
                    }
                      , P = E=>{
                        _ = E == null ? [] : _.filter(B=>B !== E),
                        T()
                    }
                      , R = E=>{
                        const {toastId: B, onOpen: L, updateId: z, children: Z} = E.props
                          , J = z == null;
                        E.staleId && M.delete(E.staleId),
                        M.set(B, E),
                        _ = [..._, E.props.toastId].filter(G=>G !== E.staleId),
                        T(),
                        p(DC(E, J ? "added" : "updated")),
                        J && zi(L) && L(O.isValidElement(Z) && Z.props)
                    }
                    ;
                    return {
                        id: d,
                        props: A,
                        observe: E=>(S.add(E),
                        ()=>S.delete(E)),
                        toggle: (E,B)=>{
                            M.forEach(L=>{
                                B != null && B !== L.props.toastId || zi(L.toggle) && L.toggle(E)
                            }
                            )
                        }
                        ,
                        removeToast: P,
                        toasts: M,
                        clearQueue: ()=>{
                            y -= v.length,
                            v = []
                        }
                        ,
                        buildToast: (E,B)=>{
                            if ((H=>{
                                let {containerId: se, toastId: ye, updateId: ve} = H;
                                const q = se ? se !== d : d !== 1
                                  , Ie = M.has(ye) && ve == null;
                                return q || Ie
                            }
                            )(B))
                                return;
                            const {toastId: L, updateId: z, data: Z, staleId: J, delay: G} = B
                              , X = ()=>{
                                P(L)
                            }
                              , ee = z == null;
                            ee && y++;
                            const ie = {
                                ...A,
                                style: A.toastStyle,
                                key: m++,
                                ...Object.fromEntries(Object.entries(B).filter(H=>{
                                    let[se,ye] = H;
                                    return ye != null
                                }
                                )),
                                toastId: L,
                                updateId: z,
                                data: Z,
                                closeToast: X,
                                isIn: !1,
                                className: Am(B.className || A.toastClassName),
                                bodyClassName: Am(B.bodyClassName || A.bodyClassName),
                                progressClassName: Am(B.progressClassName || A.progressClassName),
                                autoClose: !B.isLoading && (F = B.autoClose,
                                V = A.autoClose,
                                F === !1 || Qf(F) && F > 0 ? F : V),
                                deleteToast() {
                                    const H = M.get(L)
                                      , {onClose: se, children: ye} = H.props;
                                    zi(se) && se(O.isValidElement(ye) && ye.props),
                                    p(DC(H, "removed")),
                                    M.delete(L),
                                    y--,
                                    y < 0 && (y = 0),
                                    v.length > 0 ? R(v.shift()) : T()
                                }
                            };
                            var F, V;
                            ie.closeButton = A.closeButton,
                            B.closeButton === !1 || $x(B.closeButton) ? ie.closeButton = B.closeButton : B.closeButton === !0 && (ie.closeButton = !$x(A.closeButton) || A.closeButton);
                            let j = E;
                            O.isValidElement(E) && !Xa(E.type) ? j = O.cloneElement(E, {
                                closeToast: X,
                                toastProps: ie,
                                data: Z
                            }) : zi(E) && (j = E({
                                closeToast: X,
                                toastProps: ie,
                                data: Z
                            }));
                            const re = {
                                content: j,
                                props: ie,
                                staleId: J
                            };
                            A.limit && A.limit > 0 && y > A.limit && ee ? v.push(re) : Qf(G) ? setTimeout(()=>{
                                R(re)
                            }
                            , G) : R(re)
                        }
                        ,
                        setProps(E) {
                            A = E
                        },
                        setToggle: (E,B)=>{
                            M.get(E).toggle = B
                        }
                        ,
                        isToastActive: E=>_.some(B=>B === E),
                        getSnapshot: ()=>A.newestOnTop ? x.reverse() : x
                    }
                }(o, s, DN);
                di.set(o, l);
                const c = l.observe(a);
                return Zf.forEach(d=>l3(d.content, d.options)),
                Zf = [],
                ()=>{
                    c(),
                    di.delete(o)
                }
            },
            setProps(a) {
                var l;
                (l = di.get(o)) == null || l.setProps(a)
            },
            getSnapshot() {
                var a;
                return (a = di.get(o)) == null ? void 0 : a.getSnapshot()
            }
        }
    }(n)).current;
    i(n);
    const r = O.useSyncExternalStore(e, t, t);
    return {
        getToastToRender: function(s) {
            if (!r)
                return [];
            const o = new Map;
            return r.forEach(a=>{
                const {position: l} = a.props;
                o.has(l) || o.set(l, []),
                o.get(l).push(a)
            }
            ),
            Array.from(o, a=>s(a[0], a[1]))
        },
        isToastActive: a3,
        count: r == null ? void 0 : r.length
    }
}
function kN(n) {
    const [e,t] = O.useState(!1)
      , [i,r] = O.useState(!1)
      , s = O.useRef(null)
      , o = O.useRef({
        start: 0,
        delta: 0,
        removalDistance: 0,
        canCloseOnClick: !0,
        canDrag: !1,
        didMove: !1
    }).current
      , {autoClose: a, pauseOnHover: l, closeToast: c, onClick: d, closeOnClick: h} = n;
    var p, m;
    function y() {
        t(!0)
    }
    function v() {
        t(!1)
    }
    function _(M) {
        const S = s.current;
        o.canDrag && S && (o.didMove = !0,
        e && v(),
        o.delta = n.draggableDirection === "x" ? M.clientX - o.start : M.clientY - o.start,
        o.start !== M.clientX && (o.canCloseOnClick = !1),
        S.style.transform = `translate3d(${n.draggableDirection === "x" ? `${o.delta}px, var(--y)` : `0, calc(${o.delta}px + var(--y))`},0)`,
        S.style.opacity = "" + (1 - Math.abs(o.delta / o.removalDistance)))
    }
    function x() {
        document.removeEventListener("pointermove", _),
        document.removeEventListener("pointerup", x);
        const M = s.current;
        if (o.canDrag && o.didMove && M) {
            if (o.canDrag = !1,
            Math.abs(o.delta) > o.removalDistance)
                return r(!0),
                n.closeToast(),
                void n.collapseAll();
            M.style.transition = "transform 0.2s, opacity 0.2s",
            M.style.removeProperty("transform"),
            M.style.removeProperty("opacity")
        }
    }
    (m = di.get((p = {
        id: n.toastId,
        containerId: n.containerId,
        fn: t
    }).containerId || 1)) == null || m.setToggle(p.id, p.fn),
    O.useEffect(()=>{
        if (n.pauseOnFocusLoss)
            return document.hasFocus() || v(),
            window.addEventListener("focus", y),
            window.addEventListener("blur", v),
            ()=>{
                window.removeEventListener("focus", y),
                window.removeEventListener("blur", v)
            }
    }
    , [n.pauseOnFocusLoss]);
    const A = {
        onPointerDown: function(M) {
            if (n.draggable === !0 || n.draggable === M.pointerType) {
                o.didMove = !1,
                document.addEventListener("pointermove", _),
                document.addEventListener("pointerup", x);
                const S = s.current;
                o.canCloseOnClick = !0,
                o.canDrag = !0,
                S.style.transition = "none",
                n.draggableDirection === "x" ? (o.start = M.clientX,
                o.removalDistance = S.offsetWidth * (n.draggablePercent / 100)) : (o.start = M.clientY,
                o.removalDistance = S.offsetHeight * (n.draggablePercent === 80 ? 1.5 * n.draggablePercent : n.draggablePercent) / 100)
            }
        },
        onPointerUp: function(M) {
            const {top: S, bottom: T, left: P, right: R} = s.current.getBoundingClientRect();
            M.nativeEvent.type !== "touchend" && n.pauseOnHover && M.clientX >= P && M.clientX <= R && M.clientY >= S && M.clientY <= T ? v() : y()
        }
    };
    return a && l && (A.onMouseEnter = v,
    n.stacked || (A.onMouseLeave = y)),
    h && (A.onClick = M=>{
        d && d(M),
        o.canCloseOnClick && c()
    }
    ),
    {
        playToast: y,
        pauseToast: v,
        isRunning: e,
        preventExitTransition: i,
        toastRef: s,
        eventHandlers: A
    }
}
function NN(n) {
    let {delay: e, isRunning: t, closeToast: i, type: r="default", hide: s, className: o, style: a, controlledProgress: l, progress: c, rtl: d, isIn: h, theme: p} = n;
    const m = s || l && c === 0
      , y = {
        ...a,
        animationDuration: `${e}ms`,
        animationPlayState: t ? "running" : "paused"
    };
    l && (y.transform = `scaleX(${c})`);
    const v = To("Toastify__progress-bar", l ? "Toastify__progress-bar--controlled" : "Toastify__progress-bar--animated", `Toastify__progress-bar-theme--${p}`, `Toastify__progress-bar--${r}`, {
        "Toastify__progress-bar--rtl": d
    })
      , _ = zi(o) ? o({
        rtl: d,
        type: r,
        defaultClassName: v
    }) : To(v, o)
      , x = {
        [l && c >= 1 ? "onTransitionEnd" : "onAnimationEnd"]: l && c < 1 ? null : ()=>{
            h && i()
        }
    };
    return lt.createElement("div", {
        className: "Toastify__progress-bar--wrp",
        "data-hidden": m
    }, lt.createElement("div", {
        className: `Toastify__progress-bar--bg Toastify__progress-bar-theme--${p} Toastify__progress-bar--${r}`
    }), lt.createElement("div", {
        role: "progressbar",
        "aria-hidden": m ? "true" : "false",
        "aria-label": "notification timer",
        className: _,
        style: y,
        ...x
    }))
}
let ON = 1;
const u3 = ()=>"" + ON++;
function UN(n) {
    return n && (Xa(n.toastId) || Qf(n.toastId)) ? n.toastId : u3()
}
function _f(n, e) {
    return l3(n, e),
    e.toastId
}
function sg(n, e) {
    return {
        ...e,
        type: e && e.type || n,
        toastId: UN(e)
    }
}
function dp(n) {
    return (e,t)=>_f(e, sg(n, t))
}
function Jt(n, e) {
    return _f(n, sg("default", e))
}
Jt.loading = (n,e)=>_f(n, sg("default", {
    isLoading: !0,
    autoClose: !1,
    closeOnClick: !1,
    closeButton: !1,
    draggable: !1,
    ...e
})),
Jt.promise = function(n, e, t) {
    let i, {pending: r, error: s, success: o} = e;
    r && (i = Xa(r) ? Jt.loading(r, t) : Jt.loading(r.render, {
        ...t,
        ...r
    }));
    const a = {
        isLoading: null,
        autoClose: null,
        closeOnClick: null,
        closeButton: null,
        draggable: null
    }
      , l = (d,h,p)=>{
        if (h == null)
            return void Jt.dismiss(i);
        const m = {
            type: d,
            ...a,
            ...t,
            data: p
        }
          , y = Xa(h) ? {
            render: h
        } : h;
        return i ? Jt.update(i, {
            ...m,
            ...y
        }) : Jt(y.render, {
            ...m,
            ...y
        }),
        p
    }
      , c = zi(n) ? n() : n;
    return c.then(d=>l("success", o, d)).catch(d=>l("error", s, d)),
    c
}
,
Jt.success = dp("success"),
Jt.info = dp("info"),
Jt.error = dp("error"),
Jt.warning = dp("warning"),
Jt.warn = Jt.warning,
Jt.dark = (n,e)=>_f(n, sg("default", {
    theme: "dark",
    ...e
})),
Jt.dismiss = function(n) {
    (function(e) {
        var t;
        if (o3()) {
            if (e == null || Xa(t = e) || Qf(t))
                di.forEach(r=>{
                    r.removeToast(e)
                }
                );
            else if (e && ("containerId"in e || "id"in e)) {
                var i;
                (i = di.get(e.containerId)) != null && i.removeToast(e.id) || di.forEach(r=>{
                    r.removeToast(e.id)
                }
                )
            }
        } else
            Zf = Zf.filter(r=>e != null && r.options.toastId !== e)
    }
    )(n)
}
,
Jt.clearWaitingQueue = function(n) {
    n === void 0 && (n = {}),
    di.forEach(e=>{
        !e.props.limit || n.containerId && e.id !== n.containerId || e.clearQueue()
    }
    )
}
,
Jt.isActive = a3,
Jt.update = function(n, e) {
    e === void 0 && (e = {});
    const t = ((i,r)=>{
        var s;
        let {containerId: o} = r;
        return (s = di.get(o || 1)) == null ? void 0 : s.toasts.get(i)
    }
    )(n, e);
    if (t) {
        const {props: i, content: r} = t
          , s = {
            delay: 100,
            ...i,
            ...e,
            toastId: e.toastId || n,
            updateId: u3()
        };
        s.toastId !== n && (s.staleId = n);
        const o = s.render || r;
        delete s.render,
        _f(o, s)
    }
}
,
Jt.done = n=>{
    Jt.update(n, {
        progress: 1
    })
}
,
Jt.onChange = function(n) {
    return e1.add(n),
    ()=>{
        e1.delete(n)
    }
}
,
Jt.play = n=>FC(!0, n),
Jt.pause = n=>FC(!1, n);
const zN = typeof window < "u" ? O.useLayoutEffect : O.useEffect
  , hp = n=>{
    let {theme: e, type: t, isLoading: i, ...r} = n;
    return lt.createElement("svg", {
        viewBox: "0 0 24 24",
        width: "100%",
        height: "100%",
        fill: e === "colored" ? "currentColor" : `var(--toastify-icon-color-${t})`,
        ...r
    })
}
  , Qy = {
    info: function(n) {
        return lt.createElement(hp, {
            ...n
        }, lt.createElement("path", {
            d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z"
        }))
    },
    warning: function(n) {
        return lt.createElement(hp, {
            ...n
        }, lt.createElement("path", {
            d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z"
        }))
    },
    success: function(n) {
        return lt.createElement(hp, {
            ...n
        }, lt.createElement("path", {
            d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z"
        }))
    },
    error: function(n) {
        return lt.createElement(hp, {
            ...n
        }, lt.createElement("path", {
            d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z"
        }))
    },
    spinner: function() {
        return lt.createElement("div", {
            className: "Toastify__spinner"
        })
    }
}
  , GN = n=>{
    const {isRunning: e, preventExitTransition: t, toastRef: i, eventHandlers: r, playToast: s} = kN(n)
      , {closeButton: o, children: a, autoClose: l, onClick: c, type: d, hideProgressBar: h, closeToast: p, transition: m, position: y, className: v, style: _, bodyClassName: x, bodyStyle: A, progressClassName: M, progressStyle: S, updateId: T, role: P, progress: R, rtl: E, toastId: B, deleteToast: L, isIn: z, isLoading: Z, closeOnClick: J, theme: G} = n
      , X = To("Toastify__toast", `Toastify__toast-theme--${G}`, `Toastify__toast--${d}`, {
        "Toastify__toast--rtl": E
    }, {
        "Toastify__toast--close-on-click": J
    })
      , ee = zi(v) ? v({
        rtl: E,
        position: y,
        type: d,
        defaultClassName: X
    }) : To(X, v)
      , ie = function(re) {
        let {theme: H, type: se, isLoading: ye, icon: ve} = re
          , q = null;
        const Ie = {
            theme: H,
            type: se
        };
        return ve === !1 || (zi(ve) ? q = ve({
            ...Ie,
            isLoading: ye
        }) : O.isValidElement(ve) ? q = O.cloneElement(ve, Ie) : ye ? q = Qy.spinner() : (Ne=>Ne in Qy)(se) && (q = Qy[se](Ie))),
        q
    }(n)
      , F = !!R || !l
      , V = {
        closeToast: p,
        type: d,
        theme: G
    };
    let j = null;
    return o === !1 || (j = zi(o) ? o(V) : O.isValidElement(o) ? O.cloneElement(o, V) : function(re) {
        let {closeToast: H, theme: se, ariaLabel: ye="close"} = re;
        return lt.createElement("button", {
            className: `Toastify__close-button Toastify__close-button--${se}`,
            type: "button",
            onClick: ve=>{
                ve.stopPropagation(),
                H(ve)
            }
            ,
            "aria-label": ye
        }, lt.createElement("svg", {
            "aria-hidden": "true",
            viewBox: "0 0 14 16"
        }, lt.createElement("path", {
            fillRule: "evenodd",
            d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z"
        })))
    }(V)),
    lt.createElement(m, {
        isIn: z,
        done: L,
        position: y,
        preventExitTransition: t,
        nodeRef: i,
        playToast: s
    }, lt.createElement("div", {
        id: B,
        onClick: c,
        "data-in": z,
        className: ee,
        ...r,
        style: _,
        ref: i
    }, lt.createElement("div", {
        ...z && {
            role: P
        },
        className: zi(x) ? x({
            type: d
        }) : To("Toastify__toast-body", x),
        style: A
    }, ie != null && lt.createElement("div", {
        className: To("Toastify__toast-icon", {
            "Toastify--animate-icon Toastify__zoom-enter": !Z
        })
    }, ie), lt.createElement("div", null, a)), j, lt.createElement(NN, {
        ...T && !F ? {
            key: `pb-${T}`
        } : {},
        rtl: E,
        theme: G,
        delay: l,
        isRunning: e,
        isIn: z,
        closeToast: p,
        hide: h,
        type: d,
        style: S,
        className: M,
        controlledProgress: F,
        progress: R || 0
    })))
}
  , Wg = function(n, e) {
    return e === void 0 && (e = !1),
    {
        enter: `Toastify--animate Toastify__${n}-enter`,
        exit: `Toastify--animate Toastify__${n}-exit`,
        appendPosition: e
    }
}
  , HN = Vg(Wg("bounce", !0));
Vg(Wg("slide", !0));
Vg(Wg("zoom"));
Vg(Wg("flip"));
const VN = {
    position: "top-right",
    transition: HN,
    autoClose: 5e3,
    closeButton: !0,
    pauseOnHover: !0,
    pauseOnFocusLoss: !0,
    draggable: "touch",
    draggablePercent: 80,
    draggableDirection: "x",
    role: "alert",
    theme: "light"
};
function WN(n) {
    let e = {
        ...VN,
        ...n
    };
    const t = n.stacked
      , [i,r] = O.useState(!0)
      , s = O.useRef(null)
      , {getToastToRender: o, isToastActive: a, count: l} = FN(e)
      , {className: c, style: d, rtl: h, containerId: p} = e;
    function m(v) {
        const _ = To("Toastify__toast-container", `Toastify__toast-container--${v}`, {
            "Toastify__toast-container--rtl": h
        });
        return zi(c) ? c({
            position: v,
            rtl: h,
            defaultClassName: _
        }) : To(_, Am(c))
    }
    function y() {
        t && (r(!0),
        Jt.play())
    }
    return zN(()=>{
        if (t) {
            var v;
            const _ = s.current.querySelectorAll('[data-in="true"]')
              , x = 12
              , A = (v = e.position) == null ? void 0 : v.includes("top");
            let M = 0
              , S = 0;
            Array.from(_).reverse().forEach((T,P)=>{
                const R = T;
                R.classList.add("Toastify__toast--stacked"),
                P > 0 && (R.dataset.collapsed = `${i}`),
                R.dataset.pos || (R.dataset.pos = A ? "top" : "bot");
                const E = M * (i ? .2 : 1) + (i ? 0 : x * P);
                R.style.setProperty("--y", `${A ? E : -1 * E}px`),
                R.style.setProperty("--g", `${x}`),
                R.style.setProperty("--s", "" + (1 - (i ? S : 0))),
                M += R.offsetHeight,
                S += .025
            }
            )
        }
    }
    , [i, l, t]),
    lt.createElement("div", {
        ref: s,
        className: "Toastify",
        id: p,
        onMouseEnter: ()=>{
            t && (r(!1),
            Jt.pause())
        }
        ,
        onMouseLeave: y
    }, o((v,_)=>{
        const x = _.length ? {
            ...d
        } : {
            ...d,
            pointerEvents: "none"
        };
        return lt.createElement("div", {
            className: m(v),
            style: x,
            key: `container-${v}`
        }, _.map(A=>{
            let {content: M, props: S} = A;
            return lt.createElement(GN, {
                ...S,
                stacked: t,
                collapseAll: y,
                isIn: a(S.toastId, S.containerId),
                style: S.style,
                key: `toast-${S.key}`
            }, M)
        }
        ))
    }
    ))
}
const jN = "" + new URL("pro-04d66707.png",import.meta.url).href
  , JN = "" + new URL("github-3b4e1609.png",import.meta.url).href
  , XN = "" + new URL("css-79a7f026.png",import.meta.url).href
  , KN = "" + new URL("figma-184a11e6.png",import.meta.url).href
  , YN = "" + new URL("html-92b76a73.png",import.meta.url).href
  , QN = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAYAAAA+VemSAAAACXBIWXMAAAsTAAALEwEAmpwYAAAOgElEQVR4nO2dCdCVZRXHz8Pnwi4groElmijuK6m4YCqJpZmJqJla40qGWjgYZZQL5p4GJZlboKKTGzoouWSAiQsuqONY42Q1LVrZYlpZnebcy51B6uO7977LeZ/7/H4z/wGGmfve5zznf577vu+ziAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtIW+JIqIQafkgKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyB/Sp+yKQJHwmlft+3l4kumiN62dmixx8WdJ9dg246LOjggUH79A4aQv3v79sg6Oab1P//pAlBL50iev9s0b8tq3bBkdTwDnjsisHA7zwj+v1viB62f9C+vbN9395rBx03JuhV00TfXFrF/kgM74DHriob+A8/EZ16YtChg7N9x+40oF/QyccGfXVhlfojMbwDHruqaOB3l4teMkV00IBijLuq1loz6PRJov94rgr9kRjeAY9dVTPwy/eJ7rZtOcZdVVtvHvSp2737IzG8DRC7qmTghdeWN+p2p769g94zEwNj4AqYMyYDz7tcdI0uX/PKCtn3mP01r/5IDG8DxK4qGPjumdUxr6yQvY6aezEGxsAVMGmVDWz3vAP7+xtWunnltGRu2f2RGN4GiF2eBranvttu4W9UWY3WHxL0tYcwMAaugFmrZuDzJ2e/fhkaN6a82WaSGt4GiF1eBv79Y6L9+/qbs1ndcCEGxsAVMGxVDDztZH9TtqIh64Ra0Sm+PxLD2wCxy8PANtNqw6H+pmxWgwcGvWZ6Wf2RGN4GiF0eBr732/nd+24/MugVU0WfuUP09cX11Ub259J5oldPE917l/oroXY//9hDgr6xpMz+SAxvA8QuDwNPOjq7cfv1qd+X/ufFnq9nr4J22LK1z990WKgtPyy/PxLD2wCxy8PANuc46/vZR29qfR3xxPE9f3ZXV9Azjwv61tNe/ZEY3gaIXWUb+O/PSs0kWa553ufba+u/losefuDqf44/eZt3fySGtwFiV9kGfnF+tmvarht/far99trIOmqz//3MGWeK/vP5KvRHYngHPHaVbeAHr8t2zQP2yD6pwh54NeZejx0d9JUFVeqPxPAOeOwq28C2cCHL9T57eD6zor46SfTa85p7CKal9kdieAc8dpVt4NuvzHZN28ius/sjMbwDHrvKNnDWd8AH7omBOwpvA8Susg38yA2S+f2v7VLZuf2RGN4Bj11lG9geGGW95qxzO7k/EsM74LGrbAPb6NmrV7Zrrjso6E/v79T+SAzvgMeusg1s2nJEtmuaRgwPtd08Oq8/EsM74LHLw8C2QCDrdU22Fc+NM6r3Kkgz9UdieAc8dnkY+KaL8t2Jw1YcPXZzp/RHYngHPHZ5GNiOTFlzjfwM3JAdZLZgduz9kRjeAY9dHgY2fXI1iwqyasetgt5yaTXmNmvL/ZEY3gGPXV4GtuWARRm4ITti1FYu/XZRTP2RGN4Bj11eBjbZrKqiTWxae62gnz406LN3xtAfieEd8NjlaeDn75LayYBlmHjl1UwPfLe6T64lNbwDHrs8DWz6+uk+e0NvNzLozZeI/vsF/z54b38khnfAY5e3gc1AB+9TvoEbsu19bruiSv2RGN4Bj13eBja9uVRqI6KXiUWCfvhD/mcDY+AKGCI2VcHApt8tzr7ZXVZ1dQX94gm+q50kNbwNELuqYmDTHx+X2mQMTxOLBN1qRNAnnDa3k9TwNkDsqpKBGycW2iiYdcVSVq3RFfSCM8p/Wi2p4W2A2FU1Azf0w+9JbSKG92h81MGhthUuBsbA7maNycAmO0zshMP8R+OD9irvvlhSw9sAsavKBl55G9j9Rvua+JCxobYxPAbGwO6mjc3ADc2fJbrLNn4mPuv44tsqqeFtgNgVk4EbWjRH9KP7Zjt1sB2FEGq7ahbbH4nhbYDYFaOBG3ruzvo9sh12VpaJN14/29EuPfdHYngbIHbFbOCVZ3JdeY7o+zcux8TnnlZcmyU1vJMndnWCgRt6d7norZeJ7jSqWAMP7B/0z08U1R+J4Z00sauTDLyyFl4rtfnNRZn4m18qqj8SwztRYlenGrghO+93/93zN/Do7Yppt6SGd4LErk43cEN3Xi26wbr5GbhXr6C/frSI/kgM78SIXakY2GR7Y+21c34mnnd5Ef2RGN5JEbtSMrDpradF99gxHwN/4YT82y6p4Z0QMcvm96ZmYNNrD0ntlMOsbT94HwyMgR0T+fXF1TSwLWIouu02LTJr27f5IAbGwE0m3M8flNrWqLboPa8kthP+sibxkQeFXN/jXnhGfXRcOq9YAy+Zm73t6w3BwBi4h0Sz0wVmnCnat3c9aU6ekF/S3Ped7El83Mfz+T7L737vQoVRmxW7DtemQ2Zte78+GBgD93CavW3vsuqE+rtn5pPENtplTeJTJ4bMo+75k6W2+fqqn33OScXeX2e9D+7qwsAYuJvXHXYEZ3erbQYPDPri/OwJvOdO2e8Dp3wm28buq5v2aNva2ESMIsxra3vt87O0vX9fDIyBV9kjeda5UjNoT8lj281kOaX+hXvy2VDdFhG0c1tgG7o3cyrDpsOCvrEkfwO/ujB7+zdaDwNj4BUJZXsS79riYvWhg4P+6Mb2Rp8xOYy+pjuuau3adj6RnR7YyjXGjs7/fvjqadkNvN1IDJy8gf+0VPRzx9Tvp9qd0jfp6FA7c7eZxH17mdQ2asvDvCZbk9vsqDt9UvvnAo/fO799qexzNt8ke9uPGIeBkzbw3ItFNxyaj5HsKfVJE0LtyfJfnnzvdWxr1JfvE71iqtR+kuZlXrumPYTqqZ3LfiC6fQ4nL9i+WLYBfNa4n35MddcFS2p4m7Bd/eyB7A9RVie7jx4xPOjwDetGK+Ia9hCsmbbuvkN+17T7zgWz24u5/QyffGx+3+XB6/LPC0kNbyNmkY2YRRm4DH3l1OYMvHiO5L5/1d671I8JbWanSNss/pZLpfZuOa/r9+1dzHtqSQ1vE2aRLUfLY06ul1o5DGzi+OJ+adi9qE12ue4CqW06d89M0RtnSO1khUP3C7ruoPyvO3E864GTN7Al9mVn+5yPm1X287yVY0dsAYFtReP9vfPSw9cXU9QlNbxH0awyE4wb45+QrcoKT6tttZ+x3t87D+00qrXihYE72MCm3/xYdP0h/onZrGwktddf7bT1xCP8v38VH17pCklqeJsvz3nPZe5vnEUXndV+O+09dB6vlLw0oeD1z5Ia3sbLU3d9q9hXS3nIJkBkffpqvzi2+IB/W1rVsA3yXc6JgTvMwCZ7elr2kSHNymZR5bVO95cP5zuppGj171vOod+SGt6GK0L2sKdPQZMvsuiqafkvKLCn2d7tkh5kSx3vb3PyCAZO0MAmq/Z2Do938jY07eRi7v1spZFNyvBun3SjQQPaWzCCgRMegRv61SP5rNnNIvs5bxMiimynzaf+8intL+goStuPDPrSveX2uaSGt8nKWCN8zfTm1gjnLZvBZBuil9XWx28t/lyjZrTWmkGnnljslj4YOBEDr7xLx6c+Vl8+WMaoa69L7Jplt9PmNl9/gc+9ca9eQT9xQNBXFvj1s6SGt7HKlu2kYdvt/L89pLLKfsIeMra1Oc5FydYP28O8Mu6P1xkQ9JQjQ23JpXe7JTW8A+4l2zvZTsjbd7f63lFZRh3bCcS2uPnFw/7t6u5p9SVT6mbOa7KLvdO1bXptR5F3ctooIA9JangHvAqyA65tIf9XJ4kefmDQnbcOtamZNrJYstpobffQm2xUX8NrezmbYefPqm/u7v39W5GZbdGc+t5hpx1VPx1hhy1DbWMEa2OjmA3oV//3ZsNDbfsgWz1kC/Bvv7K+Ftu7HdqNJDW8A46IgWJgDEwhoBAoIzBJQCGIOwckNbwDjoiBYmAMTCGgECgjMElAIYg7ByQ1vAOOiIFiYAxMIaAQKCMwSUAhiDsHJDW8A46IgWJgDEwhoBAoIzBJQCGIOwckNbwDjoiBYmAMTCGgECgjMElAIYg7ByQ1vAOOiIFiYAxMIaAQKCMwSUAhiDsHJDW8A46IgWJgDEwhoBBoiiMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEg+/BceiofdqS/+vQAAAABJRU5ErkJggg=="
  , ZN = "" + new URL("java-322a9f14.png",import.meta.url).href
  , qN = "" + new URL("nodejs-d83eb6dd.png",import.meta.url).href
  , $N = "" + new URL("reactjs-966214a8.png",import.meta.url).href
  , eO = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAYAAAA+VemSAAAACXBIWXMAAAsTAAALEwEAmpwYAAANMUlEQVR4nO2d+48V9RXAv//Gtw/balttayOpjVZr06TPqLRJ09Q+09Yaa01sapNWKqiAqCiU+MJXfSGC+ADxQa1AK0WMogJW2L3syrIvdpcL+95ln7B7mu8Y7GaD9N7ZmXvuzPl8kvOLMXsvZ87nnLkz852vcwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsfDX7BaCHOSlBpw1tBNOkAOPwAhMI6AReCYwRUAjyHYNOGtoJ5wgBx6BEZhGQCPwTGCKgEaQ7Rpw1tBOOEEOPAIjMI2ARuCZwBQBjSDbNeCsoZ1wghx4BEZgGgGNwDOBKQIaQbZrwFlDO+EEOfAIjMA0AhqBZwJTBDSCbNeAs4Z2wgly4BEYgWkENALPBKYIaATZrgFnDe2EE+TAIzAC0whoBJ4JTBHQCLJdA84a2gknyIFHYASmEdAIPBOYIqARZLsGnDW0E06QA4/ACEwjoBF4JjBFQCPIdg04a2gnnCAHHoERmEZAI/BMYIqARpDtGnDW0E44QQ48AiMwjYBG4JnAFAGNINs14KyhnXCCHHgERmAaAY3AM4EpAhpBtmvAWUM74QQ58AiMwDQCGoFnAlMENIJs14CzhnbCCXLgERiBaQQ0As8EpghoBNmuAWcN7YQT5MAjMALTCGgEnglMEdAIsl0DzhraCSfIgUdgBKYR0Ag8E5gioBFkuwacNbQTTpADj8AITCOgEXgmMEVAI8h2DThraCecIAcegRGYRkAj8ExgioBGkO0acNbQTjhBDjwCIzCNgEbgmcAUAY0g2zXgrKGdcIIceARGYBoBjcAzgSkCGkG2a8BZQzvhBDnwCIzANAIagWcCUwQ0gmzXgLOGdsIJcuARGIFpBDQCzwSmCGgE2a4BZw3thBPkwCMwAtMIaASeCUwR0AiyXQPOGtoJJ8iBR2AEphHQCDwTmCKgEWS7Bpw1tBNOkAOPwAhMI6AReCYwRUAjyHYNOGtoJ5wgBx6BEZhGQCPwTGCKgEaQ7Rpw1tBOOEEOPALnW+Dm7jEBkYUbOiqW81mLCvKjBxrl6qcPyF83FeXJt3tk275BebdtWJq6xqJj0jt0TPqG34+uI0ej/7bv8Gj0/2ypH5BndvbKfVs7ZcGLHXLlE61y0d0N8vkFtUzgJNGWE4GrQ+ALltbL3Ofa5eXafin2j6faL/uGj8nOliFZub1b5jzbJrOXN8ip82oS+Xc4a2jLicB6Ap97a100XeuLo6LNsYnJaHqv3dUrf17XJucsrkNgBM4XSQl88fIG+fue/kiaamXVm90IjMD5YqYCn3dbnWzY3SeT1evtBzz0WhcCI3C+iCvwR+bsjk5Lh8YmJCvc9cphBEbgfBFH4NOuq4kuTGWNpZuKCIzAtgU+a1FB9rQPSxa5MebZhrOG9hXmUoL7wOULfPoNtZmVN3Dt+nYERmCbAn/8L3vk9f1HJMtc/fQBBEZgmwIv23xIss4Vq1sQGIHtCXzhXfuq+v5uqfxqRTMCI7A9gbc1DEoeuOTBRgRGYFsC/+zhJskL37unAYER2JbAm/cOVOy7tHSPyT9q+qNHHu/d2im3bSxGz1U/uK0zWoUUvktrT/xVZN++Yx8CI7Adgc++ZW+qv33D395U6JdLH2uWMxcWSpbrjPm10bLEIPiOliEp9SuG1VHcB87JfeCfPNQol61sTiX+8NSBxIo8rKZJ63uGCM8yf1iOwprbtAjPT4cGkcSxPHNhQf74zAF5s+nkt7m+HPPznDW05dSOLywsJFbobzUNqf070jh9Hj82Kb9/sjW173zB0nr527ZOOXKCZ7TDcYnzN501tAXSjjwIHB7cGBxNdqFCONX93er05PXTTrPDKXb/8LEPPj/uAn9nDW2BtCMPAn9tab0kzYo34i3n8zMUOVwQC5P/o3Pi/Q1nDW2BtCMPAoeHHpIknNKWc6HKJxxxL2CFcNbQFkg78iBwuDqdJC/u7lM/Lj5mOGtoJ1w78iDwPf8+LEnyp7Vt6sfFxwxnDe2Ea0ceBH709S5JknDbTvu4+JjhrKGdcO3Ig8BP7eiRJJkd8zFGXwXhrKGdcO3Ig8DPvtMrSfLrmCuBfBWEs4Z2wrUjDwKvfrNbkiQ8XKF9XHzMcNbQTrh25EHgIFzSOyeEV/JoHxsfI5w1tBOuHXkQOOnbSIGwF5L2sfExwllDO+HakQeBw0KHNAgbk2kfH19mOGtoJ1w78iBwWKWUFkHi8Ky19nHyJYazhnbCtSMPAoc4NHBU0mJX69BJlzL6KgpnDe2Ea0deBF6f8K2k6QyMTERrjk+5trqnsbOGdsK1Iy8Cp/U7eDphc+/wWWG/Je1j5xEYgfMi8Kfm1UjP0P/W06bN7rbhaBVUtYnsrKGdcO3Ii8Ah7t6S7KKGUgjbt1y2sjn2+l0ERmAEnrKZ2YleT1MJ6oujctWaVvUr1s4a2h1TO/I0gUOEV7tq0tw9Fu1FrHWxy1lDu+C0I28Cf3LunujtmNp09I3L9S90yCfmVlZkZw3tgtOOvAkc4uLlDdF7paqBtt7xaKfBj1Xo1NpZQ7vYtCOPAoeY+1y7VBP1xVH56UNNCIzACFyqxPe/muwqpSR4/t0+mXVTMi+JP1E4a2hPCu3I6wQ+HmGvompjYGRC5jybznu3nDW0C0w78i5weNDikYTfmZXk2y9PT3jdsbOGdoFpR94FnrpmuBo3/m7qGpPv3BlvJ0IERmAzAof4wX37pXMwvVVLcRken4i9off0cNbQLirtsCRwiHMW18n2xpPvDKjByPiE/PzhmV+ldtbQLijtsCZwiPDc8rzn22VI6bHLDyPcu/7lozOT2FlDu5i0w6LAx+PcW+vklbrktyWdCeFZ7m/e/h4CIzAClypy+P1ZODgi1UJz95h85nq2F2UCM4FLljisIpq7vj3VV/OUw+Pbu2NNYWcN7dM47bB8Cn2iCIsPwmqiorLIE5MiF91d/hYvzhraBaMdCHzivJx2XY3c/NLBir7lYzqvNRxBYARG4Jk0uPBbdMnGovQP64h84V3lPeThrKE9AbWDCVxank6fXyu3//OQDI5W9tbTk2XuEOGsoS2QdiBw+fkKq5wqtd64f/hYWS8FcNbQFkg7EDhe3r66pF42FSpzD/mSMh6zdNbQFkg7EHhm+fvNymbpPpLuFetlmw8hMAIjcFpNcNaigrz63mBqAoenxZjATGAmcIpnMqdcu0c27O5LReDGzlEERmAErsTTXBtr+xMXOFwwK3UHCGcN7d+g2sFv4GTz+bkFtan8Jj51XmnPRjtraAukHQicfE6XbT6UuMBfvLGAwAiMwJV6L3XShEbLBGYCM4ErIPCXbt6buMBh90UERmAEroDA5y+pT1Te8DK+Uj/bWaMSB7SaIw+/gc+7rS5662Slti/5fzH7nobEH6cs9bOdNbQPtnbkQeCvL3t/4r3dPDSj19EkFQs3dEiS1HaMlPzZzhraB1s78iTw8dPN8CL3M0u86JNGvHNgWJIkPCBS6mc7a2gLpB15E3jqy+Hu/Neh6L5sJb/LLx5pkqRZvuVwyZ/vrKEtkHbkVeCp+xA98GpndGEp7e9x1qKCtPeOS9L8dlULAiOwTYGnvmMqLAq49LHmkm/JlBPnL6lPZWPxycnSH+II4ayhUXDVFFYEnn56Hbb5vGJVi3z6uppE3p01mNKbOuqKpV/AQuAqEAqB0xd4KuGiV6FjRNa81RNt+fndO/eddMfAcKsqbM9y5ROt0etuwil6moTX+CAwE5gJXCZh25XwgvW9B0fk3bbhaBK29oxV7FU6x0+fwz1uBEZgBM4gbzTyWll+A/MbOLNcEmPLUWcN7d+g2mHxIlZep69HYH2hEBiBx45OyjdiPhLqrKEtkHYwgauPhRs6Yh9PZw1tgbQDgauLTYX+aANyBEZgBM4YO1uGogdDZtKQnTW0J6B2MIGrg+2NR+SM+TNfeOGsoS2QdiCwPuvf6S1r/yMERmAErgIGRiaizcSTbMjOGtoTUDvyMIG/cmtd9OhjVpiYFFm7q1fOvmVv4rlw1tAWSDvyIHCIcAr64wcb5d6tnbKjZaiizyyXSvhOz/+nT751R3qv/XHW0BZIO/Ii8PQIOxn88P79smRjUbbUD1R8Y+6p1LSPyOKXizLrpuQnLgJXQbEhcPo5CPdWw6L7yx9viXZOeGlPv9QXR2X06GTiK4hausdk3a5euWZdW9mriRCYCVxWEeR1Ape7Pej3722Qq9a0yvwXO6I1uCve6IpOd7e+NxhtHTo9Nu8diNYDh/duXf9CR7Q+ePbyBvnsDcm/7aOccNbQLh6CHHgERmAaAY3AM4EpAhpBtmvAWUM74QQ58AiMwDQCGoFnAlMENIJs14CzhnbCCXLgERiBaQQ0As8EpghoBNmuAWcN7YQT5MAjMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4bf4LtvMh68AvCz8AAAAASUVORK5CYII="
  , tO = "" + new URL("cpp-238bc449.png",import.meta.url).href
  , nO = "" + new URL("dart-23123cd1.png",import.meta.url).href
  , iO = "" + new URL("mql5-34df7b32.png",import.meta.url).href
  , rO = "" + new URL("php-c2f197f5.png",import.meta.url).href
  , sO = "" + new URL("server-d1e8319d.png",import.meta.url).href
  , oO = "" + new URL("ios-245a361f.png",import.meta.url).href
  , aO = "" + new URL("android-b92eb8ff.png",import.meta.url).href
  , lO = "" + new URL("pc-b91b632f.png",import.meta.url).href
  , uO = "" + new URL("backend-9d7ac101.png",import.meta.url).href
  , cO = "" + new URL("graduation-297f89d0.png",import.meta.url).href
  , fO = "" + new URL("mql5-34df7b32.png",import.meta.url).href
  , dO = "" + new URL("binary_hub-39f81fe7.png",import.meta.url).href
  , hO = "" + new URL("bakame_coders-cd91814e.png",import.meta.url).href
  , pO = "" + new URL("ulk_dic-f4a10d06.png",import.meta.url).href
  , mO = "" + new URL("moses-1b12225d.png",import.meta.url).href
  , gO = "" + new URL("elie-ae282444.png",import.meta.url).href
  , yO = "" + new URL("kevine-39d28591.png",import.meta.url).href
  , vO = "" + new URL("tera_brain-8acdfde9.png",import.meta.url).href
  , xO = "" + new URL("bakame_web-df41b4f4.png",import.meta.url).href
  , _O = "" + new URL("CoachConnect-4fec4d1b.png",import.meta.url).href
  , AO = "" + new URL("DriversHiringSystem-8b2579b5.png",import.meta.url).href
  , MO = "" + new URL("NtaKomisiyo-9851505b.png",import.meta.url).href
  , wO = "" + new URL("SaveStreetChildren-4104bc8c.png",import.meta.url).href
  , SO = "" + new URL("EtiteEvents-357345eb.png",import.meta.url).href
  , CO = "" + new URL("AmategekoYumuhanda-f960a9db.png",import.meta.url).href
  , EO = "" + new URL("dashboard-69614d28.png",import.meta.url).href
  , TO = "" + new URL("wikilix-0062db50.png",import.meta.url).href
  , c3 = "" + new URL("external_link-431539fe.png",import.meta.url).href;
var f3 = {
    color: void 0,
    size: void 0,
    className: void 0,
    style: void 0,
    attr: void 0
}
  , kC = lt.createContext && lt.createContext(f3)
  , bO = ["attr", "size", "title"];
function PO(n, e) {
    if (n == null)
        return {};
    var t = BO(n, e), i, r;
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(n);
        for (r = 0; r < s.length; r++)
            i = s[r],
            !(e.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(n, i) && (t[i] = n[i])
    }
    return t
}
function BO(n, e) {
    if (n == null)
        return {};
    var t = {}, i = Object.keys(n), r, s;
    for (s = 0; s < i.length; s++)
        r = i[s],
        !(e.indexOf(r) >= 0) && (t[r] = n[r]);
    return t
}
function og() {
    return og = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }
    ,
    og.apply(this, arguments)
}
function NC(n, e) {
    var t = Object.keys(n);
    if (Object.getOwnPropertySymbols) {
        var i = Object.getOwnPropertySymbols(n);
        e && (i = i.filter(function(r) {
            return Object.getOwnPropertyDescriptor(n, r).enumerable
        })),
        t.push.apply(t, i)
    }
    return t
}
function ag(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? NC(Object(t), !0).forEach(function(i) {
            RO(n, i, t[i])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : NC(Object(t)).forEach(function(i) {
            Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i))
        })
    }
    return n
}
function RO(n, e, t) {
    return e = LO(e),
    e in n ? Object.defineProperty(n, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : n[e] = t,
    n
}
function LO(n) {
    var e = IO(n, "string");
    return typeof e == "symbol" ? e : String(e)
}
function IO(n, e) {
    if (typeof n != "object" || n === null)
        return n;
    var t = n[Symbol.toPrimitive];
    if (t !== void 0) {
        var i = t.call(n, e || "default");
        if (typeof i != "object")
            return i;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(n)
}
function d3(n) {
    return n && n.map((e,t)=>lt.createElement(e.tag, ag({
        key: t
    }, e.attr), d3(e.child)))
}
function ea(n) {
    return e=>lt.createElement(DO, og({
        attr: ag({}, n.attr)
    }, e), d3(n.child))
}
function DO(n) {
    var e = t=>{
        var {attr: i, size: r, title: s} = n, o = PO(n, bO), a = r || t.size || "1em", l;
        return t.className && (l = t.className),
        n.className && (l = (l ? l + " " : "") + n.className),
        lt.createElement("svg", og({
            stroke: "currentColor",
            fill: "currentColor",
            strokeWidth: "0"
        }, t.attr, i, o, {
            className: l,
            style: ag(ag({
                color: n.color || t.color
            }, t.style), n.style),
            height: a,
            width: a,
            xmlns: "http://www.w3.org/2000/svg"
        }), s && lt.createElement("title", null, s), n.children)
    }
    ;
    return kC !== void 0 ? lt.createElement(kC.Consumer, null, t=>e(t)) : e(f3)
}
function ZX(n) {
    return ea({
        tag: "svg",
        attr: {
            viewBox: "0 0 512 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M325.3 234.3L104.6 13l280.8 161.2-60.1 60.1zM47 0C34 6.8 25.3 19.2 25.3 35.3v441.3c0 16.1 8.7 28.5 21.7 35.3l256.6-256L47 0zm425.2 225.6l-58.9-34.1-65.7 64.5 65.7 64.5 60.1-34.1c18-14.3 18-46.5-1.2-60.8zM104.6 499l280.8-161.2-60.1-60.1L104.6 499z"
            },
            child: []
        }]
    })(n)
}
function qX(n) {
    return ea({
        tag: "svg",
        attr: {
            viewBox: "0 0 496 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm169.5 338.9c-3.5 8.1-18.1 14-44.8 18.2-1.4 1.9-2.5 9.8-4.3 15.9-1.1 3.7-3.7 5.9-8.1 5.9h-.2c-6.2 0-12.8-2.9-25.8-2.9-17.6 0-23.7 4-37.4 13.7-14.5 10.3-28.4 19.1-49.2 18.2-21 1.6-38.6-11.2-48.5-18.2-13.8-9.7-19.8-13.7-37.4-13.7-12.5 0-20.4 3.1-25.8 3.1-5.4 0-7.5-3.3-8.3-6-1.8-6.1-2.9-14.1-4.3-16-13.8-2.1-44.8-7.5-45.5-21.4-.2-3.6 2.3-6.8 5.9-7.4 46.3-7.6 67.1-55.1 68-57.1 0-.1.1-.2.2-.3 2.5-5 3-9.2 1.6-12.5-3.4-7.9-17.9-10.7-24-13.2-15.8-6.2-18-13.4-17-18.3 1.6-8.5 14.4-13.8 21.9-10.3 5.9 2.8 11.2 4.2 15.7 4.2 3.3 0 5.5-.8 6.6-1.4-1.4-23.9-4.7-58 3.8-77.1C183.1 100 230.7 96 244.7 96c.6 0 6.1-.1 6.7-.1 34.7 0 68 17.8 84.3 54.3 8.5 19.1 5.2 53.1 3.8 77.1 1.1.6 2.9 1.3 5.7 1.4 4.3-.2 9.2-1.6 14.7-4.2 4-1.9 9.6-1.6 13.6 0 6.3 2.3 10.3 6.8 10.4 11.9.1 6.5-5.7 12.1-17.2 16.6-1.4.6-3.1 1.1-4.9 1.7-6.5 2.1-16.4 5.2-19 11.5-1.4 3.3-.8 7.5 1.6 12.5.1.1.1.2.2.3.9 2 21.7 49.5 68 57.1 4 1 7.1 5.5 4.9 10.8z"
            },
            child: []
        }]
    })(n)
}
function $X(n) {
    return ea({
        tag: "svg",
        attr: {
            viewBox: "0 0 496 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm121.8 169.9l-40.7 191.8c-3 13.6-11.1 16.9-22.4 10.5l-62-45.7-29.9 28.8c-3.3 3.3-6.1 6.1-12.5 6.1l4.4-63.1 114.9-103.8c5-4.4-1.1-6.9-7.7-2.5l-142 89.4-61.2-19.1c-13.3-4.2-13.6-13.3 2.8-19.7l239.1-92.2c11.1-4 20.8 2.7 17.2 19.5z"
            },
            child: []
        }]
    })(n)
}
function eK(n) {
    return ea({
        tag: "svg",
        attr: {
            viewBox: "0 0 448 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M448,209.91a210.06,210.06,0,0,1-122.77-39.25V349.38A162.55,162.55,0,1,1,185,188.31V278.2a74.62,74.62,0,1,0,52.23,71.18V0l88,0a121.18,121.18,0,0,0,1.86,22.17h0A122.18,122.18,0,0,0,381,102.39a121.43,121.43,0,0,0,67,20.14Z"
            },
            child: []
        }]
    })(n)
}
function tK(n) {
    return ea({
        tag: "svg",
        attr: {
            viewBox: "0 0 448 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M380.9 97.1C339 55.1 283.2 32 223.9 32c-122.4 0-222 99.6-222 222 0 39.1 10.2 77.3 29.6 111L0 480l117.7-30.9c32.4 17.7 68.9 27 106.1 27h.1c122.3 0 224.1-99.6 224.1-222 0-59.3-25.2-115-67.1-157zm-157 341.6c-33.2 0-65.7-8.9-94-25.7l-6.7-4-69.8 18.3L72 359.2l-4.4-7c-18.5-29.4-28.2-63.3-28.2-98.2 0-101.7 82.8-184.5 184.6-184.5 49.3 0 95.6 19.2 130.4 54.1 34.8 34.9 56.2 81.2 56.1 130.5 0 101.8-84.9 184.6-186.6 184.6zm101.2-138.2c-5.5-2.8-32.8-16.2-37.9-18-5.1-1.9-8.8-2.8-12.5 2.8-3.7 5.6-14.3 18-17.6 21.8-3.2 3.7-6.5 4.2-12 1.4-32.6-16.3-54-29.1-75.5-66-5.7-9.8 5.7-9.1 16.3-30.3 1.8-3.7.9-6.9-.5-9.7-1.4-2.8-12.5-30.1-17.1-41.2-4.5-10.8-9.1-9.3-12.5-9.5-3.2-.2-6.9-.2-10.6-.2-3.7 0-9.7 1.4-14.8 6.9-5.1 5.6-19.4 19-19.4 46.3 0 27.3 19.9 53.7 22.6 57.4 2.8 3.7 39.1 59.7 94.8 83.8 35.2 15.2 49 16.5 66.6 13.9 10.7-1.6 32.8-13.4 37.4-26.4 4.6-13 4.6-24.1 3.2-26.4-1.3-2.5-5-3.9-10.5-6.6z"
            },
            child: []
        }]
    })(n)
}
function nK(n) {
    return ea({
        tag: "svg",
        attr: {
            viewBox: "0 0 512 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"
            },
            child: []
        }]
    })(n)
}
function iK(n) {
    return ea({
        tag: "svg",
        attr: {
            viewBox: "0 0 512 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M493.4 24.6l-104-24c-11.3-2.6-22.9 3.3-27.5 13.9l-48 112c-4.2 9.8-1.4 21.3 6.9 28l60.6 49.6c-36 76.7-98.9 140.5-177.2 177.2l-49.6-60.6c-6.8-8.3-18.2-11.1-28-6.9l-112 48C3.9 366.5-2 378.1.6 389.4l24 104C27.1 504.2 36.7 512 48 512c256.1 0 464-207.5 464-464 0-11.2-7.7-20.9-18.6-23.4z"
            },
            child: []
        }]
    })(n)
}
function FO(n) {
    return ea({
        tag: "svg",
        attr: {
            viewBox: "0 0 512 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M304 48c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48zm-48 368c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm208-208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zM96 256c0-26.51-21.49-48-48-48S0 229.49 0 256s21.49 48 48 48 48-21.49 48-48zm12.922 99.078c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.491-48-48-48zm294.156 0c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.49-48-48-48zM108.922 60.922c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.491-48-48-48z"
            },
            child: []
        }]
    })(n)
}
const OC = ()=>xe("div", {
    className: "h-screen w-full bg-mainColor flex justify-center items-center",
    children: ut("div", {
        className: "flex flex-col justify-center items-center animate-pulse text-white text-2xl gap-5",
        children: [xe("img", {
            src: jN,
            width: 100
        }), xe(FO, {
            className: "animate-spin text-4xl"
        }), xe("h2", {
            children: "Loading..."
        })]
    })
});
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const jg = "149"
  , ba = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
}
  , Pa = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
}
  , h3 = 0
  , t1 = 1
  , p3 = 2
  , kO = 3
  , m3 = 0
  , Jg = 1
  , Af = 2
  , Ua = 3
  , as = 0
  , Bi = 1
  , Ir = 2
  , NO = 2
  , Us = 0
  , Ka = 1
  , n1 = 2
  , i1 = 3
  , r1 = 4
  , g3 = 5
  , Da = 100
  , y3 = 101
  , v3 = 102
  , s1 = 103
  , o1 = 104
  , x3 = 200
  , _3 = 201
  , A3 = 202
  , M3 = 203
  , dA = 204
  , hA = 205
  , w3 = 206
  , S3 = 207
  , C3 = 208
  , E3 = 209
  , T3 = 210
  , b3 = 0
  , P3 = 1
  , B3 = 2
  , lg = 3
  , R3 = 4
  , L3 = 5
  , I3 = 6
  , D3 = 7
  , Cd = 0
  , F3 = 1
  , k3 = 2
  , kr = 0
  , N3 = 1
  , O3 = 2
  , U3 = 3
  , pA = 4
  , z3 = 5
  , Xg = 300
  , Vo = 301
  , Wo = 302
  , qf = 303
  , $f = 304
  , qu = 306
  , jo = 1e3
  , Vn = 1001
  , ku = 1002
  , hn = 1003
  , ed = 1004
  , OO = 1004
  , Eu = 1005
  , UO = 1005
  , nn = 1006
  , Kg = 1007
  , zO = 1007
  , ls = 1008
  , GO = 1008
  , Js = 1009
  , G3 = 1010
  , H3 = 1011
  , mA = 1012
  , V3 = 1013
  , bo = 1014
  , Ds = 1015
  , Nu = 1016
  , W3 = 1017
  , j3 = 1018
  , Ya = 1020
  , J3 = 1021
  , Ci = 1023
  , X3 = 1024
  , K3 = 1025
  , Uo = 1026
  , ol = 1027
  , Y3 = 1028
  , Q3 = 1029
  , Z3 = 1030
  , q3 = 1031
  , $3 = 1033
  , Mm = 33776
  , wm = 33777
  , Sm = 33778
  , Cm = 33779
  , a1 = 35840
  , l1 = 35841
  , u1 = 35842
  , c1 = 35843
  , eB = 36196
  , f1 = 37492
  , d1 = 37496
  , h1 = 37808
  , p1 = 37809
  , m1 = 37810
  , g1 = 37811
  , y1 = 37812
  , v1 = 37813
  , x1 = 37814
  , _1 = 37815
  , A1 = 37816
  , M1 = 37817
  , w1 = 37818
  , S1 = 37819
  , C1 = 37820
  , E1 = 37821
  , Em = 36492
  , tB = 36283
  , T1 = 36284
  , b1 = 36285
  , P1 = 36286
  , nB = 2200
  , iB = 2201
  , rB = 2202
  , Ou = 2300
  , al = 2301
  , Tm = 2302
  , za = 2400
  , Ga = 2401
  , td = 2402
  , Yg = 2500
  , gA = 2501
  , HO = 0
  , sB = 1
  , yA = 2
  , Xs = 3e3
  , Et = 3001
  , oB = 3200
  , aB = 3201
  , Qs = 0
  , lB = 1
  , VO = ""
  , Br = "srgb"
  , Uu = "srgb-linear"
  , WO = 0
  , bm = 7680
  , jO = 7681
  , JO = 7682
  , XO = 7683
  , KO = 34055
  , YO = 34056
  , QO = 5386
  , ZO = 512
  , qO = 513
  , $O = 514
  , e4 = 515
  , t4 = 516
  , n4 = 517
  , i4 = 518
  , uB = 519
  , nd = 35044
  , Qa = 35048
  , r4 = 35040
  , s4 = 35045
  , o4 = 35049
  , a4 = 35041
  , l4 = 35046
  , u4 = 35050
  , c4 = 35042
  , f4 = "100"
  , B1 = "300 es"
  , ug = 1035;
class cs {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const i = this._listeners;
        i[e] === void 0 && (i[e] = []),
        i[e].indexOf(t) === -1 && i[e].push(t)
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0)
            return !1;
        const i = this._listeners;
        return i[e] !== void 0 && i[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0)
            return;
        const r = this._listeners[e];
        if (r !== void 0) {
            const s = r.indexOf(t);
            s !== -1 && r.splice(s, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0)
            return;
        const i = this._listeners[e.type];
        if (i !== void 0) {
            e.target = this;
            const r = i.slice(0);
            for (let s = 0, o = r.length; s < o; s++)
                r[s].call(this, e);
            e.target = null
        }
    }
}
const $n = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let UC = 1234567;
const Za = Math.PI / 180
  , id = 180 / Math.PI;
function Vi() {
    const n = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , t = Math.random() * 4294967295 | 0
      , i = Math.random() * 4294967295 | 0;
    return ($n[n & 255] + $n[n >> 8 & 255] + $n[n >> 16 & 255] + $n[n >> 24 & 255] + "-" + $n[e & 255] + $n[e >> 8 & 255] + "-" + $n[e >> 16 & 15 | 64] + $n[e >> 24 & 255] + "-" + $n[t & 63 | 128] + $n[t >> 8 & 255] + "-" + $n[t >> 16 & 255] + $n[t >> 24 & 255] + $n[i & 255] + $n[i >> 8 & 255] + $n[i >> 16 & 255] + $n[i >> 24 & 255]).toLowerCase()
}
function vn(n, e, t) {
    return Math.max(e, Math.min(t, n))
}
function vA(n, e) {
    return (n % e + e) % e
}
function d4(n, e, t, i, r) {
    return i + (n - e) * (r - i) / (t - e)
}
function h4(n, e, t) {
    return n !== e ? (t - n) / (e - n) : 0
}
function Mf(n, e, t) {
    return (1 - t) * n + t * e
}
function p4(n, e, t, i) {
    return Mf(n, e, 1 - Math.exp(-t * i))
}
function m4(n, e=1) {
    return e - Math.abs(vA(n, e * 2) - e)
}
function g4(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e),
    n * n * (3 - 2 * n))
}
function y4(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e),
    n * n * n * (n * (n * 6 - 15) + 10))
}
function v4(n, e) {
    return n + Math.floor(Math.random() * (e - n + 1))
}
function x4(n, e) {
    return n + Math.random() * (e - n)
}
function _4(n) {
    return n * (.5 - Math.random())
}
function A4(n) {
    n !== void 0 && (UC = n);
    let e = UC += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1),
    e ^= e + Math.imul(e ^ e >>> 7, e | 61),
    ((e ^ e >>> 14) >>> 0) / 4294967296
}
function M4(n) {
    return n * Za
}
function w4(n) {
    return n * id
}
function R1(n) {
    return (n & n - 1) === 0 && n !== 0
}
function cB(n) {
    return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
}
function cg(n) {
    return Math.pow(2, Math.floor(Math.log(n) / Math.LN2))
}
function S4(n, e, t, i, r) {
    const s = Math.cos
      , o = Math.sin
      , a = s(t / 2)
      , l = o(t / 2)
      , c = s((e + i) / 2)
      , d = o((e + i) / 2)
      , h = s((e - i) / 2)
      , p = o((e - i) / 2)
      , m = s((i - e) / 2)
      , y = o((i - e) / 2);
    switch (r) {
    case "XYX":
        n.set(a * d, l * h, l * p, a * c);
        break;
    case "YZY":
        n.set(l * p, a * d, l * h, a * c);
        break;
    case "ZXZ":
        n.set(l * h, l * p, a * d, a * c);
        break;
    case "XZX":
        n.set(a * d, l * y, l * m, a * c);
        break;
    case "YXY":
        n.set(l * m, a * d, l * y, a * c);
        break;
    case "ZYZ":
        n.set(l * y, l * m, a * d, a * c);
        break;
    default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
    }
}
function Fs(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint16Array:
        return n / 65535;
    case Uint8Array:
        return n / 255;
    case Int16Array:
        return Math.max(n / 32767, -1);
    case Int8Array:
        return Math.max(n / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function Gt(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint16Array:
        return Math.round(n * 65535);
    case Uint8Array:
        return Math.round(n * 255);
    case Int16Array:
        return Math.round(n * 32767);
    case Int8Array:
        return Math.round(n * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
var fB = Object.freeze({
    __proto__: null,
    DEG2RAD: Za,
    RAD2DEG: id,
    ceilPowerOfTwo: cB,
    clamp: vn,
    damp: p4,
    degToRad: M4,
    denormalize: Fs,
    euclideanModulo: vA,
    floorPowerOfTwo: cg,
    generateUUID: Vi,
    inverseLerp: h4,
    isPowerOfTwo: R1,
    lerp: Mf,
    mapLinear: d4,
    normalize: Gt,
    pingpong: m4,
    radToDeg: w4,
    randFloat: x4,
    randFloatSpread: _4,
    randInt: v4,
    seededRandom: A4,
    setQuaternionFromProperEuler: S4,
    smootherstep: y4,
    smoothstep: g4
});
class pe {
    constructor(e=0, t=0) {
        pe.prototype.isVector2 = !0,
        this.x = e,
        this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x
          , i = this.y
          , r = e.elements;
        return this.x = r[0] * t + r[3] * i + r[6],
        this.y = r[1] * t + r[4] * i + r[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , i = this.y - e.y;
        return t * t + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this
    }
    rotateAround(e, t) {
        const i = Math.cos(t)
          , r = Math.sin(t)
          , s = this.x - e.x
          , o = this.y - e.y;
        return this.x = s * i - o * r + e.x,
        this.y = s * r + o * i + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class hi {
    constructor() {
        hi.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
    }
    set(e, t, i, r, s, o, a, l, c) {
        const d = this.elements;
        return d[0] = e,
        d[1] = r,
        d[2] = a,
        d[3] = t,
        d[4] = s,
        d[5] = l,
        d[6] = i,
        d[7] = o,
        d[8] = c,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const t = this.elements
          , i = e.elements;
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        i.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements
          , r = t.elements
          , s = this.elements
          , o = i[0]
          , a = i[3]
          , l = i[6]
          , c = i[1]
          , d = i[4]
          , h = i[7]
          , p = i[2]
          , m = i[5]
          , y = i[8]
          , v = r[0]
          , _ = r[3]
          , x = r[6]
          , A = r[1]
          , M = r[4]
          , S = r[7]
          , T = r[2]
          , P = r[5]
          , R = r[8];
        return s[0] = o * v + a * A + l * T,
        s[3] = o * _ + a * M + l * P,
        s[6] = o * x + a * S + l * R,
        s[1] = c * v + d * A + h * T,
        s[4] = c * _ + d * M + h * P,
        s[7] = c * x + d * S + h * R,
        s[2] = p * v + m * A + y * T,
        s[5] = p * _ + m * M + y * P,
        s[8] = p * x + m * S + y * R,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , d = e[8];
        return t * o * d - t * a * c - i * s * d + i * a * l + r * s * c - r * o * l
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , d = e[8]
          , h = d * o - a * c
          , p = a * l - d * s
          , m = c * s - o * l
          , y = t * h + i * p + r * m;
        if (y === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const v = 1 / y;
        return e[0] = h * v,
        e[1] = (r * c - d * i) * v,
        e[2] = (a * i - r * o) * v,
        e[3] = p * v,
        e[4] = (d * t - r * l) * v,
        e[5] = (r * s - a * t) * v,
        e[6] = m * v,
        e[7] = (i * l - c * t) * v,
        e[8] = (o * t - i * s) * v,
        this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    }
    setUvTransform(e, t, i, r, s, o, a) {
        const l = Math.cos(s)
          , c = Math.sin(s);
        return this.set(i * l, i * c, -i * (l * o + c * a) + o + e, -r * c, r * l, -r * (-c * o + l * a) + a + t, 0, 0, 1),
        this
    }
    scale(e, t) {
        return this.premultiply(Zy.makeScale(e, t)),
        this
    }
    rotate(e) {
        return this.premultiply(Zy.makeRotation(-e)),
        this
    }
    translate(e, t) {
        return this.premultiply(Zy.makeTranslation(e, t)),
        this
    }
    makeTranslation(e, t) {
        return this.set(1, 0, e, 0, 1, t, 0, 0, 1),
        this
    }
    makeRotation(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, -i, 0, i, t, 0, 0, 0, 1),
        this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
        this
    }
    equals(e) {
        const t = this.elements
          , i = e.elements;
        for (let r = 0; r < 9; r++)
            if (t[r] !== i[r])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let i = 0; i < 9; i++)
            this.elements[i] = e[i + t];
        return this
    }
    toArray(e=[], t=0) {
        const i = this.elements;
        return e[t] = i[0],
        e[t + 1] = i[1],
        e[t + 2] = i[2],
        e[t + 3] = i[3],
        e[t + 4] = i[4],
        e[t + 5] = i[5],
        e[t + 6] = i[6],
        e[t + 7] = i[7],
        e[t + 8] = i[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const Zy = new hi;
function dB(n) {
    for (let e = n.length - 1; e >= 0; --e)
        if (n[e] >= 65535)
            return !0;
    return !1
}
const C4 = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
};
function hu(n, e) {
    return new C4[n](e)
}
function rd(n) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", n)
}
function qa(n) {
    return n < .04045 ? n * .0773993808 : Math.pow(n * .9478672986 + .0521327014, 2.4)
}
function Pm(n) {
    return n < .0031308 ? n * 12.92 : 1.055 * Math.pow(n, .41666) - .055
}
const qy = {
    [Br]: {
        [Uu]: qa
    },
    [Uu]: {
        [Br]: Pm
    }
}
  , ei = {
    legacyMode: !0,
    get workingColorSpace() {
        return Uu
    },
    set workingColorSpace(n) {
        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
    },
    convert: function(n, e, t) {
        if (this.legacyMode || e === t || !e || !t)
            return n;
        if (qy[e] && qy[e][t] !== void 0) {
            const i = qy[e][t];
            return n.r = i(n.r),
            n.g = i(n.g),
            n.b = i(n.b),
            n
        }
        throw new Error("Unsupported color space conversion.")
    },
    fromWorkingColorSpace: function(n, e) {
        return this.convert(n, this.workingColorSpace, e)
    },
    toWorkingColorSpace: function(n, e) {
        return this.convert(n, e, this.workingColorSpace)
    }
}
  , hB = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , En = {
    r: 0,
    g: 0,
    b: 0
}
  , Cr = {
    h: 0,
    s: 0,
    l: 0
}
  , pp = {
    h: 0,
    s: 0,
    l: 0
};
function $y(n, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n
}
function mp(n, e) {
    return e.r = n.r,
    e.g = n.g,
    e.b = n.b,
    e
}
class Le {
    constructor(e, t, i) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        t === void 0 && i === void 0 ? this.set(e) : this.setRGB(e, t, i)
    }
    set(e) {
        return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e),
        this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, t=Br) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        ei.toWorkingColorSpace(this, t),
        this
    }
    setRGB(e, t, i, r=ei.workingColorSpace) {
        return this.r = e,
        this.g = t,
        this.b = i,
        ei.toWorkingColorSpace(this, r),
        this
    }
    setHSL(e, t, i, r=ei.workingColorSpace) {
        if (e = vA(e, 1),
        t = vn(t, 0, 1),
        i = vn(i, 0, 1),
        t === 0)
            this.r = this.g = this.b = i;
        else {
            const s = i <= .5 ? i * (1 + t) : i + t - i * t
              , o = 2 * i - s;
            this.r = $y(o, s, e + 1 / 3),
            this.g = $y(o, s, e),
            this.b = $y(o, s, e - 1 / 3)
        }
        return ei.toWorkingColorSpace(this, r),
        this
    }
    setStyle(e, t=Br) {
        function i(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let r;
        if (r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
            let s;
            const o = r[1]
              , a = r[2];
            switch (o) {
            case "rgb":
            case "rgba":
                if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return this.r = Math.min(255, parseInt(s[1], 10)) / 255,
                    this.g = Math.min(255, parseInt(s[2], 10)) / 255,
                    this.b = Math.min(255, parseInt(s[3], 10)) / 255,
                    ei.toWorkingColorSpace(this, t),
                    i(s[4]),
                    this;
                if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return this.r = Math.min(100, parseInt(s[1], 10)) / 100,
                    this.g = Math.min(100, parseInt(s[2], 10)) / 100,
                    this.b = Math.min(100, parseInt(s[3], 10)) / 100,
                    ei.toWorkingColorSpace(this, t),
                    i(s[4]),
                    this;
                break;
            case "hsl":
            case "hsla":
                if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) {
                    const l = parseFloat(s[1]) / 360
                      , c = parseFloat(s[2]) / 100
                      , d = parseFloat(s[3]) / 100;
                    return i(s[4]),
                    this.setHSL(l, c, d, t)
                }
                break
            }
        } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const s = r[1]
              , o = s.length;
            if (o === 3)
                return this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255,
                this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255,
                this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255,
                ei.toWorkingColorSpace(this, t),
                this;
            if (o === 6)
                return this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255,
                this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255,
                this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255,
                ei.toWorkingColorSpace(this, t),
                this
        }
        return e && e.length > 0 ? this.setColorName(e, t) : this
    }
    setColorName(e, t=Br) {
        const i = hB[e.toLowerCase()];
        return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = qa(e.r),
        this.g = qa(e.g),
        this.b = qa(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = Pm(e.r),
        this.g = Pm(e.g),
        this.b = Pm(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=Br) {
        return ei.fromWorkingColorSpace(mp(this, En), e),
        vn(En.r * 255, 0, 255) << 16 ^ vn(En.g * 255, 0, 255) << 8 ^ vn(En.b * 255, 0, 255) << 0
    }
    getHexString(e=Br) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=ei.workingColorSpace) {
        ei.fromWorkingColorSpace(mp(this, En), t);
        const i = En.r
          , r = En.g
          , s = En.b
          , o = Math.max(i, r, s)
          , a = Math.min(i, r, s);
        let l, c;
        const d = (a + o) / 2;
        if (a === o)
            l = 0,
            c = 0;
        else {
            const h = o - a;
            switch (c = d <= .5 ? h / (o + a) : h / (2 - o - a),
            o) {
            case i:
                l = (r - s) / h + (r < s ? 6 : 0);
                break;
            case r:
                l = (s - i) / h + 2;
                break;
            case s:
                l = (i - r) / h + 4;
                break
            }
            l /= 6
        }
        return e.h = l,
        e.s = c,
        e.l = d,
        e
    }
    getRGB(e, t=ei.workingColorSpace) {
        return ei.fromWorkingColorSpace(mp(this, En), t),
        e.r = En.r,
        e.g = En.g,
        e.b = En.b,
        e
    }
    getStyle(e=Br) {
        return ei.fromWorkingColorSpace(mp(this, En), e),
        e !== Br ? `color(${e} ${En.r} ${En.g} ${En.b})` : `rgb(${En.r * 255 | 0},${En.g * 255 | 0},${En.b * 255 | 0})`
    }
    offsetHSL(e, t, i) {
        return this.getHSL(Cr),
        Cr.h += e,
        Cr.s += t,
        Cr.l += i,
        this.setHSL(Cr.h, Cr.s, Cr.l),
        this
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    }
    lerpColors(e, t, i) {
        return this.r = e.r + (t.r - e.r) * i,
        this.g = e.g + (t.g - e.g) * i,
        this.b = e.b + (t.b - e.b) * i,
        this
    }
    lerpHSL(e, t) {
        this.getHSL(Cr),
        e.getHSL(pp);
        const i = Mf(Cr.h, pp.h, t)
          , r = Mf(Cr.s, pp.s, t)
          , s = Mf(Cr.l, pp.l, t);
        return this.setHSL(i, r, s),
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0) {
        return this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t),
        this.g = e.getY(t),
        this.b = e.getZ(t),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
Le.NAMES = hB;
let Il;
class xA {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let t;
        if (e instanceof HTMLCanvasElement)
            t = e;
        else {
            Il === void 0 && (Il = rd("canvas")),
            Il.width = e.width,
            Il.height = e.height;
            const i = Il.getContext("2d");
            e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height),
            t = Il
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
        t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = rd("canvas");
            t.width = e.width,
            t.height = e.height;
            const i = t.getContext("2d");
            i.drawImage(e, 0, 0, e.width, e.height);
            const r = i.getImageData(0, 0, e.width, e.height)
              , s = r.data;
            for (let o = 0; o < s.length; o++)
                s[o] = qa(s[o] / 255) * 255;
            return i.putImageData(r, 0, 0),
            t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let i = 0; i < t.length; i++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(qa(t[i] / 255) * 255) : t[i] = qa(t[i]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
class Ha {
    constructor(e=null) {
        this.isSource = !0,
        this.uuid = Vi(),
        this.data = e,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const i = {
            uuid: this.uuid,
            url: ""
        }
          , r = this.data;
        if (r !== null) {
            let s;
            if (Array.isArray(r)) {
                s = [];
                for (let o = 0, a = r.length; o < a; o++)
                    r[o].isDataTexture ? s.push(ev(r[o].image)) : s.push(ev(r[o]))
            } else
                s = ev(r);
            i.url = s
        }
        return t || (e.images[this.uuid] = i),
        i
    }
}
function ev(n) {
    return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? xA.getDataURL(n) : n.data ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let E4 = 0;
class qt extends cs {
    constructor(e=qt.DEFAULT_IMAGE, t=qt.DEFAULT_MAPPING, i=Vn, r=Vn, s=nn, o=ls, a=Ci, l=Js, c=qt.DEFAULT_ANISOTROPY, d=Xs) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: E4++
        }),
        this.uuid = Vi(),
        this.name = "",
        this.source = new Ha(e),
        this.mipmaps = [],
        this.mapping = t,
        this.wrapS = i,
        this.wrapT = r,
        this.magFilter = s,
        this.minFilter = o,
        this.anisotropy = c,
        this.format = a,
        this.internalFormat = null,
        this.type = l,
        this.offset = new pe(0,0),
        this.repeat = new pe(1,1),
        this.center = new pe(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new hi,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.encoding = d,
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.needsPMREMUpdate = !1
    }
    get image() {
        return this.source.data
    }
    set image(e) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.encoding = e.encoding,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const i = {
            metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        t || (e.textures[this.uuid] = i),
        i
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== Xg)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case jo:
                e.x = e.x - Math.floor(e.x);
                break;
            case Vn:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case ku:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case jo:
                e.y = e.y - Math.floor(e.y);
                break;
            case Vn:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case ku:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
}
qt.DEFAULT_IMAGE = null;
qt.DEFAULT_MAPPING = Xg;
qt.DEFAULT_ANISOTROPY = 1;
class Nt {
    constructor(e=0, t=0, i=0, r=1) {
        Nt.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = i,
        this.w = r
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, i, r) {
        return this.x = e,
        this.y = t,
        this.z = i,
        this.w = r,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = this.w
          , o = e.elements;
        return this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s,
        this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s,
        this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s,
        this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / t,
        this.y = e.y / t,
        this.z = e.z / t),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, i, r, s;
        const l = e.elements
          , c = l[0]
          , d = l[4]
          , h = l[8]
          , p = l[1]
          , m = l[5]
          , y = l[9]
          , v = l[2]
          , _ = l[6]
          , x = l[10];
        if (Math.abs(d - p) < .01 && Math.abs(h - v) < .01 && Math.abs(y - _) < .01) {
            if (Math.abs(d + p) < .1 && Math.abs(h + v) < .1 && Math.abs(y + _) < .1 && Math.abs(c + m + x - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            t = Math.PI;
            const M = (c + 1) / 2
              , S = (m + 1) / 2
              , T = (x + 1) / 2
              , P = (d + p) / 4
              , R = (h + v) / 4
              , E = (y + _) / 4;
            return M > S && M > T ? M < .01 ? (i = 0,
            r = .707106781,
            s = .707106781) : (i = Math.sqrt(M),
            r = P / i,
            s = R / i) : S > T ? S < .01 ? (i = .707106781,
            r = 0,
            s = .707106781) : (r = Math.sqrt(S),
            i = P / r,
            s = E / r) : T < .01 ? (i = .707106781,
            r = .707106781,
            s = 0) : (s = Math.sqrt(T),
            i = R / s,
            r = E / s),
            this.set(i, r, s, t),
            this
        }
        let A = Math.sqrt((_ - y) * (_ - y) + (h - v) * (h - v) + (p - d) * (p - d));
        return Math.abs(A) < .001 && (A = 1),
        this.x = (_ - y) / A,
        this.y = (h - v) / A,
        this.z = (p - d) / A,
        this.w = Math.acos((c + m + x - 1) / 2),
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this.w = Math.max(e.w, Math.min(t.w, this.w)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this.w = Math.max(e, Math.min(t, this.w)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this.z = e.z + (t.z - e.z) * i,
        this.w = e.w + (t.w - e.w) * i,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class Ur extends cs {
    constructor(e=1, t=1, i={}) {
        super(),
        this.isWebGLRenderTarget = !0,
        this.width = e,
        this.height = t,
        this.depth = 1,
        this.scissor = new Nt(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new Nt(0,0,e,t);
        const r = {
            width: e,
            height: t,
            depth: 1
        };
        this.texture = new qt(r,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),
        this.texture.isRenderTargetTexture = !0,
        this.texture.flipY = !1,
        this.texture.generateMipmaps = i.generateMipmaps !== void 0 ? i.generateMipmaps : !1,
        this.texture.internalFormat = i.internalFormat !== void 0 ? i.internalFormat : null,
        this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : nn,
        this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0,
        this.stencilBuffer = i.stencilBuffer !== void 0 ? i.stencilBuffer : !1,
        this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null,
        this.samples = i.samples !== void 0 ? i.samples : 0
    }
    setSize(e, t, i=1) {
        (this.width !== e || this.height !== t || this.depth !== i) && (this.width = e,
        this.height = t,
        this.depth = i,
        this.texture.image.width = e,
        this.texture.image.height = t,
        this.texture.image.depth = i,
        this.dispose()),
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.viewport.copy(e.viewport),
        this.texture = e.texture.clone(),
        this.texture.isRenderTargetTexture = !0;
        const t = Object.assign({}, e.texture.image);
        return this.texture.source = new Ha(t),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class Qg extends qt {
    constructor(e=null, t=1, i=1, r=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i,
            depth: r
        },
        this.magFilter = hn,
        this.minFilter = hn,
        this.wrapR = Vn,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class T4 extends Ur {
    constructor(e=1, t=1, i=1) {
        super(e, t),
        this.isWebGLArrayRenderTarget = !0,
        this.depth = i,
        this.texture = new Qg(null,e,t,i),
        this.texture.isRenderTargetTexture = !0
    }
}
class _A extends qt {
    constructor(e=null, t=1, i=1, r=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i,
            depth: r
        },
        this.magFilter = hn,
        this.minFilter = hn,
        this.wrapR = Vn,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class b4 extends Ur {
    constructor(e=1, t=1, i=1) {
        super(e, t),
        this.isWebGL3DRenderTarget = !0,
        this.depth = i,
        this.texture = new _A(null,e,t,i),
        this.texture.isRenderTargetTexture = !0
    }
}
class P4 extends Ur {
    constructor(e=1, t=1, i=1, r={}) {
        super(e, t, r),
        this.isWebGLMultipleRenderTargets = !0;
        const s = this.texture;
        this.texture = [];
        for (let o = 0; o < i; o++)
            this.texture[o] = s.clone(),
            this.texture[o].isRenderTargetTexture = !0
    }
    setSize(e, t, i=1) {
        if (this.width !== e || this.height !== t || this.depth !== i) {
            this.width = e,
            this.height = t,
            this.depth = i;
            for (let r = 0, s = this.texture.length; r < s; r++)
                this.texture[r].image.width = e,
                this.texture[r].image.height = t,
                this.texture[r].image.depth = i;
            this.dispose()
        }
        return this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t),
        this
    }
    copy(e) {
        this.dispose(),
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.viewport.set(0, 0, this.width, this.height),
        this.scissor.set(0, 0, this.width, this.height),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.texture.length = 0;
        for (let t = 0, i = e.texture.length; t < i; t++)
            this.texture[t] = e.texture[t].clone(),
            this.texture[t].isRenderTargetTexture = !0;
        return this
    }
}
class jn {
    constructor(e=0, t=0, i=0, r=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = i,
        this._w = r
    }
    static slerpFlat(e, t, i, r, s, o, a) {
        let l = i[r + 0]
          , c = i[r + 1]
          , d = i[r + 2]
          , h = i[r + 3];
        const p = s[o + 0]
          , m = s[o + 1]
          , y = s[o + 2]
          , v = s[o + 3];
        if (a === 0) {
            e[t + 0] = l,
            e[t + 1] = c,
            e[t + 2] = d,
            e[t + 3] = h;
            return
        }
        if (a === 1) {
            e[t + 0] = p,
            e[t + 1] = m,
            e[t + 2] = y,
            e[t + 3] = v;
            return
        }
        if (h !== v || l !== p || c !== m || d !== y) {
            let _ = 1 - a;
            const x = l * p + c * m + d * y + h * v
              , A = x >= 0 ? 1 : -1
              , M = 1 - x * x;
            if (M > Number.EPSILON) {
                const T = Math.sqrt(M)
                  , P = Math.atan2(T, x * A);
                _ = Math.sin(_ * P) / T,
                a = Math.sin(a * P) / T
            }
            const S = a * A;
            if (l = l * _ + p * S,
            c = c * _ + m * S,
            d = d * _ + y * S,
            h = h * _ + v * S,
            _ === 1 - a) {
                const T = 1 / Math.sqrt(l * l + c * c + d * d + h * h);
                l *= T,
                c *= T,
                d *= T,
                h *= T
            }
        }
        e[t] = l,
        e[t + 1] = c,
        e[t + 2] = d,
        e[t + 3] = h
    }
    static multiplyQuaternionsFlat(e, t, i, r, s, o) {
        const a = i[r]
          , l = i[r + 1]
          , c = i[r + 2]
          , d = i[r + 3]
          , h = s[o]
          , p = s[o + 1]
          , m = s[o + 2]
          , y = s[o + 3];
        return e[t] = a * y + d * h + l * m - c * p,
        e[t + 1] = l * y + d * p + c * h - a * m,
        e[t + 2] = c * y + d * m + a * p - l * h,
        e[t + 3] = d * y - a * h - l * p - c * m,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, i, r) {
        return this._x = e,
        this._y = t,
        this._z = i,
        this._w = r,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, t) {
        const i = e._x
          , r = e._y
          , s = e._z
          , o = e._order
          , a = Math.cos
          , l = Math.sin
          , c = a(i / 2)
          , d = a(r / 2)
          , h = a(s / 2)
          , p = l(i / 2)
          , m = l(r / 2)
          , y = l(s / 2);
        switch (o) {
        case "XYZ":
            this._x = p * d * h + c * m * y,
            this._y = c * m * h - p * d * y,
            this._z = c * d * y + p * m * h,
            this._w = c * d * h - p * m * y;
            break;
        case "YXZ":
            this._x = p * d * h + c * m * y,
            this._y = c * m * h - p * d * y,
            this._z = c * d * y - p * m * h,
            this._w = c * d * h + p * m * y;
            break;
        case "ZXY":
            this._x = p * d * h - c * m * y,
            this._y = c * m * h + p * d * y,
            this._z = c * d * y + p * m * h,
            this._w = c * d * h - p * m * y;
            break;
        case "ZYX":
            this._x = p * d * h - c * m * y,
            this._y = c * m * h + p * d * y,
            this._z = c * d * y - p * m * h,
            this._w = c * d * h + p * m * y;
            break;
        case "YZX":
            this._x = p * d * h + c * m * y,
            this._y = c * m * h + p * d * y,
            this._z = c * d * y - p * m * h,
            this._w = c * d * h - p * m * y;
            break;
        case "XZY":
            this._x = p * d * h - c * m * y,
            this._y = c * m * h - p * d * y,
            this._z = c * d * y + p * m * h,
            this._w = c * d * h + p * m * y;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return t !== !1 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, t) {
        const i = t / 2
          , r = Math.sin(i);
        return this._x = e.x * r,
        this._y = e.y * r,
        this._z = e.z * r,
        this._w = Math.cos(i),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const t = e.elements
          , i = t[0]
          , r = t[4]
          , s = t[8]
          , o = t[1]
          , a = t[5]
          , l = t[9]
          , c = t[2]
          , d = t[6]
          , h = t[10]
          , p = i + a + h;
        if (p > 0) {
            const m = .5 / Math.sqrt(p + 1);
            this._w = .25 / m,
            this._x = (d - l) * m,
            this._y = (s - c) * m,
            this._z = (o - r) * m
        } else if (i > a && i > h) {
            const m = 2 * Math.sqrt(1 + i - a - h);
            this._w = (d - l) / m,
            this._x = .25 * m,
            this._y = (r + o) / m,
            this._z = (s + c) / m
        } else if (a > h) {
            const m = 2 * Math.sqrt(1 + a - i - h);
            this._w = (s - c) / m,
            this._x = (r + o) / m,
            this._y = .25 * m,
            this._z = (l + d) / m
        } else {
            const m = 2 * Math.sqrt(1 + h - i - a);
            this._w = (o - r) / m,
            this._x = (s + c) / m,
            this._y = (l + d) / m,
            this._z = .25 * m
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, t) {
        let i = e.dot(t) + 1;
        return i < Number.EPSILON ? (i = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = i) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = i)) : (this._x = e.y * t.z - e.z * t.y,
        this._y = e.z * t.x - e.x * t.z,
        this._z = e.x * t.y - e.y * t.x,
        this._w = i),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(vn(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const i = this.angleTo(e);
        if (i === 0)
            return this;
        const r = Math.min(1, t / i);
        return this.slerp(e, r),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const i = e._x
          , r = e._y
          , s = e._z
          , o = e._w
          , a = t._x
          , l = t._y
          , c = t._z
          , d = t._w;
        return this._x = i * d + o * a + r * c - s * l,
        this._y = r * d + o * l + s * a - i * c,
        this._z = s * d + o * c + i * l - r * a,
        this._w = o * d - i * a - r * l - s * c,
        this._onChangeCallback(),
        this
    }
    slerp(e, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(e);
        const i = this._x
          , r = this._y
          , s = this._z
          , o = this._w;
        let a = o * e._w + i * e._x + r * e._y + s * e._z;
        if (a < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        a = -a) : this.copy(e),
        a >= 1)
            return this._w = o,
            this._x = i,
            this._y = r,
            this._z = s,
            this;
        const l = 1 - a * a;
        if (l <= Number.EPSILON) {
            const m = 1 - t;
            return this._w = m * o + t * this._w,
            this._x = m * i + t * this._x,
            this._y = m * r + t * this._y,
            this._z = m * s + t * this._z,
            this.normalize(),
            this._onChangeCallback(),
            this
        }
        const c = Math.sqrt(l)
          , d = Math.atan2(c, a)
          , h = Math.sin((1 - t) * d) / c
          , p = Math.sin(t * d) / c;
        return this._w = o * h + this._w * p,
        this._x = i * h + this._x * p,
        this._y = r * h + this._y * p,
        this._z = s * h + this._z * p,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, t, i) {
        return this.copy(e).slerp(t, i)
    }
    random() {
        const e = Math.random()
          , t = Math.sqrt(1 - e)
          , i = Math.sqrt(e)
          , r = 2 * Math.PI * Math.random()
          , s = 2 * Math.PI * Math.random();
        return this.set(t * Math.cos(r), i * Math.sin(s), i * Math.cos(s), t * Math.sin(r))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0) {
        return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class D {
    constructor(e=0, t=0, i=0) {
        D.prototype.isVector3 = !0,
        this.x = e,
        this.y = t,
        this.z = i
    }
    set(e, t, i) {
        return i === void 0 && (i = this.z),
        this.x = e,
        this.y = t,
        this.z = i,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(zC.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(zC.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[3] * i + s[6] * r,
        this.y = s[1] * t + s[4] * i + s[7] * r,
        this.z = s[2] * t + s[5] * i + s[8] * r,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements
          , o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
        return this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o,
        this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o,
        this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o,
        this
    }
    applyQuaternion(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.x
          , o = e.y
          , a = e.z
          , l = e.w
          , c = l * t + o * r - a * i
          , d = l * i + a * t - s * r
          , h = l * r + s * i - o * t
          , p = -s * t - o * i - a * r;
        return this.x = c * l + p * -s + d * -a - h * -o,
        this.y = d * l + p * -o + h * -s - c * -a,
        this.z = h * l + p * -a + c * -o - d * -s,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[4] * i + s[8] * r,
        this.y = s[1] * t + s[5] * i + s[9] * r,
        this.z = s[2] * t + s[6] * i + s[10] * r,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this.z = e.z + (t.z - e.z) * i,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z
          , o = t.x
          , a = t.y
          , l = t.z;
        return this.x = r * l - s * a,
        this.y = s * o - i * l,
        this.z = i * a - r * o,
        this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0)
            return this.set(0, 0, 0);
        const i = e.dot(this) / t;
        return this.copy(e).multiplyScalar(i)
    }
    projectOnPlane(e) {
        return tv.copy(this).projectOnVector(e),
        this.sub(tv)
    }
    reflect(e) {
        return this.sub(tv.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(vn(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , i = this.y - e.y
          , r = this.z - e.z;
        return t * t + i * i + r * r
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, i) {
        const r = Math.sin(t) * e;
        return this.x = r * Math.sin(i),
        this.y = Math.cos(t) * e,
        this.z = r * Math.cos(i),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, i) {
        return this.x = e * Math.sin(t),
        this.y = i,
        this.z = e * Math.cos(t),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length()
          , i = this.setFromMatrixColumn(e, 1).length()
          , r = this.setFromMatrixColumn(e, 2).length();
        return this.x = t,
        this.y = i,
        this.z = r,
        this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = (Math.random() - .5) * 2
          , t = Math.random() * Math.PI * 2
          , i = Math.sqrt(1 - e ** 2);
        return this.x = i * Math.cos(t),
        this.y = i * Math.sin(t),
        this.z = e,
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const tv = new D
  , zC = new jn;
class ta {
    constructor(e=new D(1 / 0,1 / 0,1 / 0), t=new D(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromArray(e) {
        let t = 1 / 0
          , i = 1 / 0
          , r = 1 / 0
          , s = -1 / 0
          , o = -1 / 0
          , a = -1 / 0;
        for (let l = 0, c = e.length; l < c; l += 3) {
            const d = e[l]
              , h = e[l + 1]
              , p = e[l + 2];
            d < t && (t = d),
            h < i && (i = h),
            p < r && (r = p),
            d > s && (s = d),
            h > o && (o = h),
            p > a && (a = p)
        }
        return this.min.set(t, i, r),
        this.max.set(s, o, a),
        this
    }
    setFromBufferAttribute(e) {
        let t = 1 / 0
          , i = 1 / 0
          , r = 1 / 0
          , s = -1 / 0
          , o = -1 / 0
          , a = -1 / 0;
        for (let l = 0, c = e.count; l < c; l++) {
            const d = e.getX(l)
              , h = e.getY(l)
              , p = e.getZ(l);
            d < t && (t = d),
            h < i && (i = h),
            p < r && (r = p),
            d > s && (s = d),
            h > o && (o = h),
            p > a && (a = p)
        }
        return this.min.set(t, i, r),
        this.max.set(s, o, a),
        this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const i = ga.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(i),
        this.max.copy(e).add(i),
        this
    }
    setFromObject(e, t=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, t=!1) {
        e.updateWorldMatrix(!1, !1);
        const i = e.geometry;
        if (i !== void 0)
            if (t && i.attributes != null && i.attributes.position !== void 0) {
                const s = i.attributes.position;
                for (let o = 0, a = s.count; o < a; o++)
                    ga.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld),
                    this.expandByPoint(ga)
            } else
                i.boundingBox === null && i.computeBoundingBox(),
                nv.copy(i.boundingBox),
                nv.applyMatrix4(e.matrixWorld),
                this.union(nv);
        const r = e.children;
        for (let s = 0, o = r.length; s < o; s++)
            this.expandByObject(r[s], t);
        return this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, ga),
        ga.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, i;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
        i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
        i = e.normal.x * this.min.x),
        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
        i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
        i += e.normal.y * this.min.y),
        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
        i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
        i += e.normal.z * this.min.z),
        t <= -e.constant && i >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(Dc),
        gp.subVectors(this.max, Dc),
        Dl.subVectors(e.a, Dc),
        Fl.subVectors(e.b, Dc),
        kl.subVectors(e.c, Dc),
        lo.subVectors(Fl, Dl),
        uo.subVectors(kl, Fl),
        ya.subVectors(Dl, kl);
        let t = [0, -lo.z, lo.y, 0, -uo.z, uo.y, 0, -ya.z, ya.y, lo.z, 0, -lo.x, uo.z, 0, -uo.x, ya.z, 0, -ya.x, -lo.y, lo.x, 0, -uo.y, uo.x, 0, -ya.y, ya.x, 0];
        return !iv(t, Dl, Fl, kl, gp) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !iv(t, Dl, Fl, kl, gp)) ? !1 : (yp.crossVectors(lo, uo),
        t = [yp.x, yp.y, yp.z],
        iv(t, Dl, Fl, kl, gp))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return ga.copy(e).clamp(this.min, this.max).sub(e).length()
    }
    getBoundingSphere(e) {
        return this.getCenter(e.center),
        e.radius = this.getSize(ga).length() * .5,
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (As[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        As[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        As[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        As[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        As[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        As[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        As[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        As[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(As),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const As = [new D, new D, new D, new D, new D, new D, new D, new D]
  , ga = new D
  , nv = new ta
  , Dl = new D
  , Fl = new D
  , kl = new D
  , lo = new D
  , uo = new D
  , ya = new D
  , Dc = new D
  , gp = new D
  , yp = new D
  , va = new D;
function iv(n, e, t, i, r) {
    for (let s = 0, o = n.length - 3; s <= o; s += 3) {
        va.fromArray(n, s);
        const a = r.x * Math.abs(va.x) + r.y * Math.abs(va.y) + r.z * Math.abs(va.z)
          , l = e.dot(va)
          , c = t.dot(va)
          , d = i.dot(va);
        if (Math.max(-Math.max(l, c, d), Math.min(l, c, d)) > a)
            return !1
    }
    return !0
}
const B4 = new ta
  , Fc = new D
  , rv = new D;
class na {
    constructor(e=new D, t=-1) {
        this.center = e,
        this.radius = t
    }
    set(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    }
    setFromPoints(e, t) {
        const i = this.center;
        t !== void 0 ? i.copy(t) : B4.setFromPoints(e).getCenter(i);
        let r = 0;
        for (let s = 0, o = e.length; s < o; s++)
            r = Math.max(r, i.distanceToSquared(e[s]));
        return this.radius = Math.sqrt(r),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const i = this.center.distanceToSquared(e);
        return t.copy(e),
        i > this.radius * this.radius && (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
        t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        if (this.isEmpty())
            return this.center.copy(e),
            this.radius = 0,
            this;
        Fc.subVectors(e, this.center);
        const t = Fc.lengthSq();
        if (t > this.radius * this.radius) {
            const i = Math.sqrt(t)
              , r = (i - this.radius) * .5;
            this.center.addScaledVector(Fc, r / i),
            this.radius += r
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (rv.subVectors(e.center, this.center).setLength(e.radius),
        this.expandByPoint(Fc.copy(e.center).add(rv)),
        this.expandByPoint(Fc.copy(e.center).sub(rv))),
        this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Ms = new D
  , sv = new D
  , vp = new D
  , co = new D
  , ov = new D
  , xp = new D
  , av = new D;
class Ed {
    constructor(e=new D, t=new D(0,0,-1)) {
        this.origin = e,
        this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, t) {
        return t.copy(this.direction).multiplyScalar(e).add(this.origin)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, Ms)),
        this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const i = t.dot(this.direction);
        return i < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(i).add(this.origin)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = Ms.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (Ms.copy(this.direction).multiplyScalar(t).add(this.origin),
        Ms.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, i, r) {
        sv.copy(e).add(t).multiplyScalar(.5),
        vp.copy(t).sub(e).normalize(),
        co.copy(this.origin).sub(sv);
        const s = e.distanceTo(t) * .5
          , o = -this.direction.dot(vp)
          , a = co.dot(this.direction)
          , l = -co.dot(vp)
          , c = co.lengthSq()
          , d = Math.abs(1 - o * o);
        let h, p, m, y;
        if (d > 0)
            if (h = o * l - a,
            p = o * a - l,
            y = s * d,
            h >= 0)
                if (p >= -y)
                    if (p <= y) {
                        const v = 1 / d;
                        h *= v,
                        p *= v,
                        m = h * (h + o * p + 2 * a) + p * (o * h + p + 2 * l) + c
                    } else
                        p = s,
                        h = Math.max(0, -(o * p + a)),
                        m = -h * h + p * (p + 2 * l) + c;
                else
                    p = -s,
                    h = Math.max(0, -(o * p + a)),
                    m = -h * h + p * (p + 2 * l) + c;
            else
                p <= -y ? (h = Math.max(0, -(-o * s + a)),
                p = h > 0 ? -s : Math.min(Math.max(-s, -l), s),
                m = -h * h + p * (p + 2 * l) + c) : p <= y ? (h = 0,
                p = Math.min(Math.max(-s, -l), s),
                m = p * (p + 2 * l) + c) : (h = Math.max(0, -(o * s + a)),
                p = h > 0 ? s : Math.min(Math.max(-s, -l), s),
                m = -h * h + p * (p + 2 * l) + c);
        else
            p = o > 0 ? -s : s,
            h = Math.max(0, -(o * p + a)),
            m = -h * h + p * (p + 2 * l) + c;
        return i && i.copy(this.direction).multiplyScalar(h).add(this.origin),
        r && r.copy(vp).multiplyScalar(p).add(sv),
        m
    }
    intersectSphere(e, t) {
        Ms.subVectors(e.center, this.origin);
        const i = Ms.dot(this.direction)
          , r = Ms.dot(Ms) - i * i
          , s = e.radius * e.radius;
        if (r > s)
            return null;
        const o = Math.sqrt(s - r)
          , a = i - o
          , l = i + o;
        return a < 0 && l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const i = -(this.origin.dot(e.normal) + e.constant) / t;
        return i >= 0 ? i : null
    }
    intersectPlane(e, t) {
        const i = this.distanceToPlane(e);
        return i === null ? null : this.at(i, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let i, r, s, o, a, l;
        const c = 1 / this.direction.x
          , d = 1 / this.direction.y
          , h = 1 / this.direction.z
          , p = this.origin;
        return c >= 0 ? (i = (e.min.x - p.x) * c,
        r = (e.max.x - p.x) * c) : (i = (e.max.x - p.x) * c,
        r = (e.min.x - p.x) * c),
        d >= 0 ? (s = (e.min.y - p.y) * d,
        o = (e.max.y - p.y) * d) : (s = (e.max.y - p.y) * d,
        o = (e.min.y - p.y) * d),
        i > o || s > r || ((s > i || isNaN(i)) && (i = s),
        (o < r || isNaN(r)) && (r = o),
        h >= 0 ? (a = (e.min.z - p.z) * h,
        l = (e.max.z - p.z) * h) : (a = (e.max.z - p.z) * h,
        l = (e.min.z - p.z) * h),
        i > l || a > r) || ((a > i || i !== i) && (i = a),
        (l < r || r !== r) && (r = l),
        r < 0) ? null : this.at(i >= 0 ? i : r, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, Ms) !== null
    }
    intersectTriangle(e, t, i, r, s) {
        ov.subVectors(t, e),
        xp.subVectors(i, e),
        av.crossVectors(ov, xp);
        let o = this.direction.dot(av), a;
        if (o > 0) {
            if (r)
                return null;
            a = 1
        } else if (o < 0)
            a = -1,
            o = -o;
        else
            return null;
        co.subVectors(this.origin, e);
        const l = a * this.direction.dot(xp.crossVectors(co, xp));
        if (l < 0)
            return null;
        const c = a * this.direction.dot(ov.cross(co));
        if (c < 0 || l + c > o)
            return null;
        const d = -a * co.dot(av);
        return d < 0 ? null : this.at(d / o, s)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class rt {
    constructor() {
        rt.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    }
    set(e, t, i, r, s, o, a, l, c, d, h, p, m, y, v, _) {
        const x = this.elements;
        return x[0] = e,
        x[4] = t,
        x[8] = i,
        x[12] = r,
        x[1] = s,
        x[5] = o,
        x[9] = a,
        x[13] = l,
        x[2] = c,
        x[6] = d,
        x[10] = h,
        x[14] = p,
        x[3] = m,
        x[7] = y,
        x[11] = v,
        x[15] = _,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new rt().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements
          , i = e.elements;
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        t[9] = i[9],
        t[10] = i[10],
        t[11] = i[11],
        t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        t[15] = i[15],
        this
    }
    copyPosition(e) {
        const t = this.elements
          , i = e.elements;
        return t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        i.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, t, i) {
        return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const t = this.elements
          , i = e.elements
          , r = 1 / Nl.setFromMatrixColumn(e, 0).length()
          , s = 1 / Nl.setFromMatrixColumn(e, 1).length()
          , o = 1 / Nl.setFromMatrixColumn(e, 2).length();
        return t[0] = i[0] * r,
        t[1] = i[1] * r,
        t[2] = i[2] * r,
        t[3] = 0,
        t[4] = i[4] * s,
        t[5] = i[5] * s,
        t[6] = i[6] * s,
        t[7] = 0,
        t[8] = i[8] * o,
        t[9] = i[9] * o,
        t[10] = i[10] * o,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const t = this.elements
          , i = e.x
          , r = e.y
          , s = e.z
          , o = Math.cos(i)
          , a = Math.sin(i)
          , l = Math.cos(r)
          , c = Math.sin(r)
          , d = Math.cos(s)
          , h = Math.sin(s);
        if (e.order === "XYZ") {
            const p = o * d
              , m = o * h
              , y = a * d
              , v = a * h;
            t[0] = l * d,
            t[4] = -l * h,
            t[8] = c,
            t[1] = m + y * c,
            t[5] = p - v * c,
            t[9] = -a * l,
            t[2] = v - p * c,
            t[6] = y + m * c,
            t[10] = o * l
        } else if (e.order === "YXZ") {
            const p = l * d
              , m = l * h
              , y = c * d
              , v = c * h;
            t[0] = p + v * a,
            t[4] = y * a - m,
            t[8] = o * c,
            t[1] = o * h,
            t[5] = o * d,
            t[9] = -a,
            t[2] = m * a - y,
            t[6] = v + p * a,
            t[10] = o * l
        } else if (e.order === "ZXY") {
            const p = l * d
              , m = l * h
              , y = c * d
              , v = c * h;
            t[0] = p - v * a,
            t[4] = -o * h,
            t[8] = y + m * a,
            t[1] = m + y * a,
            t[5] = o * d,
            t[9] = v - p * a,
            t[2] = -o * c,
            t[6] = a,
            t[10] = o * l
        } else if (e.order === "ZYX") {
            const p = o * d
              , m = o * h
              , y = a * d
              , v = a * h;
            t[0] = l * d,
            t[4] = y * c - m,
            t[8] = p * c + v,
            t[1] = l * h,
            t[5] = v * c + p,
            t[9] = m * c - y,
            t[2] = -c,
            t[6] = a * l,
            t[10] = o * l
        } else if (e.order === "YZX") {
            const p = o * l
              , m = o * c
              , y = a * l
              , v = a * c;
            t[0] = l * d,
            t[4] = v - p * h,
            t[8] = y * h + m,
            t[1] = h,
            t[5] = o * d,
            t[9] = -a * d,
            t[2] = -c * d,
            t[6] = m * h + y,
            t[10] = p - v * h
        } else if (e.order === "XZY") {
            const p = o * l
              , m = o * c
              , y = a * l
              , v = a * c;
            t[0] = l * d,
            t[4] = -h,
            t[8] = c * d,
            t[1] = p * h + v,
            t[5] = o * d,
            t[9] = m * h - y,
            t[2] = y * h - m,
            t[6] = a * d,
            t[10] = v * h + p
        }
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(R4, e, L4)
    }
    lookAt(e, t, i) {
        const r = this.elements;
        return ki.subVectors(e, t),
        ki.lengthSq() === 0 && (ki.z = 1),
        ki.normalize(),
        fo.crossVectors(i, ki),
        fo.lengthSq() === 0 && (Math.abs(i.z) === 1 ? ki.x += 1e-4 : ki.z += 1e-4,
        ki.normalize(),
        fo.crossVectors(i, ki)),
        fo.normalize(),
        _p.crossVectors(ki, fo),
        r[0] = fo.x,
        r[4] = _p.x,
        r[8] = ki.x,
        r[1] = fo.y,
        r[5] = _p.y,
        r[9] = ki.y,
        r[2] = fo.z,
        r[6] = _p.z,
        r[10] = ki.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements
          , r = t.elements
          , s = this.elements
          , o = i[0]
          , a = i[4]
          , l = i[8]
          , c = i[12]
          , d = i[1]
          , h = i[5]
          , p = i[9]
          , m = i[13]
          , y = i[2]
          , v = i[6]
          , _ = i[10]
          , x = i[14]
          , A = i[3]
          , M = i[7]
          , S = i[11]
          , T = i[15]
          , P = r[0]
          , R = r[4]
          , E = r[8]
          , B = r[12]
          , L = r[1]
          , z = r[5]
          , Z = r[9]
          , J = r[13]
          , G = r[2]
          , X = r[6]
          , ee = r[10]
          , ie = r[14]
          , F = r[3]
          , V = r[7]
          , j = r[11]
          , re = r[15];
        return s[0] = o * P + a * L + l * G + c * F,
        s[4] = o * R + a * z + l * X + c * V,
        s[8] = o * E + a * Z + l * ee + c * j,
        s[12] = o * B + a * J + l * ie + c * re,
        s[1] = d * P + h * L + p * G + m * F,
        s[5] = d * R + h * z + p * X + m * V,
        s[9] = d * E + h * Z + p * ee + m * j,
        s[13] = d * B + h * J + p * ie + m * re,
        s[2] = y * P + v * L + _ * G + x * F,
        s[6] = y * R + v * z + _ * X + x * V,
        s[10] = y * E + v * Z + _ * ee + x * j,
        s[14] = y * B + v * J + _ * ie + x * re,
        s[3] = A * P + M * L + S * G + T * F,
        s[7] = A * R + M * z + S * X + T * V,
        s[11] = A * E + M * Z + S * ee + T * j,
        s[15] = A * B + M * J + S * ie + T * re,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , i = e[4]
          , r = e[8]
          , s = e[12]
          , o = e[1]
          , a = e[5]
          , l = e[9]
          , c = e[13]
          , d = e[2]
          , h = e[6]
          , p = e[10]
          , m = e[14]
          , y = e[3]
          , v = e[7]
          , _ = e[11]
          , x = e[15];
        return y * (+s * l * h - r * c * h - s * a * p + i * c * p + r * a * m - i * l * m) + v * (+t * l * m - t * c * p + s * o * p - r * o * m + r * c * d - s * l * d) + _ * (+t * c * h - t * a * m - s * o * h + i * o * m + s * a * d - i * c * d) + x * (-r * a * d - t * l * h + t * a * p + r * o * h - i * o * p + i * l * d)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    }
    setPosition(e, t, i) {
        const r = this.elements;
        return e.isVector3 ? (r[12] = e.x,
        r[13] = e.y,
        r[14] = e.z) : (r[12] = e,
        r[13] = t,
        r[14] = i),
        this
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , d = e[8]
          , h = e[9]
          , p = e[10]
          , m = e[11]
          , y = e[12]
          , v = e[13]
          , _ = e[14]
          , x = e[15]
          , A = h * _ * c - v * p * c + v * l * m - a * _ * m - h * l * x + a * p * x
          , M = y * p * c - d * _ * c - y * l * m + o * _ * m + d * l * x - o * p * x
          , S = d * v * c - y * h * c + y * a * m - o * v * m - d * a * x + o * h * x
          , T = y * h * l - d * v * l - y * a * p + o * v * p + d * a * _ - o * h * _
          , P = t * A + i * M + r * S + s * T;
        if (P === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const R = 1 / P;
        return e[0] = A * R,
        e[1] = (v * p * s - h * _ * s - v * r * m + i * _ * m + h * r * x - i * p * x) * R,
        e[2] = (a * _ * s - v * l * s + v * r * c - i * _ * c - a * r * x + i * l * x) * R,
        e[3] = (h * l * s - a * p * s - h * r * c + i * p * c + a * r * m - i * l * m) * R,
        e[4] = M * R,
        e[5] = (d * _ * s - y * p * s + y * r * m - t * _ * m - d * r * x + t * p * x) * R,
        e[6] = (y * l * s - o * _ * s - y * r * c + t * _ * c + o * r * x - t * l * x) * R,
        e[7] = (o * p * s - d * l * s + d * r * c - t * p * c - o * r * m + t * l * m) * R,
        e[8] = S * R,
        e[9] = (y * h * s - d * v * s - y * i * m + t * v * m + d * i * x - t * h * x) * R,
        e[10] = (o * v * s - y * a * s + y * i * c - t * v * c - o * i * x + t * a * x) * R,
        e[11] = (d * a * s - o * h * s - d * i * c + t * h * c + o * i * m - t * a * m) * R,
        e[12] = T * R,
        e[13] = (d * v * r - y * h * r + y * i * p - t * v * p - d * i * _ + t * h * _) * R,
        e[14] = (y * a * r - o * v * r - y * i * l + t * v * l + o * i * _ - t * a * _) * R,
        e[15] = (o * h * r - d * a * r + d * i * l - t * h * l - o * i * p + t * a * p) * R,
        this
    }
    scale(e) {
        const t = this.elements
          , i = e.x
          , r = e.y
          , s = e.z;
        return t[0] *= i,
        t[4] *= r,
        t[8] *= s,
        t[1] *= i,
        t[5] *= r,
        t[9] *= s,
        t[2] *= i,
        t[6] *= r,
        t[10] *= s,
        t[3] *= i,
        t[7] *= r,
        t[11] *= s,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, i, r))
    }
    makeTranslation(e, t, i) {
        return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, t) {
        const i = Math.cos(t)
          , r = Math.sin(t)
          , s = 1 - i
          , o = e.x
          , a = e.y
          , l = e.z
          , c = s * o
          , d = s * a;
        return this.set(c * o + i, c * a - r * l, c * l + r * a, 0, c * a + r * l, d * a + i, d * l - r * o, 0, c * l - r * a, d * l + r * o, s * l * l + i, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, t, i) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, t, i, r, s, o) {
        return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, t, i) {
        const r = this.elements
          , s = t._x
          , o = t._y
          , a = t._z
          , l = t._w
          , c = s + s
          , d = o + o
          , h = a + a
          , p = s * c
          , m = s * d
          , y = s * h
          , v = o * d
          , _ = o * h
          , x = a * h
          , A = l * c
          , M = l * d
          , S = l * h
          , T = i.x
          , P = i.y
          , R = i.z;
        return r[0] = (1 - (v + x)) * T,
        r[1] = (m + S) * T,
        r[2] = (y - M) * T,
        r[3] = 0,
        r[4] = (m - S) * P,
        r[5] = (1 - (p + x)) * P,
        r[6] = (_ + A) * P,
        r[7] = 0,
        r[8] = (y + M) * R,
        r[9] = (_ - A) * R,
        r[10] = (1 - (p + v)) * R,
        r[11] = 0,
        r[12] = e.x,
        r[13] = e.y,
        r[14] = e.z,
        r[15] = 1,
        this
    }
    decompose(e, t, i) {
        const r = this.elements;
        let s = Nl.set(r[0], r[1], r[2]).length();
        const o = Nl.set(r[4], r[5], r[6]).length()
          , a = Nl.set(r[8], r[9], r[10]).length();
        this.determinant() < 0 && (s = -s),
        e.x = r[12],
        e.y = r[13],
        e.z = r[14],
        Er.copy(this);
        const c = 1 / s
          , d = 1 / o
          , h = 1 / a;
        return Er.elements[0] *= c,
        Er.elements[1] *= c,
        Er.elements[2] *= c,
        Er.elements[4] *= d,
        Er.elements[5] *= d,
        Er.elements[6] *= d,
        Er.elements[8] *= h,
        Er.elements[9] *= h,
        Er.elements[10] *= h,
        t.setFromRotationMatrix(Er),
        i.x = s,
        i.y = o,
        i.z = a,
        this
    }
    makePerspective(e, t, i, r, s, o) {
        const a = this.elements
          , l = 2 * s / (t - e)
          , c = 2 * s / (i - r)
          , d = (t + e) / (t - e)
          , h = (i + r) / (i - r)
          , p = -(o + s) / (o - s)
          , m = -2 * o * s / (o - s);
        return a[0] = l,
        a[4] = 0,
        a[8] = d,
        a[12] = 0,
        a[1] = 0,
        a[5] = c,
        a[9] = h,
        a[13] = 0,
        a[2] = 0,
        a[6] = 0,
        a[10] = p,
        a[14] = m,
        a[3] = 0,
        a[7] = 0,
        a[11] = -1,
        a[15] = 0,
        this
    }
    makeOrthographic(e, t, i, r, s, o) {
        const a = this.elements
          , l = 1 / (t - e)
          , c = 1 / (i - r)
          , d = 1 / (o - s)
          , h = (t + e) * l
          , p = (i + r) * c
          , m = (o + s) * d;
        return a[0] = 2 * l,
        a[4] = 0,
        a[8] = 0,
        a[12] = -h,
        a[1] = 0,
        a[5] = 2 * c,
        a[9] = 0,
        a[13] = -p,
        a[2] = 0,
        a[6] = 0,
        a[10] = -2 * d,
        a[14] = -m,
        a[3] = 0,
        a[7] = 0,
        a[11] = 0,
        a[15] = 1,
        this
    }
    equals(e) {
        const t = this.elements
          , i = e.elements;
        for (let r = 0; r < 16; r++)
            if (t[r] !== i[r])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let i = 0; i < 16; i++)
            this.elements[i] = e[i + t];
        return this
    }
    toArray(e=[], t=0) {
        const i = this.elements;
        return e[t] = i[0],
        e[t + 1] = i[1],
        e[t + 2] = i[2],
        e[t + 3] = i[3],
        e[t + 4] = i[4],
        e[t + 5] = i[5],
        e[t + 6] = i[6],
        e[t + 7] = i[7],
        e[t + 8] = i[8],
        e[t + 9] = i[9],
        e[t + 10] = i[10],
        e[t + 11] = i[11],
        e[t + 12] = i[12],
        e[t + 13] = i[13],
        e[t + 14] = i[14],
        e[t + 15] = i[15],
        e
    }
}
const Nl = new D
  , Er = new rt
  , R4 = new D(0,0,0)
  , L4 = new D(1,1,1)
  , fo = new D
  , _p = new D
  , ki = new D
  , GC = new rt
  , HC = new jn;
class Td {
    constructor(e=0, t=0, i=0, r=Td.DEFAULT_ORDER) {
        this.isEuler = !0,
        this._x = e,
        this._y = t,
        this._z = i,
        this._order = r
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, i, r=this._order) {
        return this._x = e,
        this._y = t,
        this._z = i,
        this._order = r,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, t=this._order, i=!0) {
        const r = e.elements
          , s = r[0]
          , o = r[4]
          , a = r[8]
          , l = r[1]
          , c = r[5]
          , d = r[9]
          , h = r[2]
          , p = r[6]
          , m = r[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(vn(a, -1, 1)),
            Math.abs(a) < .9999999 ? (this._x = Math.atan2(-d, m),
            this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(p, c),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-vn(d, -1, 1)),
            Math.abs(d) < .9999999 ? (this._y = Math.atan2(a, m),
            this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, s),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(vn(p, -1, 1)),
            Math.abs(p) < .9999999 ? (this._y = Math.atan2(-h, m),
            this._z = Math.atan2(-o, c)) : (this._y = 0,
            this._z = Math.atan2(l, s));
            break;
        case "ZYX":
            this._y = Math.asin(-vn(h, -1, 1)),
            Math.abs(h) < .9999999 ? (this._x = Math.atan2(p, m),
            this._z = Math.atan2(l, s)) : (this._x = 0,
            this._z = Math.atan2(-o, c));
            break;
        case "YZX":
            this._z = Math.asin(vn(l, -1, 1)),
            Math.abs(l) < .9999999 ? (this._x = Math.atan2(-d, c),
            this._y = Math.atan2(-h, s)) : (this._x = 0,
            this._y = Math.atan2(a, m));
            break;
        case "XZY":
            this._z = Math.asin(-vn(o, -1, 1)),
            Math.abs(o) < .9999999 ? (this._x = Math.atan2(p, c),
            this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-d, m),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t,
        i === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, t, i) {
        return GC.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(GC, t, i)
    }
    setFromVector3(e, t=this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return HC.setFromEuler(this),
        this.setFromQuaternion(HC, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
Td.DEFAULT_ORDER = "XYZ";
class $a {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let I4 = 0;
const VC = new D
  , Ol = new jn
  , ws = new rt
  , Ap = new D
  , kc = new D
  , D4 = new D
  , F4 = new jn
  , WC = new D(1,0,0)
  , jC = new D(0,1,0)
  , JC = new D(0,0,1)
  , k4 = {
    type: "added"
}
  , XC = {
    type: "removed"
};
class Rt extends cs {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: I4++
        }),
        this.uuid = Vi(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = Rt.DEFAULT_UP.clone();
        const e = new D
          , t = new Td
          , i = new jn
          , r = new D(1,1,1);
        function s() {
            i.setFromEuler(t, !1)
        }
        function o() {
            t.setFromQuaternion(i, void 0, !1)
        }
        t._onChange(s),
        i._onChange(o),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            modelViewMatrix: {
                value: new rt
            },
            normalMatrix: {
                value: new hi
            }
        }),
        this.matrix = new rt,
        this.matrixWorld = new rt,
        this.matrixAutoUpdate = Rt.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.matrixWorldAutoUpdate = Rt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.layers = new $a,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return Ol.setFromAxisAngle(e, t),
        this.quaternion.multiply(Ol),
        this
    }
    rotateOnWorldAxis(e, t) {
        return Ol.setFromAxisAngle(e, t),
        this.quaternion.premultiply(Ol),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(WC, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(jC, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(JC, e)
    }
    translateOnAxis(e, t) {
        return VC.copy(e).applyQuaternion(this.quaternion),
        this.position.add(VC.multiplyScalar(t)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(WC, e)
    }
    translateY(e) {
        return this.translateOnAxis(jC, e)
    }
    translateZ(e) {
        return this.translateOnAxis(JC, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(ws.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, i) {
        e.isVector3 ? Ap.copy(e) : Ap.set(e, t, i);
        const r = this.parent;
        this.updateWorldMatrix(!0, !1),
        kc.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? ws.lookAt(kc, Ap, this.up) : ws.lookAt(Ap, kc, this.up),
        this.quaternion.setFromRotationMatrix(ws),
        r && (ws.extractRotation(r.matrixWorld),
        Ol.setFromRotationMatrix(ws),
        this.quaternion.premultiply(Ol.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
                this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(k4)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++)
                this.remove(arguments[i]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null,
        this.children.splice(t, 1),
        e.dispatchEvent(XC)),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        for (let e = 0; e < this.children.length; e++) {
            const t = this.children[e];
            t.parent = null,
            t.dispatchEvent(XC)
        }
        return this.children.length = 0,
        this
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        ws.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        ws.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(ws),
        this.add(e),
        e.updateWorldMatrix(!1, !0),
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t)
            return this;
        for (let i = 0, r = this.children.length; i < r; i++) {
            const o = this.children[i].getObjectByProperty(e, t);
            if (o !== void 0)
                return o
        }
    }
    getObjectsByProperty(e, t) {
        let i = [];
        this[e] === t && i.push(this);
        for (let r = 0, s = this.children.length; r < s; r++) {
            const o = this.children[r].getObjectsByProperty(e, t);
            o.length > 0 && (i = i.concat(o))
        }
        return i
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(kc, e, D4),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(kc, F4, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++)
            t[i].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++)
            t[i].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t),
        t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e)
        }
    }
    updateWorldMatrix(e, t) {
        const i = this.parent;
        if (e === !0 && i !== null && i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        t === !0) {
            const r = this.children;
            for (let s = 0, o = r.length; s < o; s++) {
                const a = r[s];
                a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0)
            }
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string"
          , i = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        i.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const r = {};
        r.uuid = this.uuid,
        r.type = this.type,
        this.name !== "" && (r.name = this.name),
        this.castShadow === !0 && (r.castShadow = !0),
        this.receiveShadow === !0 && (r.receiveShadow = !0),
        this.visible === !1 && (r.visible = !1),
        this.frustumCulled === !1 && (r.frustumCulled = !1),
        this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (r.userData = this.userData),
        r.layers = this.layers.mask,
        r.matrix = this.matrix.toArray(),
        this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
        this.isInstancedMesh && (r.type = "InstancedMesh",
        r.count = this.count,
        r.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON()));
        function s(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)),
            l.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            r.geometry = s(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const l = a.shapes;
                if (Array.isArray(l))
                    for (let c = 0, d = l.length; c < d; c++) {
                        const h = l[c];
                        s(e.shapes, h)
                    }
                else
                    s(e.shapes, l)
            }
        }
        if (this.isSkinnedMesh && (r.bindMode = this.bindMode,
        r.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (s(e.skeletons, this.skeleton),
        r.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let l = 0, c = this.material.length; l < c; l++)
                    a.push(s(e.materials, this.material[l]));
                r.material = a
            } else
                r.material = s(e.materials, this.material);
        if (this.children.length > 0) {
            r.children = [];
            for (let a = 0; a < this.children.length; a++)
                r.children.push(this.children[a].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            r.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const l = this.animations[a];
                r.animations.push(s(e.animations, l))
            }
        }
        if (t) {
            const a = o(e.geometries)
              , l = o(e.materials)
              , c = o(e.textures)
              , d = o(e.images)
              , h = o(e.shapes)
              , p = o(e.skeletons)
              , m = o(e.animations)
              , y = o(e.nodes);
            a.length > 0 && (i.geometries = a),
            l.length > 0 && (i.materials = l),
            c.length > 0 && (i.textures = c),
            d.length > 0 && (i.images = d),
            h.length > 0 && (i.shapes = h),
            p.length > 0 && (i.skeletons = p),
            m.length > 0 && (i.animations = m),
            y.length > 0 && (i.nodes = y)
        }
        return i.object = r,
        i;
        function o(a) {
            const l = [];
            for (const c in a) {
                const d = a[c];
                delete d.metadata,
                l.push(d)
            }
            return l
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        t === !0)
            for (let i = 0; i < e.children.length; i++) {
                const r = e.children[i];
                this.add(r.clone())
            }
        return this
    }
}
Rt.DEFAULT_UP = new D(0,1,0);
Rt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Rt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Tr = new D
  , Ss = new D
  , lv = new D
  , Cs = new D
  , Ul = new D
  , zl = new D
  , KC = new D
  , uv = new D
  , cv = new D
  , fv = new D;
class pr {
    constructor(e=new D, t=new D, i=new D) {
        this.a = e,
        this.b = t,
        this.c = i
    }
    static getNormal(e, t, i, r) {
        r.subVectors(i, t),
        Tr.subVectors(e, t),
        r.cross(Tr);
        const s = r.lengthSq();
        return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0)
    }
    static getBarycoord(e, t, i, r, s) {
        Tr.subVectors(r, t),
        Ss.subVectors(i, t),
        lv.subVectors(e, t);
        const o = Tr.dot(Tr)
          , a = Tr.dot(Ss)
          , l = Tr.dot(lv)
          , c = Ss.dot(Ss)
          , d = Ss.dot(lv)
          , h = o * c - a * a;
        if (h === 0)
            return s.set(-2, -1, -1);
        const p = 1 / h
          , m = (c * l - a * d) * p
          , y = (o * d - a * l) * p;
        return s.set(1 - m - y, y, m)
    }
    static containsPoint(e, t, i, r) {
        return this.getBarycoord(e, t, i, r, Cs),
        Cs.x >= 0 && Cs.y >= 0 && Cs.x + Cs.y <= 1
    }
    static getUV(e, t, i, r, s, o, a, l) {
        return this.getBarycoord(e, t, i, r, Cs),
        l.set(0, 0),
        l.addScaledVector(s, Cs.x),
        l.addScaledVector(o, Cs.y),
        l.addScaledVector(a, Cs.z),
        l
    }
    static isFrontFacing(e, t, i, r) {
        return Tr.subVectors(i, t),
        Ss.subVectors(e, t),
        Tr.cross(Ss).dot(r) < 0
    }
    set(e, t, i) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(i),
        this
    }
    setFromPointsAndIndices(e, t, i, r) {
        return this.a.copy(e[t]),
        this.b.copy(e[i]),
        this.c.copy(e[r]),
        this
    }
    setFromAttributeAndIndices(e, t, i, r) {
        return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, i),
        this.c.fromBufferAttribute(e, r),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return Tr.subVectors(this.c, this.b),
        Ss.subVectors(this.a, this.b),
        Tr.cross(Ss).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return pr.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return pr.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getUV(e, t, i, r, s) {
        return pr.getUV(e, this.a, this.b, this.c, t, i, r, s)
    }
    containsPoint(e) {
        return pr.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return pr.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const i = this.a
          , r = this.b
          , s = this.c;
        let o, a;
        Ul.subVectors(r, i),
        zl.subVectors(s, i),
        uv.subVectors(e, i);
        const l = Ul.dot(uv)
          , c = zl.dot(uv);
        if (l <= 0 && c <= 0)
            return t.copy(i);
        cv.subVectors(e, r);
        const d = Ul.dot(cv)
          , h = zl.dot(cv);
        if (d >= 0 && h <= d)
            return t.copy(r);
        const p = l * h - d * c;
        if (p <= 0 && l >= 0 && d <= 0)
            return o = l / (l - d),
            t.copy(i).addScaledVector(Ul, o);
        fv.subVectors(e, s);
        const m = Ul.dot(fv)
          , y = zl.dot(fv);
        if (y >= 0 && m <= y)
            return t.copy(s);
        const v = m * c - l * y;
        if (v <= 0 && c >= 0 && y <= 0)
            return a = c / (c - y),
            t.copy(i).addScaledVector(zl, a);
        const _ = d * y - m * h;
        if (_ <= 0 && h - d >= 0 && m - y >= 0)
            return KC.subVectors(s, r),
            a = (h - d) / (h - d + (m - y)),
            t.copy(r).addScaledVector(KC, a);
        const x = 1 / (_ + v + p);
        return o = v * x,
        a = p * x,
        t.copy(i).addScaledVector(Ul, o).addScaledVector(zl, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
let N4 = 0;
class Sn extends cs {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: N4++
        }),
        this.uuid = Vi(),
        this.name = "",
        this.type = "Material",
        this.blending = Ka,
        this.side = as,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = dA,
        this.blendDst = hA,
        this.blendEquation = Da,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.depthFunc = lg,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = uB,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = bm,
        this.stencilZFail = bm,
        this.stencilZPass = bm,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.forceSinglePass = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const i = e[t];
                if (i === void 0) {
                    console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                    continue
                }
                const r = this[t];
                if (r === void 0) {
                    console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
                    continue
                }
                r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[t] = i
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const i = {
            metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        i.uuid = this.uuid,
        i.type = this.type,
        this.name !== "" && (i.name = this.name),
        this.color && this.color.isColor && (i.color = this.color.getHex()),
        this.roughness !== void 0 && (i.roughness = this.roughness),
        this.metalness !== void 0 && (i.metalness = this.metalness),
        this.sheen !== void 0 && (i.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
        this.emissiveIntensity && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (i.shininess = this.shininess),
        this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.iridescence !== void 0 && (i.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid,
        i.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid,
        i.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid,
        i.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid,
        i.normalMapType = this.normalMapType,
        i.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid,
        i.displacementScale = this.displacementScale,
        i.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (i.combine = this.combine)),
        this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (i.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (i.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (i.size = this.size),
        this.shadowSide !== null && (i.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation),
        this.blending !== Ka && (i.blending = this.blending),
        this.side !== as && (i.side = this.side),
        this.vertexColors && (i.vertexColors = !0),
        this.opacity < 1 && (i.opacity = this.opacity),
        this.transparent === !0 && (i.transparent = this.transparent),
        i.depthFunc = this.depthFunc,
        i.depthTest = this.depthTest,
        i.depthWrite = this.depthWrite,
        i.colorWrite = this.colorWrite,
        i.stencilWrite = this.stencilWrite,
        i.stencilWriteMask = this.stencilWriteMask,
        i.stencilFunc = this.stencilFunc,
        i.stencilRef = this.stencilRef,
        i.stencilFuncMask = this.stencilFuncMask,
        i.stencilFail = this.stencilFail,
        i.stencilZFail = this.stencilZFail,
        i.stencilZPass = this.stencilZPass,
        this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation),
        this.polygonOffset === !0 && (i.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth),
        this.dashSize !== void 0 && (i.dashSize = this.dashSize),
        this.gapSize !== void 0 && (i.gapSize = this.gapSize),
        this.scale !== void 0 && (i.scale = this.scale),
        this.dithering === !0 && (i.dithering = !0),
        this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
        this.alphaToCoverage === !0 && (i.alphaToCoverage = this.alphaToCoverage),
        this.premultipliedAlpha === !0 && (i.premultipliedAlpha = this.premultipliedAlpha),
        this.forceSinglePass === !0 && (i.forceSinglePass = this.forceSinglePass),
        this.wireframe === !0 && (i.wireframe = this.wireframe),
        this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (i.flatShading = this.flatShading),
        this.visible === !1 && (i.visible = !1),
        this.toneMapped === !1 && (i.toneMapped = !1),
        this.fog === !1 && (i.fog = !1),
        Object.keys(this.userData).length > 0 && (i.userData = this.userData);
        function r(s) {
            const o = [];
            for (const a in s) {
                const l = s[a];
                delete l.metadata,
                o.push(l)
            }
            return o
        }
        if (t) {
            const s = r(e.textures)
              , o = r(e.images);
            s.length > 0 && (i.textures = s),
            o.length > 0 && (i.images = o)
        }
        return i
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let i = null;
        if (t !== null) {
            const r = t.length;
            i = new Array(r);
            for (let s = 0; s !== r; ++s)
                i[s] = t[s].clone()
        }
        return this.clippingPlanes = i,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.forceSinglePass = e.forceSinglePass,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
}
class Gi extends Sn {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new Le(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = Cd,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const An = new D
  , Mp = new pe;
class Ft {
    constructor(e, t, i=!1) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.normalized = i,
        this.usage = nd,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, i) {
        e *= this.itemSize,
        i *= t.itemSize;
        for (let r = 0, s = this.itemSize; r < s; r++)
            this.array[e + r] = t.array[i + r];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, i = this.count; t < i; t++)
                Mp.fromBufferAttribute(this, t),
                Mp.applyMatrix3(e),
                this.setXY(t, Mp.x, Mp.y);
        else if (this.itemSize === 3)
            for (let t = 0, i = this.count; t < i; t++)
                An.fromBufferAttribute(this, t),
                An.applyMatrix3(e),
                this.setXYZ(t, An.x, An.y, An.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.count; t < i; t++)
            An.fromBufferAttribute(this, t),
            An.applyMatrix4(e),
            this.setXYZ(t, An.x, An.y, An.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++)
            An.fromBufferAttribute(this, t),
            An.applyNormalMatrix(e),
            this.setXYZ(t, An.x, An.y, An.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++)
            An.fromBufferAttribute(this, t),
            An.transformDirection(e),
            this.setXYZ(t, An.x, An.y, An.z);
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = Fs(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = Gt(t, this.array)),
        this.array[e * this.itemSize] = t,
        this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = Fs(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = Gt(t, this.array)),
        this.array[e * this.itemSize + 1] = t,
        this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = Fs(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = Gt(t, this.array)),
        this.array[e * this.itemSize + 2] = t,
        this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = Fs(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = Gt(t, this.array)),
        this.array[e * this.itemSize + 3] = t,
        this
    }
    setXY(e, t, i) {
        return e *= this.itemSize,
        this.normalized && (t = Gt(t, this.array),
        i = Gt(i, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this
    }
    setXYZ(e, t, i, r) {
        return e *= this.itemSize,
        this.normalized && (t = Gt(t, this.array),
        i = Gt(i, this.array),
        r = Gt(r, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this.array[e + 2] = r,
        this
    }
    setXYZW(e, t, i, r, s) {
        return e *= this.itemSize,
        this.normalized && (t = Gt(t, this.array),
        i = Gt(i, this.array),
        r = Gt(r, this.array),
        s = Gt(s, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this.array[e + 2] = r,
        this.array[e + 3] = s,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== nd && (e.usage = this.usage),
        (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange),
        e
    }
    copyColorsArray() {
        console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")
    }
    copyVector2sArray() {
        console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")
    }
    copyVector3sArray() {
        console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")
    }
    copyVector4sArray() {
        console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")
    }
}
class O4 extends Ft {
    constructor(e, t, i) {
        super(new Int8Array(e), t, i)
    }
}
class U4 extends Ft {
    constructor(e, t, i) {
        super(new Uint8Array(e), t, i)
    }
}
class z4 extends Ft {
    constructor(e, t, i) {
        super(new Uint8ClampedArray(e), t, i)
    }
}
class G4 extends Ft {
    constructor(e, t, i) {
        super(new Int16Array(e), t, i)
    }
}
class AA extends Ft {
    constructor(e, t, i) {
        super(new Uint16Array(e), t, i)
    }
}
class H4 extends Ft {
    constructor(e, t, i) {
        super(new Int32Array(e), t, i)
    }
}
class MA extends Ft {
    constructor(e, t, i) {
        super(new Uint32Array(e), t, i)
    }
}
class V4 extends Ft {
    constructor(e, t, i) {
        super(new Uint16Array(e), t, i),
        this.isFloat16BufferAttribute = !0
    }
}
class je extends Ft {
    constructor(e, t, i) {
        super(new Float32Array(e), t, i)
    }
}
class W4 extends Ft {
    constructor(e, t, i) {
        super(new Float64Array(e), t, i)
    }
}
let j4 = 0;
const ar = new rt
  , dv = new Rt
  , Gl = new D
  , Ni = new ta
  , Nc = new ta
  , Nn = new D;
class ct extends cs {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: j4++
        }),
        this.uuid = Vi(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (dB(e) ? MA : AA)(e,1) : this.index = e,
        this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, i=0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: i
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e),
        t.needsUpdate = !0);
        const i = this.attributes.normal;
        if (i !== void 0) {
            const s = new hi().getNormalMatrix(e);
            i.applyNormalMatrix(s),
            i.needsUpdate = !0
        }
        const r = this.attributes.tangent;
        return r !== void 0 && (r.transformDirection(e),
        r.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return ar.makeRotationFromQuaternion(e),
        this.applyMatrix4(ar),
        this
    }
    rotateX(e) {
        return ar.makeRotationX(e),
        this.applyMatrix4(ar),
        this
    }
    rotateY(e) {
        return ar.makeRotationY(e),
        this.applyMatrix4(ar),
        this
    }
    rotateZ(e) {
        return ar.makeRotationZ(e),
        this.applyMatrix4(ar),
        this
    }
    translate(e, t, i) {
        return ar.makeTranslation(e, t, i),
        this.applyMatrix4(ar),
        this
    }
    scale(e, t, i) {
        return ar.makeScale(e, t, i),
        this.applyMatrix4(ar),
        this
    }
    lookAt(e) {
        return dv.lookAt(e),
        dv.updateMatrix(),
        this.applyMatrix4(dv.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(Gl).negate(),
        this.translate(Gl.x, Gl.y, Gl.z),
        this
    }
    setFromPoints(e) {
        const t = [];
        for (let i = 0, r = e.length; i < r; i++) {
            const s = e[i];
            t.push(s.x, s.y, s.z || 0)
        }
        return this.setAttribute("position", new je(t,3)),
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new ta);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingBox.set(new D(-1 / 0,-1 / 0,-1 / 0), new D(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            t)
                for (let i = 0, r = t.length; i < r; i++) {
                    const s = t[i];
                    Ni.setFromBufferAttribute(s),
                    this.morphTargetsRelative ? (Nn.addVectors(this.boundingBox.min, Ni.min),
                    this.boundingBox.expandByPoint(Nn),
                    Nn.addVectors(this.boundingBox.max, Ni.max),
                    this.boundingBox.expandByPoint(Nn)) : (this.boundingBox.expandByPoint(Ni.min),
                    this.boundingBox.expandByPoint(Ni.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new na);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingSphere.set(new D, 1 / 0);
            return
        }
        if (e) {
            const i = this.boundingSphere.center;
            if (Ni.setFromBufferAttribute(e),
            t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s];
                    Nc.setFromBufferAttribute(a),
                    this.morphTargetsRelative ? (Nn.addVectors(Ni.min, Nc.min),
                    Ni.expandByPoint(Nn),
                    Nn.addVectors(Ni.max, Nc.max),
                    Ni.expandByPoint(Nn)) : (Ni.expandByPoint(Nc.min),
                    Ni.expandByPoint(Nc.max))
                }
            Ni.getCenter(i);
            let r = 0;
            for (let s = 0, o = e.count; s < o; s++)
                Nn.fromBufferAttribute(e, s),
                r = Math.max(r, i.distanceToSquared(Nn));
            if (t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s]
                      , l = this.morphTargetsRelative;
                    for (let c = 0, d = a.count; c < d; c++)
                        Nn.fromBufferAttribute(a, c),
                        l && (Gl.fromBufferAttribute(e, c),
                        Nn.add(Gl)),
                        r = Math.max(r, i.distanceToSquared(Nn))
                }
            this.boundingSphere.radius = Math.sqrt(r),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const i = e.array
          , r = t.position.array
          , s = t.normal.array
          , o = t.uv.array
          , a = r.length / 3;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Ft(new Float32Array(4 * a),4));
        const l = this.getAttribute("tangent").array
          , c = []
          , d = [];
        for (let L = 0; L < a; L++)
            c[L] = new D,
            d[L] = new D;
        const h = new D
          , p = new D
          , m = new D
          , y = new pe
          , v = new pe
          , _ = new pe
          , x = new D
          , A = new D;
        function M(L, z, Z) {
            h.fromArray(r, L * 3),
            p.fromArray(r, z * 3),
            m.fromArray(r, Z * 3),
            y.fromArray(o, L * 2),
            v.fromArray(o, z * 2),
            _.fromArray(o, Z * 2),
            p.sub(h),
            m.sub(h),
            v.sub(y),
            _.sub(y);
            const J = 1 / (v.x * _.y - _.x * v.y);
            isFinite(J) && (x.copy(p).multiplyScalar(_.y).addScaledVector(m, -v.y).multiplyScalar(J),
            A.copy(m).multiplyScalar(v.x).addScaledVector(p, -_.x).multiplyScalar(J),
            c[L].add(x),
            c[z].add(x),
            c[Z].add(x),
            d[L].add(A),
            d[z].add(A),
            d[Z].add(A))
        }
        let S = this.groups;
        S.length === 0 && (S = [{
            start: 0,
            count: i.length
        }]);
        for (let L = 0, z = S.length; L < z; ++L) {
            const Z = S[L]
              , J = Z.start
              , G = Z.count;
            for (let X = J, ee = J + G; X < ee; X += 3)
                M(i[X + 0], i[X + 1], i[X + 2])
        }
        const T = new D
          , P = new D
          , R = new D
          , E = new D;
        function B(L) {
            R.fromArray(s, L * 3),
            E.copy(R);
            const z = c[L];
            T.copy(z),
            T.sub(R.multiplyScalar(R.dot(z))).normalize(),
            P.crossVectors(E, z);
            const J = P.dot(d[L]) < 0 ? -1 : 1;
            l[L * 4] = T.x,
            l[L * 4 + 1] = T.y,
            l[L * 4 + 2] = T.z,
            l[L * 4 + 3] = J
        }
        for (let L = 0, z = S.length; L < z; ++L) {
            const Z = S[L]
              , J = Z.start
              , G = Z.count;
            for (let X = J, ee = J + G; X < ee; X += 3)
                B(i[X + 0]),
                B(i[X + 1]),
                B(i[X + 2])
        }
    }
    computeVertexNormals() {
        const e = this.index
          , t = this.getAttribute("position");
        if (t !== void 0) {
            let i = this.getAttribute("normal");
            if (i === void 0)
                i = new Ft(new Float32Array(t.count * 3),3),
                this.setAttribute("normal", i);
            else
                for (let p = 0, m = i.count; p < m; p++)
                    i.setXYZ(p, 0, 0, 0);
            const r = new D
              , s = new D
              , o = new D
              , a = new D
              , l = new D
              , c = new D
              , d = new D
              , h = new D;
            if (e)
                for (let p = 0, m = e.count; p < m; p += 3) {
                    const y = e.getX(p + 0)
                      , v = e.getX(p + 1)
                      , _ = e.getX(p + 2);
                    r.fromBufferAttribute(t, y),
                    s.fromBufferAttribute(t, v),
                    o.fromBufferAttribute(t, _),
                    d.subVectors(o, s),
                    h.subVectors(r, s),
                    d.cross(h),
                    a.fromBufferAttribute(i, y),
                    l.fromBufferAttribute(i, v),
                    c.fromBufferAttribute(i, _),
                    a.add(d),
                    l.add(d),
                    c.add(d),
                    i.setXYZ(y, a.x, a.y, a.z),
                    i.setXYZ(v, l.x, l.y, l.z),
                    i.setXYZ(_, c.x, c.y, c.z)
                }
            else
                for (let p = 0, m = t.count; p < m; p += 3)
                    r.fromBufferAttribute(t, p + 0),
                    s.fromBufferAttribute(t, p + 1),
                    o.fromBufferAttribute(t, p + 2),
                    d.subVectors(o, s),
                    h.subVectors(r, s),
                    d.cross(h),
                    i.setXYZ(p + 0, d.x, d.y, d.z),
                    i.setXYZ(p + 1, d.x, d.y, d.z),
                    i.setXYZ(p + 2, d.x, d.y, d.z);
            this.normalizeNormals(),
            i.needsUpdate = !0
        }
    }
    merge() {
        return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."),
        this
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, i = e.count; t < i; t++)
            Nn.fromBufferAttribute(e, t),
            Nn.normalize(),
            e.setXYZ(t, Nn.x, Nn.y, Nn.z)
    }
    toNonIndexed() {
        function e(a, l) {
            const c = a.array
              , d = a.itemSize
              , h = a.normalized
              , p = new c.constructor(l.length * d);
            let m = 0
              , y = 0;
            for (let v = 0, _ = l.length; v < _; v++) {
                a.isInterleavedBufferAttribute ? m = l[v] * a.data.stride + a.offset : m = l[v] * d;
                for (let x = 0; x < d; x++)
                    p[y++] = c[m++]
            }
            return new Ft(p,d,h)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const t = new ct
          , i = this.index.array
          , r = this.attributes;
        for (const a in r) {
            const l = r[a]
              , c = e(l, i);
            t.setAttribute(a, c)
        }
        const s = this.morphAttributes;
        for (const a in s) {
            const l = []
              , c = s[a];
            for (let d = 0, h = c.length; d < h; d++) {
                const p = c[d]
                  , m = e(p, i);
                l.push(m)
            }
            t.morphAttributes[a] = l
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            t.addGroup(c.start, c.count, c.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const l = this.parameters;
            for (const c in l)
                l[c] !== void 0 && (e[c] = l[c]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const i = this.attributes;
        for (const l in i) {
            const c = i[l];
            e.data.attributes[l] = c.toJSON(e.data)
        }
        const r = {};
        let s = !1;
        for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l]
              , d = [];
            for (let h = 0, p = c.length; h < p; h++) {
                const m = c[h];
                d.push(m.toJSON(e.data))
            }
            d.length > 0 && (r[l] = d,
            s = !0)
        }
        s && (e.data.morphAttributes = r,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
        }),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const i = e.index;
        i !== null && this.setIndex(i.clone(t));
        const r = e.attributes;
        for (const c in r) {
            const d = r[c];
            this.setAttribute(c, d.clone(t))
        }
        const s = e.morphAttributes;
        for (const c in s) {
            const d = []
              , h = s[c];
            for (let p = 0, m = h.length; p < m; p++)
                d.push(h[p].clone(t));
            this.morphAttributes[c] = d
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let c = 0, d = o.length; c < d; c++) {
            const h = o[c];
            this.addGroup(h.start, h.count, h.materialIndex)
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const l = e.boundingSphere;
        return l !== null && (this.boundingSphere = l.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        e.parameters !== void 0 && (this.parameters = Object.assign({}, e.parameters)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const YC = new rt
  , Hl = new Ed
  , hv = new na
  , Oc = new D
  , Uc = new D
  , zc = new D
  , pv = new D
  , wp = new D
  , Sp = new pe
  , Cp = new pe
  , Ep = new pe
  , mv = new D
  , Tp = new D;
class Un extends Rt {
    constructor(e=new ct, t=new Gi) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const i = this.geometry
          , r = i.attributes.position
          , s = i.morphAttributes.position
          , o = i.morphTargetsRelative;
        t.fromBufferAttribute(r, e);
        const a = this.morphTargetInfluences;
        if (s && a) {
            wp.set(0, 0, 0);
            for (let l = 0, c = s.length; l < c; l++) {
                const d = a[l]
                  , h = s[l];
                d !== 0 && (pv.fromBufferAttribute(h, e),
                o ? wp.addScaledVector(pv, d) : wp.addScaledVector(pv.sub(t), d))
            }
            t.add(wp)
        }
        return this.isSkinnedMesh && this.boneTransform(e, t),
        t
    }
    raycast(e, t) {
        const i = this.geometry
          , r = this.material
          , s = this.matrixWorld;
        if (r === void 0 || (i.boundingSphere === null && i.computeBoundingSphere(),
        hv.copy(i.boundingSphere),
        hv.applyMatrix4(s),
        e.ray.intersectsSphere(hv) === !1) || (YC.copy(s).invert(),
        Hl.copy(e.ray).applyMatrix4(YC),
        i.boundingBox !== null && Hl.intersectsBox(i.boundingBox) === !1))
            return;
        let o;
        const a = i.index
          , l = i.attributes.position
          , c = i.attributes.uv
          , d = i.attributes.uv2
          , h = i.groups
          , p = i.drawRange;
        if (a !== null)
            if (Array.isArray(r))
                for (let m = 0, y = h.length; m < y; m++) {
                    const v = h[m]
                      , _ = r[v.materialIndex]
                      , x = Math.max(v.start, p.start)
                      , A = Math.min(a.count, Math.min(v.start + v.count, p.start + p.count));
                    for (let M = x, S = A; M < S; M += 3) {
                        const T = a.getX(M)
                          , P = a.getX(M + 1)
                          , R = a.getX(M + 2);
                        o = bp(this, _, e, Hl, c, d, T, P, R),
                        o && (o.faceIndex = Math.floor(M / 3),
                        o.face.materialIndex = v.materialIndex,
                        t.push(o))
                    }
                }
            else {
                const m = Math.max(0, p.start)
                  , y = Math.min(a.count, p.start + p.count);
                for (let v = m, _ = y; v < _; v += 3) {
                    const x = a.getX(v)
                      , A = a.getX(v + 1)
                      , M = a.getX(v + 2);
                    o = bp(this, r, e, Hl, c, d, x, A, M),
                    o && (o.faceIndex = Math.floor(v / 3),
                    t.push(o))
                }
            }
        else if (l !== void 0)
            if (Array.isArray(r))
                for (let m = 0, y = h.length; m < y; m++) {
                    const v = h[m]
                      , _ = r[v.materialIndex]
                      , x = Math.max(v.start, p.start)
                      , A = Math.min(l.count, Math.min(v.start + v.count, p.start + p.count));
                    for (let M = x, S = A; M < S; M += 3) {
                        const T = M
                          , P = M + 1
                          , R = M + 2;
                        o = bp(this, _, e, Hl, c, d, T, P, R),
                        o && (o.faceIndex = Math.floor(M / 3),
                        o.face.materialIndex = v.materialIndex,
                        t.push(o))
                    }
                }
            else {
                const m = Math.max(0, p.start)
                  , y = Math.min(l.count, p.start + p.count);
                for (let v = m, _ = y; v < _; v += 3) {
                    const x = v
                      , A = v + 1
                      , M = v + 2;
                    o = bp(this, r, e, Hl, c, d, x, A, M),
                    o && (o.faceIndex = Math.floor(v / 3),
                    t.push(o))
                }
            }
    }
}
function J4(n, e, t, i, r, s, o, a) {
    let l;
    if (e.side === Bi ? l = i.intersectTriangle(o, s, r, !0, a) : l = i.intersectTriangle(r, s, o, e.side === as, a),
    l === null)
        return null;
    Tp.copy(a),
    Tp.applyMatrix4(n.matrixWorld);
    const c = t.ray.origin.distanceTo(Tp);
    return c < t.near || c > t.far ? null : {
        distance: c,
        point: Tp.clone(),
        object: n
    }
}
function bp(n, e, t, i, r, s, o, a, l) {
    n.getVertexPosition(o, Oc),
    n.getVertexPosition(a, Uc),
    n.getVertexPosition(l, zc);
    const c = J4(n, e, t, i, Oc, Uc, zc, mv);
    if (c) {
        r && (Sp.fromBufferAttribute(r, o),
        Cp.fromBufferAttribute(r, a),
        Ep.fromBufferAttribute(r, l),
        c.uv = pr.getUV(mv, Oc, Uc, zc, Sp, Cp, Ep, new pe)),
        s && (Sp.fromBufferAttribute(s, o),
        Cp.fromBufferAttribute(s, a),
        Ep.fromBufferAttribute(s, l),
        c.uv2 = pr.getUV(mv, Oc, Uc, zc, Sp, Cp, Ep, new pe));
        const d = {
            a: o,
            b: a,
            c: l,
            normal: new D,
            materialIndex: 0
        };
        pr.getNormal(Oc, Uc, zc, d.normal),
        c.face = d
    }
    return c
}
class ia extends ct {
    constructor(e=1, t=1, i=1, r=1, s=1, o=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: r,
            heightSegments: s,
            depthSegments: o
        };
        const a = this;
        r = Math.floor(r),
        s = Math.floor(s),
        o = Math.floor(o);
        const l = []
          , c = []
          , d = []
          , h = [];
        let p = 0
          , m = 0;
        y("z", "y", "x", -1, -1, i, t, e, o, s, 0),
        y("z", "y", "x", 1, -1, i, t, -e, o, s, 1),
        y("x", "z", "y", 1, 1, e, i, t, r, o, 2),
        y("x", "z", "y", 1, -1, e, i, -t, r, o, 3),
        y("x", "y", "z", 1, -1, e, t, i, r, s, 4),
        y("x", "y", "z", -1, -1, e, t, -i, r, s, 5),
        this.setIndex(l),
        this.setAttribute("position", new je(c,3)),
        this.setAttribute("normal", new je(d,3)),
        this.setAttribute("uv", new je(h,2));
        function y(v, _, x, A, M, S, T, P, R, E, B) {
            const L = S / R
              , z = T / E
              , Z = S / 2
              , J = T / 2
              , G = P / 2
              , X = R + 1
              , ee = E + 1;
            let ie = 0
              , F = 0;
            const V = new D;
            for (let j = 0; j < ee; j++) {
                const re = j * z - J;
                for (let H = 0; H < X; H++) {
                    const se = H * L - Z;
                    V[v] = se * A,
                    V[_] = re * M,
                    V[x] = G,
                    c.push(V.x, V.y, V.z),
                    V[v] = 0,
                    V[_] = 0,
                    V[x] = P > 0 ? 1 : -1,
                    d.push(V.x, V.y, V.z),
                    h.push(H / R),
                    h.push(1 - j / E),
                    ie += 1
                }
            }
            for (let j = 0; j < E; j++)
                for (let re = 0; re < R; re++) {
                    const H = p + re + X * j
                      , se = p + re + X * (j + 1)
                      , ye = p + (re + 1) + X * (j + 1)
                      , ve = p + (re + 1) + X * j;
                    l.push(H, se, ve),
                    l.push(se, ye, ve),
                    F += 6
                }
            a.addGroup(m, F, B),
            m += F,
            p += ie
        }
    }
    static fromJSON(e) {
        return new ia(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
function zu(n) {
    const e = {};
    for (const t in n) {
        e[t] = {};
        for (const i in n[t]) {
            const r = n[t][i];
            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[t][i] = r.clone() : Array.isArray(r) ? e[t][i] = r.slice() : e[t][i] = r
        }
    }
    return e
}
function ui(n) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
        const i = zu(n[t]);
        for (const r in i)
            e[r] = i[r]
    }
    return e
}
function X4(n) {
    const e = [];
    for (let t = 0; t < n.length; t++)
        e.push(n[t].clone());
    return e
}
function pB(n) {
    return n.getRenderTarget() === null && n.outputEncoding === Et ? Br : Uu
}
const mB = {
    clone: zu,
    merge: ui
};
var K4 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
  , Y4 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class us extends Sn {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = K4,
        this.fragmentShader = Y4,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = zu(e.uniforms),
        this.uniformsGroups = X4(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (const r in this.uniforms) {
            const o = this.uniforms[r].value;
            o && o.isTexture ? t.uniforms[r] = {
                type: "t",
                value: o.toJSON(e).uuid
            } : o && o.isColor ? t.uniforms[r] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? t.uniforms[r] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? t.uniforms[r] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? t.uniforms[r] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? t.uniforms[r] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? t.uniforms[r] = {
                type: "m4",
                value: o.toArray()
            } : t.uniforms[r] = {
                value: o
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader;
        const i = {};
        for (const r in this.extensions)
            this.extensions[r] === !0 && (i[r] = !0);
        return Object.keys(i).length > 0 && (t.extensions = i),
        t
    }
}
class bd extends Rt {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new rt,
        this.projectionMatrix = new rt,
        this.projectionMatrixInverse = new rt
    }
    copy(e, t) {
        return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(-t[8], -t[9], -t[10]).normalize()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Ht extends bd {
    constructor(e=50, t=1, i=.1, r=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = i,
        this.far = r,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = id * 2 * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(Za * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return id * 2 * Math.atan(Math.tan(Za * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    setViewOffset(e, t, i, r, s, o) {
        this.aspect = e / t,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = i,
        this.view.offsetY = r,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(Za * .5 * this.fov) / this.zoom
          , i = 2 * t
          , r = this.aspect * i
          , s = -.5 * r;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth
              , c = o.fullHeight;
            s += o.offsetX * r / l,
            t -= o.offsetY * i / c,
            r *= o.width / l,
            i *= o.height / c
        }
        const a = this.filmOffset;
        a !== 0 && (s += e * a / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t
    }
}
const Vl = -90
  , Wl = 1;
class wA extends Rt {
    constructor(e, t, i) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = i;
        const r = new Ht(Vl,Wl,e,t);
        r.layers = this.layers,
        r.up.set(0, 1, 0),
        r.lookAt(1, 0, 0),
        this.add(r);
        const s = new Ht(Vl,Wl,e,t);
        s.layers = this.layers,
        s.up.set(0, 1, 0),
        s.lookAt(-1, 0, 0),
        this.add(s);
        const o = new Ht(Vl,Wl,e,t);
        o.layers = this.layers,
        o.up.set(0, 0, -1),
        o.lookAt(0, 1, 0),
        this.add(o);
        const a = new Ht(Vl,Wl,e,t);
        a.layers = this.layers,
        a.up.set(0, 0, 1),
        a.lookAt(0, -1, 0),
        this.add(a);
        const l = new Ht(Vl,Wl,e,t);
        l.layers = this.layers,
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, 1),
        this.add(l);
        const c = new Ht(Vl,Wl,e,t);
        c.layers = this.layers,
        c.up.set(0, 1, 0),
        c.lookAt(0, 0, -1),
        this.add(c)
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const i = this.renderTarget
          , [r,s,o,a,l,c] = this.children
          , d = e.getRenderTarget()
          , h = e.toneMapping
          , p = e.xr.enabled;
        e.toneMapping = kr,
        e.xr.enabled = !1;
        const m = i.texture.generateMipmaps;
        i.texture.generateMipmaps = !1,
        e.setRenderTarget(i, 0),
        e.render(t, r),
        e.setRenderTarget(i, 1),
        e.render(t, s),
        e.setRenderTarget(i, 2),
        e.render(t, o),
        e.setRenderTarget(i, 3),
        e.render(t, a),
        e.setRenderTarget(i, 4),
        e.render(t, l),
        i.texture.generateMipmaps = m,
        e.setRenderTarget(i, 5),
        e.render(t, c),
        e.setRenderTarget(d),
        e.toneMapping = h,
        e.xr.enabled = p,
        i.texture.needsPMREMUpdate = !0
    }
}
class Pd extends qt {
    constructor(e, t, i, r, s, o, a, l, c, d) {
        e = e !== void 0 ? e : [],
        t = t !== void 0 ? t : Vo,
        super(e, t, i, r, s, o, a, l, c, d),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class SA extends Ur {
    constructor(e=1, t={}) {
        super(e, e, t),
        this.isWebGLCubeRenderTarget = !0;
        const i = {
            width: e,
            height: e,
            depth: 1
        }
          , r = [i, i, i, i, i, i];
        this.texture = new Pd(r,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1,
        this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : nn
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type,
        this.texture.encoding = t.encoding,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
        const i = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , r = new ia(5,5,5)
          , s = new us({
            name: "CubemapFromEquirect",
            uniforms: zu(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            side: Bi,
            blending: Us
        });
        s.uniforms.tEquirect.value = t;
        const o = new Un(r,s)
          , a = t.minFilter;
        return t.minFilter === ls && (t.minFilter = nn),
        new wA(1,10,this).update(e, o),
        t.minFilter = a,
        o.geometry.dispose(),
        o.material.dispose(),
        this
    }
    clear(e, t, i, r) {
        const s = e.getRenderTarget();
        for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o),
            e.clear(t, i, r);
        e.setRenderTarget(s)
    }
}
const gv = new D
  , Q4 = new D
  , Z4 = new hi;
class _o {
    constructor(e=new D(1,0,0), t=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    }
    setComponents(e, t, i, r) {
        return this.normal.set(e, t, i),
        this.constant = r,
        this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, t, i) {
        const r = gv.subVectors(i, t).cross(Q4.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(r, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
    }
    intersectLine(e, t) {
        const i = e.delta(gv)
          , r = this.normal.dot(i);
        if (r === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const s = -(e.start.dot(this.normal) + this.constant) / r;
        return s < 0 || s > 1 ? null : t.copy(i).multiplyScalar(s).add(e.start)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start)
          , i = this.distanceToPoint(e.end);
        return t < 0 && i > 0 || i < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const i = t || Z4.getNormalMatrix(e)
          , r = this.coplanarPoint(gv).applyMatrix4(e)
          , s = this.normal.applyMatrix3(i).normalize();
        return this.constant = -r.dot(s),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const jl = new na
  , Pp = new D;
class Zg {
    constructor(e=new _o, t=new _o, i=new _o, r=new _o, s=new _o, o=new _o) {
        this.planes = [e, t, i, r, s, o]
    }
    set(e, t, i, r, s, o) {
        const a = this.planes;
        return a[0].copy(e),
        a[1].copy(t),
        a[2].copy(i),
        a[3].copy(r),
        a[4].copy(s),
        a[5].copy(o),
        this
    }
    copy(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++)
            t[i].copy(e.planes[i]);
        return this
    }
    setFromProjectionMatrix(e) {
        const t = this.planes
          , i = e.elements
          , r = i[0]
          , s = i[1]
          , o = i[2]
          , a = i[3]
          , l = i[4]
          , c = i[5]
          , d = i[6]
          , h = i[7]
          , p = i[8]
          , m = i[9]
          , y = i[10]
          , v = i[11]
          , _ = i[12]
          , x = i[13]
          , A = i[14]
          , M = i[15];
        return t[0].setComponents(a - r, h - l, v - p, M - _).normalize(),
        t[1].setComponents(a + r, h + l, v + p, M + _).normalize(),
        t[2].setComponents(a + s, h + c, v + m, M + x).normalize(),
        t[3].setComponents(a - s, h - c, v - m, M - x).normalize(),
        t[4].setComponents(a - o, h - d, v - y, M - A).normalize(),
        t[5].setComponents(a + o, h + d, v + y, M + A).normalize(),
        this
    }
    intersectsObject(e) {
        const t = e.geometry;
        return t.boundingSphere === null && t.computeBoundingSphere(),
        jl.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
        this.intersectsSphere(jl)
    }
    intersectsSprite(e) {
        return jl.center.set(0, 0, 0),
        jl.radius = .7071067811865476,
        jl.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(jl)
    }
    intersectsSphere(e) {
        const t = this.planes
          , i = e.center
          , r = -e.radius;
        for (let s = 0; s < 6; s++)
            if (t[s].distanceToPoint(i) < r)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) {
            const r = t[i];
            if (Pp.x = r.normal.x > 0 ? e.max.x : e.min.x,
            Pp.y = r.normal.y > 0 ? e.max.y : e.min.y,
            Pp.z = r.normal.z > 0 ? e.max.z : e.min.z,
            r.distanceToPoint(Pp) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++)
            if (t[i].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
function gB() {
    let n = null
      , e = !1
      , t = null
      , i = null;
    function r(s, o) {
        t(s, o),
        i = n.requestAnimationFrame(r)
    }
    return {
        start: function() {
            e !== !0 && t !== null && (i = n.requestAnimationFrame(r),
            e = !0)
        },
        stop: function() {
            n.cancelAnimationFrame(i),
            e = !1
        },
        setAnimationLoop: function(s) {
            t = s
        },
        setContext: function(s) {
            n = s
        }
    }
}
function q4(n, e) {
    const t = e.isWebGL2
      , i = new WeakMap;
    function r(c, d) {
        const h = c.array
          , p = c.usage
          , m = n.createBuffer();
        n.bindBuffer(d, m),
        n.bufferData(d, h, p),
        c.onUploadCallback();
        let y;
        if (h instanceof Float32Array)
            y = 5126;
        else if (h instanceof Uint16Array)
            if (c.isFloat16BufferAttribute)
                if (t)
                    y = 5131;
                else
                    throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
            else
                y = 5123;
        else if (h instanceof Int16Array)
            y = 5122;
        else if (h instanceof Uint32Array)
            y = 5125;
        else if (h instanceof Int32Array)
            y = 5124;
        else if (h instanceof Int8Array)
            y = 5120;
        else if (h instanceof Uint8Array)
            y = 5121;
        else if (h instanceof Uint8ClampedArray)
            y = 5121;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + h);
        return {
            buffer: m,
            type: y,
            bytesPerElement: h.BYTES_PER_ELEMENT,
            version: c.version
        }
    }
    function s(c, d, h) {
        const p = d.array
          , m = d.updateRange;
        n.bindBuffer(h, c),
        m.count === -1 ? n.bufferSubData(h, 0, p) : (t ? n.bufferSubData(h, m.offset * p.BYTES_PER_ELEMENT, p, m.offset, m.count) : n.bufferSubData(h, m.offset * p.BYTES_PER_ELEMENT, p.subarray(m.offset, m.offset + m.count)),
        m.count = -1),
        d.onUploadCallback()
    }
    function o(c) {
        return c.isInterleavedBufferAttribute && (c = c.data),
        i.get(c)
    }
    function a(c) {
        c.isInterleavedBufferAttribute && (c = c.data);
        const d = i.get(c);
        d && (n.deleteBuffer(d.buffer),
        i.delete(c))
    }
    function l(c, d) {
        if (c.isGLBufferAttribute) {
            const p = i.get(c);
            (!p || p.version < c.version) && i.set(c, {
                buffer: c.buffer,
                type: c.type,
                bytesPerElement: c.elementSize,
                version: c.version
            });
            return
        }
        c.isInterleavedBufferAttribute && (c = c.data);
        const h = i.get(c);
        h === void 0 ? i.set(c, r(c, d)) : h.version < c.version && (s(h.buffer, c, d),
        h.version = c.version)
    }
    return {
        get: o,
        remove: a,
        update: l
    }
}
class $u extends ct {
    constructor(e=1, t=1, i=1, r=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: r
        };
        const s = e / 2
          , o = t / 2
          , a = Math.floor(i)
          , l = Math.floor(r)
          , c = a + 1
          , d = l + 1
          , h = e / a
          , p = t / l
          , m = []
          , y = []
          , v = []
          , _ = [];
        for (let x = 0; x < d; x++) {
            const A = x * p - o;
            for (let M = 0; M < c; M++) {
                const S = M * h - s;
                y.push(S, -A, 0),
                v.push(0, 0, 1),
                _.push(M / a),
                _.push(1 - x / l)
            }
        }
        for (let x = 0; x < l; x++)
            for (let A = 0; A < a; A++) {
                const M = A + c * x
                  , S = A + c * (x + 1)
                  , T = A + 1 + c * (x + 1)
                  , P = A + 1 + c * x;
                m.push(M, S, P),
                m.push(S, T, P)
            }
        this.setIndex(m),
        this.setAttribute("position", new je(y,3)),
        this.setAttribute("normal", new je(v,3)),
        this.setAttribute("uv", new je(_,2))
    }
    static fromJSON(e) {
        return new $u(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
var $4 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`
  , eU = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , tU = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`
  , nU = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
  , iU = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
  , rU = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
  , sU = "vec3 transformed = vec3( position );"
  , oU = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
  , aU = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`
  , lU = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`
  , uU = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
  , cU = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`
  , fU = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
  , dU = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
  , hU = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
  , pU = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
  , mU = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
  , gU = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`
  , yU = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`
  , vU = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`
  , xU = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
  , _U = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
  , AU = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
  , MU = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`
  , wU = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
  , SU = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
  , CU = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , EU = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`
  , TU = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
  , bU = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`
  , PU = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
  , BU = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
  , RU = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
  , LU = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
  , IU = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
  , DU = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
  , FU = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
  , kU = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`
  , NU = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`
  , OU = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
  , UU = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`
  , zU = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`
  , GU = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
  , HU = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`
  , VU = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
  , WU = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`
  , jU = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
  , JU = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`
  , XU = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`
  , KU = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
  , YU = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
  , QU = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
  , ZU = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`
  , qU = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
  , $U = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , ez = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`
  , tz = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`
  , nz = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`
  , iz = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
  , rz = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
  , sz = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , oz = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`
  , az = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
  , lz = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`
  , uz = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`
  , cz = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`
  , fz = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`
  , dz = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`
  , hz = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
  , pz = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , mz = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , gz = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
  , yz = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`
  , vz = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`
  , xz = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`
  , _z = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`
  , Az = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`
  , Mz = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
  , wz = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`
  , Sz = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
  , Cz = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
  , Ez = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
  , Tz = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
  , bz = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`
  , Pz = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
  , Bz = `#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`
  , Rz = `#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
  , Lz = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`
  , Iz = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
  , Dz = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
  , Fz = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`
  , kz = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
  , Nz = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
  , Oz = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
  , Uz = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
  , zz = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
  , Gz = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
  , Hz = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`
  , Vz = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`
  , Wz = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`
  , jz = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`
  , Jz = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`
  , Xz = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`
  , Kz = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`
  , Yz = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`
  , Qz = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const Zz = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
  , qz = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , $z = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , e5 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , t5 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , n5 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , i5 = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
  , r5 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`
  , s5 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
  , o5 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
  , a5 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
  , l5 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , u5 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , c5 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , f5 = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
  , d5 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , h5 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , p5 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , m5 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
  , g5 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , y5 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`
  , v5 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
  , x5 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , _5 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , A5 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
  , M5 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , w5 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , S5 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , C5 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
  , E5 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , T5 = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , b5 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`
  , P5 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , B5 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`
  , mt = {
    alphamap_fragment: $4,
    alphamap_pars_fragment: eU,
    alphatest_fragment: tU,
    alphatest_pars_fragment: nU,
    aomap_fragment: iU,
    aomap_pars_fragment: rU,
    begin_vertex: sU,
    beginnormal_vertex: oU,
    bsdfs: aU,
    iridescence_fragment: lU,
    bumpmap_pars_fragment: uU,
    clipping_planes_fragment: cU,
    clipping_planes_pars_fragment: fU,
    clipping_planes_pars_vertex: dU,
    clipping_planes_vertex: hU,
    color_fragment: pU,
    color_pars_fragment: mU,
    color_pars_vertex: gU,
    color_vertex: yU,
    common: vU,
    cube_uv_reflection_fragment: xU,
    defaultnormal_vertex: _U,
    displacementmap_pars_vertex: AU,
    displacementmap_vertex: MU,
    emissivemap_fragment: wU,
    emissivemap_pars_fragment: SU,
    encodings_fragment: CU,
    encodings_pars_fragment: EU,
    envmap_fragment: TU,
    envmap_common_pars_fragment: bU,
    envmap_pars_fragment: PU,
    envmap_pars_vertex: BU,
    envmap_physical_pars_fragment: HU,
    envmap_vertex: RU,
    fog_vertex: LU,
    fog_pars_vertex: IU,
    fog_fragment: DU,
    fog_pars_fragment: FU,
    gradientmap_pars_fragment: kU,
    lightmap_fragment: NU,
    lightmap_pars_fragment: OU,
    lights_lambert_fragment: UU,
    lights_lambert_pars_fragment: zU,
    lights_pars_begin: GU,
    lights_toon_fragment: VU,
    lights_toon_pars_fragment: WU,
    lights_phong_fragment: jU,
    lights_phong_pars_fragment: JU,
    lights_physical_fragment: XU,
    lights_physical_pars_fragment: KU,
    lights_fragment_begin: YU,
    lights_fragment_maps: QU,
    lights_fragment_end: ZU,
    logdepthbuf_fragment: qU,
    logdepthbuf_pars_fragment: $U,
    logdepthbuf_pars_vertex: ez,
    logdepthbuf_vertex: tz,
    map_fragment: nz,
    map_pars_fragment: iz,
    map_particle_fragment: rz,
    map_particle_pars_fragment: sz,
    metalnessmap_fragment: oz,
    metalnessmap_pars_fragment: az,
    morphcolor_vertex: lz,
    morphnormal_vertex: uz,
    morphtarget_pars_vertex: cz,
    morphtarget_vertex: fz,
    normal_fragment_begin: dz,
    normal_fragment_maps: hz,
    normal_pars_fragment: pz,
    normal_pars_vertex: mz,
    normal_vertex: gz,
    normalmap_pars_fragment: yz,
    clearcoat_normal_fragment_begin: vz,
    clearcoat_normal_fragment_maps: xz,
    clearcoat_pars_fragment: _z,
    iridescence_pars_fragment: Az,
    output_fragment: Mz,
    packing: wz,
    premultiplied_alpha_fragment: Sz,
    project_vertex: Cz,
    dithering_fragment: Ez,
    dithering_pars_fragment: Tz,
    roughnessmap_fragment: bz,
    roughnessmap_pars_fragment: Pz,
    shadowmap_pars_fragment: Bz,
    shadowmap_pars_vertex: Rz,
    shadowmap_vertex: Lz,
    shadowmask_pars_fragment: Iz,
    skinbase_vertex: Dz,
    skinning_pars_vertex: Fz,
    skinning_vertex: kz,
    skinnormal_vertex: Nz,
    specularmap_fragment: Oz,
    specularmap_pars_fragment: Uz,
    tonemapping_fragment: zz,
    tonemapping_pars_fragment: Gz,
    transmission_fragment: Hz,
    transmission_pars_fragment: Vz,
    uv_pars_fragment: Wz,
    uv_pars_vertex: jz,
    uv_vertex: Jz,
    uv2_pars_fragment: Xz,
    uv2_pars_vertex: Kz,
    uv2_vertex: Yz,
    worldpos_vertex: Qz,
    background_vert: Zz,
    background_frag: qz,
    backgroundCube_vert: $z,
    backgroundCube_frag: e5,
    cube_vert: t5,
    cube_frag: n5,
    depth_vert: i5,
    depth_frag: r5,
    distanceRGBA_vert: s5,
    distanceRGBA_frag: o5,
    equirect_vert: a5,
    equirect_frag: l5,
    linedashed_vert: u5,
    linedashed_frag: c5,
    meshbasic_vert: f5,
    meshbasic_frag: d5,
    meshlambert_vert: h5,
    meshlambert_frag: p5,
    meshmatcap_vert: m5,
    meshmatcap_frag: g5,
    meshnormal_vert: y5,
    meshnormal_frag: v5,
    meshphong_vert: x5,
    meshphong_frag: _5,
    meshphysical_vert: A5,
    meshphysical_frag: M5,
    meshtoon_vert: w5,
    meshtoon_frag: S5,
    points_vert: C5,
    points_frag: E5,
    shadow_vert: T5,
    shadow_frag: b5,
    sprite_vert: P5,
    sprite_frag: B5
}
  , Re = {
    common: {
        diffuse: {
            value: new Le(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new hi
        },
        uv2Transform: {
            value: new hi
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalScale: {
            value: new pe(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new Le(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new Le(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new hi
        }
    },
    sprite: {
        diffuse: {
            value: new Le(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new pe(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new hi
        }
    }
}
  , Lr = {
    basic: {
        uniforms: ui([Re.common, Re.specularmap, Re.envmap, Re.aomap, Re.lightmap, Re.fog]),
        vertexShader: mt.meshbasic_vert,
        fragmentShader: mt.meshbasic_frag
    },
    lambert: {
        uniforms: ui([Re.common, Re.specularmap, Re.envmap, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.fog, Re.lights, {
            emissive: {
                value: new Le(0)
            }
        }]),
        vertexShader: mt.meshlambert_vert,
        fragmentShader: mt.meshlambert_frag
    },
    phong: {
        uniforms: ui([Re.common, Re.specularmap, Re.envmap, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.fog, Re.lights, {
            emissive: {
                value: new Le(0)
            },
            specular: {
                value: new Le(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: mt.meshphong_vert,
        fragmentShader: mt.meshphong_frag
    },
    standard: {
        uniforms: ui([Re.common, Re.envmap, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.roughnessmap, Re.metalnessmap, Re.fog, Re.lights, {
            emissive: {
                value: new Le(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: mt.meshphysical_vert,
        fragmentShader: mt.meshphysical_frag
    },
    toon: {
        uniforms: ui([Re.common, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.gradientmap, Re.fog, Re.lights, {
            emissive: {
                value: new Le(0)
            }
        }]),
        vertexShader: mt.meshtoon_vert,
        fragmentShader: mt.meshtoon_frag
    },
    matcap: {
        uniforms: ui([Re.common, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: mt.meshmatcap_vert,
        fragmentShader: mt.meshmatcap_frag
    },
    points: {
        uniforms: ui([Re.points, Re.fog]),
        vertexShader: mt.points_vert,
        fragmentShader: mt.points_frag
    },
    dashed: {
        uniforms: ui([Re.common, Re.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: mt.linedashed_vert,
        fragmentShader: mt.linedashed_frag
    },
    depth: {
        uniforms: ui([Re.common, Re.displacementmap]),
        vertexShader: mt.depth_vert,
        fragmentShader: mt.depth_frag
    },
    normal: {
        uniforms: ui([Re.common, Re.bumpmap, Re.normalmap, Re.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: mt.meshnormal_vert,
        fragmentShader: mt.meshnormal_frag
    },
    sprite: {
        uniforms: ui([Re.sprite, Re.fog]),
        vertexShader: mt.sprite_vert,
        fragmentShader: mt.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new hi
            },
            t2D: {
                value: null
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: mt.background_vert,
        fragmentShader: mt.background_frag
    },
    backgroundCube: {
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            backgroundBlurriness: {
                value: 0
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: mt.backgroundCube_vert,
        fragmentShader: mt.backgroundCube_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: mt.cube_vert,
        fragmentShader: mt.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: mt.equirect_vert,
        fragmentShader: mt.equirect_frag
    },
    distanceRGBA: {
        uniforms: ui([Re.common, Re.displacementmap, {
            referencePosition: {
                value: new D
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: mt.distanceRGBA_vert,
        fragmentShader: mt.distanceRGBA_frag
    },
    shadow: {
        uniforms: ui([Re.lights, Re.fog, {
            color: {
                value: new Le(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: mt.shadow_vert,
        fragmentShader: mt.shadow_frag
    }
};
Lr.physical = {
    uniforms: ui([Lr.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatNormalScale: {
            value: new pe(1,1)
        },
        clearcoatNormalMap: {
            value: null
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new Le(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionSamplerSize: {
            value: new pe
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new Le(0)
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularColor: {
            value: new Le(1,1,1)
        },
        specularColorMap: {
            value: null
        }
    }]),
    vertexShader: mt.meshphysical_vert,
    fragmentShader: mt.meshphysical_frag
};
const Bp = {
    r: 0,
    b: 0,
    g: 0
};
function R5(n, e, t, i, r, s, o) {
    const a = new Le(0);
    let l = s === !0 ? 0 : 1, c, d, h = null, p = 0, m = null;
    function y(_, x) {
        let A = !1
          , M = x.isScene === !0 ? x.background : null;
        M && M.isTexture && (M = (x.backgroundBlurriness > 0 ? t : e).get(M));
        const S = n.xr
          , T = S.getSession && S.getSession();
        T && T.environmentBlendMode === "additive" && (M = null),
        M === null ? v(a, l) : M && M.isColor && (v(M, 1),
        A = !0),
        (n.autoClear || A) && n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil),
        M && (M.isCubeTexture || M.mapping === qu) ? (d === void 0 && (d = new Un(new ia(1,1,1),new us({
            name: "BackgroundCubeMaterial",
            uniforms: zu(Lr.backgroundCube.uniforms),
            vertexShader: Lr.backgroundCube.vertexShader,
            fragmentShader: Lr.backgroundCube.fragmentShader,
            side: Bi,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        d.geometry.deleteAttribute("normal"),
        d.geometry.deleteAttribute("uv"),
        d.onBeforeRender = function(P, R, E) {
            this.matrixWorld.copyPosition(E.matrixWorld)
        }
        ,
        Object.defineProperty(d.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        r.update(d)),
        d.material.uniforms.envMap.value = M,
        d.material.uniforms.flipEnvMap.value = M.isCubeTexture && M.isRenderTargetTexture === !1 ? -1 : 1,
        d.material.uniforms.backgroundBlurriness.value = x.backgroundBlurriness,
        d.material.uniforms.backgroundIntensity.value = x.backgroundIntensity,
        d.material.toneMapped = M.encoding !== Et,
        (h !== M || p !== M.version || m !== n.toneMapping) && (d.material.needsUpdate = !0,
        h = M,
        p = M.version,
        m = n.toneMapping),
        d.layers.enableAll(),
        _.unshift(d, d.geometry, d.material, 0, 0, null)) : M && M.isTexture && (c === void 0 && (c = new Un(new $u(2,2),new us({
            name: "BackgroundMaterial",
            uniforms: zu(Lr.background.uniforms),
            vertexShader: Lr.background.vertexShader,
            fragmentShader: Lr.background.fragmentShader,
            side: as,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        c.geometry.deleteAttribute("normal"),
        Object.defineProperty(c.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        r.update(c)),
        c.material.uniforms.t2D.value = M,
        c.material.uniforms.backgroundIntensity.value = x.backgroundIntensity,
        c.material.toneMapped = M.encoding !== Et,
        M.matrixAutoUpdate === !0 && M.updateMatrix(),
        c.material.uniforms.uvTransform.value.copy(M.matrix),
        (h !== M || p !== M.version || m !== n.toneMapping) && (c.material.needsUpdate = !0,
        h = M,
        p = M.version,
        m = n.toneMapping),
        c.layers.enableAll(),
        _.unshift(c, c.geometry, c.material, 0, 0, null))
    }
    function v(_, x) {
        _.getRGB(Bp, pB(n)),
        i.buffers.color.setClear(Bp.r, Bp.g, Bp.b, x, o)
    }
    return {
        getClearColor: function() {
            return a
        },
        setClearColor: function(_, x=1) {
            a.set(_),
            l = x,
            v(a, l)
        },
        getClearAlpha: function() {
            return l
        },
        setClearAlpha: function(_) {
            l = _,
            v(a, l)
        },
        render: y
    }
}
function L5(n, e, t, i) {
    const r = n.getParameter(34921)
      , s = i.isWebGL2 ? null : e.get("OES_vertex_array_object")
      , o = i.isWebGL2 || s !== null
      , a = {}
      , l = _(null);
    let c = l
      , d = !1;
    function h(G, X, ee, ie, F) {
        let V = !1;
        if (o) {
            const j = v(ie, ee, X);
            c !== j && (c = j,
            m(c.object)),
            V = x(G, ie, ee, F),
            V && A(G, ie, ee, F)
        } else {
            const j = X.wireframe === !0;
            (c.geometry !== ie.id || c.program !== ee.id || c.wireframe !== j) && (c.geometry = ie.id,
            c.program = ee.id,
            c.wireframe = j,
            V = !0)
        }
        F !== null && t.update(F, 34963),
        (V || d) && (d = !1,
        E(G, X, ee, ie),
        F !== null && n.bindBuffer(34963, t.get(F).buffer))
    }
    function p() {
        return i.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES()
    }
    function m(G) {
        return i.isWebGL2 ? n.bindVertexArray(G) : s.bindVertexArrayOES(G)
    }
    function y(G) {
        return i.isWebGL2 ? n.deleteVertexArray(G) : s.deleteVertexArrayOES(G)
    }
    function v(G, X, ee) {
        const ie = ee.wireframe === !0;
        let F = a[G.id];
        F === void 0 && (F = {},
        a[G.id] = F);
        let V = F[X.id];
        V === void 0 && (V = {},
        F[X.id] = V);
        let j = V[ie];
        return j === void 0 && (j = _(p()),
        V[ie] = j),
        j
    }
    function _(G) {
        const X = []
          , ee = []
          , ie = [];
        for (let F = 0; F < r; F++)
            X[F] = 0,
            ee[F] = 0,
            ie[F] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: X,
            enabledAttributes: ee,
            attributeDivisors: ie,
            object: G,
            attributes: {},
            index: null
        }
    }
    function x(G, X, ee, ie) {
        const F = c.attributes
          , V = X.attributes;
        let j = 0;
        const re = ee.getAttributes();
        for (const H in re)
            if (re[H].location >= 0) {
                const ye = F[H];
                let ve = V[H];
                if (ve === void 0 && (H === "instanceMatrix" && G.instanceMatrix && (ve = G.instanceMatrix),
                H === "instanceColor" && G.instanceColor && (ve = G.instanceColor)),
                ye === void 0 || ye.attribute !== ve || ve && ye.data !== ve.data)
                    return !0;
                j++
            }
        return c.attributesNum !== j || c.index !== ie
    }
    function A(G, X, ee, ie) {
        const F = {}
          , V = X.attributes;
        let j = 0;
        const re = ee.getAttributes();
        for (const H in re)
            if (re[H].location >= 0) {
                let ye = V[H];
                ye === void 0 && (H === "instanceMatrix" && G.instanceMatrix && (ye = G.instanceMatrix),
                H === "instanceColor" && G.instanceColor && (ye = G.instanceColor));
                const ve = {};
                ve.attribute = ye,
                ye && ye.data && (ve.data = ye.data),
                F[H] = ve,
                j++
            }
        c.attributes = F,
        c.attributesNum = j,
        c.index = ie
    }
    function M() {
        const G = c.newAttributes;
        for (let X = 0, ee = G.length; X < ee; X++)
            G[X] = 0
    }
    function S(G) {
        T(G, 0)
    }
    function T(G, X) {
        const ee = c.newAttributes
          , ie = c.enabledAttributes
          , F = c.attributeDivisors;
        ee[G] = 1,
        ie[G] === 0 && (n.enableVertexAttribArray(G),
        ie[G] = 1),
        F[G] !== X && ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](G, X),
        F[G] = X)
    }
    function P() {
        const G = c.newAttributes
          , X = c.enabledAttributes;
        for (let ee = 0, ie = X.length; ee < ie; ee++)
            X[ee] !== G[ee] && (n.disableVertexAttribArray(ee),
            X[ee] = 0)
    }
    function R(G, X, ee, ie, F, V) {
        i.isWebGL2 === !0 && (ee === 5124 || ee === 5125) ? n.vertexAttribIPointer(G, X, ee, F, V) : n.vertexAttribPointer(G, X, ee, ie, F, V)
    }
    function E(G, X, ee, ie) {
        if (i.isWebGL2 === !1 && (G.isInstancedMesh || ie.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
            return;
        M();
        const F = ie.attributes
          , V = ee.getAttributes()
          , j = X.defaultAttributeValues;
        for (const re in V) {
            const H = V[re];
            if (H.location >= 0) {
                let se = F[re];
                if (se === void 0 && (re === "instanceMatrix" && G.instanceMatrix && (se = G.instanceMatrix),
                re === "instanceColor" && G.instanceColor && (se = G.instanceColor)),
                se !== void 0) {
                    const ye = se.normalized
                      , ve = se.itemSize
                      , q = t.get(se);
                    if (q === void 0)
                        continue;
                    const Ie = q.buffer
                      , Ne = q.type
                      , He = q.bytesPerElement;
                    if (se.isInterleavedBufferAttribute) {
                        const Me = se.data
                          , De = Me.stride
                          , de = se.offset;
                        if (Me.isInstancedInterleavedBuffer) {
                            for (let ae = 0; ae < H.locationSize; ae++)
                                T(H.location + ae, Me.meshPerAttribute);
                            G.isInstancedMesh !== !0 && ie._maxInstanceCount === void 0 && (ie._maxInstanceCount = Me.meshPerAttribute * Me.count)
                        } else
                            for (let ae = 0; ae < H.locationSize; ae++)
                                S(H.location + ae);
                        n.bindBuffer(34962, Ie);
                        for (let ae = 0; ae < H.locationSize; ae++)
                            R(H.location + ae, ve / H.locationSize, Ne, ye, De * He, (de + ve / H.locationSize * ae) * He)
                    } else {
                        if (se.isInstancedBufferAttribute) {
                            for (let Me = 0; Me < H.locationSize; Me++)
                                T(H.location + Me, se.meshPerAttribute);
                            G.isInstancedMesh !== !0 && ie._maxInstanceCount === void 0 && (ie._maxInstanceCount = se.meshPerAttribute * se.count)
                        } else
                            for (let Me = 0; Me < H.locationSize; Me++)
                                S(H.location + Me);
                        n.bindBuffer(34962, Ie);
                        for (let Me = 0; Me < H.locationSize; Me++)
                            R(H.location + Me, ve / H.locationSize, Ne, ye, ve * He, ve / H.locationSize * Me * He)
                    }
                } else if (j !== void 0) {
                    const ye = j[re];
                    if (ye !== void 0)
                        switch (ye.length) {
                        case 2:
                            n.vertexAttrib2fv(H.location, ye);
                            break;
                        case 3:
                            n.vertexAttrib3fv(H.location, ye);
                            break;
                        case 4:
                            n.vertexAttrib4fv(H.location, ye);
                            break;
                        default:
                            n.vertexAttrib1fv(H.location, ye)
                        }
                }
            }
        }
        P()
    }
    function B() {
        Z();
        for (const G in a) {
            const X = a[G];
            for (const ee in X) {
                const ie = X[ee];
                for (const F in ie)
                    y(ie[F].object),
                    delete ie[F];
                delete X[ee]
            }
            delete a[G]
        }
    }
    function L(G) {
        if (a[G.id] === void 0)
            return;
        const X = a[G.id];
        for (const ee in X) {
            const ie = X[ee];
            for (const F in ie)
                y(ie[F].object),
                delete ie[F];
            delete X[ee]
        }
        delete a[G.id]
    }
    function z(G) {
        for (const X in a) {
            const ee = a[X];
            if (ee[G.id] === void 0)
                continue;
            const ie = ee[G.id];
            for (const F in ie)
                y(ie[F].object),
                delete ie[F];
            delete ee[G.id]
        }
    }
    function Z() {
        J(),
        d = !0,
        c !== l && (c = l,
        m(c.object))
    }
    function J() {
        l.geometry = null,
        l.program = null,
        l.wireframe = !1
    }
    return {
        setup: h,
        reset: Z,
        resetDefaultState: J,
        dispose: B,
        releaseStatesOfGeometry: L,
        releaseStatesOfProgram: z,
        initAttributes: M,
        enableAttribute: S,
        disableUnusedAttributes: P
    }
}
function I5(n, e, t, i) {
    const r = i.isWebGL2;
    let s;
    function o(c) {
        s = c
    }
    function a(c, d) {
        n.drawArrays(s, c, d),
        t.update(d, s, 1)
    }
    function l(c, d, h) {
        if (h === 0)
            return;
        let p, m;
        if (r)
            p = n,
            m = "drawArraysInstanced";
        else if (p = e.get("ANGLE_instanced_arrays"),
        m = "drawArraysInstancedANGLE",
        p === null) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        p[m](s, c, d, h),
        t.update(d, s, h)
    }
    this.setMode = o,
    this.render = a,
    this.renderInstances = l
}
function D5(n, e, t) {
    let i;
    function r() {
        if (i !== void 0)
            return i;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const R = e.get("EXT_texture_filter_anisotropic");
            i = n.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            i = 0;
        return i
    }
    function s(R) {
        if (R === "highp") {
            if (n.getShaderPrecisionFormat(35633, 36338).precision > 0 && n.getShaderPrecisionFormat(35632, 36338).precision > 0)
                return "highp";
            R = "mediump"
        }
        return R === "mediump" && n.getShaderPrecisionFormat(35633, 36337).precision > 0 && n.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
    }
    const o = typeof WebGL2RenderingContext < "u" && n instanceof WebGL2RenderingContext;
    let a = t.precision !== void 0 ? t.precision : "highp";
    const l = s(a);
    l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."),
    a = l);
    const c = o || e.has("WEBGL_draw_buffers")
      , d = t.logarithmicDepthBuffer === !0
      , h = n.getParameter(34930)
      , p = n.getParameter(35660)
      , m = n.getParameter(3379)
      , y = n.getParameter(34076)
      , v = n.getParameter(34921)
      , _ = n.getParameter(36347)
      , x = n.getParameter(36348)
      , A = n.getParameter(36349)
      , M = p > 0
      , S = o || e.has("OES_texture_float")
      , T = M && S
      , P = o ? n.getParameter(36183) : 0;
    return {
        isWebGL2: o,
        drawBuffers: c,
        getMaxAnisotropy: r,
        getMaxPrecision: s,
        precision: a,
        logarithmicDepthBuffer: d,
        maxTextures: h,
        maxVertexTextures: p,
        maxTextureSize: m,
        maxCubemapSize: y,
        maxAttributes: v,
        maxVertexUniforms: _,
        maxVaryings: x,
        maxFragmentUniforms: A,
        vertexTextures: M,
        floatFragmentTextures: S,
        floatVertexTextures: T,
        maxSamples: P
    }
}
function F5(n) {
    const e = this;
    let t = null
      , i = 0
      , r = !1
      , s = !1;
    const o = new _o
      , a = new hi
      , l = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = l,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(h, p) {
        const m = h.length !== 0 || p || i !== 0 || r;
        return r = p,
        i = h.length,
        m
    }
    ,
    this.beginShadows = function() {
        s = !0,
        d(null)
    }
    ,
    this.endShadows = function() {
        s = !1
    }
    ,
    this.setGlobalState = function(h, p) {
        t = d(h, p, 0)
    }
    ,
    this.setState = function(h, p, m) {
        const y = h.clippingPlanes
          , v = h.clipIntersection
          , _ = h.clipShadows
          , x = n.get(h);
        if (!r || y === null || y.length === 0 || s && !_)
            s ? d(null) : c();
        else {
            const A = s ? 0 : i
              , M = A * 4;
            let S = x.clippingState || null;
            l.value = S,
            S = d(y, p, M, m);
            for (let T = 0; T !== M; ++T)
                S[T] = t[T];
            x.clippingState = S,
            this.numIntersection = v ? this.numPlanes : 0,
            this.numPlanes += A
        }
    }
    ;
    function c() {
        l.value !== t && (l.value = t,
        l.needsUpdate = i > 0),
        e.numPlanes = i,
        e.numIntersection = 0
    }
    function d(h, p, m, y) {
        const v = h !== null ? h.length : 0;
        let _ = null;
        if (v !== 0) {
            if (_ = l.value,
            y !== !0 || _ === null) {
                const x = m + v * 4
                  , A = p.matrixWorldInverse;
                a.getNormalMatrix(A),
                (_ === null || _.length < x) && (_ = new Float32Array(x));
                for (let M = 0, S = m; M !== v; ++M,
                S += 4)
                    o.copy(h[M]).applyMatrix4(A, a),
                    o.normal.toArray(_, S),
                    _[S + 3] = o.constant
            }
            l.value = _,
            l.needsUpdate = !0
        }
        return e.numPlanes = v,
        e.numIntersection = 0,
        _
    }
}
function k5(n) {
    let e = new WeakMap;
    function t(o, a) {
        return a === qf ? o.mapping = Vo : a === $f && (o.mapping = Wo),
        o
    }
    function i(o) {
        if (o && o.isTexture && o.isRenderTargetTexture === !1) {
            const a = o.mapping;
            if (a === qf || a === $f)
                if (e.has(o)) {
                    const l = e.get(o).texture;
                    return t(l, o.mapping)
                } else {
                    const l = o.image;
                    if (l && l.height > 0) {
                        const c = new SA(l.height / 2);
                        return c.fromEquirectangularTexture(n, o),
                        e.set(o, c),
                        o.addEventListener("dispose", r),
                        t(c.texture, o.mapping)
                    } else
                        return null
                }
        }
        return o
    }
    function r(o) {
        const a = o.target;
        a.removeEventListener("dispose", r);
        const l = e.get(a);
        l !== void 0 && (e.delete(a),
        l.dispose())
    }
    function s() {
        e = new WeakMap
    }
    return {
        get: i,
        dispose: s
    }
}
class Nr extends bd {
    constructor(e=-1, t=1, i=1, r=-1, s=.1, o=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = i,
        this.bottom = r,
        this.near = s,
        this.far = o,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, t, i, r, s, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = i,
        this.view.offsetY = r,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , t = (this.top - this.bottom) / (2 * this.zoom)
          , i = (this.right + this.left) / 2
          , r = (this.top + this.bottom) / 2;
        let s = i - e
          , o = i + e
          , a = r + t
          , l = r - t;
        if (this.view !== null && this.view.enabled) {
            const c = (this.right - this.left) / this.view.fullWidth / this.zoom
              , d = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += c * this.view.offsetX,
            o = s + c * this.view.width,
            a -= d * this.view.offsetY,
            l = a - d * this.view.height
        }
        this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t
    }
}
const pu = 4
  , QC = [.125, .215, .35, .446, .526, .582]
  , Fa = 20
  , yv = new Nr
  , ZC = new Le;
let vv = null;
const Ba = (1 + Math.sqrt(5)) / 2
  , Jl = 1 / Ba
  , qC = [new D(1,1,1), new D(-1,1,1), new D(1,1,-1), new D(-1,1,-1), new D(0,Ba,Jl), new D(0,Ba,-Jl), new D(Jl,0,Ba), new D(-Jl,0,Ba), new D(Ba,Jl,0), new D(-Ba,Jl,0)];
class L1 {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t=0, i=.1, r=100) {
        vv = this._renderer.getRenderTarget(),
        this._setSize(256);
        const s = this._allocateTargets();
        return s.depthBuffer = !0,
        this._sceneToCubeUV(e, i, r, s),
        t > 0 && this._blur(s, 0, 0, t),
        this._applyPMREM(s),
        this._cleanup(s),
        s
    }
    fromEquirectangular(e, t=null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t=null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = tE(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = eE(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(vv),
        e.scissorTest = !1,
        Rp(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === Vo || e.mapping === Wo ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        vv = this._renderer.getRenderTarget();
        const i = t || this._allocateTargets();
        return this._textureToCubeUV(e, i),
        this._applyPMREM(i),
        this._cleanup(i),
        i
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , t = 4 * this._cubeSize
          , i = {
            magFilter: nn,
            minFilter: nn,
            generateMipmaps: !1,
            type: Nu,
            format: Ci,
            encoding: Xs,
            depthBuffer: !1
        }
          , r = $C(e, t, i);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = $C(e, t, i);
            const {_lodMax: s} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = N5(s)),
            this._blurMaterial = O5(s, e, t)
        }
        return r
    }
    _compileMaterial(e) {
        const t = new Un(this._lodPlanes[0],e);
        this._renderer.compile(t, yv)
    }
    _sceneToCubeUV(e, t, i, r) {
        const a = new Ht(90,1,t,i)
          , l = [1, -1, 1, 1, 1, 1]
          , c = [1, 1, 1, -1, -1, -1]
          , d = this._renderer
          , h = d.autoClear
          , p = d.toneMapping;
        d.getClearColor(ZC),
        d.toneMapping = kr,
        d.autoClear = !1;
        const m = new Gi({
            name: "PMREM.Background",
            side: Bi,
            depthWrite: !1,
            depthTest: !1
        })
          , y = new Un(new ia,m);
        let v = !1;
        const _ = e.background;
        _ ? _.isColor && (m.color.copy(_),
        e.background = null,
        v = !0) : (m.color.copy(ZC),
        v = !0);
        for (let x = 0; x < 6; x++) {
            const A = x % 3;
            A === 0 ? (a.up.set(0, l[x], 0),
            a.lookAt(c[x], 0, 0)) : A === 1 ? (a.up.set(0, 0, l[x]),
            a.lookAt(0, c[x], 0)) : (a.up.set(0, l[x], 0),
            a.lookAt(0, 0, c[x]));
            const M = this._cubeSize;
            Rp(r, A * M, x > 2 ? M : 0, M, M),
            d.setRenderTarget(r),
            v && d.render(y, a),
            d.render(e, a)
        }
        y.geometry.dispose(),
        y.material.dispose(),
        d.toneMapping = p,
        d.autoClear = h,
        e.background = _
    }
    _textureToCubeUV(e, t) {
        const i = this._renderer
          , r = e.mapping === Vo || e.mapping === Wo;
        r ? (this._cubemapMaterial === null && (this._cubemapMaterial = tE()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = eE());
        const s = r ? this._cubemapMaterial : this._equirectMaterial
          , o = new Un(this._lodPlanes[0],s)
          , a = s.uniforms;
        a.envMap.value = e;
        const l = this._cubeSize;
        Rp(t, 0, 0, 3 * l, 2 * l),
        i.setRenderTarget(t),
        i.render(o, yv)
    }
    _applyPMREM(e) {
        const t = this._renderer
          , i = t.autoClear;
        t.autoClear = !1;
        for (let r = 1; r < this._lodPlanes.length; r++) {
            const s = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1])
              , o = qC[(r - 1) % qC.length];
            this._blur(e, r - 1, r, s, o)
        }
        t.autoClear = i
    }
    _blur(e, t, i, r, s) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, t, i, r, "latitudinal", s),
        this._halfBlur(o, e, i, i, r, "longitudinal", s)
    }
    _halfBlur(e, t, i, r, s, o, a) {
        const l = this._renderer
          , c = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const d = 3
          , h = new Un(this._lodPlanes[r],c)
          , p = c.uniforms
          , m = this._sizeLods[i] - 1
          , y = isFinite(s) ? Math.PI / (2 * m) : 2 * Math.PI / (2 * Fa - 1)
          , v = s / y
          , _ = isFinite(s) ? 1 + Math.floor(d * v) : Fa;
        _ > Fa && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${_} samples when the maximum is set to ${Fa}`);
        const x = [];
        let A = 0;
        for (let R = 0; R < Fa; ++R) {
            const E = R / v
              , B = Math.exp(-E * E / 2);
            x.push(B),
            R === 0 ? A += B : R < _ && (A += 2 * B)
        }
        for (let R = 0; R < x.length; R++)
            x[R] = x[R] / A;
        p.envMap.value = e.texture,
        p.samples.value = _,
        p.weights.value = x,
        p.latitudinal.value = o === "latitudinal",
        a && (p.poleAxis.value = a);
        const {_lodMax: M} = this;
        p.dTheta.value = y,
        p.mipInt.value = M - i;
        const S = this._sizeLods[r]
          , T = 3 * S * (r > M - pu ? r - M + pu : 0)
          , P = 4 * (this._cubeSize - S);
        Rp(t, T, P, 3 * S, 2 * S),
        l.setRenderTarget(t),
        l.render(h, yv)
    }
}
function N5(n) {
    const e = []
      , t = []
      , i = [];
    let r = n;
    const s = n - pu + 1 + QC.length;
    for (let o = 0; o < s; o++) {
        const a = Math.pow(2, r);
        t.push(a);
        let l = 1 / a;
        o > n - pu ? l = QC[o - n + pu - 1] : o === 0 && (l = 0),
        i.push(l);
        const c = 1 / (a - 2)
          , d = -c
          , h = 1 + c
          , p = [d, d, h, d, h, h, d, d, h, h, d, h]
          , m = 6
          , y = 6
          , v = 3
          , _ = 2
          , x = 1
          , A = new Float32Array(v * y * m)
          , M = new Float32Array(_ * y * m)
          , S = new Float32Array(x * y * m);
        for (let P = 0; P < m; P++) {
            const R = P % 3 * 2 / 3 - 1
              , E = P > 2 ? 0 : -1
              , B = [R, E, 0, R + 2 / 3, E, 0, R + 2 / 3, E + 1, 0, R, E, 0, R + 2 / 3, E + 1, 0, R, E + 1, 0];
            A.set(B, v * y * P),
            M.set(p, _ * y * P);
            const L = [P, P, P, P, P, P];
            S.set(L, x * y * P)
        }
        const T = new ct;
        T.setAttribute("position", new Ft(A,v)),
        T.setAttribute("uv", new Ft(M,_)),
        T.setAttribute("faceIndex", new Ft(S,x)),
        e.push(T),
        r > pu && r--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: i
    }
}
function $C(n, e, t) {
    const i = new Ur(n,e,t);
    return i.texture.mapping = qu,
    i.texture.name = "PMREM.cubeUv",
    i.scissorTest = !0,
    i
}
function Rp(n, e, t, i, r) {
    n.viewport.set(e, t, i, r),
    n.scissor.set(e, t, i, r)
}
function O5(n, e, t) {
    const i = new Float32Array(Fa)
      , r = new D(0,1,0);
    return new us({
        name: "SphericalGaussianBlur",
        defines: {
            n: Fa,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${n}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: i
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: r
            }
        },
        vertexShader: CA(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: Us,
        depthTest: !1,
        depthWrite: !1
    })
}
function eE() {
    return new us({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: CA(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: Us,
        depthTest: !1,
        depthWrite: !1
    })
}
function tE() {
    return new us({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: CA(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: Us,
        depthTest: !1,
        depthWrite: !1
    })
}
function CA() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function U5(n) {
    let e = new WeakMap
      , t = null;
    function i(a) {
        if (a && a.isTexture) {
            const l = a.mapping
              , c = l === qf || l === $f
              , d = l === Vo || l === Wo;
            if (c || d)
                if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
                    a.needsPMREMUpdate = !1;
                    let h = e.get(a);
                    return t === null && (t = new L1(n)),
                    h = c ? t.fromEquirectangular(a, h) : t.fromCubemap(a, h),
                    e.set(a, h),
                    h.texture
                } else {
                    if (e.has(a))
                        return e.get(a).texture;
                    {
                        const h = a.image;
                        if (c && h && h.height > 0 || d && h && r(h)) {
                            t === null && (t = new L1(n));
                            const p = c ? t.fromEquirectangular(a) : t.fromCubemap(a);
                            return e.set(a, p),
                            a.addEventListener("dispose", s),
                            p.texture
                        } else
                            return null
                    }
                }
        }
        return a
    }
    function r(a) {
        let l = 0;
        const c = 6;
        for (let d = 0; d < c; d++)
            a[d] !== void 0 && l++;
        return l === c
    }
    function s(a) {
        const l = a.target;
        l.removeEventListener("dispose", s);
        const c = e.get(l);
        c !== void 0 && (e.delete(l),
        c.dispose())
    }
    function o() {
        e = new WeakMap,
        t !== null && (t.dispose(),
        t = null)
    }
    return {
        get: i,
        dispose: o
    }
}
function z5(n) {
    const e = {};
    function t(i) {
        if (e[i] !== void 0)
            return e[i];
        let r;
        switch (i) {
        case "WEBGL_depth_texture":
            r = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            r = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            r = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            r = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            r = n.getExtension(i)
        }
        return e[i] = r,
        r
    }
    return {
        has: function(i) {
            return t(i) !== null
        },
        init: function(i) {
            i.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"),
            t("OES_texture_float"),
            t("OES_texture_half_float"),
            t("OES_texture_half_float_linear"),
            t("OES_standard_derivatives"),
            t("OES_element_index_uint"),
            t("OES_vertex_array_object"),
            t("ANGLE_instanced_arrays")),
            t("OES_texture_float_linear"),
            t("EXT_color_buffer_half_float"),
            t("WEBGL_multisampled_render_to_texture")
        },
        get: function(i) {
            const r = t(i);
            return r === null && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."),
            r
        }
    }
}
function G5(n, e, t, i) {
    const r = {}
      , s = new WeakMap;
    function o(h) {
        const p = h.target;
        p.index !== null && e.remove(p.index);
        for (const y in p.attributes)
            e.remove(p.attributes[y]);
        p.removeEventListener("dispose", o),
        delete r[p.id];
        const m = s.get(p);
        m && (e.remove(m),
        s.delete(p)),
        i.releaseStatesOfGeometry(p),
        p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount,
        t.memory.geometries--
    }
    function a(h, p) {
        return r[p.id] === !0 || (p.addEventListener("dispose", o),
        r[p.id] = !0,
        t.memory.geometries++),
        p
    }
    function l(h) {
        const p = h.attributes;
        for (const y in p)
            e.update(p[y], 34962);
        const m = h.morphAttributes;
        for (const y in m) {
            const v = m[y];
            for (let _ = 0, x = v.length; _ < x; _++)
                e.update(v[_], 34962)
        }
    }
    function c(h) {
        const p = []
          , m = h.index
          , y = h.attributes.position;
        let v = 0;
        if (m !== null) {
            const A = m.array;
            v = m.version;
            for (let M = 0, S = A.length; M < S; M += 3) {
                const T = A[M + 0]
                  , P = A[M + 1]
                  , R = A[M + 2];
                p.push(T, P, P, R, R, T)
            }
        } else {
            const A = y.array;
            v = y.version;
            for (let M = 0, S = A.length / 3 - 1; M < S; M += 3) {
                const T = M + 0
                  , P = M + 1
                  , R = M + 2;
                p.push(T, P, P, R, R, T)
            }
        }
        const _ = new (dB(p) ? MA : AA)(p,1);
        _.version = v;
        const x = s.get(h);
        x && e.remove(x),
        s.set(h, _)
    }
    function d(h) {
        const p = s.get(h);
        if (p) {
            const m = h.index;
            m !== null && p.version < m.version && c(h)
        } else
            c(h);
        return s.get(h)
    }
    return {
        get: a,
        update: l,
        getWireframeAttribute: d
    }
}
function H5(n, e, t, i) {
    const r = i.isWebGL2;
    let s;
    function o(p) {
        s = p
    }
    let a, l;
    function c(p) {
        a = p.type,
        l = p.bytesPerElement
    }
    function d(p, m) {
        n.drawElements(s, m, a, p * l),
        t.update(m, s, 1)
    }
    function h(p, m, y) {
        if (y === 0)
            return;
        let v, _;
        if (r)
            v = n,
            _ = "drawElementsInstanced";
        else if (v = e.get("ANGLE_instanced_arrays"),
        _ = "drawElementsInstancedANGLE",
        v === null) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        v[_](s, m, a, p * l, y),
        t.update(m, s, y)
    }
    this.setMode = o,
    this.setIndex = c,
    this.render = d,
    this.renderInstances = h
}
function V5(n) {
    const e = {
        geometries: 0,
        textures: 0
    }
      , t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function i(s, o, a) {
        switch (t.calls++,
        o) {
        case 4:
            t.triangles += a * (s / 3);
            break;
        case 1:
            t.lines += a * (s / 2);
            break;
        case 3:
            t.lines += a * (s - 1);
            break;
        case 2:
            t.lines += a * s;
            break;
        case 0:
            t.points += a * s;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", o);
            break
        }
    }
    function r() {
        t.frame++,
        t.calls = 0,
        t.triangles = 0,
        t.points = 0,
        t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: r,
        update: i
    }
}
function W5(n, e) {
    return n[0] - e[0]
}
function j5(n, e) {
    return Math.abs(e[1]) - Math.abs(n[1])
}
function J5(n, e, t) {
    const i = {}
      , r = new Float32Array(8)
      , s = new WeakMap
      , o = new Nt
      , a = [];
    for (let c = 0; c < 8; c++)
        a[c] = [c, 0];
    function l(c, d, h, p) {
        const m = c.morphTargetInfluences;
        if (e.isWebGL2 === !0) {
            const y = d.morphAttributes.position || d.morphAttributes.normal || d.morphAttributes.color
              , v = y !== void 0 ? y.length : 0;
            let _ = s.get(d);
            if (_ === void 0 || _.count !== v) {
                let X = function() {
                    J.dispose(),
                    s.delete(d),
                    d.removeEventListener("dispose", X)
                };
                _ !== void 0 && _.texture.dispose();
                const M = d.morphAttributes.position !== void 0
                  , S = d.morphAttributes.normal !== void 0
                  , T = d.morphAttributes.color !== void 0
                  , P = d.morphAttributes.position || []
                  , R = d.morphAttributes.normal || []
                  , E = d.morphAttributes.color || [];
                let B = 0;
                M === !0 && (B = 1),
                S === !0 && (B = 2),
                T === !0 && (B = 3);
                let L = d.attributes.position.count * B
                  , z = 1;
                L > e.maxTextureSize && (z = Math.ceil(L / e.maxTextureSize),
                L = e.maxTextureSize);
                const Z = new Float32Array(L * z * 4 * v)
                  , J = new Qg(Z,L,z,v);
                J.type = Ds,
                J.needsUpdate = !0;
                const G = B * 4;
                for (let ee = 0; ee < v; ee++) {
                    const ie = P[ee]
                      , F = R[ee]
                      , V = E[ee]
                      , j = L * z * 4 * ee;
                    for (let re = 0; re < ie.count; re++) {
                        const H = re * G;
                        M === !0 && (o.fromBufferAttribute(ie, re),
                        Z[j + H + 0] = o.x,
                        Z[j + H + 1] = o.y,
                        Z[j + H + 2] = o.z,
                        Z[j + H + 3] = 0),
                        S === !0 && (o.fromBufferAttribute(F, re),
                        Z[j + H + 4] = o.x,
                        Z[j + H + 5] = o.y,
                        Z[j + H + 6] = o.z,
                        Z[j + H + 7] = 0),
                        T === !0 && (o.fromBufferAttribute(V, re),
                        Z[j + H + 8] = o.x,
                        Z[j + H + 9] = o.y,
                        Z[j + H + 10] = o.z,
                        Z[j + H + 11] = V.itemSize === 4 ? o.w : 1)
                    }
                }
                _ = {
                    count: v,
                    texture: J,
                    size: new pe(L,z)
                },
                s.set(d, _),
                d.addEventListener("dispose", X)
            }
            let x = 0;
            for (let M = 0; M < m.length; M++)
                x += m[M];
            const A = d.morphTargetsRelative ? 1 : 1 - x;
            p.getUniforms().setValue(n, "morphTargetBaseInfluence", A),
            p.getUniforms().setValue(n, "morphTargetInfluences", m),
            p.getUniforms().setValue(n, "morphTargetsTexture", _.texture, t),
            p.getUniforms().setValue(n, "morphTargetsTextureSize", _.size)
        } else {
            const y = m === void 0 ? 0 : m.length;
            let v = i[d.id];
            if (v === void 0 || v.length !== y) {
                v = [];
                for (let S = 0; S < y; S++)
                    v[S] = [S, 0];
                i[d.id] = v
            }
            for (let S = 0; S < y; S++) {
                const T = v[S];
                T[0] = S,
                T[1] = m[S]
            }
            v.sort(j5);
            for (let S = 0; S < 8; S++)
                S < y && v[S][1] ? (a[S][0] = v[S][0],
                a[S][1] = v[S][1]) : (a[S][0] = Number.MAX_SAFE_INTEGER,
                a[S][1] = 0);
            a.sort(W5);
            const _ = d.morphAttributes.position
              , x = d.morphAttributes.normal;
            let A = 0;
            for (let S = 0; S < 8; S++) {
                const T = a[S]
                  , P = T[0]
                  , R = T[1];
                P !== Number.MAX_SAFE_INTEGER && R ? (_ && d.getAttribute("morphTarget" + S) !== _[P] && d.setAttribute("morphTarget" + S, _[P]),
                x && d.getAttribute("morphNormal" + S) !== x[P] && d.setAttribute("morphNormal" + S, x[P]),
                r[S] = R,
                A += R) : (_ && d.hasAttribute("morphTarget" + S) === !0 && d.deleteAttribute("morphTarget" + S),
                x && d.hasAttribute("morphNormal" + S) === !0 && d.deleteAttribute("morphNormal" + S),
                r[S] = 0)
            }
            const M = d.morphTargetsRelative ? 1 : 1 - A;
            p.getUniforms().setValue(n, "morphTargetBaseInfluence", M),
            p.getUniforms().setValue(n, "morphTargetInfluences", r)
        }
    }
    return {
        update: l
    }
}
function X5(n, e, t, i) {
    let r = new WeakMap;
    function s(l) {
        const c = i.render.frame
          , d = l.geometry
          , h = e.get(l, d);
        return r.get(h) !== c && (e.update(h),
        r.set(h, c)),
        l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a),
        t.update(l.instanceMatrix, 34962),
        l.instanceColor !== null && t.update(l.instanceColor, 34962)),
        h
    }
    function o() {
        r = new WeakMap
    }
    function a(l) {
        const c = l.target;
        c.removeEventListener("dispose", a),
        t.remove(c.instanceMatrix),
        c.instanceColor !== null && t.remove(c.instanceColor)
    }
    return {
        update: s,
        dispose: o
    }
}
const yB = new qt
  , vB = new Qg
  , xB = new _A
  , _B = new Pd
  , nE = []
  , iE = []
  , rE = new Float32Array(16)
  , sE = new Float32Array(9)
  , oE = new Float32Array(4);
function ec(n, e, t) {
    const i = n[0];
    if (i <= 0 || i > 0)
        return n;
    const r = e * t;
    let s = nE[r];
    if (s === void 0 && (s = new Float32Array(r),
    nE[r] = s),
    e !== 0) {
        i.toArray(s, 0);
        for (let o = 1, a = 0; o !== e; ++o)
            a += t,
            n[o].toArray(s, a)
    }
    return s
}
function Bn(n, e) {
    if (n.length !== e.length)
        return !1;
    for (let t = 0, i = n.length; t < i; t++)
        if (n[t] !== e[t])
            return !1;
    return !0
}
function Rn(n, e) {
    for (let t = 0, i = e.length; t < i; t++)
        n[t] = e[t]
}
function qg(n, e) {
    let t = iE[e];
    t === void 0 && (t = new Int32Array(e),
    iE[e] = t);
    for (let i = 0; i !== e; ++i)
        t[i] = n.allocateTextureUnit();
    return t
}
function K5(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1f(this.addr, e),
    t[0] = e)
}
function Y5(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Bn(t, e))
            return;
        n.uniform2fv(this.addr, e),
        Rn(t, e)
    }
}
function Q5(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b),
        t[0] = e.r,
        t[1] = e.g,
        t[2] = e.b);
    else {
        if (Bn(t, e))
            return;
        n.uniform3fv(this.addr, e),
        Rn(t, e)
    }
}
function Z5(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Bn(t, e))
            return;
        n.uniform4fv(this.addr, e),
        Rn(t, e)
    }
}
function q5(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (Bn(t, e))
            return;
        n.uniformMatrix2fv(this.addr, !1, e),
        Rn(t, e)
    } else {
        if (Bn(t, i))
            return;
        oE.set(i),
        n.uniformMatrix2fv(this.addr, !1, oE),
        Rn(t, i)
    }
}
function $5(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (Bn(t, e))
            return;
        n.uniformMatrix3fv(this.addr, !1, e),
        Rn(t, e)
    } else {
        if (Bn(t, i))
            return;
        sE.set(i),
        n.uniformMatrix3fv(this.addr, !1, sE),
        Rn(t, i)
    }
}
function eG(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (Bn(t, e))
            return;
        n.uniformMatrix4fv(this.addr, !1, e),
        Rn(t, e)
    } else {
        if (Bn(t, i))
            return;
        rE.set(i),
        n.uniformMatrix4fv(this.addr, !1, rE),
        Rn(t, i)
    }
}
function tG(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1i(this.addr, e),
    t[0] = e)
}
function nG(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Bn(t, e))
            return;
        n.uniform2iv(this.addr, e),
        Rn(t, e)
    }
}
function iG(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (Bn(t, e))
            return;
        n.uniform3iv(this.addr, e),
        Rn(t, e)
    }
}
function rG(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Bn(t, e))
            return;
        n.uniform4iv(this.addr, e),
        Rn(t, e)
    }
}
function sG(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1ui(this.addr, e),
    t[0] = e)
}
function oG(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Bn(t, e))
            return;
        n.uniform2uiv(this.addr, e),
        Rn(t, e)
    }
}
function aG(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (Bn(t, e))
            return;
        n.uniform3uiv(this.addr, e),
        Rn(t, e)
    }
}
function lG(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Bn(t, e))
            return;
        n.uniform4uiv(this.addr, e),
        Rn(t, e)
    }
}
function uG(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTexture2D(e || yB, r)
}
function cG(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTexture3D(e || xB, r)
}
function fG(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTextureCube(e || _B, r)
}
function dG(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTexture2DArray(e || vB, r)
}
function hG(n) {
    switch (n) {
    case 5126:
        return K5;
    case 35664:
        return Y5;
    case 35665:
        return Q5;
    case 35666:
        return Z5;
    case 35674:
        return q5;
    case 35675:
        return $5;
    case 35676:
        return eG;
    case 5124:
    case 35670:
        return tG;
    case 35667:
    case 35671:
        return nG;
    case 35668:
    case 35672:
        return iG;
    case 35669:
    case 35673:
        return rG;
    case 5125:
        return sG;
    case 36294:
        return oG;
    case 36295:
        return aG;
    case 36296:
        return lG;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return uG;
    case 35679:
    case 36299:
    case 36307:
        return cG;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return fG;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return dG
    }
}
function pG(n, e) {
    n.uniform1fv(this.addr, e)
}
function mG(n, e) {
    const t = ec(e, this.size, 2);
    n.uniform2fv(this.addr, t)
}
function gG(n, e) {
    const t = ec(e, this.size, 3);
    n.uniform3fv(this.addr, t)
}
function yG(n, e) {
    const t = ec(e, this.size, 4);
    n.uniform4fv(this.addr, t)
}
function vG(n, e) {
    const t = ec(e, this.size, 4);
    n.uniformMatrix2fv(this.addr, !1, t)
}
function xG(n, e) {
    const t = ec(e, this.size, 9);
    n.uniformMatrix3fv(this.addr, !1, t)
}
function _G(n, e) {
    const t = ec(e, this.size, 16);
    n.uniformMatrix4fv(this.addr, !1, t)
}
function AG(n, e) {
    n.uniform1iv(this.addr, e)
}
function MG(n, e) {
    n.uniform2iv(this.addr, e)
}
function wG(n, e) {
    n.uniform3iv(this.addr, e)
}
function SG(n, e) {
    n.uniform4iv(this.addr, e)
}
function CG(n, e) {
    n.uniform1uiv(this.addr, e)
}
function EG(n, e) {
    n.uniform2uiv(this.addr, e)
}
function TG(n, e) {
    n.uniform3uiv(this.addr, e)
}
function bG(n, e) {
    n.uniform4uiv(this.addr, e)
}
function PG(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = qg(t, r);
    Bn(i, s) || (n.uniform1iv(this.addr, s),
    Rn(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture2D(e[o] || yB, s[o])
}
function BG(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = qg(t, r);
    Bn(i, s) || (n.uniform1iv(this.addr, s),
    Rn(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture3D(e[o] || xB, s[o])
}
function RG(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = qg(t, r);
    Bn(i, s) || (n.uniform1iv(this.addr, s),
    Rn(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTextureCube(e[o] || _B, s[o])
}
function LG(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = qg(t, r);
    Bn(i, s) || (n.uniform1iv(this.addr, s),
    Rn(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture2DArray(e[o] || vB, s[o])
}
function IG(n) {
    switch (n) {
    case 5126:
        return pG;
    case 35664:
        return mG;
    case 35665:
        return gG;
    case 35666:
        return yG;
    case 35674:
        return vG;
    case 35675:
        return xG;
    case 35676:
        return _G;
    case 5124:
    case 35670:
        return AG;
    case 35667:
    case 35671:
        return MG;
    case 35668:
    case 35672:
        return wG;
    case 35669:
    case 35673:
        return SG;
    case 5125:
        return CG;
    case 36294:
        return EG;
    case 36295:
        return TG;
    case 36296:
        return bG;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return PG;
    case 35679:
    case 36299:
    case 36307:
        return BG;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return RG;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return LG
    }
}
class DG {
    constructor(e, t, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.setValue = hG(t.type)
    }
}
class FG {
    constructor(e, t, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.size = t.size,
        this.setValue = IG(t.type)
    }
}
class kG {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, t, i) {
        const r = this.seq;
        for (let s = 0, o = r.length; s !== o; ++s) {
            const a = r[s];
            a.setValue(e, t[a.id], i)
        }
    }
}
const xv = /(\w+)(\])?(\[|\.)?/g;
function aE(n, e) {
    n.seq.push(e),
    n.map[e.id] = e
}
function NG(n, e, t) {
    const i = n.name
      , r = i.length;
    for (xv.lastIndex = 0; ; ) {
        const s = xv.exec(i)
          , o = xv.lastIndex;
        let a = s[1];
        const l = s[2] === "]"
          , c = s[3];
        if (l && (a = a | 0),
        c === void 0 || c === "[" && o + 2 === r) {
            aE(t, c === void 0 ? new DG(a,n,e) : new FG(a,n,e));
            break
        } else {
            let h = t.map[a];
            h === void 0 && (h = new kG(a),
            aE(t, h)),
            t = h
        }
    }
}
class Bm {
    constructor(e, t) {
        this.seq = [],
        this.map = {};
        const i = e.getProgramParameter(t, 35718);
        for (let r = 0; r < i; ++r) {
            const s = e.getActiveUniform(t, r)
              , o = e.getUniformLocation(t, s.name);
            NG(s, o, this)
        }
    }
    setValue(e, t, i, r) {
        const s = this.map[t];
        s !== void 0 && s.setValue(e, i, r)
    }
    setOptional(e, t, i) {
        const r = t[i];
        r !== void 0 && this.setValue(e, i, r)
    }
    static upload(e, t, i, r) {
        for (let s = 0, o = t.length; s !== o; ++s) {
            const a = t[s]
              , l = i[a.id];
            l.needsUpdate !== !1 && a.setValue(e, l.value, r)
        }
    }
    static seqWithValue(e, t) {
        const i = [];
        for (let r = 0, s = e.length; r !== s; ++r) {
            const o = e[r];
            o.id in t && i.push(o)
        }
        return i
    }
}
function lE(n, e, t) {
    const i = n.createShader(e);
    return n.shaderSource(i, t),
    n.compileShader(i),
    i
}
let OG = 0;
function UG(n, e) {
    const t = n.split(`
`)
      , i = []
      , r = Math.max(e - 6, 0)
      , s = Math.min(e + 6, t.length);
    for (let o = r; o < s; o++) {
        const a = o + 1;
        i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`)
    }
    return i.join(`
`)
}
function zG(n) {
    switch (n) {
    case Xs:
        return ["Linear", "( value )"];
    case Et:
        return ["sRGB", "( value )"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported encoding:", n),
        ["Linear", "( value )"]
    }
}
function uE(n, e, t) {
    const i = n.getShaderParameter(e, 35713)
      , r = n.getShaderInfoLog(e).trim();
    if (i && r === "")
        return "";
    const s = /ERROR: 0:(\d+)/.exec(r);
    if (s) {
        const o = parseInt(s[1]);
        return t.toUpperCase() + `

` + r + `

` + UG(n.getShaderSource(e), o)
    } else
        return r
}
function GG(n, e) {
    const t = zG(e);
    return "vec4 " + n + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }"
}
function HG(n, e) {
    let t;
    switch (e) {
    case N3:
        t = "Linear";
        break;
    case O3:
        t = "Reinhard";
        break;
    case U3:
        t = "OptimizedCineon";
        break;
    case pA:
        t = "ACESFilmic";
        break;
    case z3:
        t = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        t = "Linear"
    }
    return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}
function VG(n) {
    return [n.extensionDerivatives || n.envMapCubeUVHeight || n.bumpMap || n.tangentSpaceNormalMap || n.clearcoatNormalMap || n.flatShading || n.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", n.extensionDrawBuffers && n.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (n.extensionShaderTextureLOD || n.envMap || n.transmission) && n.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(uf).join(`
`)
}
function WG(n) {
    const e = [];
    for (const t in n) {
        const i = n[t];
        i !== !1 && e.push("#define " + t + " " + i)
    }
    return e.join(`
`)
}
function jG(n, e) {
    const t = {}
      , i = n.getProgramParameter(e, 35721);
    for (let r = 0; r < i; r++) {
        const s = n.getActiveAttrib(e, r)
          , o = s.name;
        let a = 1;
        s.type === 35674 && (a = 2),
        s.type === 35675 && (a = 3),
        s.type === 35676 && (a = 4),
        t[o] = {
            type: s.type,
            location: n.getAttribLocation(e, o),
            locationSize: a
        }
    }
    return t
}
function uf(n) {
    return n !== ""
}
function cE(n, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function fE(n, e) {
    return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const JG = /^[ \t]*#include +<([\w\d./]+)>/gm;
function I1(n) {
    return n.replace(JG, XG)
}
function XG(n, e) {
    const t = mt[e];
    if (t === void 0)
        throw new Error("Can not resolve #include <" + e + ">");
    return I1(t)
}
const KG = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function dE(n) {
    return n.replace(KG, YG)
}
function YG(n, e, t, i) {
    let r = "";
    for (let s = parseInt(e); s < parseInt(t); s++)
        r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
    return r
}
function hE(n) {
    let e = "precision " + n.precision + ` float;
precision ` + n.precision + " int;";
    return n.precision === "highp" ? e += `
#define HIGH_PRECISION` : n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e
}
function QG(n) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return n.shadowMapType === Jg ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === Af ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === Ua && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function ZG(n) {
    let e = "ENVMAP_TYPE_CUBE";
    if (n.envMap)
        switch (n.envMapMode) {
        case Vo:
        case Wo:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case qu:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function qG(n) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (n.envMap)
        switch (n.envMapMode) {
        case Wo:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function $G(n) {
    let e = "ENVMAP_BLENDING_NONE";
    if (n.envMap)
        switch (n.combine) {
        case Cd:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case F3:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case k3:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function e8(n) {
    const e = n.envMapCubeUVHeight;
    if (e === null)
        return null;
    const t = Math.log2(e) - 2
      , i = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: i,
        maxMip: t
    }
}
function t8(n, e, t, i) {
    const r = n.getContext()
      , s = t.defines;
    let o = t.vertexShader
      , a = t.fragmentShader;
    const l = QG(t)
      , c = ZG(t)
      , d = qG(t)
      , h = $G(t)
      , p = e8(t)
      , m = t.isWebGL2 ? "" : VG(t)
      , y = WG(s)
      , v = r.createProgram();
    let _, x, A = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (_ = [y].filter(uf).join(`
`),
    _.length > 0 && (_ += `
`),
    x = [m, y].filter(uf).join(`
`),
    x.length > 0 && (x += `
`)) : (_ = [hE(t), "#define SHADER_NAME " + t.shaderName, y, t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + d : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.displacementMap && t.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(uf).join(`
`),
    x = [m, hE(t), "#define SHADER_NAME " + t.shaderName, y, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + d : "", t.envMap ? "#define " + h : "", p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "", p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "", p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== kr ? "#define TONE_MAPPING" : "", t.toneMapping !== kr ? mt.tonemapping_pars_fragment : "", t.toneMapping !== kr ? HG("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", mt.encodings_pars_fragment, GG("linearToOutputTexel", t.outputEncoding), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(uf).join(`
`)),
    o = I1(o),
    o = cE(o, t),
    o = fE(o, t),
    a = I1(a),
    a = cE(a, t),
    a = fE(a, t),
    o = dE(o),
    a = dE(a),
    t.isWebGL2 && t.isRawShaderMaterial !== !0 && (A = `#version 300 es
`,
    _ = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + _,
    x = ["#define varying in", t.glslVersion === B1 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === B1 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + x);
    const M = A + _ + o
      , S = A + x + a
      , T = lE(r, 35633, M)
      , P = lE(r, 35632, S);
    if (r.attachShader(v, T),
    r.attachShader(v, P),
    t.index0AttributeName !== void 0 ? r.bindAttribLocation(v, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(v, 0, "position"),
    r.linkProgram(v),
    n.debug.checkShaderErrors) {
        const B = r.getProgramInfoLog(v).trim()
          , L = r.getShaderInfoLog(T).trim()
          , z = r.getShaderInfoLog(P).trim();
        let Z = !0
          , J = !0;
        if (r.getProgramParameter(v, 35714) === !1) {
            Z = !1;
            const G = uE(r, T, "vertex")
              , X = uE(r, P, "fragment");
            console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(v, 35715) + `

Program Info Log: ` + B + `
` + G + `
` + X)
        } else
            B !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", B) : (L === "" || z === "") && (J = !1);
        J && (this.diagnostics = {
            runnable: Z,
            programLog: B,
            vertexShader: {
                log: L,
                prefix: _
            },
            fragmentShader: {
                log: z,
                prefix: x
            }
        })
    }
    r.deleteShader(T),
    r.deleteShader(P);
    let R;
    this.getUniforms = function() {
        return R === void 0 && (R = new Bm(r,v)),
        R
    }
    ;
    let E;
    return this.getAttributes = function() {
        return E === void 0 && (E = jG(r, v)),
        E
    }
    ,
    this.destroy = function() {
        i.releaseStatesOfProgram(this),
        r.deleteProgram(v),
        this.program = void 0
    }
    ,
    this.name = t.shaderName,
    this.id = OG++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = v,
    this.vertexShader = T,
    this.fragmentShader = P,
    this
}
let n8 = 0;
class i8 {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader
          , i = e.fragmentShader
          , r = this._getShaderStage(t)
          , s = this._getShaderStage(i)
          , o = this._getShaderCacheForMaterial(e);
        return o.has(r) === !1 && (o.add(r),
        r.usedTimes++),
        o.has(s) === !1 && (o.add(s),
        s.usedTimes++),
        this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const i of t)
            i.usedTimes--,
            i.usedTimes === 0 && this.shaderCache.delete(i.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let i = t.get(e);
        return i === void 0 && (i = new Set,
        t.set(e, i)),
        i
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let i = t.get(e);
        return i === void 0 && (i = new r8(e),
        t.set(e, i)),
        i
    }
}
class r8 {
    constructor(e) {
        this.id = n8++,
        this.code = e,
        this.usedTimes = 0
    }
}
function s8(n, e, t, i, r, s, o) {
    const a = new $a
      , l = new i8
      , c = []
      , d = r.isWebGL2
      , h = r.logarithmicDepthBuffer
      , p = r.vertexTextures;
    let m = r.precision;
    const y = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function v(E, B, L, z, Z) {
        const J = z.fog
          , G = Z.geometry
          , X = E.isMeshStandardMaterial ? z.environment : null
          , ee = (E.isMeshStandardMaterial ? t : e).get(E.envMap || X)
          , ie = ee && ee.mapping === qu ? ee.image.height : null
          , F = y[E.type];
        E.precision !== null && (m = r.getMaxPrecision(E.precision),
        m !== E.precision && console.warn("THREE.WebGLProgram.getParameters:", E.precision, "not supported, using", m, "instead."));
        const V = G.morphAttributes.position || G.morphAttributes.normal || G.morphAttributes.color
          , j = V !== void 0 ? V.length : 0;
        let re = 0;
        G.morphAttributes.position !== void 0 && (re = 1),
        G.morphAttributes.normal !== void 0 && (re = 2),
        G.morphAttributes.color !== void 0 && (re = 3);
        let H, se, ye, ve;
        if (F) {
            const De = Lr[F];
            H = De.vertexShader,
            se = De.fragmentShader
        } else
            H = E.vertexShader,
            se = E.fragmentShader,
            l.update(E),
            ye = l.getVertexShaderID(E),
            ve = l.getFragmentShaderID(E);
        const q = n.getRenderTarget()
          , Ie = E.alphaTest > 0
          , Ne = E.clearcoat > 0
          , He = E.iridescence > 0;
        return {
            isWebGL2: d,
            shaderID: F,
            shaderName: E.type,
            vertexShader: H,
            fragmentShader: se,
            defines: E.defines,
            customVertexShaderID: ye,
            customFragmentShaderID: ve,
            isRawShaderMaterial: E.isRawShaderMaterial === !0,
            glslVersion: E.glslVersion,
            precision: m,
            instancing: Z.isInstancedMesh === !0,
            instancingColor: Z.isInstancedMesh === !0 && Z.instanceColor !== null,
            supportsVertexTextures: p,
            outputEncoding: q === null ? n.outputEncoding : q.isXRRenderTarget === !0 ? q.texture.encoding : Xs,
            map: !!E.map,
            matcap: !!E.matcap,
            envMap: !!ee,
            envMapMode: ee && ee.mapping,
            envMapCubeUVHeight: ie,
            lightMap: !!E.lightMap,
            aoMap: !!E.aoMap,
            emissiveMap: !!E.emissiveMap,
            bumpMap: !!E.bumpMap,
            normalMap: !!E.normalMap,
            objectSpaceNormalMap: E.normalMapType === lB,
            tangentSpaceNormalMap: E.normalMapType === Qs,
            decodeVideoTexture: !!E.map && E.map.isVideoTexture === !0 && E.map.encoding === Et,
            clearcoat: Ne,
            clearcoatMap: Ne && !!E.clearcoatMap,
            clearcoatRoughnessMap: Ne && !!E.clearcoatRoughnessMap,
            clearcoatNormalMap: Ne && !!E.clearcoatNormalMap,
            iridescence: He,
            iridescenceMap: He && !!E.iridescenceMap,
            iridescenceThicknessMap: He && !!E.iridescenceThicknessMap,
            displacementMap: !!E.displacementMap,
            roughnessMap: !!E.roughnessMap,
            metalnessMap: !!E.metalnessMap,
            specularMap: !!E.specularMap,
            specularIntensityMap: !!E.specularIntensityMap,
            specularColorMap: !!E.specularColorMap,
            opaque: E.transparent === !1 && E.blending === Ka,
            alphaMap: !!E.alphaMap,
            alphaTest: Ie,
            gradientMap: !!E.gradientMap,
            sheen: E.sheen > 0,
            sheenColorMap: !!E.sheenColorMap,
            sheenRoughnessMap: !!E.sheenRoughnessMap,
            transmission: E.transmission > 0,
            transmissionMap: !!E.transmissionMap,
            thicknessMap: !!E.thicknessMap,
            combine: E.combine,
            vertexTangents: !!E.normalMap && !!G.attributes.tangent,
            vertexColors: E.vertexColors,
            vertexAlphas: E.vertexColors === !0 && !!G.attributes.color && G.attributes.color.itemSize === 4,
            vertexUvs: !!E.map || !!E.bumpMap || !!E.normalMap || !!E.specularMap || !!E.alphaMap || !!E.emissiveMap || !!E.roughnessMap || !!E.metalnessMap || !!E.clearcoatMap || !!E.clearcoatRoughnessMap || !!E.clearcoatNormalMap || !!E.iridescenceMap || !!E.iridescenceThicknessMap || !!E.displacementMap || !!E.transmissionMap || !!E.thicknessMap || !!E.specularIntensityMap || !!E.specularColorMap || !!E.sheenColorMap || !!E.sheenRoughnessMap,
            uvsVertexOnly: !(E.map || E.bumpMap || E.normalMap || E.specularMap || E.alphaMap || E.emissiveMap || E.roughnessMap || E.metalnessMap || E.clearcoatNormalMap || E.iridescenceMap || E.iridescenceThicknessMap || E.transmission > 0 || E.transmissionMap || E.thicknessMap || E.specularIntensityMap || E.specularColorMap || E.sheen > 0 || E.sheenColorMap || E.sheenRoughnessMap) && !!E.displacementMap,
            fog: !!J,
            useFog: E.fog === !0,
            fogExp2: J && J.isFogExp2,
            flatShading: !!E.flatShading,
            sizeAttenuation: E.sizeAttenuation,
            logarithmicDepthBuffer: h,
            skinning: Z.isSkinnedMesh === !0,
            morphTargets: G.morphAttributes.position !== void 0,
            morphNormals: G.morphAttributes.normal !== void 0,
            morphColors: G.morphAttributes.color !== void 0,
            morphTargetsCount: j,
            morphTextureStride: re,
            numDirLights: B.directional.length,
            numPointLights: B.point.length,
            numSpotLights: B.spot.length,
            numSpotLightMaps: B.spotLightMap.length,
            numRectAreaLights: B.rectArea.length,
            numHemiLights: B.hemi.length,
            numDirLightShadows: B.directionalShadowMap.length,
            numPointLightShadows: B.pointShadowMap.length,
            numSpotLightShadows: B.spotShadowMap.length,
            numSpotLightShadowsWithMaps: B.numSpotLightShadowsWithMaps,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: E.dithering,
            shadowMapEnabled: n.shadowMap.enabled && L.length > 0,
            shadowMapType: n.shadowMap.type,
            toneMapping: E.toneMapped ? n.toneMapping : kr,
            physicallyCorrectLights: n.physicallyCorrectLights,
            premultipliedAlpha: E.premultipliedAlpha,
            doubleSided: E.side === Ir,
            flipSided: E.side === Bi,
            useDepthPacking: !!E.depthPacking,
            depthPacking: E.depthPacking || 0,
            index0AttributeName: E.index0AttributeName,
            extensionDerivatives: E.extensions && E.extensions.derivatives,
            extensionFragDepth: E.extensions && E.extensions.fragDepth,
            extensionDrawBuffers: E.extensions && E.extensions.drawBuffers,
            extensionShaderTextureLOD: E.extensions && E.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: d || i.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: d || i.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: d || i.has("EXT_shader_texture_lod"),
            customProgramCacheKey: E.customProgramCacheKey()
        }
    }
    function _(E) {
        const B = [];
        if (E.shaderID ? B.push(E.shaderID) : (B.push(E.customVertexShaderID),
        B.push(E.customFragmentShaderID)),
        E.defines !== void 0)
            for (const L in E.defines)
                B.push(L),
                B.push(E.defines[L]);
        return E.isRawShaderMaterial === !1 && (x(B, E),
        A(B, E),
        B.push(n.outputEncoding)),
        B.push(E.customProgramCacheKey),
        B.join()
    }
    function x(E, B) {
        E.push(B.precision),
        E.push(B.outputEncoding),
        E.push(B.envMapMode),
        E.push(B.envMapCubeUVHeight),
        E.push(B.combine),
        E.push(B.vertexUvs),
        E.push(B.fogExp2),
        E.push(B.sizeAttenuation),
        E.push(B.morphTargetsCount),
        E.push(B.morphAttributeCount),
        E.push(B.numDirLights),
        E.push(B.numPointLights),
        E.push(B.numSpotLights),
        E.push(B.numSpotLightMaps),
        E.push(B.numHemiLights),
        E.push(B.numRectAreaLights),
        E.push(B.numDirLightShadows),
        E.push(B.numPointLightShadows),
        E.push(B.numSpotLightShadows),
        E.push(B.numSpotLightShadowsWithMaps),
        E.push(B.shadowMapType),
        E.push(B.toneMapping),
        E.push(B.numClippingPlanes),
        E.push(B.numClipIntersection),
        E.push(B.depthPacking)
    }
    function A(E, B) {
        a.disableAll(),
        B.isWebGL2 && a.enable(0),
        B.supportsVertexTextures && a.enable(1),
        B.instancing && a.enable(2),
        B.instancingColor && a.enable(3),
        B.map && a.enable(4),
        B.matcap && a.enable(5),
        B.envMap && a.enable(6),
        B.lightMap && a.enable(7),
        B.aoMap && a.enable(8),
        B.emissiveMap && a.enable(9),
        B.bumpMap && a.enable(10),
        B.normalMap && a.enable(11),
        B.objectSpaceNormalMap && a.enable(12),
        B.tangentSpaceNormalMap && a.enable(13),
        B.clearcoat && a.enable(14),
        B.clearcoatMap && a.enable(15),
        B.clearcoatRoughnessMap && a.enable(16),
        B.clearcoatNormalMap && a.enable(17),
        B.iridescence && a.enable(18),
        B.iridescenceMap && a.enable(19),
        B.iridescenceThicknessMap && a.enable(20),
        B.displacementMap && a.enable(21),
        B.specularMap && a.enable(22),
        B.roughnessMap && a.enable(23),
        B.metalnessMap && a.enable(24),
        B.gradientMap && a.enable(25),
        B.alphaMap && a.enable(26),
        B.alphaTest && a.enable(27),
        B.vertexColors && a.enable(28),
        B.vertexAlphas && a.enable(29),
        B.vertexUvs && a.enable(30),
        B.vertexTangents && a.enable(31),
        B.uvsVertexOnly && a.enable(32),
        E.push(a.mask),
        a.disableAll(),
        B.fog && a.enable(0),
        B.useFog && a.enable(1),
        B.flatShading && a.enable(2),
        B.logarithmicDepthBuffer && a.enable(3),
        B.skinning && a.enable(4),
        B.morphTargets && a.enable(5),
        B.morphNormals && a.enable(6),
        B.morphColors && a.enable(7),
        B.premultipliedAlpha && a.enable(8),
        B.shadowMapEnabled && a.enable(9),
        B.physicallyCorrectLights && a.enable(10),
        B.doubleSided && a.enable(11),
        B.flipSided && a.enable(12),
        B.useDepthPacking && a.enable(13),
        B.dithering && a.enable(14),
        B.specularIntensityMap && a.enable(15),
        B.specularColorMap && a.enable(16),
        B.transmission && a.enable(17),
        B.transmissionMap && a.enable(18),
        B.thicknessMap && a.enable(19),
        B.sheen && a.enable(20),
        B.sheenColorMap && a.enable(21),
        B.sheenRoughnessMap && a.enable(22),
        B.decodeVideoTexture && a.enable(23),
        B.opaque && a.enable(24),
        E.push(a.mask)
    }
    function M(E) {
        const B = y[E.type];
        let L;
        if (B) {
            const z = Lr[B];
            L = mB.clone(z.uniforms)
        } else
            L = E.uniforms;
        return L
    }
    function S(E, B) {
        let L;
        for (let z = 0, Z = c.length; z < Z; z++) {
            const J = c[z];
            if (J.cacheKey === B) {
                L = J,
                ++L.usedTimes;
                break
            }
        }
        return L === void 0 && (L = new t8(n,B,E,s),
        c.push(L)),
        L
    }
    function T(E) {
        if (--E.usedTimes === 0) {
            const B = c.indexOf(E);
            c[B] = c[c.length - 1],
            c.pop(),
            E.destroy()
        }
    }
    function P(E) {
        l.remove(E)
    }
    function R() {
        l.dispose()
    }
    return {
        getParameters: v,
        getProgramCacheKey: _,
        getUniforms: M,
        acquireProgram: S,
        releaseProgram: T,
        releaseShaderCache: P,
        programs: c,
        dispose: R
    }
}
function o8() {
    let n = new WeakMap;
    function e(s) {
        let o = n.get(s);
        return o === void 0 && (o = {},
        n.set(s, o)),
        o
    }
    function t(s) {
        n.delete(s)
    }
    function i(s, o, a) {
        n.get(s)[o] = a
    }
    function r() {
        n = new WeakMap
    }
    return {
        get: e,
        remove: t,
        update: i,
        dispose: r
    }
}
function a8(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id
}
function pE(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id
}
function mE() {
    const n = [];
    let e = 0;
    const t = []
      , i = []
      , r = [];
    function s() {
        e = 0,
        t.length = 0,
        i.length = 0,
        r.length = 0
    }
    function o(h, p, m, y, v, _) {
        let x = n[e];
        return x === void 0 ? (x = {
            id: h.id,
            object: h,
            geometry: p,
            material: m,
            groupOrder: y,
            renderOrder: h.renderOrder,
            z: v,
            group: _
        },
        n[e] = x) : (x.id = h.id,
        x.object = h,
        x.geometry = p,
        x.material = m,
        x.groupOrder = y,
        x.renderOrder = h.renderOrder,
        x.z = v,
        x.group = _),
        e++,
        x
    }
    function a(h, p, m, y, v, _) {
        const x = o(h, p, m, y, v, _);
        m.transmission > 0 ? i.push(x) : m.transparent === !0 ? r.push(x) : t.push(x)
    }
    function l(h, p, m, y, v, _) {
        const x = o(h, p, m, y, v, _);
        m.transmission > 0 ? i.unshift(x) : m.transparent === !0 ? r.unshift(x) : t.unshift(x)
    }
    function c(h, p) {
        t.length > 1 && t.sort(h || a8),
        i.length > 1 && i.sort(p || pE),
        r.length > 1 && r.sort(p || pE)
    }
    function d() {
        for (let h = e, p = n.length; h < p; h++) {
            const m = n[h];
            if (m.id === null)
                break;
            m.id = null,
            m.object = null,
            m.geometry = null,
            m.material = null,
            m.group = null
        }
    }
    return {
        opaque: t,
        transmissive: i,
        transparent: r,
        init: s,
        push: a,
        unshift: l,
        finish: d,
        sort: c
    }
}
function l8() {
    let n = new WeakMap;
    function e(i, r) {
        const s = n.get(i);
        let o;
        return s === void 0 ? (o = new mE,
        n.set(i, [o])) : r >= s.length ? (o = new mE,
        s.push(o)) : o = s[r],
        o
    }
    function t() {
        n = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}
function u8() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0)
                return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    direction: new D,
                    color: new Le
                };
                break;
            case "SpotLight":
                t = {
                    position: new D,
                    direction: new D,
                    color: new Le,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                t = {
                    position: new D,
                    color: new Le,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                t = {
                    direction: new D,
                    skyColor: new Le,
                    groundColor: new Le
                };
                break;
            case "RectAreaLight":
                t = {
                    color: new Le,
                    position: new D,
                    halfWidth: new D,
                    halfHeight: new D
                };
                break
            }
            return n[e.id] = t,
            t
        }
    }
}
function c8() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0)
                return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new pe
                };
                break;
            case "SpotLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new pe
                };
                break;
            case "PointLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new pe,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return n[e.id] = t,
            t
        }
    }
}
let f8 = 0;
function d8(n, e) {
    return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0)
}
function h8(n, e) {
    const t = new u8
      , i = c8()
      , r = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0
    };
    for (let d = 0; d < 9; d++)
        r.probe.push(new D);
    const s = new D
      , o = new rt
      , a = new rt;
    function l(d, h) {
        let p = 0
          , m = 0
          , y = 0;
        for (let z = 0; z < 9; z++)
            r.probe[z].set(0, 0, 0);
        let v = 0
          , _ = 0
          , x = 0
          , A = 0
          , M = 0
          , S = 0
          , T = 0
          , P = 0
          , R = 0
          , E = 0;
        d.sort(d8);
        const B = h !== !0 ? Math.PI : 1;
        for (let z = 0, Z = d.length; z < Z; z++) {
            const J = d[z]
              , G = J.color
              , X = J.intensity
              , ee = J.distance
              , ie = J.shadow && J.shadow.map ? J.shadow.map.texture : null;
            if (J.isAmbientLight)
                p += G.r * X * B,
                m += G.g * X * B,
                y += G.b * X * B;
            else if (J.isLightProbe)
                for (let F = 0; F < 9; F++)
                    r.probe[F].addScaledVector(J.sh.coefficients[F], X);
            else if (J.isDirectionalLight) {
                const F = t.get(J);
                if (F.color.copy(J.color).multiplyScalar(J.intensity * B),
                J.castShadow) {
                    const V = J.shadow
                      , j = i.get(J);
                    j.shadowBias = V.bias,
                    j.shadowNormalBias = V.normalBias,
                    j.shadowRadius = V.radius,
                    j.shadowMapSize = V.mapSize,
                    r.directionalShadow[v] = j,
                    r.directionalShadowMap[v] = ie,
                    r.directionalShadowMatrix[v] = J.shadow.matrix,
                    S++
                }
                r.directional[v] = F,
                v++
            } else if (J.isSpotLight) {
                const F = t.get(J);
                F.position.setFromMatrixPosition(J.matrixWorld),
                F.color.copy(G).multiplyScalar(X * B),
                F.distance = ee,
                F.coneCos = Math.cos(J.angle),
                F.penumbraCos = Math.cos(J.angle * (1 - J.penumbra)),
                F.decay = J.decay,
                r.spot[x] = F;
                const V = J.shadow;
                if (J.map && (r.spotLightMap[R] = J.map,
                R++,
                V.updateMatrices(J),
                J.castShadow && E++),
                r.spotLightMatrix[x] = V.matrix,
                J.castShadow) {
                    const j = i.get(J);
                    j.shadowBias = V.bias,
                    j.shadowNormalBias = V.normalBias,
                    j.shadowRadius = V.radius,
                    j.shadowMapSize = V.mapSize,
                    r.spotShadow[x] = j,
                    r.spotShadowMap[x] = ie,
                    P++
                }
                x++
            } else if (J.isRectAreaLight) {
                const F = t.get(J);
                F.color.copy(G).multiplyScalar(X),
                F.halfWidth.set(J.width * .5, 0, 0),
                F.halfHeight.set(0, J.height * .5, 0),
                r.rectArea[A] = F,
                A++
            } else if (J.isPointLight) {
                const F = t.get(J);
                if (F.color.copy(J.color).multiplyScalar(J.intensity * B),
                F.distance = J.distance,
                F.decay = J.decay,
                J.castShadow) {
                    const V = J.shadow
                      , j = i.get(J);
                    j.shadowBias = V.bias,
                    j.shadowNormalBias = V.normalBias,
                    j.shadowRadius = V.radius,
                    j.shadowMapSize = V.mapSize,
                    j.shadowCameraNear = V.camera.near,
                    j.shadowCameraFar = V.camera.far,
                    r.pointShadow[_] = j,
                    r.pointShadowMap[_] = ie,
                    r.pointShadowMatrix[_] = J.shadow.matrix,
                    T++
                }
                r.point[_] = F,
                _++
            } else if (J.isHemisphereLight) {
                const F = t.get(J);
                F.skyColor.copy(J.color).multiplyScalar(X * B),
                F.groundColor.copy(J.groundColor).multiplyScalar(X * B),
                r.hemi[M] = F,
                M++
            }
        }
        A > 0 && (e.isWebGL2 || n.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = Re.LTC_FLOAT_1,
        r.rectAreaLTC2 = Re.LTC_FLOAT_2) : n.has("OES_texture_half_float_linear") === !0 ? (r.rectAreaLTC1 = Re.LTC_HALF_1,
        r.rectAreaLTC2 = Re.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
        r.ambient[0] = p,
        r.ambient[1] = m,
        r.ambient[2] = y;
        const L = r.hash;
        (L.directionalLength !== v || L.pointLength !== _ || L.spotLength !== x || L.rectAreaLength !== A || L.hemiLength !== M || L.numDirectionalShadows !== S || L.numPointShadows !== T || L.numSpotShadows !== P || L.numSpotMaps !== R) && (r.directional.length = v,
        r.spot.length = x,
        r.rectArea.length = A,
        r.point.length = _,
        r.hemi.length = M,
        r.directionalShadow.length = S,
        r.directionalShadowMap.length = S,
        r.pointShadow.length = T,
        r.pointShadowMap.length = T,
        r.spotShadow.length = P,
        r.spotShadowMap.length = P,
        r.directionalShadowMatrix.length = S,
        r.pointShadowMatrix.length = T,
        r.spotLightMatrix.length = P + R - E,
        r.spotLightMap.length = R,
        r.numSpotLightShadowsWithMaps = E,
        L.directionalLength = v,
        L.pointLength = _,
        L.spotLength = x,
        L.rectAreaLength = A,
        L.hemiLength = M,
        L.numDirectionalShadows = S,
        L.numPointShadows = T,
        L.numSpotShadows = P,
        L.numSpotMaps = R,
        r.version = f8++)
    }
    function c(d, h) {
        let p = 0
          , m = 0
          , y = 0
          , v = 0
          , _ = 0;
        const x = h.matrixWorldInverse;
        for (let A = 0, M = d.length; A < M; A++) {
            const S = d[A];
            if (S.isDirectionalLight) {
                const T = r.directional[p];
                T.direction.setFromMatrixPosition(S.matrixWorld),
                s.setFromMatrixPosition(S.target.matrixWorld),
                T.direction.sub(s),
                T.direction.transformDirection(x),
                p++
            } else if (S.isSpotLight) {
                const T = r.spot[y];
                T.position.setFromMatrixPosition(S.matrixWorld),
                T.position.applyMatrix4(x),
                T.direction.setFromMatrixPosition(S.matrixWorld),
                s.setFromMatrixPosition(S.target.matrixWorld),
                T.direction.sub(s),
                T.direction.transformDirection(x),
                y++
            } else if (S.isRectAreaLight) {
                const T = r.rectArea[v];
                T.position.setFromMatrixPosition(S.matrixWorld),
                T.position.applyMatrix4(x),
                a.identity(),
                o.copy(S.matrixWorld),
                o.premultiply(x),
                a.extractRotation(o),
                T.halfWidth.set(S.width * .5, 0, 0),
                T.halfHeight.set(0, S.height * .5, 0),
                T.halfWidth.applyMatrix4(a),
                T.halfHeight.applyMatrix4(a),
                v++
            } else if (S.isPointLight) {
                const T = r.point[m];
                T.position.setFromMatrixPosition(S.matrixWorld),
                T.position.applyMatrix4(x),
                m++
            } else if (S.isHemisphereLight) {
                const T = r.hemi[_];
                T.direction.setFromMatrixPosition(S.matrixWorld),
                T.direction.transformDirection(x),
                _++
            }
        }
    }
    return {
        setup: l,
        setupView: c,
        state: r
    }
}
function gE(n, e) {
    const t = new h8(n,e)
      , i = []
      , r = [];
    function s() {
        i.length = 0,
        r.length = 0
    }
    function o(h) {
        i.push(h)
    }
    function a(h) {
        r.push(h)
    }
    function l(h) {
        t.setup(i, h)
    }
    function c(h) {
        t.setupView(i, h)
    }
    return {
        init: s,
        state: {
            lightsArray: i,
            shadowsArray: r,
            lights: t
        },
        setupLights: l,
        setupLightsView: c,
        pushLight: o,
        pushShadow: a
    }
}
function p8(n, e) {
    let t = new WeakMap;
    function i(s, o=0) {
        const a = t.get(s);
        let l;
        return a === void 0 ? (l = new gE(n,e),
        t.set(s, [l])) : o >= a.length ? (l = new gE(n,e),
        a.push(l)) : l = a[o],
        l
    }
    function r() {
        t = new WeakMap
    }
    return {
        get: i,
        dispose: r
    }
}
class EA extends Sn {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = oB,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class TA extends Sn {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.referencePosition = new D,
        this.nearDistance = 1,
        this.farDistance = 1e3,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.referencePosition.copy(e.referencePosition),
        this.nearDistance = e.nearDistance,
        this.farDistance = e.farDistance,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
const m8 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
  , g8 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function y8(n, e, t) {
    let i = new Zg;
    const r = new pe
      , s = new pe
      , o = new Nt
      , a = new EA({
        depthPacking: aB
    })
      , l = new TA
      , c = {}
      , d = t.maxTextureSize
      , h = {
        [as]: Bi,
        [Bi]: as,
        [Ir]: Ir
    }
      , p = new us({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new pe
            },
            radius: {
                value: 4
            }
        },
        vertexShader: m8,
        fragmentShader: g8
    })
      , m = p.clone();
    m.defines.HORIZONTAL_PASS = 1;
    const y = new ct;
    y.setAttribute("position", new Ft(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const v = new Un(y,p)
      , _ = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = Jg,
    this.render = function(S, T, P) {
        if (_.enabled === !1 || _.autoUpdate === !1 && _.needsUpdate === !1 || S.length === 0)
            return;
        const R = n.getRenderTarget()
          , E = n.getActiveCubeFace()
          , B = n.getActiveMipmapLevel()
          , L = n.state;
        L.setBlending(Us),
        L.buffers.color.setClear(1, 1, 1, 1),
        L.buffers.depth.setTest(!0),
        L.setScissorTest(!1);
        for (let z = 0, Z = S.length; z < Z; z++) {
            const J = S[z]
              , G = J.shadow;
            if (G === void 0) {
                console.warn("THREE.WebGLShadowMap:", J, "has no shadow.");
                continue
            }
            if (G.autoUpdate === !1 && G.needsUpdate === !1)
                continue;
            r.copy(G.mapSize);
            const X = G.getFrameExtents();
            if (r.multiply(X),
            s.copy(G.mapSize),
            (r.x > d || r.y > d) && (r.x > d && (s.x = Math.floor(d / X.x),
            r.x = s.x * X.x,
            G.mapSize.x = s.x),
            r.y > d && (s.y = Math.floor(d / X.y),
            r.y = s.y * X.y,
            G.mapSize.y = s.y)),
            G.map === null) {
                const ie = this.type !== Ua ? {
                    minFilter: hn,
                    magFilter: hn
                } : {};
                G.map = new Ur(r.x,r.y,ie),
                G.map.texture.name = J.name + ".shadowMap",
                G.camera.updateProjectionMatrix()
            }
            n.setRenderTarget(G.map),
            n.clear();
            const ee = G.getViewportCount();
            for (let ie = 0; ie < ee; ie++) {
                const F = G.getViewport(ie);
                o.set(s.x * F.x, s.y * F.y, s.x * F.z, s.y * F.w),
                L.viewport(o),
                G.updateMatrices(J, ie),
                i = G.getFrustum(),
                M(T, P, G.camera, J, this.type)
            }
            G.isPointLightShadow !== !0 && this.type === Ua && x(G, P),
            G.needsUpdate = !1
        }
        _.needsUpdate = !1,
        n.setRenderTarget(R, E, B)
    }
    ;
    function x(S, T) {
        const P = e.update(v);
        p.defines.VSM_SAMPLES !== S.blurSamples && (p.defines.VSM_SAMPLES = S.blurSamples,
        m.defines.VSM_SAMPLES = S.blurSamples,
        p.needsUpdate = !0,
        m.needsUpdate = !0),
        S.mapPass === null && (S.mapPass = new Ur(r.x,r.y)),
        p.uniforms.shadow_pass.value = S.map.texture,
        p.uniforms.resolution.value = S.mapSize,
        p.uniforms.radius.value = S.radius,
        n.setRenderTarget(S.mapPass),
        n.clear(),
        n.renderBufferDirect(T, null, P, p, v, null),
        m.uniforms.shadow_pass.value = S.mapPass.texture,
        m.uniforms.resolution.value = S.mapSize,
        m.uniforms.radius.value = S.radius,
        n.setRenderTarget(S.map),
        n.clear(),
        n.renderBufferDirect(T, null, P, m, v, null)
    }
    function A(S, T, P, R, E, B) {
        let L = null;
        const z = P.isPointLight === !0 ? S.customDistanceMaterial : S.customDepthMaterial;
        if (z !== void 0)
            L = z;
        else if (L = P.isPointLight === !0 ? l : a,
        n.localClippingEnabled && T.clipShadows === !0 && Array.isArray(T.clippingPlanes) && T.clippingPlanes.length !== 0 || T.displacementMap && T.displacementScale !== 0 || T.alphaMap && T.alphaTest > 0 || T.map && T.alphaTest > 0) {
            const Z = L.uuid
              , J = T.uuid;
            let G = c[Z];
            G === void 0 && (G = {},
            c[Z] = G);
            let X = G[J];
            X === void 0 && (X = L.clone(),
            G[J] = X),
            L = X
        }
        return L.visible = T.visible,
        L.wireframe = T.wireframe,
        B === Ua ? L.side = T.shadowSide !== null ? T.shadowSide : T.side : L.side = T.shadowSide !== null ? T.shadowSide : h[T.side],
        L.alphaMap = T.alphaMap,
        L.alphaTest = T.alphaTest,
        L.map = T.map,
        L.clipShadows = T.clipShadows,
        L.clippingPlanes = T.clippingPlanes,
        L.clipIntersection = T.clipIntersection,
        L.displacementMap = T.displacementMap,
        L.displacementScale = T.displacementScale,
        L.displacementBias = T.displacementBias,
        L.wireframeLinewidth = T.wireframeLinewidth,
        L.linewidth = T.linewidth,
        P.isPointLight === !0 && L.isMeshDistanceMaterial === !0 && (L.referencePosition.setFromMatrixPosition(P.matrixWorld),
        L.nearDistance = R,
        L.farDistance = E),
        L
    }
    function M(S, T, P, R, E) {
        if (S.visible === !1)
            return;
        if (S.layers.test(T.layers) && (S.isMesh || S.isLine || S.isPoints) && (S.castShadow || S.receiveShadow && E === Ua) && (!S.frustumCulled || i.intersectsObject(S))) {
            S.modelViewMatrix.multiplyMatrices(P.matrixWorldInverse, S.matrixWorld);
            const z = e.update(S)
              , Z = S.material;
            if (Array.isArray(Z)) {
                const J = z.groups;
                for (let G = 0, X = J.length; G < X; G++) {
                    const ee = J[G]
                      , ie = Z[ee.materialIndex];
                    if (ie && ie.visible) {
                        const F = A(S, ie, R, P.near, P.far, E);
                        n.renderBufferDirect(P, null, z, F, S, ee)
                    }
                }
            } else if (Z.visible) {
                const J = A(S, Z, R, P.near, P.far, E);
                n.renderBufferDirect(P, null, z, J, S, null)
            }
        }
        const L = S.children;
        for (let z = 0, Z = L.length; z < Z; z++)
            M(L[z], T, P, R, E)
    }
}
function v8(n, e, t) {
    const i = t.isWebGL2;
    function r() {
        let Y = !1;
        const ce = new Nt;
        let _e = null;
        const Ue = new Nt(0,0,0,0);
        return {
            setMask: function(Ye) {
                _e !== Ye && !Y && (n.colorMask(Ye, Ye, Ye, Ye),
                _e = Ye)
            },
            setLocked: function(Ye) {
                Y = Ye
            },
            setClear: function(Ye, Pt, pn, Ln, Wr) {
                Wr === !0 && (Ye *= Ln,
                Pt *= Ln,
                pn *= Ln),
                ce.set(Ye, Pt, pn, Ln),
                Ue.equals(ce) === !1 && (n.clearColor(Ye, Pt, pn, Ln),
                Ue.copy(ce))
            },
            reset: function() {
                Y = !1,
                _e = null,
                Ue.set(-1, 0, 0, 0)
            }
        }
    }
    function s() {
        let Y = !1
          , ce = null
          , _e = null
          , Ue = null;
        return {
            setTest: function(Ye) {
                Ye ? Ie(2929) : Ne(2929)
            },
            setMask: function(Ye) {
                ce !== Ye && !Y && (n.depthMask(Ye),
                ce = Ye)
            },
            setFunc: function(Ye) {
                if (_e !== Ye) {
                    switch (Ye) {
                    case b3:
                        n.depthFunc(512);
                        break;
                    case P3:
                        n.depthFunc(519);
                        break;
                    case B3:
                        n.depthFunc(513);
                        break;
                    case lg:
                        n.depthFunc(515);
                        break;
                    case R3:
                        n.depthFunc(514);
                        break;
                    case L3:
                        n.depthFunc(518);
                        break;
                    case I3:
                        n.depthFunc(516);
                        break;
                    case D3:
                        n.depthFunc(517);
                        break;
                    default:
                        n.depthFunc(515)
                    }
                    _e = Ye
                }
            },
            setLocked: function(Ye) {
                Y = Ye
            },
            setClear: function(Ye) {
                Ue !== Ye && (n.clearDepth(Ye),
                Ue = Ye)
            },
            reset: function() {
                Y = !1,
                ce = null,
                _e = null,
                Ue = null
            }
        }
    }
    function o() {
        let Y = !1
          , ce = null
          , _e = null
          , Ue = null
          , Ye = null
          , Pt = null
          , pn = null
          , Ln = null
          , Wr = null;
        return {
            setTest: function(Ut) {
                Y || (Ut ? Ie(2960) : Ne(2960))
            },
            setMask: function(Ut) {
                ce !== Ut && !Y && (n.stencilMask(Ut),
                ce = Ut)
            },
            setFunc: function(Ut, Yi, xi) {
                (_e !== Ut || Ue !== Yi || Ye !== xi) && (n.stencilFunc(Ut, Yi, xi),
                _e = Ut,
                Ue = Yi,
                Ye = xi)
            },
            setOp: function(Ut, Yi, xi) {
                (Pt !== Ut || pn !== Yi || Ln !== xi) && (n.stencilOp(Ut, Yi, xi),
                Pt = Ut,
                pn = Yi,
                Ln = xi)
            },
            setLocked: function(Ut) {
                Y = Ut
            },
            setClear: function(Ut) {
                Wr !== Ut && (n.clearStencil(Ut),
                Wr = Ut)
            },
            reset: function() {
                Y = !1,
                ce = null,
                _e = null,
                Ue = null,
                Ye = null,
                Pt = null,
                pn = null,
                Ln = null,
                Wr = null
            }
        }
    }
    const a = new r
      , l = new s
      , c = new o
      , d = new WeakMap
      , h = new WeakMap;
    let p = {}
      , m = {}
      , y = new WeakMap
      , v = []
      , _ = null
      , x = !1
      , A = null
      , M = null
      , S = null
      , T = null
      , P = null
      , R = null
      , E = null
      , B = !1
      , L = null
      , z = null
      , Z = null
      , J = null
      , G = null;
    const X = n.getParameter(35661);
    let ee = !1
      , ie = 0;
    const F = n.getParameter(7938);
    F.indexOf("WebGL") !== -1 ? (ie = parseFloat(/^WebGL (\d)/.exec(F)[1]),
    ee = ie >= 1) : F.indexOf("OpenGL ES") !== -1 && (ie = parseFloat(/^OpenGL ES (\d)/.exec(F)[1]),
    ee = ie >= 2);
    let V = null
      , j = {};
    const re = n.getParameter(3088)
      , H = n.getParameter(2978)
      , se = new Nt().fromArray(re)
      , ye = new Nt().fromArray(H);
    function ve(Y, ce, _e) {
        const Ue = new Uint8Array(4)
          , Ye = n.createTexture();
        n.bindTexture(Y, Ye),
        n.texParameteri(Y, 10241, 9728),
        n.texParameteri(Y, 10240, 9728);
        for (let Pt = 0; Pt < _e; Pt++)
            n.texImage2D(ce + Pt, 0, 6408, 1, 1, 0, 6408, 5121, Ue);
        return Ye
    }
    const q = {};
    q[3553] = ve(3553, 3553, 1),
    q[34067] = ve(34067, 34069, 6),
    a.setClear(0, 0, 0, 1),
    l.setClear(1),
    c.setClear(0),
    Ie(2929),
    l.setFunc(lg),
    Be(!1),
    Ze(t1),
    Ie(2884),
    Ce(Us);
    function Ie(Y) {
        p[Y] !== !0 && (n.enable(Y),
        p[Y] = !0)
    }
    function Ne(Y) {
        p[Y] !== !1 && (n.disable(Y),
        p[Y] = !1)
    }
    function He(Y, ce) {
        return m[Y] !== ce ? (n.bindFramebuffer(Y, ce),
        m[Y] = ce,
        i && (Y === 36009 && (m[36160] = ce),
        Y === 36160 && (m[36009] = ce)),
        !0) : !1
    }
    function Me(Y, ce) {
        let _e = v
          , Ue = !1;
        if (Y)
            if (_e = y.get(ce),
            _e === void 0 && (_e = [],
            y.set(ce, _e)),
            Y.isWebGLMultipleRenderTargets) {
                const Ye = Y.texture;
                if (_e.length !== Ye.length || _e[0] !== 36064) {
                    for (let Pt = 0, pn = Ye.length; Pt < pn; Pt++)
                        _e[Pt] = 36064 + Pt;
                    _e.length = Ye.length,
                    Ue = !0
                }
            } else
                _e[0] !== 36064 && (_e[0] = 36064,
                Ue = !0);
        else
            _e[0] !== 1029 && (_e[0] = 1029,
            Ue = !0);
        Ue && (t.isWebGL2 ? n.drawBuffers(_e) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(_e))
    }
    function De(Y) {
        return _ !== Y ? (n.useProgram(Y),
        _ = Y,
        !0) : !1
    }
    const de = {
        [Da]: 32774,
        [y3]: 32778,
        [v3]: 32779
    };
    if (i)
        de[s1] = 32775,
        de[o1] = 32776;
    else {
        const Y = e.get("EXT_blend_minmax");
        Y !== null && (de[s1] = Y.MIN_EXT,
        de[o1] = Y.MAX_EXT)
    }
    const ae = {
        [x3]: 0,
        [_3]: 1,
        [A3]: 768,
        [dA]: 770,
        [T3]: 776,
        [C3]: 774,
        [w3]: 772,
        [M3]: 769,
        [hA]: 771,
        [E3]: 775,
        [S3]: 773
    };
    function Ce(Y, ce, _e, Ue, Ye, Pt, pn, Ln) {
        if (Y === Us) {
            x === !0 && (Ne(3042),
            x = !1);
            return
        }
        if (x === !1 && (Ie(3042),
        x = !0),
        Y !== g3) {
            if (Y !== A || Ln !== B) {
                if ((M !== Da || P !== Da) && (n.blendEquation(32774),
                M = Da,
                P = Da),
                Ln)
                    switch (Y) {
                    case Ka:
                        n.blendFuncSeparate(1, 771, 1, 771);
                        break;
                    case n1:
                        n.blendFunc(1, 1);
                        break;
                    case i1:
                        n.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case r1:
                        n.blendFuncSeparate(0, 768, 0, 770);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", Y);
                        break
                    }
                else
                    switch (Y) {
                    case Ka:
                        n.blendFuncSeparate(770, 771, 1, 771);
                        break;
                    case n1:
                        n.blendFunc(770, 1);
                        break;
                    case i1:
                        n.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case r1:
                        n.blendFunc(0, 768);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", Y);
                        break
                    }
                S = null,
                T = null,
                R = null,
                E = null,
                A = Y,
                B = Ln
            }
            return
        }
        Ye = Ye || ce,
        Pt = Pt || _e,
        pn = pn || Ue,
        (ce !== M || Ye !== P) && (n.blendEquationSeparate(de[ce], de[Ye]),
        M = ce,
        P = Ye),
        (_e !== S || Ue !== T || Pt !== R || pn !== E) && (n.blendFuncSeparate(ae[_e], ae[Ue], ae[Pt], ae[pn]),
        S = _e,
        T = Ue,
        R = Pt,
        E = pn),
        A = Y,
        B = !1
    }
    function ze(Y, ce) {
        Y.side === Ir ? Ne(2884) : Ie(2884);
        let _e = Y.side === Bi;
        ce && (_e = !_e),
        Be(_e),
        Y.blending === Ka && Y.transparent === !1 ? Ce(Us) : Ce(Y.blending, Y.blendEquation, Y.blendSrc, Y.blendDst, Y.blendEquationAlpha, Y.blendSrcAlpha, Y.blendDstAlpha, Y.premultipliedAlpha),
        l.setFunc(Y.depthFunc),
        l.setTest(Y.depthTest),
        l.setMask(Y.depthWrite),
        a.setMask(Y.colorWrite);
        const Ue = Y.stencilWrite;
        c.setTest(Ue),
        Ue && (c.setMask(Y.stencilWriteMask),
        c.setFunc(Y.stencilFunc, Y.stencilRef, Y.stencilFuncMask),
        c.setOp(Y.stencilFail, Y.stencilZFail, Y.stencilZPass)),
        We(Y.polygonOffset, Y.polygonOffsetFactor, Y.polygonOffsetUnits),
        Y.alphaToCoverage === !0 ? Ie(32926) : Ne(32926)
    }
    function Be(Y) {
        L !== Y && (Y ? n.frontFace(2304) : n.frontFace(2305),
        L = Y)
    }
    function Ze(Y) {
        Y !== h3 ? (Ie(2884),
        Y !== z && (Y === t1 ? n.cullFace(1029) : Y === p3 ? n.cullFace(1028) : n.cullFace(1032))) : Ne(2884),
        z = Y
    }
    function Je(Y) {
        Y !== Z && (ee && n.lineWidth(Y),
        Z = Y)
    }
    function We(Y, ce, _e) {
        Y ? (Ie(32823),
        (J !== ce || G !== _e) && (n.polygonOffset(ce, _e),
        J = ce,
        G = _e)) : Ne(32823)
    }
    function xt(Y) {
        Y ? Ie(3089) : Ne(3089)
    }
    function St(Y) {
        Y === void 0 && (Y = 33984 + X - 1),
        V !== Y && (n.activeTexture(Y),
        V = Y)
    }
    function U(Y, ce, _e) {
        _e === void 0 && (V === null ? _e = 33984 + X - 1 : _e = V);
        let Ue = j[_e];
        Ue === void 0 && (Ue = {
            type: void 0,
            texture: void 0
        },
        j[_e] = Ue),
        (Ue.type !== Y || Ue.texture !== ce) && (V !== _e && (n.activeTexture(_e),
        V = _e),
        n.bindTexture(Y, ce || q[Y]),
        Ue.type = Y,
        Ue.texture = ce)
    }
    function I() {
        const Y = j[V];
        Y !== void 0 && Y.type !== void 0 && (n.bindTexture(Y.type, null),
        Y.type = void 0,
        Y.texture = void 0)
    }
    function oe() {
        try {
            n.compressedTexImage2D.apply(n, arguments)
        } catch (Y) {
            console.error("THREE.WebGLState:", Y)
        }
    }
    function we() {
        try {
            n.compressedTexImage3D.apply(n, arguments)
        } catch (Y) {
            console.error("THREE.WebGLState:", Y)
        }
    }
    function Ee() {
        try {
            n.texSubImage2D.apply(n, arguments)
        } catch (Y) {
            console.error("THREE.WebGLState:", Y)
        }
    }
    function Pe() {
        try {
            n.texSubImage3D.apply(n, arguments)
        } catch (Y) {
            console.error("THREE.WebGLState:", Y)
        }
    }
    function tt() {
        try {
            n.compressedTexSubImage2D.apply(n, arguments)
        } catch (Y) {
            console.error("THREE.WebGLState:", Y)
        }
    }
    function Fe() {
        try {
            n.compressedTexSubImage3D.apply(n, arguments)
        } catch (Y) {
            console.error("THREE.WebGLState:", Y)
        }
    }
    function me() {
        try {
            n.texStorage2D.apply(n, arguments)
        } catch (Y) {
            console.error("THREE.WebGLState:", Y)
        }
    }
    function Xe() {
        try {
            n.texStorage3D.apply(n, arguments)
        } catch (Y) {
            console.error("THREE.WebGLState:", Y)
        }
    }
    function W() {
        try {
            n.texImage2D.apply(n, arguments)
        } catch (Y) {
            console.error("THREE.WebGLState:", Y)
        }
    }
    function le() {
        try {
            n.texImage3D.apply(n, arguments)
        } catch (Y) {
            console.error("THREE.WebGLState:", Y)
        }
    }
    function Ae(Y) {
        se.equals(Y) === !1 && (n.scissor(Y.x, Y.y, Y.z, Y.w),
        se.copy(Y))
    }
    function be(Y) {
        ye.equals(Y) === !1 && (n.viewport(Y.x, Y.y, Y.z, Y.w),
        ye.copy(Y))
    }
    function $e(Y, ce) {
        let _e = h.get(ce);
        _e === void 0 && (_e = new WeakMap,
        h.set(ce, _e));
        let Ue = _e.get(Y);
        Ue === void 0 && (Ue = n.getUniformBlockIndex(ce, Y.name),
        _e.set(Y, Ue))
    }
    function vt(Y, ce) {
        const Ue = h.get(ce).get(Y);
        d.get(ce) !== Ue && (n.uniformBlockBinding(ce, Ue, Y.__bindingPointIndex),
        d.set(ce, Ue))
    }
    function Wt() {
        n.disable(3042),
        n.disable(2884),
        n.disable(2929),
        n.disable(32823),
        n.disable(3089),
        n.disable(2960),
        n.disable(32926),
        n.blendEquation(32774),
        n.blendFunc(1, 0),
        n.blendFuncSeparate(1, 0, 1, 0),
        n.colorMask(!0, !0, !0, !0),
        n.clearColor(0, 0, 0, 0),
        n.depthMask(!0),
        n.depthFunc(513),
        n.clearDepth(1),
        n.stencilMask(4294967295),
        n.stencilFunc(519, 0, 4294967295),
        n.stencilOp(7680, 7680, 7680),
        n.clearStencil(0),
        n.cullFace(1029),
        n.frontFace(2305),
        n.polygonOffset(0, 0),
        n.activeTexture(33984),
        n.bindFramebuffer(36160, null),
        i === !0 && (n.bindFramebuffer(36009, null),
        n.bindFramebuffer(36008, null)),
        n.useProgram(null),
        n.lineWidth(1),
        n.scissor(0, 0, n.canvas.width, n.canvas.height),
        n.viewport(0, 0, n.canvas.width, n.canvas.height),
        p = {},
        V = null,
        j = {},
        m = {},
        y = new WeakMap,
        v = [],
        _ = null,
        x = !1,
        A = null,
        M = null,
        S = null,
        T = null,
        P = null,
        R = null,
        E = null,
        B = !1,
        L = null,
        z = null,
        Z = null,
        J = null,
        G = null,
        se.set(0, 0, n.canvas.width, n.canvas.height),
        ye.set(0, 0, n.canvas.width, n.canvas.height),
        a.reset(),
        l.reset(),
        c.reset()
    }
    return {
        buffers: {
            color: a,
            depth: l,
            stencil: c
        },
        enable: Ie,
        disable: Ne,
        bindFramebuffer: He,
        drawBuffers: Me,
        useProgram: De,
        setBlending: Ce,
        setMaterial: ze,
        setFlipSided: Be,
        setCullFace: Ze,
        setLineWidth: Je,
        setPolygonOffset: We,
        setScissorTest: xt,
        activeTexture: St,
        bindTexture: U,
        unbindTexture: I,
        compressedTexImage2D: oe,
        compressedTexImage3D: we,
        texImage2D: W,
        texImage3D: le,
        updateUBOMapping: $e,
        uniformBlockBinding: vt,
        texStorage2D: me,
        texStorage3D: Xe,
        texSubImage2D: Ee,
        texSubImage3D: Pe,
        compressedTexSubImage2D: tt,
        compressedTexSubImage3D: Fe,
        scissor: Ae,
        viewport: be,
        reset: Wt
    }
}
function x8(n, e, t, i, r, s, o) {
    const a = r.isWebGL2
      , l = r.maxTextures
      , c = r.maxCubemapSize
      , d = r.maxTextureSize
      , h = r.maxSamples
      , p = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , m = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
      , y = new WeakMap;
    let v;
    const _ = new WeakMap;
    let x = !1;
    try {
        x = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch {}
    function A(U, I) {
        return x ? new OffscreenCanvas(U,I) : rd("canvas")
    }
    function M(U, I, oe, we) {
        let Ee = 1;
        if ((U.width > we || U.height > we) && (Ee = we / Math.max(U.width, U.height)),
        Ee < 1 || I === !0)
            if (typeof HTMLImageElement < "u" && U instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && U instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && U instanceof ImageBitmap) {
                const Pe = I ? cg : Math.floor
                  , tt = Pe(Ee * U.width)
                  , Fe = Pe(Ee * U.height);
                v === void 0 && (v = A(tt, Fe));
                const me = oe ? A(tt, Fe) : v;
                return me.width = tt,
                me.height = Fe,
                me.getContext("2d").drawImage(U, 0, 0, tt, Fe),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + U.width + "x" + U.height + ") to (" + tt + "x" + Fe + ")."),
                me
            } else
                return "data"in U && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + U.width + "x" + U.height + ")."),
                U;
        return U
    }
    function S(U) {
        return R1(U.width) && R1(U.height)
    }
    function T(U) {
        return a ? !1 : U.wrapS !== Vn || U.wrapT !== Vn || U.minFilter !== hn && U.minFilter !== nn
    }
    function P(U, I) {
        return U.generateMipmaps && I && U.minFilter !== hn && U.minFilter !== nn
    }
    function R(U) {
        n.generateMipmap(U)
    }
    function E(U, I, oe, we, Ee=!1) {
        if (a === !1)
            return I;
        if (U !== null) {
            if (n[U] !== void 0)
                return n[U];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + U + "'")
        }
        let Pe = I;
        return I === 6403 && (oe === 5126 && (Pe = 33326),
        oe === 5131 && (Pe = 33325),
        oe === 5121 && (Pe = 33321)),
        I === 33319 && (oe === 5126 && (Pe = 33328),
        oe === 5131 && (Pe = 33327),
        oe === 5121 && (Pe = 33323)),
        I === 6408 && (oe === 5126 && (Pe = 34836),
        oe === 5131 && (Pe = 34842),
        oe === 5121 && (Pe = we === Et && Ee === !1 ? 35907 : 32856),
        oe === 32819 && (Pe = 32854),
        oe === 32820 && (Pe = 32855)),
        (Pe === 33325 || Pe === 33326 || Pe === 33327 || Pe === 33328 || Pe === 34842 || Pe === 34836) && e.get("EXT_color_buffer_float"),
        Pe
    }
    function B(U, I, oe) {
        return P(U, oe) === !0 || U.isFramebufferTexture && U.minFilter !== hn && U.minFilter !== nn ? Math.log2(Math.max(I.width, I.height)) + 1 : U.mipmaps !== void 0 && U.mipmaps.length > 0 ? U.mipmaps.length : U.isCompressedTexture && Array.isArray(U.image) ? I.mipmaps.length : 1
    }
    function L(U) {
        return U === hn || U === ed || U === Eu ? 9728 : 9729
    }
    function z(U) {
        const I = U.target;
        I.removeEventListener("dispose", z),
        J(I),
        I.isVideoTexture && y.delete(I)
    }
    function Z(U) {
        const I = U.target;
        I.removeEventListener("dispose", Z),
        X(I)
    }
    function J(U) {
        const I = i.get(U);
        if (I.__webglInit === void 0)
            return;
        const oe = U.source
          , we = _.get(oe);
        if (we) {
            const Ee = we[I.__cacheKey];
            Ee.usedTimes--,
            Ee.usedTimes === 0 && G(U),
            Object.keys(we).length === 0 && _.delete(oe)
        }
        i.remove(U)
    }
    function G(U) {
        const I = i.get(U);
        n.deleteTexture(I.__webglTexture);
        const oe = U.source
          , we = _.get(oe);
        delete we[I.__cacheKey],
        o.memory.textures--
    }
    function X(U) {
        const I = U.texture
          , oe = i.get(U)
          , we = i.get(I);
        if (we.__webglTexture !== void 0 && (n.deleteTexture(we.__webglTexture),
        o.memory.textures--),
        U.depthTexture && U.depthTexture.dispose(),
        U.isWebGLCubeRenderTarget)
            for (let Ee = 0; Ee < 6; Ee++)
                n.deleteFramebuffer(oe.__webglFramebuffer[Ee]),
                oe.__webglDepthbuffer && n.deleteRenderbuffer(oe.__webglDepthbuffer[Ee]);
        else {
            if (n.deleteFramebuffer(oe.__webglFramebuffer),
            oe.__webglDepthbuffer && n.deleteRenderbuffer(oe.__webglDepthbuffer),
            oe.__webglMultisampledFramebuffer && n.deleteFramebuffer(oe.__webglMultisampledFramebuffer),
            oe.__webglColorRenderbuffer)
                for (let Ee = 0; Ee < oe.__webglColorRenderbuffer.length; Ee++)
                    oe.__webglColorRenderbuffer[Ee] && n.deleteRenderbuffer(oe.__webglColorRenderbuffer[Ee]);
            oe.__webglDepthRenderbuffer && n.deleteRenderbuffer(oe.__webglDepthRenderbuffer)
        }
        if (U.isWebGLMultipleRenderTargets)
            for (let Ee = 0, Pe = I.length; Ee < Pe; Ee++) {
                const tt = i.get(I[Ee]);
                tt.__webglTexture && (n.deleteTexture(tt.__webglTexture),
                o.memory.textures--),
                i.remove(I[Ee])
            }
        i.remove(I),
        i.remove(U)
    }
    let ee = 0;
    function ie() {
        ee = 0
    }
    function F() {
        const U = ee;
        return U >= l && console.warn("THREE.WebGLTextures: Trying to use " + U + " texture units while this GPU supports only " + l),
        ee += 1,
        U
    }
    function V(U) {
        const I = [];
        return I.push(U.wrapS),
        I.push(U.wrapT),
        I.push(U.wrapR || 0),
        I.push(U.magFilter),
        I.push(U.minFilter),
        I.push(U.anisotropy),
        I.push(U.internalFormat),
        I.push(U.format),
        I.push(U.type),
        I.push(U.generateMipmaps),
        I.push(U.premultiplyAlpha),
        I.push(U.flipY),
        I.push(U.unpackAlignment),
        I.push(U.encoding),
        I.join()
    }
    function j(U, I) {
        const oe = i.get(U);
        if (U.isVideoTexture && xt(U),
        U.isRenderTargetTexture === !1 && U.version > 0 && oe.__version !== U.version) {
            const we = U.image;
            if (we === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (we.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                Ne(oe, U, I);
                return
            }
        }
        t.bindTexture(3553, oe.__webglTexture, 33984 + I)
    }
    function re(U, I) {
        const oe = i.get(U);
        if (U.version > 0 && oe.__version !== U.version) {
            Ne(oe, U, I);
            return
        }
        t.bindTexture(35866, oe.__webglTexture, 33984 + I)
    }
    function H(U, I) {
        const oe = i.get(U);
        if (U.version > 0 && oe.__version !== U.version) {
            Ne(oe, U, I);
            return
        }
        t.bindTexture(32879, oe.__webglTexture, 33984 + I)
    }
    function se(U, I) {
        const oe = i.get(U);
        if (U.version > 0 && oe.__version !== U.version) {
            He(oe, U, I);
            return
        }
        t.bindTexture(34067, oe.__webglTexture, 33984 + I)
    }
    const ye = {
        [jo]: 10497,
        [Vn]: 33071,
        [ku]: 33648
    }
      , ve = {
        [hn]: 9728,
        [ed]: 9984,
        [Eu]: 9986,
        [nn]: 9729,
        [Kg]: 9985,
        [ls]: 9987
    };
    function q(U, I, oe) {
        if (oe ? (n.texParameteri(U, 10242, ye[I.wrapS]),
        n.texParameteri(U, 10243, ye[I.wrapT]),
        (U === 32879 || U === 35866) && n.texParameteri(U, 32882, ye[I.wrapR]),
        n.texParameteri(U, 10240, ve[I.magFilter]),
        n.texParameteri(U, 10241, ve[I.minFilter])) : (n.texParameteri(U, 10242, 33071),
        n.texParameteri(U, 10243, 33071),
        (U === 32879 || U === 35866) && n.texParameteri(U, 32882, 33071),
        (I.wrapS !== Vn || I.wrapT !== Vn) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
        n.texParameteri(U, 10240, L(I.magFilter)),
        n.texParameteri(U, 10241, L(I.minFilter)),
        I.minFilter !== hn && I.minFilter !== nn && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            const we = e.get("EXT_texture_filter_anisotropic");
            if (I.magFilter === hn || I.minFilter !== Eu && I.minFilter !== ls || I.type === Ds && e.has("OES_texture_float_linear") === !1 || a === !1 && I.type === Nu && e.has("OES_texture_half_float_linear") === !1)
                return;
            (I.anisotropy > 1 || i.get(I).__currentAnisotropy) && (n.texParameterf(U, we.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(I.anisotropy, r.getMaxAnisotropy())),
            i.get(I).__currentAnisotropy = I.anisotropy)
        }
    }
    function Ie(U, I) {
        let oe = !1;
        U.__webglInit === void 0 && (U.__webglInit = !0,
        I.addEventListener("dispose", z));
        const we = I.source;
        let Ee = _.get(we);
        Ee === void 0 && (Ee = {},
        _.set(we, Ee));
        const Pe = V(I);
        if (Pe !== U.__cacheKey) {
            Ee[Pe] === void 0 && (Ee[Pe] = {
                texture: n.createTexture(),
                usedTimes: 0
            },
            o.memory.textures++,
            oe = !0),
            Ee[Pe].usedTimes++;
            const tt = Ee[U.__cacheKey];
            tt !== void 0 && (Ee[U.__cacheKey].usedTimes--,
            tt.usedTimes === 0 && G(I)),
            U.__cacheKey = Pe,
            U.__webglTexture = Ee[Pe].texture
        }
        return oe
    }
    function Ne(U, I, oe) {
        let we = 3553;
        (I.isDataArrayTexture || I.isCompressedArrayTexture) && (we = 35866),
        I.isData3DTexture && (we = 32879);
        const Ee = Ie(U, I)
          , Pe = I.source;
        t.bindTexture(we, U.__webglTexture, 33984 + oe);
        const tt = i.get(Pe);
        if (Pe.version !== tt.__version || Ee === !0) {
            t.activeTexture(33984 + oe),
            n.pixelStorei(37440, I.flipY),
            n.pixelStorei(37441, I.premultiplyAlpha),
            n.pixelStorei(3317, I.unpackAlignment),
            n.pixelStorei(37443, 0);
            const Fe = T(I) && S(I.image) === !1;
            let me = M(I.image, Fe, !1, d);
            me = St(I, me);
            const Xe = S(me) || a
              , W = s.convert(I.format, I.encoding);
            let le = s.convert(I.type)
              , Ae = E(I.internalFormat, W, le, I.encoding, I.isVideoTexture);
            q(we, I, Xe);
            let be;
            const $e = I.mipmaps
              , vt = a && I.isVideoTexture !== !0
              , Wt = tt.__version === void 0 || Ee === !0
              , Y = B(I, me, Xe);
            if (I.isDepthTexture)
                Ae = 6402,
                a ? I.type === Ds ? Ae = 36012 : I.type === bo ? Ae = 33190 : I.type === Ya ? Ae = 35056 : Ae = 33189 : I.type === Ds && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                I.format === Uo && Ae === 6402 && I.type !== mA && I.type !== bo && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                I.type = bo,
                le = s.convert(I.type)),
                I.format === ol && Ae === 6402 && (Ae = 34041,
                I.type !== Ya && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                I.type = Ya,
                le = s.convert(I.type))),
                Wt && (vt ? t.texStorage2D(3553, 1, Ae, me.width, me.height) : t.texImage2D(3553, 0, Ae, me.width, me.height, 0, W, le, null));
            else if (I.isDataTexture)
                if ($e.length > 0 && Xe) {
                    vt && Wt && t.texStorage2D(3553, Y, Ae, $e[0].width, $e[0].height);
                    for (let ce = 0, _e = $e.length; ce < _e; ce++)
                        be = $e[ce],
                        vt ? t.texSubImage2D(3553, ce, 0, 0, be.width, be.height, W, le, be.data) : t.texImage2D(3553, ce, Ae, be.width, be.height, 0, W, le, be.data);
                    I.generateMipmaps = !1
                } else
                    vt ? (Wt && t.texStorage2D(3553, Y, Ae, me.width, me.height),
                    t.texSubImage2D(3553, 0, 0, 0, me.width, me.height, W, le, me.data)) : t.texImage2D(3553, 0, Ae, me.width, me.height, 0, W, le, me.data);
            else if (I.isCompressedTexture)
                if (I.isCompressedArrayTexture) {
                    vt && Wt && t.texStorage3D(35866, Y, Ae, $e[0].width, $e[0].height, me.depth);
                    for (let ce = 0, _e = $e.length; ce < _e; ce++)
                        be = $e[ce],
                        I.format !== Ci ? W !== null ? vt ? t.compressedTexSubImage3D(35866, ce, 0, 0, 0, be.width, be.height, me.depth, W, be.data, 0, 0) : t.compressedTexImage3D(35866, ce, Ae, be.width, be.height, me.depth, 0, be.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : vt ? t.texSubImage3D(35866, ce, 0, 0, 0, be.width, be.height, me.depth, W, le, be.data) : t.texImage3D(35866, ce, Ae, be.width, be.height, me.depth, 0, W, le, be.data)
                } else {
                    vt && Wt && t.texStorage2D(3553, Y, Ae, $e[0].width, $e[0].height);
                    for (let ce = 0, _e = $e.length; ce < _e; ce++)
                        be = $e[ce],
                        I.format !== Ci ? W !== null ? vt ? t.compressedTexSubImage2D(3553, ce, 0, 0, be.width, be.height, W, be.data) : t.compressedTexImage2D(3553, ce, Ae, be.width, be.height, 0, be.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : vt ? t.texSubImage2D(3553, ce, 0, 0, be.width, be.height, W, le, be.data) : t.texImage2D(3553, ce, Ae, be.width, be.height, 0, W, le, be.data)
                }
            else if (I.isDataArrayTexture)
                vt ? (Wt && t.texStorage3D(35866, Y, Ae, me.width, me.height, me.depth),
                t.texSubImage3D(35866, 0, 0, 0, 0, me.width, me.height, me.depth, W, le, me.data)) : t.texImage3D(35866, 0, Ae, me.width, me.height, me.depth, 0, W, le, me.data);
            else if (I.isData3DTexture)
                vt ? (Wt && t.texStorage3D(32879, Y, Ae, me.width, me.height, me.depth),
                t.texSubImage3D(32879, 0, 0, 0, 0, me.width, me.height, me.depth, W, le, me.data)) : t.texImage3D(32879, 0, Ae, me.width, me.height, me.depth, 0, W, le, me.data);
            else if (I.isFramebufferTexture) {
                if (Wt)
                    if (vt)
                        t.texStorage2D(3553, Y, Ae, me.width, me.height);
                    else {
                        let ce = me.width
                          , _e = me.height;
                        for (let Ue = 0; Ue < Y; Ue++)
                            t.texImage2D(3553, Ue, Ae, ce, _e, 0, W, le, null),
                            ce >>= 1,
                            _e >>= 1
                    }
            } else if ($e.length > 0 && Xe) {
                vt && Wt && t.texStorage2D(3553, Y, Ae, $e[0].width, $e[0].height);
                for (let ce = 0, _e = $e.length; ce < _e; ce++)
                    be = $e[ce],
                    vt ? t.texSubImage2D(3553, ce, 0, 0, W, le, be) : t.texImage2D(3553, ce, Ae, W, le, be);
                I.generateMipmaps = !1
            } else
                vt ? (Wt && t.texStorage2D(3553, Y, Ae, me.width, me.height),
                t.texSubImage2D(3553, 0, 0, 0, W, le, me)) : t.texImage2D(3553, 0, Ae, W, le, me);
            P(I, Xe) && R(we),
            tt.__version = Pe.version,
            I.onUpdate && I.onUpdate(I)
        }
        U.__version = I.version
    }
    function He(U, I, oe) {
        if (I.image.length !== 6)
            return;
        const we = Ie(U, I)
          , Ee = I.source;
        t.bindTexture(34067, U.__webglTexture, 33984 + oe);
        const Pe = i.get(Ee);
        if (Ee.version !== Pe.__version || we === !0) {
            t.activeTexture(33984 + oe),
            n.pixelStorei(37440, I.flipY),
            n.pixelStorei(37441, I.premultiplyAlpha),
            n.pixelStorei(3317, I.unpackAlignment),
            n.pixelStorei(37443, 0);
            const tt = I.isCompressedTexture || I.image[0].isCompressedTexture
              , Fe = I.image[0] && I.image[0].isDataTexture
              , me = [];
            for (let ce = 0; ce < 6; ce++)
                !tt && !Fe ? me[ce] = M(I.image[ce], !1, !0, c) : me[ce] = Fe ? I.image[ce].image : I.image[ce],
                me[ce] = St(I, me[ce]);
            const Xe = me[0]
              , W = S(Xe) || a
              , le = s.convert(I.format, I.encoding)
              , Ae = s.convert(I.type)
              , be = E(I.internalFormat, le, Ae, I.encoding)
              , $e = a && I.isVideoTexture !== !0
              , vt = Pe.__version === void 0 || we === !0;
            let Wt = B(I, Xe, W);
            q(34067, I, W);
            let Y;
            if (tt) {
                $e && vt && t.texStorage2D(34067, Wt, be, Xe.width, Xe.height);
                for (let ce = 0; ce < 6; ce++) {
                    Y = me[ce].mipmaps;
                    for (let _e = 0; _e < Y.length; _e++) {
                        const Ue = Y[_e];
                        I.format !== Ci ? le !== null ? $e ? t.compressedTexSubImage2D(34069 + ce, _e, 0, 0, Ue.width, Ue.height, le, Ue.data) : t.compressedTexImage2D(34069 + ce, _e, be, Ue.width, Ue.height, 0, Ue.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : $e ? t.texSubImage2D(34069 + ce, _e, 0, 0, Ue.width, Ue.height, le, Ae, Ue.data) : t.texImage2D(34069 + ce, _e, be, Ue.width, Ue.height, 0, le, Ae, Ue.data)
                    }
                }
            } else {
                Y = I.mipmaps,
                $e && vt && (Y.length > 0 && Wt++,
                t.texStorage2D(34067, Wt, be, me[0].width, me[0].height));
                for (let ce = 0; ce < 6; ce++)
                    if (Fe) {
                        $e ? t.texSubImage2D(34069 + ce, 0, 0, 0, me[ce].width, me[ce].height, le, Ae, me[ce].data) : t.texImage2D(34069 + ce, 0, be, me[ce].width, me[ce].height, 0, le, Ae, me[ce].data);
                        for (let _e = 0; _e < Y.length; _e++) {
                            const Ye = Y[_e].image[ce].image;
                            $e ? t.texSubImage2D(34069 + ce, _e + 1, 0, 0, Ye.width, Ye.height, le, Ae, Ye.data) : t.texImage2D(34069 + ce, _e + 1, be, Ye.width, Ye.height, 0, le, Ae, Ye.data)
                        }
                    } else {
                        $e ? t.texSubImage2D(34069 + ce, 0, 0, 0, le, Ae, me[ce]) : t.texImage2D(34069 + ce, 0, be, le, Ae, me[ce]);
                        for (let _e = 0; _e < Y.length; _e++) {
                            const Ue = Y[_e];
                            $e ? t.texSubImage2D(34069 + ce, _e + 1, 0, 0, le, Ae, Ue.image[ce]) : t.texImage2D(34069 + ce, _e + 1, be, le, Ae, Ue.image[ce])
                        }
                    }
            }
            P(I, W) && R(34067),
            Pe.__version = Ee.version,
            I.onUpdate && I.onUpdate(I)
        }
        U.__version = I.version
    }
    function Me(U, I, oe, we, Ee) {
        const Pe = s.convert(oe.format, oe.encoding)
          , tt = s.convert(oe.type)
          , Fe = E(oe.internalFormat, Pe, tt, oe.encoding);
        i.get(I).__hasExternalTextures || (Ee === 32879 || Ee === 35866 ? t.texImage3D(Ee, 0, Fe, I.width, I.height, I.depth, 0, Pe, tt, null) : t.texImage2D(Ee, 0, Fe, I.width, I.height, 0, Pe, tt, null)),
        t.bindFramebuffer(36160, U),
        We(I) ? p.framebufferTexture2DMultisampleEXT(36160, we, Ee, i.get(oe).__webglTexture, 0, Je(I)) : (Ee === 3553 || Ee >= 34069 && Ee <= 34074) && n.framebufferTexture2D(36160, we, Ee, i.get(oe).__webglTexture, 0),
        t.bindFramebuffer(36160, null)
    }
    function De(U, I, oe) {
        if (n.bindRenderbuffer(36161, U),
        I.depthBuffer && !I.stencilBuffer) {
            let we = 33189;
            if (oe || We(I)) {
                const Ee = I.depthTexture;
                Ee && Ee.isDepthTexture && (Ee.type === Ds ? we = 36012 : Ee.type === bo && (we = 33190));
                const Pe = Je(I);
                We(I) ? p.renderbufferStorageMultisampleEXT(36161, Pe, we, I.width, I.height) : n.renderbufferStorageMultisample(36161, Pe, we, I.width, I.height)
            } else
                n.renderbufferStorage(36161, we, I.width, I.height);
            n.framebufferRenderbuffer(36160, 36096, 36161, U)
        } else if (I.depthBuffer && I.stencilBuffer) {
            const we = Je(I);
            oe && We(I) === !1 ? n.renderbufferStorageMultisample(36161, we, 35056, I.width, I.height) : We(I) ? p.renderbufferStorageMultisampleEXT(36161, we, 35056, I.width, I.height) : n.renderbufferStorage(36161, 34041, I.width, I.height),
            n.framebufferRenderbuffer(36160, 33306, 36161, U)
        } else {
            const we = I.isWebGLMultipleRenderTargets === !0 ? I.texture : [I.texture];
            for (let Ee = 0; Ee < we.length; Ee++) {
                const Pe = we[Ee]
                  , tt = s.convert(Pe.format, Pe.encoding)
                  , Fe = s.convert(Pe.type)
                  , me = E(Pe.internalFormat, tt, Fe, Pe.encoding)
                  , Xe = Je(I);
                oe && We(I) === !1 ? n.renderbufferStorageMultisample(36161, Xe, me, I.width, I.height) : We(I) ? p.renderbufferStorageMultisampleEXT(36161, Xe, me, I.width, I.height) : n.renderbufferStorage(36161, me, I.width, I.height)
            }
        }
        n.bindRenderbuffer(36161, null)
    }
    function de(U, I) {
        if (I && I.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(36160, U),
        !(I.depthTexture && I.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!i.get(I.depthTexture).__webglTexture || I.depthTexture.image.width !== I.width || I.depthTexture.image.height !== I.height) && (I.depthTexture.image.width = I.width,
        I.depthTexture.image.height = I.height,
        I.depthTexture.needsUpdate = !0),
        j(I.depthTexture, 0);
        const we = i.get(I.depthTexture).__webglTexture
          , Ee = Je(I);
        if (I.depthTexture.format === Uo)
            We(I) ? p.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, we, 0, Ee) : n.framebufferTexture2D(36160, 36096, 3553, we, 0);
        else if (I.depthTexture.format === ol)
            We(I) ? p.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, we, 0, Ee) : n.framebufferTexture2D(36160, 33306, 3553, we, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function ae(U) {
        const I = i.get(U)
          , oe = U.isWebGLCubeRenderTarget === !0;
        if (U.depthTexture && !I.__autoAllocateDepthBuffer) {
            if (oe)
                throw new Error("target.depthTexture not supported in Cube render targets");
            de(I.__webglFramebuffer, U)
        } else if (oe) {
            I.__webglDepthbuffer = [];
            for (let we = 0; we < 6; we++)
                t.bindFramebuffer(36160, I.__webglFramebuffer[we]),
                I.__webglDepthbuffer[we] = n.createRenderbuffer(),
                De(I.__webglDepthbuffer[we], U, !1)
        } else
            t.bindFramebuffer(36160, I.__webglFramebuffer),
            I.__webglDepthbuffer = n.createRenderbuffer(),
            De(I.__webglDepthbuffer, U, !1);
        t.bindFramebuffer(36160, null)
    }
    function Ce(U, I, oe) {
        const we = i.get(U);
        I !== void 0 && Me(we.__webglFramebuffer, U, U.texture, 36064, 3553),
        oe !== void 0 && ae(U)
    }
    function ze(U) {
        const I = U.texture
          , oe = i.get(U)
          , we = i.get(I);
        U.addEventListener("dispose", Z),
        U.isWebGLMultipleRenderTargets !== !0 && (we.__webglTexture === void 0 && (we.__webglTexture = n.createTexture()),
        we.__version = I.version,
        o.memory.textures++);
        const Ee = U.isWebGLCubeRenderTarget === !0
          , Pe = U.isWebGLMultipleRenderTargets === !0
          , tt = S(U) || a;
        if (Ee) {
            oe.__webglFramebuffer = [];
            for (let Fe = 0; Fe < 6; Fe++)
                oe.__webglFramebuffer[Fe] = n.createFramebuffer()
        } else {
            if (oe.__webglFramebuffer = n.createFramebuffer(),
            Pe)
                if (r.drawBuffers) {
                    const Fe = U.texture;
                    for (let me = 0, Xe = Fe.length; me < Xe; me++) {
                        const W = i.get(Fe[me]);
                        W.__webglTexture === void 0 && (W.__webglTexture = n.createTexture(),
                        o.memory.textures++)
                    }
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
            if (a && U.samples > 0 && We(U) === !1) {
                const Fe = Pe ? I : [I];
                oe.__webglMultisampledFramebuffer = n.createFramebuffer(),
                oe.__webglColorRenderbuffer = [],
                t.bindFramebuffer(36160, oe.__webglMultisampledFramebuffer);
                for (let me = 0; me < Fe.length; me++) {
                    const Xe = Fe[me];
                    oe.__webglColorRenderbuffer[me] = n.createRenderbuffer(),
                    n.bindRenderbuffer(36161, oe.__webglColorRenderbuffer[me]);
                    const W = s.convert(Xe.format, Xe.encoding)
                      , le = s.convert(Xe.type)
                      , Ae = E(Xe.internalFormat, W, le, Xe.encoding, U.isXRRenderTarget === !0)
                      , be = Je(U);
                    n.renderbufferStorageMultisample(36161, be, Ae, U.width, U.height),
                    n.framebufferRenderbuffer(36160, 36064 + me, 36161, oe.__webglColorRenderbuffer[me])
                }
                n.bindRenderbuffer(36161, null),
                U.depthBuffer && (oe.__webglDepthRenderbuffer = n.createRenderbuffer(),
                De(oe.__webglDepthRenderbuffer, U, !0)),
                t.bindFramebuffer(36160, null)
            }
        }
        if (Ee) {
            t.bindTexture(34067, we.__webglTexture),
            q(34067, I, tt);
            for (let Fe = 0; Fe < 6; Fe++)
                Me(oe.__webglFramebuffer[Fe], U, I, 36064, 34069 + Fe);
            P(I, tt) && R(34067),
            t.unbindTexture()
        } else if (Pe) {
            const Fe = U.texture;
            for (let me = 0, Xe = Fe.length; me < Xe; me++) {
                const W = Fe[me]
                  , le = i.get(W);
                t.bindTexture(3553, le.__webglTexture),
                q(3553, W, tt),
                Me(oe.__webglFramebuffer, U, W, 36064 + me, 3553),
                P(W, tt) && R(3553)
            }
            t.unbindTexture()
        } else {
            let Fe = 3553;
            (U.isWebGL3DRenderTarget || U.isWebGLArrayRenderTarget) && (a ? Fe = U.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
            t.bindTexture(Fe, we.__webglTexture),
            q(Fe, I, tt),
            Me(oe.__webglFramebuffer, U, I, 36064, Fe),
            P(I, tt) && R(Fe),
            t.unbindTexture()
        }
        U.depthBuffer && ae(U)
    }
    function Be(U) {
        const I = S(U) || a
          , oe = U.isWebGLMultipleRenderTargets === !0 ? U.texture : [U.texture];
        for (let we = 0, Ee = oe.length; we < Ee; we++) {
            const Pe = oe[we];
            if (P(Pe, I)) {
                const tt = U.isWebGLCubeRenderTarget ? 34067 : 3553
                  , Fe = i.get(Pe).__webglTexture;
                t.bindTexture(tt, Fe),
                R(tt),
                t.unbindTexture()
            }
        }
    }
    function Ze(U) {
        if (a && U.samples > 0 && We(U) === !1) {
            const I = U.isWebGLMultipleRenderTargets ? U.texture : [U.texture]
              , oe = U.width
              , we = U.height;
            let Ee = 16384;
            const Pe = []
              , tt = U.stencilBuffer ? 33306 : 36096
              , Fe = i.get(U)
              , me = U.isWebGLMultipleRenderTargets === !0;
            if (me)
                for (let Xe = 0; Xe < I.length; Xe++)
                    t.bindFramebuffer(36160, Fe.__webglMultisampledFramebuffer),
                    n.framebufferRenderbuffer(36160, 36064 + Xe, 36161, null),
                    t.bindFramebuffer(36160, Fe.__webglFramebuffer),
                    n.framebufferTexture2D(36009, 36064 + Xe, 3553, null, 0);
            t.bindFramebuffer(36008, Fe.__webglMultisampledFramebuffer),
            t.bindFramebuffer(36009, Fe.__webglFramebuffer);
            for (let Xe = 0; Xe < I.length; Xe++) {
                Pe.push(36064 + Xe),
                U.depthBuffer && Pe.push(tt);
                const W = Fe.__ignoreDepthValues !== void 0 ? Fe.__ignoreDepthValues : !1;
                if (W === !1 && (U.depthBuffer && (Ee |= 256),
                U.stencilBuffer && (Ee |= 1024)),
                me && n.framebufferRenderbuffer(36008, 36064, 36161, Fe.__webglColorRenderbuffer[Xe]),
                W === !0 && (n.invalidateFramebuffer(36008, [tt]),
                n.invalidateFramebuffer(36009, [tt])),
                me) {
                    const le = i.get(I[Xe]).__webglTexture;
                    n.framebufferTexture2D(36009, 36064, 3553, le, 0)
                }
                n.blitFramebuffer(0, 0, oe, we, 0, 0, oe, we, Ee, 9728),
                m && n.invalidateFramebuffer(36008, Pe)
            }
            if (t.bindFramebuffer(36008, null),
            t.bindFramebuffer(36009, null),
            me)
                for (let Xe = 0; Xe < I.length; Xe++) {
                    t.bindFramebuffer(36160, Fe.__webglMultisampledFramebuffer),
                    n.framebufferRenderbuffer(36160, 36064 + Xe, 36161, Fe.__webglColorRenderbuffer[Xe]);
                    const W = i.get(I[Xe]).__webglTexture;
                    t.bindFramebuffer(36160, Fe.__webglFramebuffer),
                    n.framebufferTexture2D(36009, 36064 + Xe, 3553, W, 0)
                }
            t.bindFramebuffer(36009, Fe.__webglMultisampledFramebuffer)
        }
    }
    function Je(U) {
        return Math.min(h, U.samples)
    }
    function We(U) {
        const I = i.get(U);
        return a && U.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && I.__useRenderToTexture !== !1
    }
    function xt(U) {
        const I = o.render.frame;
        y.get(U) !== I && (y.set(U, I),
        U.update())
    }
    function St(U, I) {
        const oe = U.encoding
          , we = U.format
          , Ee = U.type;
        return U.isCompressedTexture === !0 || U.isVideoTexture === !0 || U.format === ug || oe !== Xs && (oe === Et ? a === !1 ? e.has("EXT_sRGB") === !0 && we === Ci ? (U.format = ug,
        U.minFilter = nn,
        U.generateMipmaps = !1) : I = xA.sRGBToLinear(I) : (we !== Ci || Ee !== Js) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", oe)),
        I
    }
    this.allocateTextureUnit = F,
    this.resetTextureUnits = ie,
    this.setTexture2D = j,
    this.setTexture2DArray = re,
    this.setTexture3D = H,
    this.setTextureCube = se,
    this.rebindTextures = Ce,
    this.setupRenderTarget = ze,
    this.updateRenderTargetMipmap = Be,
    this.updateMultisampleRenderTarget = Ze,
    this.setupDepthRenderbuffer = ae,
    this.setupFrameBufferTexture = Me,
    this.useMultisampledRTT = We
}
function AB(n, e, t) {
    const i = t.isWebGL2;
    function r(s, o=null) {
        let a;
        if (s === Js)
            return 5121;
        if (s === W3)
            return 32819;
        if (s === j3)
            return 32820;
        if (s === G3)
            return 5120;
        if (s === H3)
            return 5122;
        if (s === mA)
            return 5123;
        if (s === V3)
            return 5124;
        if (s === bo)
            return 5125;
        if (s === Ds)
            return 5126;
        if (s === Nu)
            return i ? 5131 : (a = e.get("OES_texture_half_float"),
            a !== null ? a.HALF_FLOAT_OES : null);
        if (s === J3)
            return 6406;
        if (s === Ci)
            return 6408;
        if (s === X3)
            return 6409;
        if (s === K3)
            return 6410;
        if (s === Uo)
            return 6402;
        if (s === ol)
            return 34041;
        if (s === ug)
            return a = e.get("EXT_sRGB"),
            a !== null ? a.SRGB_ALPHA_EXT : null;
        if (s === Y3)
            return 6403;
        if (s === Q3)
            return 36244;
        if (s === Z3)
            return 33319;
        if (s === q3)
            return 33320;
        if (s === $3)
            return 36249;
        if (s === Mm || s === wm || s === Sm || s === Cm)
            if (o === Et)
                if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                a !== null) {
                    if (s === Mm)
                        return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (s === wm)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (s === Sm)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (s === Cm)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (a = e.get("WEBGL_compressed_texture_s3tc"),
            a !== null) {
                if (s === Mm)
                    return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (s === wm)
                    return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (s === Sm)
                    return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (s === Cm)
                    return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (s === a1 || s === l1 || s === u1 || s === c1)
            if (a = e.get("WEBGL_compressed_texture_pvrtc"),
            a !== null) {
                if (s === a1)
                    return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (s === l1)
                    return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (s === u1)
                    return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (s === c1)
                    return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (s === eB)
            return a = e.get("WEBGL_compressed_texture_etc1"),
            a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
        if (s === f1 || s === d1)
            if (a = e.get("WEBGL_compressed_texture_etc"),
            a !== null) {
                if (s === f1)
                    return o === Et ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                if (s === d1)
                    return o === Et ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (s === h1 || s === p1 || s === m1 || s === g1 || s === y1 || s === v1 || s === x1 || s === _1 || s === A1 || s === M1 || s === w1 || s === S1 || s === C1 || s === E1)
            if (a = e.get("WEBGL_compressed_texture_astc"),
            a !== null) {
                if (s === h1)
                    return o === Et ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (s === p1)
                    return o === Et ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (s === m1)
                    return o === Et ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (s === g1)
                    return o === Et ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (s === y1)
                    return o === Et ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (s === v1)
                    return o === Et ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (s === x1)
                    return o === Et ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (s === _1)
                    return o === Et ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (s === A1)
                    return o === Et ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (s === M1)
                    return o === Et ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (s === w1)
                    return o === Et ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (s === S1)
                    return o === Et ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (s === C1)
                    return o === Et ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (s === E1)
                    return o === Et ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (s === Em)
            if (a = e.get("EXT_texture_compression_bptc"),
            a !== null) {
                if (s === Em)
                    return o === Et ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT
            } else
                return null;
        if (s === tB || s === T1 || s === b1 || s === P1)
            if (a = e.get("EXT_texture_compression_rgtc"),
            a !== null) {
                if (s === Em)
                    return a.COMPRESSED_RED_RGTC1_EXT;
                if (s === T1)
                    return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (s === b1)
                    return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (s === P1)
                    return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else
                return null;
        return s === Ya ? i ? 34042 : (a = e.get("WEBGL_depth_texture"),
        a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : n[s] !== void 0 ? n[s] : null
    }
    return {
        convert: r
    }
}
class MB extends Ht {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.cameras = e
    }
}
class ks extends Rt {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const _8 = {
    type: "move"
};
class _v {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new ks,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new ks,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new D,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new D),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new ks,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new D,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new D),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const i of e.hand.values())
                    this._getHandJoint(t, i)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, t, i) {
        let r = null
          , s = null
          , o = null;
        const a = this._targetRay
          , l = this._grip
          , c = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (c && e.hand) {
                o = !0;
                for (const v of e.hand.values()) {
                    const _ = t.getJointPose(v, i)
                      , x = this._getHandJoint(c, v);
                    _ !== null && (x.matrix.fromArray(_.transform.matrix),
                    x.matrix.decompose(x.position, x.rotation, x.scale),
                    x.jointRadius = _.radius),
                    x.visible = _ !== null
                }
                const d = c.joints["index-finger-tip"]
                  , h = c.joints["thumb-tip"]
                  , p = d.position.distanceTo(h.position)
                  , m = .02
                  , y = .005;
                c.inputState.pinching && p > m + y ? (c.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !c.inputState.pinching && p <= m - y && (c.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, i),
                s !== null && (l.matrix.fromArray(s.transform.matrix),
                l.matrix.decompose(l.position, l.rotation, l.scale),
                s.linearVelocity ? (l.hasLinearVelocity = !0,
                l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1,
                s.angularVelocity ? (l.hasAngularVelocity = !0,
                l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
            a !== null && (r = t.getPose(e.targetRaySpace, i),
            r === null && s !== null && (r = s),
            r !== null && (a.matrix.fromArray(r.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            r.linearVelocity ? (a.hasLinearVelocity = !0,
            a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1,
            r.angularVelocity ? (a.hasAngularVelocity = !0,
            a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1,
            this.dispatchEvent(_8)))
        }
        return a !== null && (a.visible = r !== null),
        l !== null && (l.visible = s !== null),
        c !== null && (c.visible = o !== null),
        this
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const i = new ks;
            i.matrixAutoUpdate = !1,
            i.visible = !1,
            e.joints[t.jointName] = i,
            e.add(i)
        }
        return e.joints[t.jointName]
    }
}
class wB extends qt {
    constructor(e, t, i, r, s, o, a, l, c, d) {
        if (d = d !== void 0 ? d : Uo,
        d !== Uo && d !== ol)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        i === void 0 && d === Uo && (i = bo),
        i === void 0 && d === ol && (i = Ya),
        super(null, r, s, o, a, l, d, i, c),
        this.isDepthTexture = !0,
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = a !== void 0 ? a : hn,
        this.minFilter = l !== void 0 ? l : hn,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
}
class A8 extends cs {
    constructor(e, t) {
        super();
        const i = this;
        let r = null
          , s = 1
          , o = null
          , a = "local-floor"
          , l = 1
          , c = null
          , d = null
          , h = null
          , p = null
          , m = null
          , y = null;
        const v = t.getContextAttributes();
        let _ = null
          , x = null;
        const A = []
          , M = []
          , S = new Set
          , T = new Map
          , P = new Ht;
        P.layers.enable(1),
        P.viewport = new Nt;
        const R = new Ht;
        R.layers.enable(2),
        R.viewport = new Nt;
        const E = [P, R]
          , B = new MB;
        B.layers.enable(1),
        B.layers.enable(2);
        let L = null
          , z = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(H) {
            let se = A[H];
            return se === void 0 && (se = new _v,
            A[H] = se),
            se.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(H) {
            let se = A[H];
            return se === void 0 && (se = new _v,
            A[H] = se),
            se.getGripSpace()
        }
        ,
        this.getHand = function(H) {
            let se = A[H];
            return se === void 0 && (se = new _v,
            A[H] = se),
            se.getHandSpace()
        }
        ;
        function Z(H) {
            const se = M.indexOf(H.inputSource);
            if (se === -1)
                return;
            const ye = A[se];
            ye !== void 0 && ye.dispatchEvent({
                type: H.type,
                data: H.inputSource
            })
        }
        function J() {
            r.removeEventListener("select", Z),
            r.removeEventListener("selectstart", Z),
            r.removeEventListener("selectend", Z),
            r.removeEventListener("squeeze", Z),
            r.removeEventListener("squeezestart", Z),
            r.removeEventListener("squeezeend", Z),
            r.removeEventListener("end", J),
            r.removeEventListener("inputsourceschange", G);
            for (let H = 0; H < A.length; H++) {
                const se = M[H];
                se !== null && (M[H] = null,
                A[H].disconnect(se))
            }
            L = null,
            z = null,
            e.setRenderTarget(_),
            m = null,
            p = null,
            h = null,
            r = null,
            x = null,
            re.stop(),
            i.isPresenting = !1,
            i.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(H) {
            s = H,
            i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(H) {
            a = H,
            i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return c || o
        }
        ,
        this.setReferenceSpace = function(H) {
            c = H
        }
        ,
        this.getBaseLayer = function() {
            return p !== null ? p : m
        }
        ,
        this.getBinding = function() {
            return h
        }
        ,
        this.getFrame = function() {
            return y
        }
        ,
        this.getSession = function() {
            return r
        }
        ,
        this.setSession = async function(H) {
            if (r = H,
            r !== null) {
                if (_ = e.getRenderTarget(),
                r.addEventListener("select", Z),
                r.addEventListener("selectstart", Z),
                r.addEventListener("selectend", Z),
                r.addEventListener("squeeze", Z),
                r.addEventListener("squeezestart", Z),
                r.addEventListener("squeezeend", Z),
                r.addEventListener("end", J),
                r.addEventListener("inputsourceschange", G),
                v.xrCompatible !== !0 && await t.makeXRCompatible(),
                r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
                    const se = {
                        antialias: r.renderState.layers === void 0 ? v.antialias : !0,
                        alpha: v.alpha,
                        depth: v.depth,
                        stencil: v.stencil,
                        framebufferScaleFactor: s
                    };
                    m = new XRWebGLLayer(r,t,se),
                    r.updateRenderState({
                        baseLayer: m
                    }),
                    x = new Ur(m.framebufferWidth,m.framebufferHeight,{
                        format: Ci,
                        type: Js,
                        encoding: e.outputEncoding,
                        stencilBuffer: v.stencil
                    })
                } else {
                    let se = null
                      , ye = null
                      , ve = null;
                    v.depth && (ve = v.stencil ? 35056 : 33190,
                    se = v.stencil ? ol : Uo,
                    ye = v.stencil ? Ya : bo);
                    const q = {
                        colorFormat: 32856,
                        depthFormat: ve,
                        scaleFactor: s
                    };
                    h = new XRWebGLBinding(r,t),
                    p = h.createProjectionLayer(q),
                    r.updateRenderState({
                        layers: [p]
                    }),
                    x = new Ur(p.textureWidth,p.textureHeight,{
                        format: Ci,
                        type: Js,
                        depthTexture: new wB(p.textureWidth,p.textureHeight,ye,void 0,void 0,void 0,void 0,void 0,void 0,se),
                        stencilBuffer: v.stencil,
                        encoding: e.outputEncoding,
                        samples: v.antialias ? 4 : 0
                    });
                    const Ie = e.properties.get(x);
                    Ie.__ignoreDepthValues = p.ignoreDepthValues
                }
                x.isXRRenderTarget = !0,
                this.setFoveation(l),
                c = null,
                o = await r.requestReferenceSpace(a),
                re.setContext(r),
                re.start(),
                i.isPresenting = !0,
                i.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ;
        function G(H) {
            for (let se = 0; se < H.removed.length; se++) {
                const ye = H.removed[se]
                  , ve = M.indexOf(ye);
                ve >= 0 && (M[ve] = null,
                A[ve].disconnect(ye))
            }
            for (let se = 0; se < H.added.length; se++) {
                const ye = H.added[se];
                let ve = M.indexOf(ye);
                if (ve === -1) {
                    for (let Ie = 0; Ie < A.length; Ie++)
                        if (Ie >= M.length) {
                            M.push(ye),
                            ve = Ie;
                            break
                        } else if (M[Ie] === null) {
                            M[Ie] = ye,
                            ve = Ie;
                            break
                        }
                    if (ve === -1)
                        break
                }
                const q = A[ve];
                q && q.connect(ye)
            }
        }
        const X = new D
          , ee = new D;
        function ie(H, se, ye) {
            X.setFromMatrixPosition(se.matrixWorld),
            ee.setFromMatrixPosition(ye.matrixWorld);
            const ve = X.distanceTo(ee)
              , q = se.projectionMatrix.elements
              , Ie = ye.projectionMatrix.elements
              , Ne = q[14] / (q[10] - 1)
              , He = q[14] / (q[10] + 1)
              , Me = (q[9] + 1) / q[5]
              , De = (q[9] - 1) / q[5]
              , de = (q[8] - 1) / q[0]
              , ae = (Ie[8] + 1) / Ie[0]
              , Ce = Ne * de
              , ze = Ne * ae
              , Be = ve / (-de + ae)
              , Ze = Be * -de;
            se.matrixWorld.decompose(H.position, H.quaternion, H.scale),
            H.translateX(Ze),
            H.translateZ(Be),
            H.matrixWorld.compose(H.position, H.quaternion, H.scale),
            H.matrixWorldInverse.copy(H.matrixWorld).invert();
            const Je = Ne + Be
              , We = He + Be
              , xt = Ce - Ze
              , St = ze + (ve - Ze)
              , U = Me * He / We * Je
              , I = De * He / We * Je;
            H.projectionMatrix.makePerspective(xt, St, U, I, Je, We)
        }
        function F(H, se) {
            se === null ? H.matrixWorld.copy(H.matrix) : H.matrixWorld.multiplyMatrices(se.matrixWorld, H.matrix),
            H.matrixWorldInverse.copy(H.matrixWorld).invert()
        }
        this.updateCamera = function(H) {
            if (r === null)
                return;
            B.near = R.near = P.near = H.near,
            B.far = R.far = P.far = H.far,
            (L !== B.near || z !== B.far) && (r.updateRenderState({
                depthNear: B.near,
                depthFar: B.far
            }),
            L = B.near,
            z = B.far);
            const se = H.parent
              , ye = B.cameras;
            F(B, se);
            for (let q = 0; q < ye.length; q++)
                F(ye[q], se);
            B.matrixWorld.decompose(B.position, B.quaternion, B.scale),
            H.matrix.copy(B.matrix),
            H.matrix.decompose(H.position, H.quaternion, H.scale);
            const ve = H.children;
            for (let q = 0, Ie = ve.length; q < Ie; q++)
                ve[q].updateMatrixWorld(!0);
            ye.length === 2 ? ie(B, P, R) : B.projectionMatrix.copy(P.projectionMatrix)
        }
        ,
        this.getCamera = function() {
            return B
        }
        ,
        this.getFoveation = function() {
            if (!(p === null && m === null))
                return l
        }
        ,
        this.setFoveation = function(H) {
            l = H,
            p !== null && (p.fixedFoveation = H),
            m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = H)
        }
        ,
        this.getPlanes = function() {
            return S
        }
        ;
        let V = null;
        function j(H, se) {
            if (d = se.getViewerPose(c || o),
            y = se,
            d !== null) {
                const ye = d.views;
                m !== null && (e.setRenderTargetFramebuffer(x, m.framebuffer),
                e.setRenderTarget(x));
                let ve = !1;
                ye.length !== B.cameras.length && (B.cameras.length = 0,
                ve = !0);
                for (let q = 0; q < ye.length; q++) {
                    const Ie = ye[q];
                    let Ne = null;
                    if (m !== null)
                        Ne = m.getViewport(Ie);
                    else {
                        const Me = h.getViewSubImage(p, Ie);
                        Ne = Me.viewport,
                        q === 0 && (e.setRenderTargetTextures(x, Me.colorTexture, p.ignoreDepthValues ? void 0 : Me.depthStencilTexture),
                        e.setRenderTarget(x))
                    }
                    let He = E[q];
                    He === void 0 && (He = new Ht,
                    He.layers.enable(q),
                    He.viewport = new Nt,
                    E[q] = He),
                    He.matrix.fromArray(Ie.transform.matrix),
                    He.projectionMatrix.fromArray(Ie.projectionMatrix),
                    He.viewport.set(Ne.x, Ne.y, Ne.width, Ne.height),
                    q === 0 && B.matrix.copy(He.matrix),
                    ve === !0 && B.cameras.push(He)
                }
            }
            for (let ye = 0; ye < A.length; ye++) {
                const ve = M[ye]
                  , q = A[ye];
                ve !== null && q !== void 0 && q.update(ve, se, c || o)
            }
            if (V && V(H, se),
            se.detectedPlanes) {
                i.dispatchEvent({
                    type: "planesdetected",
                    data: se.detectedPlanes
                });
                let ye = null;
                for (const ve of S)
                    se.detectedPlanes.has(ve) || (ye === null && (ye = []),
                    ye.push(ve));
                if (ye !== null)
                    for (const ve of ye)
                        S.delete(ve),
                        T.delete(ve),
                        i.dispatchEvent({
                            type: "planeremoved",
                            data: ve
                        });
                for (const ve of se.detectedPlanes)
                    if (!S.has(ve))
                        S.add(ve),
                        T.set(ve, se.lastChangedTime),
                        i.dispatchEvent({
                            type: "planeadded",
                            data: ve
                        });
                    else {
                        const q = T.get(ve);
                        ve.lastChangedTime > q && (T.set(ve, ve.lastChangedTime),
                        i.dispatchEvent({
                            type: "planechanged",
                            data: ve
                        }))
                    }
            }
            y = null
        }
        const re = new gB;
        re.setAnimationLoop(j),
        this.setAnimationLoop = function(H) {
            V = H
        }
        ,
        this.dispose = function() {}
    }
}
function M8(n, e) {
    function t(v, _) {
        _.color.getRGB(v.fogColor.value, pB(n)),
        _.isFog ? (v.fogNear.value = _.near,
        v.fogFar.value = _.far) : _.isFogExp2 && (v.fogDensity.value = _.density)
    }
    function i(v, _, x, A, M) {
        _.isMeshBasicMaterial || _.isMeshLambertMaterial ? r(v, _) : _.isMeshToonMaterial ? (r(v, _),
        d(v, _)) : _.isMeshPhongMaterial ? (r(v, _),
        c(v, _)) : _.isMeshStandardMaterial ? (r(v, _),
        h(v, _),
        _.isMeshPhysicalMaterial && p(v, _, M)) : _.isMeshMatcapMaterial ? (r(v, _),
        m(v, _)) : _.isMeshDepthMaterial ? r(v, _) : _.isMeshDistanceMaterial ? (r(v, _),
        y(v, _)) : _.isMeshNormalMaterial ? r(v, _) : _.isLineBasicMaterial ? (s(v, _),
        _.isLineDashedMaterial && o(v, _)) : _.isPointsMaterial ? a(v, _, x, A) : _.isSpriteMaterial ? l(v, _) : _.isShadowMaterial ? (v.color.value.copy(_.color),
        v.opacity.value = _.opacity) : _.isShaderMaterial && (_.uniformsNeedUpdate = !1)
    }
    function r(v, _) {
        v.opacity.value = _.opacity,
        _.color && v.diffuse.value.copy(_.color),
        _.emissive && v.emissive.value.copy(_.emissive).multiplyScalar(_.emissiveIntensity),
        _.map && (v.map.value = _.map),
        _.alphaMap && (v.alphaMap.value = _.alphaMap),
        _.bumpMap && (v.bumpMap.value = _.bumpMap,
        v.bumpScale.value = _.bumpScale,
        _.side === Bi && (v.bumpScale.value *= -1)),
        _.displacementMap && (v.displacementMap.value = _.displacementMap,
        v.displacementScale.value = _.displacementScale,
        v.displacementBias.value = _.displacementBias),
        _.emissiveMap && (v.emissiveMap.value = _.emissiveMap),
        _.normalMap && (v.normalMap.value = _.normalMap,
        v.normalScale.value.copy(_.normalScale),
        _.side === Bi && v.normalScale.value.negate()),
        _.specularMap && (v.specularMap.value = _.specularMap),
        _.alphaTest > 0 && (v.alphaTest.value = _.alphaTest);
        const x = e.get(_).envMap;
        if (x && (v.envMap.value = x,
        v.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1,
        v.reflectivity.value = _.reflectivity,
        v.ior.value = _.ior,
        v.refractionRatio.value = _.refractionRatio),
        _.lightMap) {
            v.lightMap.value = _.lightMap;
            const S = n.physicallyCorrectLights !== !0 ? Math.PI : 1;
            v.lightMapIntensity.value = _.lightMapIntensity * S
        }
        _.aoMap && (v.aoMap.value = _.aoMap,
        v.aoMapIntensity.value = _.aoMapIntensity);
        let A;
        _.map ? A = _.map : _.specularMap ? A = _.specularMap : _.displacementMap ? A = _.displacementMap : _.normalMap ? A = _.normalMap : _.bumpMap ? A = _.bumpMap : _.roughnessMap ? A = _.roughnessMap : _.metalnessMap ? A = _.metalnessMap : _.alphaMap ? A = _.alphaMap : _.emissiveMap ? A = _.emissiveMap : _.clearcoatMap ? A = _.clearcoatMap : _.clearcoatNormalMap ? A = _.clearcoatNormalMap : _.clearcoatRoughnessMap ? A = _.clearcoatRoughnessMap : _.iridescenceMap ? A = _.iridescenceMap : _.iridescenceThicknessMap ? A = _.iridescenceThicknessMap : _.specularIntensityMap ? A = _.specularIntensityMap : _.specularColorMap ? A = _.specularColorMap : _.transmissionMap ? A = _.transmissionMap : _.thicknessMap ? A = _.thicknessMap : _.sheenColorMap ? A = _.sheenColorMap : _.sheenRoughnessMap && (A = _.sheenRoughnessMap),
        A !== void 0 && (A.isWebGLRenderTarget && (A = A.texture),
        A.matrixAutoUpdate === !0 && A.updateMatrix(),
        v.uvTransform.value.copy(A.matrix));
        let M;
        _.aoMap ? M = _.aoMap : _.lightMap && (M = _.lightMap),
        M !== void 0 && (M.isWebGLRenderTarget && (M = M.texture),
        M.matrixAutoUpdate === !0 && M.updateMatrix(),
        v.uv2Transform.value.copy(M.matrix))
    }
    function s(v, _) {
        v.diffuse.value.copy(_.color),
        v.opacity.value = _.opacity
    }
    function o(v, _) {
        v.dashSize.value = _.dashSize,
        v.totalSize.value = _.dashSize + _.gapSize,
        v.scale.value = _.scale
    }
    function a(v, _, x, A) {
        v.diffuse.value.copy(_.color),
        v.opacity.value = _.opacity,
        v.size.value = _.size * x,
        v.scale.value = A * .5,
        _.map && (v.map.value = _.map),
        _.alphaMap && (v.alphaMap.value = _.alphaMap),
        _.alphaTest > 0 && (v.alphaTest.value = _.alphaTest);
        let M;
        _.map ? M = _.map : _.alphaMap && (M = _.alphaMap),
        M !== void 0 && (M.matrixAutoUpdate === !0 && M.updateMatrix(),
        v.uvTransform.value.copy(M.matrix))
    }
    function l(v, _) {
        v.diffuse.value.copy(_.color),
        v.opacity.value = _.opacity,
        v.rotation.value = _.rotation,
        _.map && (v.map.value = _.map),
        _.alphaMap && (v.alphaMap.value = _.alphaMap),
        _.alphaTest > 0 && (v.alphaTest.value = _.alphaTest);
        let x;
        _.map ? x = _.map : _.alphaMap && (x = _.alphaMap),
        x !== void 0 && (x.matrixAutoUpdate === !0 && x.updateMatrix(),
        v.uvTransform.value.copy(x.matrix))
    }
    function c(v, _) {
        v.specular.value.copy(_.specular),
        v.shininess.value = Math.max(_.shininess, 1e-4)
    }
    function d(v, _) {
        _.gradientMap && (v.gradientMap.value = _.gradientMap)
    }
    function h(v, _) {
        v.roughness.value = _.roughness,
        v.metalness.value = _.metalness,
        _.roughnessMap && (v.roughnessMap.value = _.roughnessMap),
        _.metalnessMap && (v.metalnessMap.value = _.metalnessMap),
        e.get(_).envMap && (v.envMapIntensity.value = _.envMapIntensity)
    }
    function p(v, _, x) {
        v.ior.value = _.ior,
        _.sheen > 0 && (v.sheenColor.value.copy(_.sheenColor).multiplyScalar(_.sheen),
        v.sheenRoughness.value = _.sheenRoughness,
        _.sheenColorMap && (v.sheenColorMap.value = _.sheenColorMap),
        _.sheenRoughnessMap && (v.sheenRoughnessMap.value = _.sheenRoughnessMap)),
        _.clearcoat > 0 && (v.clearcoat.value = _.clearcoat,
        v.clearcoatRoughness.value = _.clearcoatRoughness,
        _.clearcoatMap && (v.clearcoatMap.value = _.clearcoatMap),
        _.clearcoatRoughnessMap && (v.clearcoatRoughnessMap.value = _.clearcoatRoughnessMap),
        _.clearcoatNormalMap && (v.clearcoatNormalScale.value.copy(_.clearcoatNormalScale),
        v.clearcoatNormalMap.value = _.clearcoatNormalMap,
        _.side === Bi && v.clearcoatNormalScale.value.negate())),
        _.iridescence > 0 && (v.iridescence.value = _.iridescence,
        v.iridescenceIOR.value = _.iridescenceIOR,
        v.iridescenceThicknessMinimum.value = _.iridescenceThicknessRange[0],
        v.iridescenceThicknessMaximum.value = _.iridescenceThicknessRange[1],
        _.iridescenceMap && (v.iridescenceMap.value = _.iridescenceMap),
        _.iridescenceThicknessMap && (v.iridescenceThicknessMap.value = _.iridescenceThicknessMap)),
        _.transmission > 0 && (v.transmission.value = _.transmission,
        v.transmissionSamplerMap.value = x.texture,
        v.transmissionSamplerSize.value.set(x.width, x.height),
        _.transmissionMap && (v.transmissionMap.value = _.transmissionMap),
        v.thickness.value = _.thickness,
        _.thicknessMap && (v.thicknessMap.value = _.thicknessMap),
        v.attenuationDistance.value = _.attenuationDistance,
        v.attenuationColor.value.copy(_.attenuationColor)),
        v.specularIntensity.value = _.specularIntensity,
        v.specularColor.value.copy(_.specularColor),
        _.specularIntensityMap && (v.specularIntensityMap.value = _.specularIntensityMap),
        _.specularColorMap && (v.specularColorMap.value = _.specularColorMap)
    }
    function m(v, _) {
        _.matcap && (v.matcap.value = _.matcap)
    }
    function y(v, _) {
        v.referencePosition.value.copy(_.referencePosition),
        v.nearDistance.value = _.nearDistance,
        v.farDistance.value = _.farDistance
    }
    return {
        refreshFogUniforms: t,
        refreshMaterialUniforms: i
    }
}
function w8(n, e, t, i) {
    let r = {}
      , s = {}
      , o = [];
    const a = t.isWebGL2 ? n.getParameter(35375) : 0;
    function l(A, M) {
        const S = M.program;
        i.uniformBlockBinding(A, S)
    }
    function c(A, M) {
        let S = r[A.id];
        S === void 0 && (y(A),
        S = d(A),
        r[A.id] = S,
        A.addEventListener("dispose", _));
        const T = M.program;
        i.updateUBOMapping(A, T);
        const P = e.render.frame;
        s[A.id] !== P && (p(A),
        s[A.id] = P)
    }
    function d(A) {
        const M = h();
        A.__bindingPointIndex = M;
        const S = n.createBuffer()
          , T = A.__size
          , P = A.usage;
        return n.bindBuffer(35345, S),
        n.bufferData(35345, T, P),
        n.bindBuffer(35345, null),
        n.bindBufferBase(35345, M, S),
        S
    }
    function h() {
        for (let A = 0; A < a; A++)
            if (o.indexOf(A) === -1)
                return o.push(A),
                A;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
        0
    }
    function p(A) {
        const M = r[A.id]
          , S = A.uniforms
          , T = A.__cache;
        n.bindBuffer(35345, M);
        for (let P = 0, R = S.length; P < R; P++) {
            const E = S[P];
            if (m(E, P, T) === !0) {
                const B = E.__offset
                  , L = Array.isArray(E.value) ? E.value : [E.value];
                let z = 0;
                for (let Z = 0; Z < L.length; Z++) {
                    const J = L[Z]
                      , G = v(J);
                    typeof J == "number" ? (E.__data[0] = J,
                    n.bufferSubData(35345, B + z, E.__data)) : J.isMatrix3 ? (E.__data[0] = J.elements[0],
                    E.__data[1] = J.elements[1],
                    E.__data[2] = J.elements[2],
                    E.__data[3] = J.elements[0],
                    E.__data[4] = J.elements[3],
                    E.__data[5] = J.elements[4],
                    E.__data[6] = J.elements[5],
                    E.__data[7] = J.elements[0],
                    E.__data[8] = J.elements[6],
                    E.__data[9] = J.elements[7],
                    E.__data[10] = J.elements[8],
                    E.__data[11] = J.elements[0]) : (J.toArray(E.__data, z),
                    z += G.storage / Float32Array.BYTES_PER_ELEMENT)
                }
                n.bufferSubData(35345, B, E.__data)
            }
        }
        n.bindBuffer(35345, null)
    }
    function m(A, M, S) {
        const T = A.value;
        if (S[M] === void 0) {
            if (typeof T == "number")
                S[M] = T;
            else {
                const P = Array.isArray(T) ? T : [T]
                  , R = [];
                for (let E = 0; E < P.length; E++)
                    R.push(P[E].clone());
                S[M] = R
            }
            return !0
        } else if (typeof T == "number") {
            if (S[M] !== T)
                return S[M] = T,
                !0
        } else {
            const P = Array.isArray(S[M]) ? S[M] : [S[M]]
              , R = Array.isArray(T) ? T : [T];
            for (let E = 0; E < P.length; E++) {
                const B = P[E];
                if (B.equals(R[E]) === !1)
                    return B.copy(R[E]),
                    !0
            }
        }
        return !1
    }
    function y(A) {
        const M = A.uniforms;
        let S = 0;
        const T = 16;
        let P = 0;
        for (let R = 0, E = M.length; R < E; R++) {
            const B = M[R]
              , L = {
                boundary: 0,
                storage: 0
            }
              , z = Array.isArray(B.value) ? B.value : [B.value];
            for (let Z = 0, J = z.length; Z < J; Z++) {
                const G = z[Z]
                  , X = v(G);
                L.boundary += X.boundary,
                L.storage += X.storage
            }
            if (B.__data = new Float32Array(L.storage / Float32Array.BYTES_PER_ELEMENT),
            B.__offset = S,
            R > 0) {
                P = S % T;
                const Z = T - P;
                P !== 0 && Z - L.boundary < 0 && (S += T - P,
                B.__offset = S)
            }
            S += L.storage
        }
        return P = S % T,
        P > 0 && (S += T - P),
        A.__size = S,
        A.__cache = {},
        this
    }
    function v(A) {
        const M = {
            boundary: 0,
            storage: 0
        };
        return typeof A == "number" ? (M.boundary = 4,
        M.storage = 4) : A.isVector2 ? (M.boundary = 8,
        M.storage = 8) : A.isVector3 || A.isColor ? (M.boundary = 16,
        M.storage = 12) : A.isVector4 ? (M.boundary = 16,
        M.storage = 16) : A.isMatrix3 ? (M.boundary = 48,
        M.storage = 48) : A.isMatrix4 ? (M.boundary = 64,
        M.storage = 64) : A.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", A),
        M
    }
    function _(A) {
        const M = A.target;
        M.removeEventListener("dispose", _);
        const S = o.indexOf(M.__bindingPointIndex);
        o.splice(S, 1),
        n.deleteBuffer(r[M.id]),
        delete r[M.id],
        delete s[M.id]
    }
    function x() {
        for (const A in r)
            n.deleteBuffer(r[A]);
        o = [],
        r = {},
        s = {}
    }
    return {
        bind: l,
        update: c,
        dispose: x
    }
}
function S8() {
    const n = rd("canvas");
    return n.style.display = "block",
    n
}
function bA(n={}) {
    this.isWebGLRenderer = !0;
    const e = n.canvas !== void 0 ? n.canvas : S8()
      , t = n.context !== void 0 ? n.context : null
      , i = n.depth !== void 0 ? n.depth : !0
      , r = n.stencil !== void 0 ? n.stencil : !0
      , s = n.antialias !== void 0 ? n.antialias : !1
      , o = n.premultipliedAlpha !== void 0 ? n.premultipliedAlpha : !0
      , a = n.preserveDrawingBuffer !== void 0 ? n.preserveDrawingBuffer : !1
      , l = n.powerPreference !== void 0 ? n.powerPreference : "default"
      , c = n.failIfMajorPerformanceCaveat !== void 0 ? n.failIfMajorPerformanceCaveat : !1;
    let d;
    t !== null ? d = t.getContextAttributes().alpha : d = n.alpha !== void 0 ? n.alpha : !1;
    let h = null
      , p = null;
    const m = []
      , y = [];
    this.domElement = e,
    this.debug = {
        checkShaderErrors: !0
    },
    this.autoClear = !0,
    this.autoClearColor = !0,
    this.autoClearDepth = !0,
    this.autoClearStencil = !0,
    this.sortObjects = !0,
    this.clippingPlanes = [],
    this.localClippingEnabled = !1,
    this.outputEncoding = Xs,
    this.physicallyCorrectLights = !1,
    this.toneMapping = kr,
    this.toneMappingExposure = 1;
    const v = this;
    let _ = !1
      , x = 0
      , A = 0
      , M = null
      , S = -1
      , T = null;
    const P = new Nt
      , R = new Nt;
    let E = null
      , B = e.width
      , L = e.height
      , z = 1
      , Z = null
      , J = null;
    const G = new Nt(0,0,B,L)
      , X = new Nt(0,0,B,L);
    let ee = !1;
    const ie = new Zg;
    let F = !1
      , V = !1
      , j = null;
    const re = new rt
      , H = new pe
      , se = new D
      , ye = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0
    };
    function ve() {
        return M === null ? z : 1
    }
    let q = t;
    function Ie(k, te) {
        for (let he = 0; he < k.length; he++) {
            const $ = k[he]
              , ge = e.getContext($, te);
            if (ge !== null)
                return ge
        }
        return null
    }
    try {
        const k = {
            alpha: !0,
            depth: i,
            stencil: r,
            antialias: s,
            premultipliedAlpha: o,
            preserveDrawingBuffer: a,
            powerPreference: l,
            failIfMajorPerformanceCaveat: c
        };
        if ("setAttribute"in e && e.setAttribute("data-engine", `three.js r${jg}`),
        e.addEventListener("webglcontextlost", Ae, !1),
        e.addEventListener("webglcontextrestored", be, !1),
        e.addEventListener("webglcontextcreationerror", $e, !1),
        q === null) {
            const te = ["webgl2", "webgl", "experimental-webgl"];
            if (v.isWebGL1Renderer === !0 && te.shift(),
            q = Ie(te, k),
            q === null)
                throw Ie(te) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
        }
        q.getShaderPrecisionFormat === void 0 && (q.getShaderPrecisionFormat = function() {
            return {
                rangeMin: 1,
                rangeMax: 1,
                precision: 1
            }
        }
        )
    } catch (k) {
        throw console.error("THREE.WebGLRenderer: " + k.message),
        k
    }
    let Ne, He, Me, De, de, ae, Ce, ze, Be, Ze, Je, We, xt, St, U, I, oe, we, Ee, Pe, tt, Fe, me, Xe;
    function W() {
        Ne = new z5(q),
        He = new D5(q,Ne,n),
        Ne.init(He),
        Fe = new AB(q,Ne,He),
        Me = new v8(q,Ne,He),
        De = new V5,
        de = new o8,
        ae = new x8(q,Ne,Me,de,He,Fe,De),
        Ce = new k5(v),
        ze = new U5(v),
        Be = new q4(q,He),
        me = new L5(q,Ne,Be,He),
        Ze = new G5(q,Be,De,me),
        Je = new X5(q,Ze,Be,De),
        Ee = new J5(q,He,ae),
        I = new F5(de),
        We = new s8(v,Ce,ze,Ne,He,me,I),
        xt = new M8(v,de),
        St = new l8,
        U = new p8(Ne,He),
        we = new R5(v,Ce,ze,Me,Je,d,o),
        oe = new y8(v,Je,He),
        Xe = new w8(q,De,He,Me),
        Pe = new I5(q,Ne,De,He),
        tt = new H5(q,Ne,De,He),
        De.programs = We.programs,
        v.capabilities = He,
        v.extensions = Ne,
        v.properties = de,
        v.renderLists = St,
        v.shadowMap = oe,
        v.state = Me,
        v.info = De
    }
    W();
    const le = new A8(v,q);
    this.xr = le,
    this.getContext = function() {
        return q
    }
    ,
    this.getContextAttributes = function() {
        return q.getContextAttributes()
    }
    ,
    this.forceContextLoss = function() {
        const k = Ne.get("WEBGL_lose_context");
        k && k.loseContext()
    }
    ,
    this.forceContextRestore = function() {
        const k = Ne.get("WEBGL_lose_context");
        k && k.restoreContext()
    }
    ,
    this.getPixelRatio = function() {
        return z
    }
    ,
    this.setPixelRatio = function(k) {
        k !== void 0 && (z = k,
        this.setSize(B, L, !1))
    }
    ,
    this.getSize = function(k) {
        return k.set(B, L)
    }
    ,
    this.setSize = function(k, te, he) {
        if (le.isPresenting) {
            console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            return
        }
        B = k,
        L = te,
        e.width = Math.floor(k * z),
        e.height = Math.floor(te * z),
        he !== !1 && (e.style.width = k + "px",
        e.style.height = te + "px"),
        this.setViewport(0, 0, k, te)
    }
    ,
    this.getDrawingBufferSize = function(k) {
        return k.set(B * z, L * z).floor()
    }
    ,
    this.setDrawingBufferSize = function(k, te, he) {
        B = k,
        L = te,
        z = he,
        e.width = Math.floor(k * he),
        e.height = Math.floor(te * he),
        this.setViewport(0, 0, k, te)
    }
    ,
    this.getCurrentViewport = function(k) {
        return k.copy(P)
    }
    ,
    this.getViewport = function(k) {
        return k.copy(G)
    }
    ,
    this.setViewport = function(k, te, he, $) {
        k.isVector4 ? G.set(k.x, k.y, k.z, k.w) : G.set(k, te, he, $),
        Me.viewport(P.copy(G).multiplyScalar(z).floor())
    }
    ,
    this.getScissor = function(k) {
        return k.copy(X)
    }
    ,
    this.setScissor = function(k, te, he, $) {
        k.isVector4 ? X.set(k.x, k.y, k.z, k.w) : X.set(k, te, he, $),
        Me.scissor(R.copy(X).multiplyScalar(z).floor())
    }
    ,
    this.getScissorTest = function() {
        return ee
    }
    ,
    this.setScissorTest = function(k) {
        Me.setScissorTest(ee = k)
    }
    ,
    this.setOpaqueSort = function(k) {
        Z = k
    }
    ,
    this.setTransparentSort = function(k) {
        J = k
    }
    ,
    this.getClearColor = function(k) {
        return k.copy(we.getClearColor())
    }
    ,
    this.setClearColor = function() {
        we.setClearColor.apply(we, arguments)
    }
    ,
    this.getClearAlpha = function() {
        return we.getClearAlpha()
    }
    ,
    this.setClearAlpha = function() {
        we.setClearAlpha.apply(we, arguments)
    }
    ,
    this.clear = function(k=!0, te=!0, he=!0) {
        let $ = 0;
        k && ($ |= 16384),
        te && ($ |= 256),
        he && ($ |= 1024),
        q.clear($)
    }
    ,
    this.clearColor = function() {
        this.clear(!0, !1, !1)
    }
    ,
    this.clearDepth = function() {
        this.clear(!1, !0, !1)
    }
    ,
    this.clearStencil = function() {
        this.clear(!1, !1, !0)
    }
    ,
    this.dispose = function() {
        e.removeEventListener("webglcontextlost", Ae, !1),
        e.removeEventListener("webglcontextrestored", be, !1),
        e.removeEventListener("webglcontextcreationerror", $e, !1),
        St.dispose(),
        U.dispose(),
        de.dispose(),
        Ce.dispose(),
        ze.dispose(),
        Je.dispose(),
        me.dispose(),
        Xe.dispose(),
        We.dispose(),
        le.dispose(),
        le.removeEventListener("sessionstart", Ue),
        le.removeEventListener("sessionend", Ye),
        j && (j.dispose(),
        j = null),
        Pt.stop()
    }
    ;
    function Ae(k) {
        k.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        _ = !0
    }
    function be() {
        console.log("THREE.WebGLRenderer: Context Restored."),
        _ = !1;
        const k = De.autoReset
          , te = oe.enabled
          , he = oe.autoUpdate
          , $ = oe.needsUpdate
          , ge = oe.type;
        W(),
        De.autoReset = k,
        oe.enabled = te,
        oe.autoUpdate = he,
        oe.needsUpdate = $,
        oe.type = ge
    }
    function $e(k) {
        console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", k.statusMessage)
    }
    function vt(k) {
        const te = k.target;
        te.removeEventListener("dispose", vt),
        Wt(te)
    }
    function Wt(k) {
        Y(k),
        de.remove(k)
    }
    function Y(k) {
        const te = de.get(k).programs;
        te !== void 0 && (te.forEach(function(he) {
            We.releaseProgram(he)
        }),
        k.isShaderMaterial && We.releaseShaderCache(k))
    }
    this.renderBufferDirect = function(k, te, he, $, ge, qe) {
        te === null && (te = ye);
        const it = ge.isMesh && ge.matrixWorld.determinant() < 0
          , dt = y0(k, te, he, $, ge);
        Me.setMaterial($, it);
        let gt = he.index
          , Ct = 1;
        $.wireframe === !0 && (gt = Ze.getWireframeAttribute(he),
        Ct = 2);
        const At = he.drawRange
          , Mt = he.attributes.position;
        let ln = At.start * Ct
          , si = (At.start + At.count) * Ct;
        qe !== null && (ln = Math.max(ln, qe.start * Ct),
        si = Math.min(si, (qe.start + qe.count) * Ct)),
        gt !== null ? (ln = Math.max(ln, 0),
        si = Math.min(si, gt.count)) : Mt != null && (ln = Math.max(ln, 0),
        si = Math.min(si, Mt.count));
        const _r = si - ln;
        if (_r < 0 || _r === 1 / 0)
            return;
        me.setup(ge, $, dt, he, gt);
        let fs, Kt = Pe;
        if (gt !== null && (fs = Be.get(gt),
        Kt = tt,
        Kt.setIndex(fs)),
        ge.isMesh)
            $.wireframe === !0 ? (Me.setLineWidth($.wireframeLinewidth * ve()),
            Kt.setMode(1)) : Kt.setMode(4);
        else if (ge.isLine) {
            let ht = $.linewidth;
            ht === void 0 && (ht = 1),
            Me.setLineWidth(ht * ve()),
            ge.isLineSegments ? Kt.setMode(1) : ge.isLineLoop ? Kt.setMode(2) : Kt.setMode(3)
        } else
            ge.isPoints ? Kt.setMode(0) : ge.isSprite && Kt.setMode(4);
        if (ge.isInstancedMesh)
            Kt.renderInstances(ln, _r, ge.count);
        else if (he.isInstancedBufferGeometry) {
            const ht = he._maxInstanceCount !== void 0 ? he._maxInstanceCount : 1 / 0
              , oa = Math.min(he.instanceCount, ht);
            Kt.renderInstances(ln, _r, oa)
        } else
            Kt.render(ln, _r)
    }
    ,
    this.compile = function(k, te) {
        function he($, ge, qe) {
            $.transparent === !0 && $.side === Ir && $.forceSinglePass === !1 ? ($.side = Bi,
            $.needsUpdate = !0,
            xi($, ge, qe),
            $.side = as,
            $.needsUpdate = !0,
            xi($, ge, qe),
            $.side = Ir) : xi($, ge, qe)
        }
        p = U.get(k),
        p.init(),
        y.push(p),
        k.traverseVisible(function($) {
            $.isLight && $.layers.test(te.layers) && (p.pushLight($),
            $.castShadow && p.pushShadow($))
        }),
        p.setupLights(v.physicallyCorrectLights),
        k.traverse(function($) {
            const ge = $.material;
            if (ge)
                if (Array.isArray(ge))
                    for (let qe = 0; qe < ge.length; qe++) {
                        const it = ge[qe];
                        he(it, k, $)
                    }
                else
                    he(ge, k, $)
        }),
        y.pop(),
        p = null
    }
    ;
    let ce = null;
    function _e(k) {
        ce && ce(k)
    }
    function Ue() {
        Pt.stop()
    }
    function Ye() {
        Pt.start()
    }
    const Pt = new gB;
    Pt.setAnimationLoop(_e),
    typeof self < "u" && Pt.setContext(self),
    this.setAnimationLoop = function(k) {
        ce = k,
        le.setAnimationLoop(k),
        k === null ? Pt.stop() : Pt.start()
    }
    ,
    le.addEventListener("sessionstart", Ue),
    le.addEventListener("sessionend", Ye),
    this.render = function(k, te) {
        if (te !== void 0 && te.isCamera !== !0) {
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            return
        }
        if (_ === !0)
            return;
        k.matrixWorldAutoUpdate === !0 && k.updateMatrixWorld(),
        te.parent === null && te.matrixWorldAutoUpdate === !0 && te.updateMatrixWorld(),
        le.enabled === !0 && le.isPresenting === !0 && (le.cameraAutoUpdate === !0 && le.updateCamera(te),
        te = le.getCamera()),
        k.isScene === !0 && k.onBeforeRender(v, k, te, M),
        p = U.get(k, y.length),
        p.init(),
        y.push(p),
        re.multiplyMatrices(te.projectionMatrix, te.matrixWorldInverse),
        ie.setFromProjectionMatrix(re),
        V = this.localClippingEnabled,
        F = I.init(this.clippingPlanes, V),
        h = St.get(k, m.length),
        h.init(),
        m.push(h),
        pn(k, te, 0, v.sortObjects),
        h.finish(),
        v.sortObjects === !0 && h.sort(Z, J),
        F === !0 && I.beginShadows();
        const he = p.state.shadowsArray;
        if (oe.render(he, k, te),
        F === !0 && I.endShadows(),
        this.info.autoReset === !0 && this.info.reset(),
        we.render(h, k),
        p.setupLights(v.physicallyCorrectLights),
        te.isArrayCamera) {
            const $ = te.cameras;
            for (let ge = 0, qe = $.length; ge < qe; ge++) {
                const it = $[ge];
                Ln(h, k, it, it.viewport)
            }
        } else
            Ln(h, k, te);
        M !== null && (ae.updateMultisampleRenderTarget(M),
        ae.updateRenderTargetMipmap(M)),
        k.isScene === !0 && k.onAfterRender(v, k, te),
        me.resetDefaultState(),
        S = -1,
        T = null,
        y.pop(),
        y.length > 0 ? p = y[y.length - 1] : p = null,
        m.pop(),
        m.length > 0 ? h = m[m.length - 1] : h = null
    }
    ;
    function pn(k, te, he, $) {
        if (k.visible === !1)
            return;
        if (k.layers.test(te.layers)) {
            if (k.isGroup)
                he = k.renderOrder;
            else if (k.isLOD)
                k.autoUpdate === !0 && k.update(te);
            else if (k.isLight)
                p.pushLight(k),
                k.castShadow && p.pushShadow(k);
            else if (k.isSprite) {
                if (!k.frustumCulled || ie.intersectsSprite(k)) {
                    $ && se.setFromMatrixPosition(k.matrixWorld).applyMatrix4(re);
                    const it = Je.update(k)
                      , dt = k.material;
                    dt.visible && h.push(k, it, dt, he, se.z, null)
                }
            } else if ((k.isMesh || k.isLine || k.isPoints) && (k.isSkinnedMesh && k.skeleton.frame !== De.render.frame && (k.skeleton.update(),
            k.skeleton.frame = De.render.frame),
            !k.frustumCulled || ie.intersectsObject(k))) {
                $ && se.setFromMatrixPosition(k.matrixWorld).applyMatrix4(re);
                const it = Je.update(k)
                  , dt = k.material;
                if (Array.isArray(dt)) {
                    const gt = it.groups;
                    for (let Ct = 0, At = gt.length; Ct < At; Ct++) {
                        const Mt = gt[Ct]
                          , ln = dt[Mt.materialIndex];
                        ln && ln.visible && h.push(k, it, ln, he, se.z, Mt)
                    }
                } else
                    dt.visible && h.push(k, it, dt, he, se.z, null)
            }
        }
        const qe = k.children;
        for (let it = 0, dt = qe.length; it < dt; it++)
            pn(qe[it], te, he, $)
    }
    function Ln(k, te, he, $) {
        const ge = k.opaque
          , qe = k.transmissive
          , it = k.transparent;
        p.setupLightsView(he),
        F === !0 && I.setGlobalState(v.clippingPlanes, he),
        qe.length > 0 && Wr(ge, te, he),
        $ && Me.viewport(P.copy($)),
        ge.length > 0 && Ut(ge, te, he),
        qe.length > 0 && Ut(qe, te, he),
        it.length > 0 && Ut(it, te, he),
        Me.buffers.depth.setTest(!0),
        Me.buffers.depth.setMask(!0),
        Me.buffers.color.setMask(!0),
        Me.setPolygonOffset(!1)
    }
    function Wr(k, te, he) {
        const $ = He.isWebGL2;
        j === null && (j = new Ur(1,1,{
            generateMipmaps: !0,
            type: Ne.has("EXT_color_buffer_half_float") ? Nu : Js,
            minFilter: ls,
            samples: $ && s === !0 ? 4 : 0
        })),
        v.getDrawingBufferSize(H),
        $ ? j.setSize(H.x, H.y) : j.setSize(cg(H.x), cg(H.y));
        const ge = v.getRenderTarget();
        v.setRenderTarget(j),
        v.clear();
        const qe = v.toneMapping;
        v.toneMapping = kr,
        Ut(k, te, he),
        v.toneMapping = qe,
        ae.updateMultisampleRenderTarget(j),
        ae.updateRenderTargetMipmap(j),
        v.setRenderTarget(ge)
    }
    function Ut(k, te, he) {
        const $ = te.isScene === !0 ? te.overrideMaterial : null;
        for (let ge = 0, qe = k.length; ge < qe; ge++) {
            const it = k[ge]
              , dt = it.object
              , gt = it.geometry
              , Ct = $ === null ? it.material : $
              , At = it.group;
            dt.layers.test(he.layers) && Yi(dt, te, he, gt, Ct, At)
        }
    }
    function Yi(k, te, he, $, ge, qe) {
        k.onBeforeRender(v, te, he, $, ge, qe),
        k.modelViewMatrix.multiplyMatrices(he.matrixWorldInverse, k.matrixWorld),
        k.normalMatrix.getNormalMatrix(k.modelViewMatrix),
        ge.onBeforeRender(v, te, he, $, k, qe),
        ge.transparent === !0 && ge.side === Ir && ge.forceSinglePass === !1 ? (ge.side = Bi,
        ge.needsUpdate = !0,
        v.renderBufferDirect(he, te, $, ge, k, qe),
        ge.side = as,
        ge.needsUpdate = !0,
        v.renderBufferDirect(he, te, $, ge, k, qe),
        ge.side = Ir) : v.renderBufferDirect(he, te, $, ge, k, qe),
        k.onAfterRender(v, te, he, $, ge, qe)
    }
    function xi(k, te, he) {
        te.isScene !== !0 && (te = ye);
        const $ = de.get(k)
          , ge = p.state.lights
          , qe = p.state.shadowsArray
          , it = ge.state.version
          , dt = We.getParameters(k, ge.state, qe, te, he)
          , gt = We.getProgramCacheKey(dt);
        let Ct = $.programs;
        $.environment = k.isMeshStandardMaterial ? te.environment : null,
        $.fog = te.fog,
        $.envMap = (k.isMeshStandardMaterial ? ze : Ce).get(k.envMap || $.environment),
        Ct === void 0 && (k.addEventListener("dispose", vt),
        Ct = new Map,
        $.programs = Ct);
        let At = Ct.get(gt);
        if (At !== void 0) {
            if ($.currentProgram === At && $.lightsStateVersion === it)
                return $d(k, dt),
                At
        } else
            dt.uniforms = We.getUniforms(k),
            k.onBuild(he, dt, v),
            k.onBeforeCompile(dt, v),
            At = We.acquireProgram(dt, gt),
            Ct.set(gt, At),
            $.uniforms = dt.uniforms;
        const Mt = $.uniforms;
        (!k.isShaderMaterial && !k.isRawShaderMaterial || k.clipping === !0) && (Mt.clippingPlanes = I.uniform),
        $d(k, dt),
        $.needsLights = oc(k),
        $.lightsStateVersion = it,
        $.needsLights && (Mt.ambientLightColor.value = ge.state.ambient,
        Mt.lightProbe.value = ge.state.probe,
        Mt.directionalLights.value = ge.state.directional,
        Mt.directionalLightShadows.value = ge.state.directionalShadow,
        Mt.spotLights.value = ge.state.spot,
        Mt.spotLightShadows.value = ge.state.spotShadow,
        Mt.rectAreaLights.value = ge.state.rectArea,
        Mt.ltc_1.value = ge.state.rectAreaLTC1,
        Mt.ltc_2.value = ge.state.rectAreaLTC2,
        Mt.pointLights.value = ge.state.point,
        Mt.pointLightShadows.value = ge.state.pointShadow,
        Mt.hemisphereLights.value = ge.state.hemi,
        Mt.directionalShadowMap.value = ge.state.directionalShadowMap,
        Mt.directionalShadowMatrix.value = ge.state.directionalShadowMatrix,
        Mt.spotShadowMap.value = ge.state.spotShadowMap,
        Mt.spotLightMatrix.value = ge.state.spotLightMatrix,
        Mt.spotLightMap.value = ge.state.spotLightMap,
        Mt.pointShadowMap.value = ge.state.pointShadowMap,
        Mt.pointShadowMatrix.value = ge.state.pointShadowMatrix);
        const ln = At.getUniforms()
          , si = Bm.seqWithValue(ln.seq, Mt);
        return $.currentProgram = At,
        $.uniformsList = si,
        At
    }
    function $d(k, te) {
        const he = de.get(k);
        he.outputEncoding = te.outputEncoding,
        he.instancing = te.instancing,
        he.skinning = te.skinning,
        he.morphTargets = te.morphTargets,
        he.morphNormals = te.morphNormals,
        he.morphColors = te.morphColors,
        he.morphTargetsCount = te.morphTargetsCount,
        he.numClippingPlanes = te.numClippingPlanes,
        he.numIntersection = te.numClipIntersection,
        he.vertexAlphas = te.vertexAlphas,
        he.vertexTangents = te.vertexTangents,
        he.toneMapping = te.toneMapping
    }
    function y0(k, te, he, $, ge) {
        te.isScene !== !0 && (te = ye),
        ae.resetTextureUnits();
        const qe = te.fog
          , it = $.isMeshStandardMaterial ? te.environment : null
          , dt = M === null ? v.outputEncoding : M.isXRRenderTarget === !0 ? M.texture.encoding : Xs
          , gt = ($.isMeshStandardMaterial ? ze : Ce).get($.envMap || it)
          , Ct = $.vertexColors === !0 && !!he.attributes.color && he.attributes.color.itemSize === 4
          , At = !!$.normalMap && !!he.attributes.tangent
          , Mt = !!he.morphAttributes.position
          , ln = !!he.morphAttributes.normal
          , si = !!he.morphAttributes.color
          , _r = $.toneMapped ? v.toneMapping : kr
          , fs = he.morphAttributes.position || he.morphAttributes.normal || he.morphAttributes.color
          , Kt = fs !== void 0 ? fs.length : 0
          , ht = de.get($)
          , oa = p.state.lights;
        if (F === !0 && (V === !0 || k !== T)) {
            const kt = k === T && $.id === S;
            I.setState($, k, kt)
        }
        let un = !1;
        $.version === ht.__version ? (ht.needsLights && ht.lightsStateVersion !== oa.state.version || ht.outputEncoding !== dt || ge.isInstancedMesh && ht.instancing === !1 || !ge.isInstancedMesh && ht.instancing === !0 || ge.isSkinnedMesh && ht.skinning === !1 || !ge.isSkinnedMesh && ht.skinning === !0 || ht.envMap !== gt || $.fog === !0 && ht.fog !== qe || ht.numClippingPlanes !== void 0 && (ht.numClippingPlanes !== I.numPlanes || ht.numIntersection !== I.numIntersection) || ht.vertexAlphas !== Ct || ht.vertexTangents !== At || ht.morphTargets !== Mt || ht.morphNormals !== ln || ht.morphColors !== si || ht.toneMapping !== _r || He.isWebGL2 === !0 && ht.morphTargetsCount !== Kt) && (un = !0) : (un = !0,
        ht.__version = $.version);
        let ds = ht.currentProgram;
        un === !0 && (ds = xi($, te, ge));
        let xl = !1
          , Qi = !1
          , Zi = !1;
        const ft = ds.getUniforms()
          , Tt = ht.uniforms;
        if (Me.useProgram(ds.program) && (xl = !0,
        Qi = !0,
        Zi = !0),
        $.id !== S && (S = $.id,
        Qi = !0),
        xl || T !== k) {
            if (ft.setValue(q, "projectionMatrix", k.projectionMatrix),
            He.logarithmicDepthBuffer && ft.setValue(q, "logDepthBufFC", 2 / (Math.log(k.far + 1) / Math.LN2)),
            T !== k && (T = k,
            Qi = !0,
            Zi = !0),
            $.isShaderMaterial || $.isMeshPhongMaterial || $.isMeshToonMaterial || $.isMeshStandardMaterial || $.envMap) {
                const kt = ft.map.cameraPosition;
                kt !== void 0 && kt.setValue(q, se.setFromMatrixPosition(k.matrixWorld))
            }
            ($.isMeshPhongMaterial || $.isMeshToonMaterial || $.isMeshLambertMaterial || $.isMeshBasicMaterial || $.isMeshStandardMaterial || $.isShaderMaterial) && ft.setValue(q, "isOrthographic", k.isOrthographicCamera === !0),
            ($.isMeshPhongMaterial || $.isMeshToonMaterial || $.isMeshLambertMaterial || $.isMeshBasicMaterial || $.isMeshStandardMaterial || $.isShaderMaterial || $.isShadowMaterial || ge.isSkinnedMesh) && ft.setValue(q, "viewMatrix", k.matrixWorldInverse)
        }
        if (ge.isSkinnedMesh) {
            ft.setOptional(q, ge, "bindMatrix"),
            ft.setOptional(q, ge, "bindMatrixInverse");
            const kt = ge.skeleton;
            kt && (He.floatVertexTextures ? (kt.boneTexture === null && kt.computeBoneTexture(),
            ft.setValue(q, "boneTexture", kt.boneTexture, ae),
            ft.setValue(q, "boneTextureSize", kt.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
        }
        const qi = he.morphAttributes;
        if ((qi.position !== void 0 || qi.normal !== void 0 || qi.color !== void 0 && He.isWebGL2 === !0) && Ee.update(ge, he, $, ds),
        (Qi || ht.receiveShadow !== ge.receiveShadow) && (ht.receiveShadow = ge.receiveShadow,
        ft.setValue(q, "receiveShadow", ge.receiveShadow)),
        $.isMeshGouraudMaterial && $.envMap !== null && (Tt.envMap.value = gt,
        Tt.flipEnvMap.value = gt.isCubeTexture && gt.isRenderTargetTexture === !1 ? -1 : 1),
        Qi && (ft.setValue(q, "toneMappingExposure", v.toneMappingExposure),
        ht.needsLights && eh(Tt, Zi),
        qe && $.fog === !0 && xt.refreshFogUniforms(Tt, qe),
        xt.refreshMaterialUniforms(Tt, $, z, L, j),
        Bm.upload(q, ht.uniformsList, Tt, ae)),
        $.isShaderMaterial && $.uniformsNeedUpdate === !0 && (Bm.upload(q, ht.uniformsList, Tt, ae),
        $.uniformsNeedUpdate = !1),
        $.isSpriteMaterial && ft.setValue(q, "center", ge.center),
        ft.setValue(q, "modelViewMatrix", ge.modelViewMatrix),
        ft.setValue(q, "normalMatrix", ge.normalMatrix),
        ft.setValue(q, "modelMatrix", ge.matrixWorld),
        $.isShaderMaterial || $.isRawShaderMaterial) {
            const kt = $.uniformsGroups;
            for (let In = 0, hs = kt.length; In < hs; In++)
                if (He.isWebGL2) {
                    const ps = kt[In];
                    Xe.update(ps, ds),
                    Xe.bind(ps, ds)
                } else
                    console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
        }
        return ds
    }
    function eh(k, te) {
        k.ambientLightColor.needsUpdate = te,
        k.lightProbe.needsUpdate = te,
        k.directionalLights.needsUpdate = te,
        k.directionalLightShadows.needsUpdate = te,
        k.pointLights.needsUpdate = te,
        k.pointLightShadows.needsUpdate = te,
        k.spotLights.needsUpdate = te,
        k.spotLightShadows.needsUpdate = te,
        k.rectAreaLights.needsUpdate = te,
        k.hemisphereLights.needsUpdate = te
    }
    function oc(k) {
        return k.isMeshLambertMaterial || k.isMeshToonMaterial || k.isMeshPhongMaterial || k.isMeshStandardMaterial || k.isShadowMaterial || k.isShaderMaterial && k.lights === !0
    }
    this.getActiveCubeFace = function() {
        return x
    }
    ,
    this.getActiveMipmapLevel = function() {
        return A
    }
    ,
    this.getRenderTarget = function() {
        return M
    }
    ,
    this.setRenderTargetTextures = function(k, te, he) {
        de.get(k.texture).__webglTexture = te,
        de.get(k.depthTexture).__webglTexture = he;
        const $ = de.get(k);
        $.__hasExternalTextures = !0,
        $.__hasExternalTextures && ($.__autoAllocateDepthBuffer = he === void 0,
        $.__autoAllocateDepthBuffer || Ne.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
        $.__useRenderToTexture = !1))
    }
    ,
    this.setRenderTargetFramebuffer = function(k, te) {
        const he = de.get(k);
        he.__webglFramebuffer = te,
        he.__useDefaultFramebuffer = te === void 0
    }
    ,
    this.setRenderTarget = function(k, te=0, he=0) {
        M = k,
        x = te,
        A = he;
        let $ = !0
          , ge = null
          , qe = !1
          , it = !1;
        if (k) {
            const gt = de.get(k);
            gt.__useDefaultFramebuffer !== void 0 ? (Me.bindFramebuffer(36160, null),
            $ = !1) : gt.__webglFramebuffer === void 0 ? ae.setupRenderTarget(k) : gt.__hasExternalTextures && ae.rebindTextures(k, de.get(k.texture).__webglTexture, de.get(k.depthTexture).__webglTexture);
            const Ct = k.texture;
            (Ct.isData3DTexture || Ct.isDataArrayTexture || Ct.isCompressedArrayTexture) && (it = !0);
            const At = de.get(k).__webglFramebuffer;
            k.isWebGLCubeRenderTarget ? (ge = At[te],
            qe = !0) : He.isWebGL2 && k.samples > 0 && ae.useMultisampledRTT(k) === !1 ? ge = de.get(k).__webglMultisampledFramebuffer : ge = At,
            P.copy(k.viewport),
            R.copy(k.scissor),
            E = k.scissorTest
        } else
            P.copy(G).multiplyScalar(z).floor(),
            R.copy(X).multiplyScalar(z).floor(),
            E = ee;
        if (Me.bindFramebuffer(36160, ge) && He.drawBuffers && $ && Me.drawBuffers(k, ge),
        Me.viewport(P),
        Me.scissor(R),
        Me.setScissorTest(E),
        qe) {
            const gt = de.get(k.texture);
            q.framebufferTexture2D(36160, 36064, 34069 + te, gt.__webglTexture, he)
        } else if (it) {
            const gt = de.get(k.texture)
              , Ct = te || 0;
            q.framebufferTextureLayer(36160, 36064, gt.__webglTexture, he || 0, Ct)
        }
        S = -1
    }
    ,
    this.readRenderTargetPixels = function(k, te, he, $, ge, qe, it) {
        if (!(k && k.isWebGLRenderTarget)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            return
        }
        let dt = de.get(k).__webglFramebuffer;
        if (k.isWebGLCubeRenderTarget && it !== void 0 && (dt = dt[it]),
        dt) {
            Me.bindFramebuffer(36160, dt);
            try {
                const gt = k.texture
                  , Ct = gt.format
                  , At = gt.type;
                if (Ct !== Ci && Fe.convert(Ct) !== q.getParameter(35739)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    return
                }
                const Mt = At === Nu && (Ne.has("EXT_color_buffer_half_float") || He.isWebGL2 && Ne.has("EXT_color_buffer_float"));
                if (At !== Js && Fe.convert(At) !== q.getParameter(35738) && !(At === Ds && (He.isWebGL2 || Ne.has("OES_texture_float") || Ne.has("WEBGL_color_buffer_float"))) && !Mt) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    return
                }
                te >= 0 && te <= k.width - $ && he >= 0 && he <= k.height - ge && q.readPixels(te, he, $, ge, Fe.convert(Ct), Fe.convert(At), qe)
            } finally {
                const gt = M !== null ? de.get(M).__webglFramebuffer : null;
                Me.bindFramebuffer(36160, gt)
            }
        }
    }
    ,
    this.copyFramebufferToTexture = function(k, te, he=0) {
        const $ = Math.pow(2, -he)
          , ge = Math.floor(te.image.width * $)
          , qe = Math.floor(te.image.height * $);
        ae.setTexture2D(te, 0),
        q.copyTexSubImage2D(3553, he, 0, 0, k.x, k.y, ge, qe),
        Me.unbindTexture()
    }
    ,
    this.copyTextureToTexture = function(k, te, he, $=0) {
        const ge = te.image.width
          , qe = te.image.height
          , it = Fe.convert(he.format)
          , dt = Fe.convert(he.type);
        ae.setTexture2D(he, 0),
        q.pixelStorei(37440, he.flipY),
        q.pixelStorei(37441, he.premultiplyAlpha),
        q.pixelStorei(3317, he.unpackAlignment),
        te.isDataTexture ? q.texSubImage2D(3553, $, k.x, k.y, ge, qe, it, dt, te.image.data) : te.isCompressedTexture ? q.compressedTexSubImage2D(3553, $, k.x, k.y, te.mipmaps[0].width, te.mipmaps[0].height, it, te.mipmaps[0].data) : q.texSubImage2D(3553, $, k.x, k.y, it, dt, te.image),
        $ === 0 && he.generateMipmaps && q.generateMipmap(3553),
        Me.unbindTexture()
    }
    ,
    this.copyTextureToTexture3D = function(k, te, he, $, ge=0) {
        if (v.isWebGL1Renderer) {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
            return
        }
        const qe = k.max.x - k.min.x + 1
          , it = k.max.y - k.min.y + 1
          , dt = k.max.z - k.min.z + 1
          , gt = Fe.convert($.format)
          , Ct = Fe.convert($.type);
        let At;
        if ($.isData3DTexture)
            ae.setTexture3D($, 0),
            At = 32879;
        else if ($.isDataArrayTexture)
            ae.setTexture2DArray($, 0),
            At = 35866;
        else {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            return
        }
        q.pixelStorei(37440, $.flipY),
        q.pixelStorei(37441, $.premultiplyAlpha),
        q.pixelStorei(3317, $.unpackAlignment);
        const Mt = q.getParameter(3314)
          , ln = q.getParameter(32878)
          , si = q.getParameter(3316)
          , _r = q.getParameter(3315)
          , fs = q.getParameter(32877)
          , Kt = he.isCompressedTexture ? he.mipmaps[0] : he.image;
        q.pixelStorei(3314, Kt.width),
        q.pixelStorei(32878, Kt.height),
        q.pixelStorei(3316, k.min.x),
        q.pixelStorei(3315, k.min.y),
        q.pixelStorei(32877, k.min.z),
        he.isDataTexture || he.isData3DTexture ? q.texSubImage3D(At, ge, te.x, te.y, te.z, qe, it, dt, gt, Ct, Kt.data) : he.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
        q.compressedTexSubImage3D(At, ge, te.x, te.y, te.z, qe, it, dt, gt, Kt.data)) : q.texSubImage3D(At, ge, te.x, te.y, te.z, qe, it, dt, gt, Ct, Kt),
        q.pixelStorei(3314, Mt),
        q.pixelStorei(32878, ln),
        q.pixelStorei(3316, si),
        q.pixelStorei(3315, _r),
        q.pixelStorei(32877, fs),
        ge === 0 && $.generateMipmaps && q.generateMipmap(At),
        Me.unbindTexture()
    }
    ,
    this.initTexture = function(k) {
        k.isCubeTexture ? ae.setTextureCube(k, 0) : k.isData3DTexture ? ae.setTexture3D(k, 0) : k.isDataArrayTexture || k.isCompressedArrayTexture ? ae.setTexture2DArray(k, 0) : ae.setTexture2D(k, 0),
        Me.unbindTexture()
    }
    ,
    this.resetState = function() {
        x = 0,
        A = 0,
        M = null,
        Me.reset(),
        me.reset()
    }
    ,
    typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
        detail: this
    }))
}
class SB extends bA {
}
SB.prototype.isWebGL1Renderer = !0;
class $g {
    constructor(e, t=25e-5) {
        this.isFogExp2 = !0,
        this.name = "",
        this.color = new Le(e),
        this.density = t
    }
    clone() {
        return new $g(this.color,this.density)
    }
    toJSON() {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        }
    }
}
class e0 {
    constructor(e, t=1, i=1e3) {
        this.isFog = !0,
        this.name = "",
        this.color = new Le(e),
        this.near = t,
        this.far = i
    }
    clone() {
        return new e0(this.color,this.near,this.far)
    }
    toJSON() {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }
}
class PA extends Rt {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        this.backgroundBlurriness = e.backgroundBlurriness,
        this.backgroundIntensity = e.backgroundIntensity,
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
        t
    }
    get autoUpdate() {
        return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),
        this.matrixWorldAutoUpdate
    }
    set autoUpdate(e) {
        console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),
        this.matrixWorldAutoUpdate = e
    }
}
class Bd {
    constructor(e, t) {
        this.isInterleavedBuffer = !0,
        this.array = e,
        this.stride = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.usage = nd,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0,
        this.uuid = Vi()
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array),
        this.count = e.count,
        this.stride = e.stride,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, i) {
        e *= this.stride,
        i *= t.stride;
        for (let r = 0, s = this.stride; r < s; r++)
            this.array[e + r] = t.array[i + r];
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Vi()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
          , i = new this.constructor(t,this.stride);
        return i.setUsage(this.usage),
        i
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Vi()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
        {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const li = new D;
class Jo {
    constructor(e, t, i, r=!1) {
        this.isInterleavedBufferAttribute = !0,
        this.name = "",
        this.data = e,
        this.itemSize = t,
        this.offset = i,
        this.normalized = r
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.data.count; t < i; t++)
            li.fromBufferAttribute(this, t),
            li.applyMatrix4(e),
            this.setXYZ(t, li.x, li.y, li.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++)
            li.fromBufferAttribute(this, t),
            li.applyNormalMatrix(e),
            this.setXYZ(t, li.x, li.y, li.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++)
            li.fromBufferAttribute(this, t),
            li.transformDirection(e),
            this.setXYZ(t, li.x, li.y, li.z);
        return this
    }
    setX(e, t) {
        return this.normalized && (t = Gt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset] = t,
        this
    }
    setY(e, t) {
        return this.normalized && (t = Gt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 1] = t,
        this
    }
    setZ(e, t) {
        return this.normalized && (t = Gt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 2] = t,
        this
    }
    setW(e, t) {
        return this.normalized && (t = Gt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 3] = t,
        this
    }
    getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = Fs(t, this.array)),
        t
    }
    getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = Fs(t, this.array)),
        t
    }
    getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = Fs(t, this.array)),
        t
    }
    getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = Fs(t, this.array)),
        t
    }
    setXY(e, t, i) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = Gt(t, this.array),
        i = Gt(i, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = i,
        this
    }
    setXYZ(e, t, i, r) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = Gt(t, this.array),
        i = Gt(i, this.array),
        r = Gt(r, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = i,
        this.data.array[e + 2] = r,
        this
    }
    setXYZW(e, t, i, r, s) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = Gt(t, this.array),
        i = Gt(i, this.array),
        r = Gt(r, this.array),
        s = Gt(s, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = i,
        this.data.array[e + 2] = r,
        this.data.array[e + 3] = s,
        this
    }
    clone(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
                const r = i * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    t.push(this.data.array[r + s])
            }
            return new Ft(new this.array.constructor(t),this.itemSize,this.normalized)
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
            new Jo(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
    }
    toJSON(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
                const r = i * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    t.push(this.data.array[r + s])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            }
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
            {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
    }
}
class BA extends Sn {
    constructor(e) {
        super(),
        this.isSpriteMaterial = !0,
        this.type = "SpriteMaterial",
        this.color = new Le(16777215),
        this.map = null,
        this.alphaMap = null,
        this.rotation = 0,
        this.sizeAttenuation = !0,
        this.transparent = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.rotation = e.rotation,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
let Xl;
const Gc = new D
  , Kl = new D
  , Yl = new D
  , Ql = new pe
  , Hc = new pe
  , CB = new rt
  , Lp = new D
  , Vc = new D
  , Ip = new D
  , yE = new pe
  , Av = new pe
  , vE = new pe;
class EB extends Rt {
    constructor(e) {
        if (super(),
        this.isSprite = !0,
        this.type = "Sprite",
        Xl === void 0) {
            Xl = new ct;
            const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
              , i = new Bd(t,5);
            Xl.setIndex([0, 1, 2, 0, 2, 3]),
            Xl.setAttribute("position", new Jo(i,3,0,!1)),
            Xl.setAttribute("uv", new Jo(i,2,3,!1))
        }
        this.geometry = Xl,
        this.material = e !== void 0 ? e : new BA,
        this.center = new pe(.5,.5)
    }
    raycast(e, t) {
        e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
        Kl.setFromMatrixScale(this.matrixWorld),
        CB.copy(e.camera.matrixWorld),
        this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
        Yl.setFromMatrixPosition(this.modelViewMatrix),
        e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Kl.multiplyScalar(-Yl.z);
        const i = this.material.rotation;
        let r, s;
        i !== 0 && (s = Math.cos(i),
        r = Math.sin(i));
        const o = this.center;
        Dp(Lp.set(-.5, -.5, 0), Yl, o, Kl, r, s),
        Dp(Vc.set(.5, -.5, 0), Yl, o, Kl, r, s),
        Dp(Ip.set(.5, .5, 0), Yl, o, Kl, r, s),
        yE.set(0, 0),
        Av.set(1, 0),
        vE.set(1, 1);
        let a = e.ray.intersectTriangle(Lp, Vc, Ip, !1, Gc);
        if (a === null && (Dp(Vc.set(-.5, .5, 0), Yl, o, Kl, r, s),
        Av.set(0, 1),
        a = e.ray.intersectTriangle(Lp, Ip, Vc, !1, Gc),
        a === null))
            return;
        const l = e.ray.origin.distanceTo(Gc);
        l < e.near || l > e.far || t.push({
            distance: l,
            point: Gc.clone(),
            uv: pr.getUV(Gc, Lp, Vc, Ip, yE, Av, vE, new pe),
            face: null,
            object: this
        })
    }
    copy(e, t) {
        return super.copy(e, t),
        e.center !== void 0 && this.center.copy(e.center),
        this.material = e.material,
        this
    }
}
function Dp(n, e, t, i, r, s) {
    Ql.subVectors(n, t).addScalar(.5).multiply(i),
    r !== void 0 ? (Hc.x = s * Ql.x - r * Ql.y,
    Hc.y = r * Ql.x + s * Ql.y) : Hc.copy(Ql),
    n.copy(e),
    n.x += Hc.x,
    n.y += Hc.y,
    n.applyMatrix4(CB)
}
const Fp = new D
  , xE = new D;
class TB extends Rt {
    constructor() {
        super(),
        this._currentLevel = 0,
        this.type = "LOD",
        Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            },
            isLOD: {
                value: !0
            }
        }),
        this.autoUpdate = !0
    }
    copy(e) {
        super.copy(e, !1);
        const t = e.levels;
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            this.addLevel(s.object.clone(), s.distance, s.hysteresis)
        }
        return this.autoUpdate = e.autoUpdate,
        this
    }
    addLevel(e, t=0, i=0) {
        t = Math.abs(t);
        const r = this.levels;
        let s;
        for (s = 0; s < r.length && !(t < r[s].distance); s++)
            ;
        return r.splice(s, 0, {
            distance: t,
            hysteresis: i,
            object: e
        }),
        this.add(e),
        this
    }
    getCurrentLevel() {
        return this._currentLevel
    }
    getObjectForDistance(e) {
        const t = this.levels;
        if (t.length > 0) {
            let i, r;
            for (i = 1,
            r = t.length; i < r; i++) {
                let s = t[i].distance;
                if (t[i].object.visible && (s -= s * t[i].hysteresis),
                e < s)
                    break
            }
            return t[i - 1].object
        }
        return null
    }
    raycast(e, t) {
        if (this.levels.length > 0) {
            Fp.setFromMatrixPosition(this.matrixWorld);
            const r = e.ray.origin.distanceTo(Fp);
            this.getObjectForDistance(r).raycast(e, t)
        }
    }
    update(e) {
        const t = this.levels;
        if (t.length > 1) {
            Fp.setFromMatrixPosition(e.matrixWorld),
            xE.setFromMatrixPosition(this.matrixWorld);
            const i = Fp.distanceTo(xE) / e.zoom;
            t[0].object.visible = !0;
            let r, s;
            for (r = 1,
            s = t.length; r < s; r++) {
                let o = t[r].distance;
                if (t[r].object.visible && (o -= o * t[r].hysteresis),
                i >= o)
                    t[r - 1].object.visible = !1,
                    t[r].object.visible = !0;
                else
                    break
            }
            for (this._currentLevel = r - 1; r < s; r++)
                t[r].object.visible = !1
        }
    }
    toJSON(e) {
        const t = super.toJSON(e);
        this.autoUpdate === !1 && (t.object.autoUpdate = !1),
        t.object.levels = [];
        const i = this.levels;
        for (let r = 0, s = i.length; r < s; r++) {
            const o = i[r];
            t.object.levels.push({
                object: o.object.uuid,
                distance: o.distance,
                hysteresis: o.hysteresis
            })
        }
        return t
    }
}
const _E = new D
  , AE = new Nt
  , ME = new Nt
  , C8 = new D
  , wE = new rt;
class RA extends Un {
    constructor(e, t) {
        super(e, t),
        this.isSkinnedMesh = !0,
        this.type = "SkinnedMesh",
        this.bindMode = "attached",
        this.bindMatrix = new rt,
        this.bindMatrixInverse = new rt
    }
    copy(e, t) {
        return super.copy(e, t),
        this.bindMode = e.bindMode,
        this.bindMatrix.copy(e.bindMatrix),
        this.bindMatrixInverse.copy(e.bindMatrixInverse),
        this.skeleton = e.skeleton,
        this
    }
    bind(e, t) {
        this.skeleton = e,
        t === void 0 && (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        t = this.matrixWorld),
        this.bindMatrix.copy(t),
        this.bindMatrixInverse.copy(t).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const e = new Nt
          , t = this.geometry.attributes.skinWeight;
        for (let i = 0, r = t.count; i < r; i++) {
            e.fromBufferAttribute(t, i);
            const s = 1 / e.manhattanLength();
            s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
            t.setXYZW(i, e.x, e.y, e.z, e.w)
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    boneTransform(e, t) {
        const i = this.skeleton
          , r = this.geometry;
        AE.fromBufferAttribute(r.attributes.skinIndex, e),
        ME.fromBufferAttribute(r.attributes.skinWeight, e),
        _E.copy(t).applyMatrix4(this.bindMatrix),
        t.set(0, 0, 0);
        for (let s = 0; s < 4; s++) {
            const o = ME.getComponent(s);
            if (o !== 0) {
                const a = AE.getComponent(s);
                wE.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]),
                t.addScaledVector(C8.copy(_E).applyMatrix4(wE), o)
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse)
    }
}
class t0 extends Rt {
    constructor() {
        super(),
        this.isBone = !0,
        this.type = "Bone"
    }
}
class Tu extends qt {
    constructor(e=null, t=1, i=1, r, s, o, a, l, c=hn, d=hn, h, p) {
        super(null, o, a, l, c, d, r, s, h, p),
        this.isDataTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i
        },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
const SE = new rt
  , E8 = new rt;
class Rd {
    constructor(e=[], t=[]) {
        this.uuid = Vi(),
        this.bones = e.slice(0),
        this.boneInverses = t,
        this.boneMatrices = null,
        this.boneTexture = null,
        this.boneTextureSize = 0,
        this.frame = -1,
        this.init()
    }
    init() {
        const e = this.bones
          , t = this.boneInverses;
        if (this.boneMatrices = new Float32Array(e.length * 16),
        t.length === 0)
            this.calculateInverses();
        else if (e.length !== t.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
            this.boneInverses = [];
            for (let i = 0, r = this.bones.length; i < r; i++)
                this.boneInverses.push(new rt)
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = new rt;
            this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
            this.boneInverses.push(i)
        }
    }
    pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && i.matrixWorld.copy(this.boneInverses[e]).invert()
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(),
            i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld),
            i.matrix.decompose(i.position, i.quaternion, i.scale))
        }
    }
    update() {
        const e = this.bones
          , t = this.boneInverses
          , i = this.boneMatrices
          , r = this.boneTexture;
        for (let s = 0, o = e.length; s < o; s++) {
            const a = e[s] ? e[s].matrixWorld : E8;
            SE.multiplyMatrices(a, t[s]),
            SE.toArray(i, s * 16)
        }
        r !== null && (r.needsUpdate = !0)
    }
    clone() {
        return new Rd(this.bones,this.boneInverses)
    }
    computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        e = cB(e),
        e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const i = new Tu(t,e,e,Ci,Ds);
        return i.needsUpdate = !0,
        this.boneMatrices = t,
        this.boneTexture = i,
        this.boneTextureSize = e,
        this
    }
    getBoneByName(e) {
        for (let t = 0, i = this.bones.length; t < i; t++) {
            const r = this.bones[t];
            if (r.name === e)
                return r
        }
    }
    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(),
        this.boneTexture = null)
    }
    fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let i = 0, r = e.bones.length; i < r; i++) {
            const s = e.bones[i];
            let o = t[s];
            o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s),
            o = new t0),
            this.bones.push(o),
            this.boneInverses.push(new rt().fromArray(e.boneInverses[i]))
        }
        return this.init(),
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        e.uuid = this.uuid;
        const t = this.bones
          , i = this.boneInverses;
        for (let r = 0, s = t.length; r < s; r++) {
            const o = t[r];
            e.bones.push(o.uuid);
            const a = i[r];
            e.boneInverses.push(a.toArray())
        }
        return e
    }
}
class Gu extends Ft {
    constructor(e, t, i, r=1) {
        super(e, t, i),
        this.isInstancedBufferAttribute = !0,
        this.meshPerAttribute = r
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute,
        e.isInstancedBufferAttribute = !0,
        e
    }
}
const CE = new rt
  , EE = new rt
  , kp = []
  , T8 = new rt
  , Wc = new Un;
class bB extends Un {
    constructor(e, t, i) {
        super(e, t),
        this.isInstancedMesh = !0,
        this.instanceMatrix = new Gu(new Float32Array(i * 16),16),
        this.instanceColor = null,
        this.count = i,
        this.frustumCulled = !1;
        for (let r = 0; r < i; r++)
            this.setMatrixAt(r, T8)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.instanceMatrix.copy(e.instanceMatrix),
        e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
        this.count = e.count,
        this
    }
    getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3)
    }
    getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16)
    }
    raycast(e, t) {
        const i = this.matrixWorld
          , r = this.count;
        if (Wc.geometry = this.geometry,
        Wc.material = this.material,
        Wc.material !== void 0)
            for (let s = 0; s < r; s++) {
                this.getMatrixAt(s, CE),
                EE.multiplyMatrices(i, CE),
                Wc.matrixWorld = EE,
                Wc.raycast(e, kp);
                for (let o = 0, a = kp.length; o < a; o++) {
                    const l = kp[o];
                    l.instanceId = s,
                    l.object = this,
                    t.push(l)
                }
                kp.length = 0
            }
    }
    setColorAt(e, t) {
        this.instanceColor === null && (this.instanceColor = new Gu(new Float32Array(this.instanceMatrix.count * 3),3)),
        t.toArray(this.instanceColor.array, e * 3)
    }
    setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16)
    }
    updateMorphTargets() {}
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class ri extends Sn {
    constructor(e) {
        super(),
        this.isLineBasicMaterial = !0,
        this.type = "LineBasicMaterial",
        this.color = new Le(16777215),
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this.fog = e.fog,
        this
    }
}
const TE = new D
  , bE = new D
  , PE = new rt
  , Mv = new Ed
  , Np = new na;
class Ks extends Rt {
    constructor(e=new ct, t=new ri) {
        super(),
        this.isLine = !0,
        this.type = "Line",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , i = [0];
            for (let r = 1, s = t.count; r < s; r++)
                TE.fromBufferAttribute(t, r - 1),
                bE.fromBufferAttribute(t, r),
                i[r] = i[r - 1],
                i[r] += TE.distanceTo(bE);
            e.setAttribute("lineDistance", new je(i,1))
        } else
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(e, t) {
        const i = this.geometry
          , r = this.matrixWorld
          , s = e.params.Line.threshold
          , o = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(),
        Np.copy(i.boundingSphere),
        Np.applyMatrix4(r),
        Np.radius += s,
        e.ray.intersectsSphere(Np) === !1)
            return;
        PE.copy(r).invert(),
        Mv.copy(e.ray).applyMatrix4(PE);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , l = a * a
          , c = new D
          , d = new D
          , h = new D
          , p = new D
          , m = this.isLineSegments ? 2 : 1
          , y = i.index
          , _ = i.attributes.position;
        if (y !== null) {
            const x = Math.max(0, o.start)
              , A = Math.min(y.count, o.start + o.count);
            for (let M = x, S = A - 1; M < S; M += m) {
                const T = y.getX(M)
                  , P = y.getX(M + 1);
                if (c.fromBufferAttribute(_, T),
                d.fromBufferAttribute(_, P),
                Mv.distanceSqToSegment(c, d, p, h) > l)
                    continue;
                p.applyMatrix4(this.matrixWorld);
                const E = e.ray.origin.distanceTo(p);
                E < e.near || E > e.far || t.push({
                    distance: E,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: M,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        } else {
            const x = Math.max(0, o.start)
              , A = Math.min(_.count, o.start + o.count);
            for (let M = x, S = A - 1; M < S; M += m) {
                if (c.fromBufferAttribute(_, M),
                d.fromBufferAttribute(_, M + 1),
                Mv.distanceSqToSegment(c, d, p, h) > l)
                    continue;
                p.applyMatrix4(this.matrixWorld);
                const P = e.ray.origin.distanceTo(p);
                P < e.near || P > e.far || t.push({
                    distance: P,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: M,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
const BE = new D
  , RE = new D;
class Gr extends Ks {
    constructor(e, t) {
        super(e, t),
        this.isLineSegments = !0,
        this.type = "LineSegments"
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , i = [];
            for (let r = 0, s = t.count; r < s; r += 2)
                BE.fromBufferAttribute(t, r),
                RE.fromBufferAttribute(t, r + 1),
                i[r] = r === 0 ? 0 : i[r - 1],
                i[r + 1] = i[r] + BE.distanceTo(RE);
            e.setAttribute("lineDistance", new je(i,1))
        } else
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class LA extends Ks {
    constructor(e, t) {
        super(e, t),
        this.isLineLoop = !0,
        this.type = "LineLoop"
    }
}
class Ld extends Sn {
    constructor(e) {
        super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new Le(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
const LE = new rt
  , D1 = new Ed
  , Op = new na
  , Up = new D;
let IA = class extends Rt {
    constructor(e=new ct, t=new Ld) {
        super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    raycast(e, t) {
        const i = this.geometry
          , r = this.matrixWorld
          , s = e.params.Points.threshold
          , o = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(),
        Op.copy(i.boundingSphere),
        Op.applyMatrix4(r),
        Op.radius += s,
        e.ray.intersectsSphere(Op) === !1)
            return;
        LE.copy(r).invert(),
        D1.copy(e.ray).applyMatrix4(LE);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , l = a * a
          , c = i.index
          , h = i.attributes.position;
        if (c !== null) {
            const p = Math.max(0, o.start)
              , m = Math.min(c.count, o.start + o.count);
            for (let y = p, v = m; y < v; y++) {
                const _ = c.getX(y);
                Up.fromBufferAttribute(h, _),
                IE(Up, _, l, r, e, t, this)
            }
        } else {
            const p = Math.max(0, o.start)
              , m = Math.min(h.count, o.start + o.count);
            for (let y = p, v = m; y < v; y++)
                Up.fromBufferAttribute(h, y),
                IE(Up, y, l, r, e, t, this)
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
;
function IE(n, e, t, i, r, s, o) {
    const a = D1.distanceSqToPoint(n);
    if (a < t) {
        const l = new D;
        D1.closestPointToPoint(n, l),
        l.applyMatrix4(i);
        const c = r.ray.origin.distanceTo(l);
        if (c < r.near || c > r.far)
            return;
        s.push({
            distance: c,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            object: o
        })
    }
}
class b8 extends qt {
    constructor(e, t, i, r, s, o, a, l, c) {
        super(e, t, i, r, s, o, a, l, c),
        this.isVideoTexture = !0,
        this.minFilter = o !== void 0 ? o : nn,
        this.magFilter = s !== void 0 ? s : nn,
        this.generateMipmaps = !1;
        const d = this;
        function h() {
            d.needsUpdate = !0,
            e.requestVideoFrameCallback(h)
        }
        "requestVideoFrameCallback"in e && e.requestVideoFrameCallback(h)
    }
    clone() {
        return new this.constructor(this.image).copy(this)
    }
    update() {
        const e = this.image;
        "requestVideoFrameCallback"in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
}
class P8 extends qt {
    constructor(e, t, i) {
        super({
            width: e,
            height: t
        }),
        this.isFramebufferTexture = !0,
        this.format = i,
        this.magFilter = hn,
        this.minFilter = hn,
        this.generateMipmaps = !1,
        this.needsUpdate = !0
    }
}
class DA extends qt {
    constructor(e, t, i, r, s, o, a, l, c, d, h, p) {
        super(null, o, a, l, c, d, r, s, h, p),
        this.isCompressedTexture = !0,
        this.image = {
            width: t,
            height: i
        },
        this.mipmaps = e,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
}
class B8 extends DA {
    constructor(e, t, i, r, s, o) {
        super(e, t, i, s, o),
        this.isCompressedArrayTexture = !0,
        this.image.depth = r,
        this.wrapR = Vn
    }
}
class R8 extends qt {
    constructor(e, t, i, r, s, o, a, l, c) {
        super(e, t, i, r, s, o, a, l, c),
        this.isCanvasTexture = !0,
        this.needsUpdate = !0
    }
}
class Hr {
    constructor() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."),
        null
    }
    getPointAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getPoint(i, t)
    }
    getPoints(e=5) {
        const t = [];
        for (let i = 0; i <= e; i++)
            t.push(this.getPoint(i / e));
        return t
    }
    getSpacedPoints(e=5) {
        const t = [];
        for (let i = 0; i <= e; i++)
            t.push(this.getPointAt(i / e));
        return t
    }
    getLength() {
        const e = this.getLengths();
        return e[e.length - 1]
    }
    getLengths(e=this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
            return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let i, r = this.getPoint(0), s = 0;
        t.push(0);
        for (let o = 1; o <= e; o++)
            i = this.getPoint(o / e),
            s += i.distanceTo(r),
            t.push(s),
            r = i;
        return this.cacheArcLengths = t,
        t
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.getLengths()
    }
    getUtoTmapping(e, t) {
        const i = this.getLengths();
        let r = 0;
        const s = i.length;
        let o;
        t ? o = t : o = e * i[s - 1];
        let a = 0, l = s - 1, c;
        for (; a <= l; )
            if (r = Math.floor(a + (l - a) / 2),
            c = i[r] - o,
            c < 0)
                a = r + 1;
            else if (c > 0)
                l = r - 1;
            else {
                l = r;
                break
            }
        if (r = l,
        i[r] === o)
            return r / (s - 1);
        const d = i[r]
          , p = i[r + 1] - d
          , m = (o - d) / p;
        return (r + m) / (s - 1)
    }
    getTangent(e, t) {
        let r = e - 1e-4
          , s = e + 1e-4;
        r < 0 && (r = 0),
        s > 1 && (s = 1);
        const o = this.getPoint(r)
          , a = this.getPoint(s)
          , l = t || (o.isVector2 ? new pe : new D);
        return l.copy(a).sub(o).normalize(),
        l
    }
    getTangentAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getTangent(i, t)
    }
    computeFrenetFrames(e, t) {
        const i = new D
          , r = []
          , s = []
          , o = []
          , a = new D
          , l = new rt;
        for (let m = 0; m <= e; m++) {
            const y = m / e;
            r[m] = this.getTangentAt(y, new D)
        }
        s[0] = new D,
        o[0] = new D;
        let c = Number.MAX_VALUE;
        const d = Math.abs(r[0].x)
          , h = Math.abs(r[0].y)
          , p = Math.abs(r[0].z);
        d <= c && (c = d,
        i.set(1, 0, 0)),
        h <= c && (c = h,
        i.set(0, 1, 0)),
        p <= c && i.set(0, 0, 1),
        a.crossVectors(r[0], i).normalize(),
        s[0].crossVectors(r[0], a),
        o[0].crossVectors(r[0], s[0]);
        for (let m = 1; m <= e; m++) {
            if (s[m] = s[m - 1].clone(),
            o[m] = o[m - 1].clone(),
            a.crossVectors(r[m - 1], r[m]),
            a.length() > Number.EPSILON) {
                a.normalize();
                const y = Math.acos(vn(r[m - 1].dot(r[m]), -1, 1));
                s[m].applyMatrix4(l.makeRotationAxis(a, y))
            }
            o[m].crossVectors(r[m], s[m])
        }
        if (t === !0) {
            let m = Math.acos(vn(s[0].dot(s[e]), -1, 1));
            m /= e,
            r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (m = -m);
            for (let y = 1; y <= e; y++)
                s[y].applyMatrix4(l.makeRotationAxis(r[y], m * y)),
                o[y].crossVectors(r[y], s[y])
        }
        return {
            tangents: r,
            normals: s,
            binormals: o
        }
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions,
        e.type = this.type,
        e
    }
    fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
}
class n0 extends Hr {
    constructor(e=0, t=0, i=1, r=1, s=0, o=Math.PI * 2, a=!1, l=0) {
        super(),
        this.isEllipseCurve = !0,
        this.type = "EllipseCurve",
        this.aX = e,
        this.aY = t,
        this.xRadius = i,
        this.yRadius = r,
        this.aStartAngle = s,
        this.aEndAngle = o,
        this.aClockwise = a,
        this.aRotation = l
    }
    getPoint(e, t) {
        const i = t || new pe
          , r = Math.PI * 2;
        let s = this.aEndAngle - this.aStartAngle;
        const o = Math.abs(s) < Number.EPSILON;
        for (; s < 0; )
            s += r;
        for (; s > r; )
            s -= r;
        s < Number.EPSILON && (o ? s = 0 : s = r),
        this.aClockwise === !0 && !o && (s === r ? s = -r : s = s - r);
        const a = this.aStartAngle + e * s;
        let l = this.aX + this.xRadius * Math.cos(a)
          , c = this.aY + this.yRadius * Math.sin(a);
        if (this.aRotation !== 0) {
            const d = Math.cos(this.aRotation)
              , h = Math.sin(this.aRotation)
              , p = l - this.aX
              , m = c - this.aY;
            l = p * d - m * h + this.aX,
            c = p * h + m * d + this.aY
        }
        return i.set(l, c)
    }
    copy(e) {
        return super.copy(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.aX = this.aX,
        e.aY = this.aY,
        e.xRadius = this.xRadius,
        e.yRadius = this.yRadius,
        e.aStartAngle = this.aStartAngle,
        e.aEndAngle = this.aEndAngle,
        e.aClockwise = this.aClockwise,
        e.aRotation = this.aRotation,
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
}
class PB extends n0 {
    constructor(e, t, i, r, s, o) {
        super(e, t, i, i, r, s, o),
        this.isArcCurve = !0,
        this.type = "ArcCurve"
    }
}
function FA() {
    let n = 0
      , e = 0
      , t = 0
      , i = 0;
    function r(s, o, a, l) {
        n = s,
        e = a,
        t = -3 * s + 3 * o - 2 * a - l,
        i = 2 * s - 2 * o + a + l
    }
    return {
        initCatmullRom: function(s, o, a, l, c) {
            r(o, a, c * (a - s), c * (l - o))
        },
        initNonuniformCatmullRom: function(s, o, a, l, c, d, h) {
            let p = (o - s) / c - (a - s) / (c + d) + (a - o) / d
              , m = (a - o) / d - (l - o) / (d + h) + (l - a) / h;
            p *= d,
            m *= d,
            r(o, a, p, m)
        },
        calc: function(s) {
            const o = s * s
              , a = o * s;
            return n + e * s + t * o + i * a
        }
    }
}
const zp = new D
  , wv = new FA
  , Sv = new FA
  , Cv = new FA;
class BB extends Hr {
    constructor(e=[], t=!1, i="centripetal", r=.5) {
        super(),
        this.isCatmullRomCurve3 = !0,
        this.type = "CatmullRomCurve3",
        this.points = e,
        this.closed = t,
        this.curveType = i,
        this.tension = r
    }
    getPoint(e, t=new D) {
        const i = t
          , r = this.points
          , s = r.length
          , o = (s - (this.closed ? 0 : 1)) * e;
        let a = Math.floor(o)
          , l = o - a;
        this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2,
        l = 1);
        let c, d;
        this.closed || a > 0 ? c = r[(a - 1) % s] : (zp.subVectors(r[0], r[1]).add(r[0]),
        c = zp);
        const h = r[a % s]
          , p = r[(a + 1) % s];
        if (this.closed || a + 2 < s ? d = r[(a + 2) % s] : (zp.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]),
        d = zp),
        this.curveType === "centripetal" || this.curveType === "chordal") {
            const m = this.curveType === "chordal" ? .5 : .25;
            let y = Math.pow(c.distanceToSquared(h), m)
              , v = Math.pow(h.distanceToSquared(p), m)
              , _ = Math.pow(p.distanceToSquared(d), m);
            v < 1e-4 && (v = 1),
            y < 1e-4 && (y = v),
            _ < 1e-4 && (_ = v),
            wv.initNonuniformCatmullRom(c.x, h.x, p.x, d.x, y, v, _),
            Sv.initNonuniformCatmullRom(c.y, h.y, p.y, d.y, y, v, _),
            Cv.initNonuniformCatmullRom(c.z, h.z, p.z, d.z, y, v, _)
        } else
            this.curveType === "catmullrom" && (wv.initCatmullRom(c.x, h.x, p.x, d.x, this.tension),
            Sv.initCatmullRom(c.y, h.y, p.y, d.y, this.tension),
            Cv.initCatmullRom(c.z, h.z, p.z, d.z, this.tension));
        return i.set(wv.calc(l), Sv.calc(l), Cv.calc(l)),
        i
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(r.clone())
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
            const r = this.points[t];
            e.points.push(r.toArray())
        }
        return e.closed = this.closed,
        e.curveType = this.curveType,
        e.tension = this.tension,
        e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(new D().fromArray(r))
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
}
function DE(n, e, t, i, r) {
    const s = (i - e) * .5
      , o = (r - t) * .5
      , a = n * n
      , l = n * a;
    return (2 * t - 2 * i + s + o) * l + (-3 * t + 3 * i - 2 * s - o) * a + s * n + t
}
function L8(n, e) {
    const t = 1 - n;
    return t * t * e
}
function I8(n, e) {
    return 2 * (1 - n) * n * e
}
function D8(n, e) {
    return n * n * e
}
function wf(n, e, t, i) {
    return L8(n, e) + I8(n, t) + D8(n, i)
}
function F8(n, e) {
    const t = 1 - n;
    return t * t * t * e
}
function k8(n, e) {
    const t = 1 - n;
    return 3 * t * t * n * e
}
function N8(n, e) {
    return 3 * (1 - n) * n * n * e
}
function O8(n, e) {
    return n * n * n * e
}
function Sf(n, e, t, i, r) {
    return F8(n, e) + k8(n, t) + N8(n, i) + O8(n, r)
}
class kA extends Hr {
    constructor(e=new pe, t=new pe, i=new pe, r=new pe) {
        super(),
        this.isCubicBezierCurve = !0,
        this.type = "CubicBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i,
        this.v3 = r
    }
    getPoint(e, t=new pe) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2
          , a = this.v3;
        return i.set(Sf(e, r.x, s.x, o.x, a.x), Sf(e, r.y, s.y, o.y, a.y)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class RB extends Hr {
    constructor(e=new D, t=new D, i=new D, r=new D) {
        super(),
        this.isCubicBezierCurve3 = !0,
        this.type = "CubicBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i,
        this.v3 = r
    }
    getPoint(e, t=new D) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2
          , a = this.v3;
        return i.set(Sf(e, r.x, s.x, o.x, a.x), Sf(e, r.y, s.y, o.y, a.y), Sf(e, r.z, s.z, o.z, a.z)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class i0 extends Hr {
    constructor(e=new pe, t=new pe) {
        super(),
        this.isLineCurve = !0,
        this.type = "LineCurve",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new pe) {
        const i = t;
        return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
        i.multiplyScalar(e).add(this.v1)),
        i
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t) {
        const i = t || new pe;
        return i.copy(this.v2).sub(this.v1).normalize(),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class LB extends Hr {
    constructor(e=new D, t=new D) {
        super(),
        this.isLineCurve3 = !0,
        this.type = "LineCurve3",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new D) {
        const i = t;
        return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
        i.multiplyScalar(e).add(this.v1)),
        i
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class NA extends Hr {
    constructor(e=new pe, t=new pe, i=new pe) {
        super(),
        this.isQuadraticBezierCurve = !0,
        this.type = "QuadraticBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i
    }
    getPoint(e, t=new pe) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2;
        return i.set(wf(e, r.x, s.x, o.x), wf(e, r.y, s.y, o.y)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class OA extends Hr {
    constructor(e=new D, t=new D, i=new D) {
        super(),
        this.isQuadraticBezierCurve3 = !0,
        this.type = "QuadraticBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i
    }
    getPoint(e, t=new D) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2;
        return i.set(wf(e, r.x, s.x, o.x), wf(e, r.y, s.y, o.y), wf(e, r.z, s.z, o.z)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class UA extends Hr {
    constructor(e=[]) {
        super(),
        this.isSplineCurve = !0,
        this.type = "SplineCurve",
        this.points = e
    }
    getPoint(e, t=new pe) {
        const i = t
          , r = this.points
          , s = (r.length - 1) * e
          , o = Math.floor(s)
          , a = s - o
          , l = r[o === 0 ? o : o - 1]
          , c = r[o]
          , d = r[o > r.length - 2 ? r.length - 1 : o + 1]
          , h = r[o > r.length - 3 ? r.length - 1 : o + 2];
        return i.set(DE(a, l.x, c.x, d.x, h.x), DE(a, l.y, c.y, d.y, h.y)),
        i
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(r.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
            const r = this.points[t];
            e.points.push(r.toArray())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(new pe().fromArray(r))
        }
        return this
    }
}
var zA = Object.freeze({
    __proto__: null,
    ArcCurve: PB,
    CatmullRomCurve3: BB,
    CubicBezierCurve: kA,
    CubicBezierCurve3: RB,
    EllipseCurve: n0,
    LineCurve: i0,
    LineCurve3: LB,
    QuadraticBezierCurve: NA,
    QuadraticBezierCurve3: OA,
    SplineCurve: UA
});
class IB extends Hr {
    constructor() {
        super(),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    add(e) {
        this.curves.push(e)
    }
    closePath() {
        const e = this.curves[0].getPoint(0)
          , t = this.curves[this.curves.length - 1].getPoint(1);
        e.equals(t) || this.curves.push(new i0(t,e))
    }
    getPoint(e, t) {
        const i = e * this.getLength()
          , r = this.getCurveLengths();
        let s = 0;
        for (; s < r.length; ) {
            if (r[s] >= i) {
                const o = r[s] - i
                  , a = this.curves[s]
                  , l = a.getLength()
                  , c = l === 0 ? 0 : 1 - o / l;
                return a.getPointAt(c, t)
            }
            s++
        }
        return null
    }
    getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1]
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.cacheLengths = null,
        this.getCurveLengths()
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
            return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let i = 0, r = this.curves.length; i < r; i++)
            t += this.curves[i].getLength(),
            e.push(t);
        return this.cacheLengths = e,
        e
    }
    getSpacedPoints(e=40) {
        const t = [];
        for (let i = 0; i <= e; i++)
            t.push(this.getPoint(i / e));
        return this.autoClose && t.push(t[0]),
        t
    }
    getPoints(e=12) {
        const t = [];
        let i;
        for (let r = 0, s = this.curves; r < s.length; r++) {
            const o = s[r]
              , a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e
              , l = o.getPoints(a);
            for (let c = 0; c < l.length; c++) {
                const d = l[c];
                i && i.equals(d) || (t.push(d),
                i = d)
            }
        }
        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]),
        t
    }
    copy(e) {
        super.copy(e),
        this.curves = [];
        for (let t = 0, i = e.curves.length; t < i; t++) {
            const r = e.curves[t];
            this.curves.push(r.clone())
        }
        return this.autoClose = e.autoClose,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.autoClose = this.autoClose,
        e.curves = [];
        for (let t = 0, i = this.curves.length; t < i; t++) {
            const r = this.curves[t];
            e.curves.push(r.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.autoClose = e.autoClose,
        this.curves = [];
        for (let t = 0, i = e.curves.length; t < i; t++) {
            const r = e.curves[t];
            this.curves.push(new zA[r.type]().fromJSON(r))
        }
        return this
    }
}
class sd extends IB {
    constructor(e) {
        super(),
        this.type = "Path",
        this.currentPoint = new pe,
        e && this.setFromPoints(e)
    }
    setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, i = e.length; t < i; t++)
            this.lineTo(e[t].x, e[t].y);
        return this
    }
    moveTo(e, t) {
        return this.currentPoint.set(e, t),
        this
    }
    lineTo(e, t) {
        const i = new i0(this.currentPoint.clone(),new pe(e,t));
        return this.curves.push(i),
        this.currentPoint.set(e, t),
        this
    }
    quadraticCurveTo(e, t, i, r) {
        const s = new NA(this.currentPoint.clone(),new pe(e,t),new pe(i,r));
        return this.curves.push(s),
        this.currentPoint.set(i, r),
        this
    }
    bezierCurveTo(e, t, i, r, s, o) {
        const a = new kA(this.currentPoint.clone(),new pe(e,t),new pe(i,r),new pe(s,o));
        return this.curves.push(a),
        this.currentPoint.set(s, o),
        this
    }
    splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e)
          , i = new UA(t);
        return this.curves.push(i),
        this.currentPoint.copy(e[e.length - 1]),
        this
    }
    arc(e, t, i, r, s, o) {
        const a = this.currentPoint.x
          , l = this.currentPoint.y;
        return this.absarc(e + a, t + l, i, r, s, o),
        this
    }
    absarc(e, t, i, r, s, o) {
        return this.absellipse(e, t, i, i, r, s, o),
        this
    }
    ellipse(e, t, i, r, s, o, a, l) {
        const c = this.currentPoint.x
          , d = this.currentPoint.y;
        return this.absellipse(e + c, t + d, i, r, s, o, a, l),
        this
    }
    absellipse(e, t, i, r, s, o, a, l) {
        const c = new n0(e,t,i,r,s,o,a,l);
        if (this.curves.length > 0) {
            const h = c.getPoint(0);
            h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
        }
        this.curves.push(c);
        const d = c.getPoint(1);
        return this.currentPoint.copy(d),
        this
    }
    copy(e) {
        return super.copy(e),
        this.currentPoint.copy(e.currentPoint),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.currentPoint = this.currentPoint.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.currentPoint.fromArray(e.currentPoint),
        this
    }
}
class tc extends ct {
    constructor(e=[new pe(0,-.5), new pe(.5,0), new pe(0,.5)], t=12, i=0, r=Math.PI * 2) {
        super(),
        this.type = "LatheGeometry",
        this.parameters = {
            points: e,
            segments: t,
            phiStart: i,
            phiLength: r
        },
        t = Math.floor(t),
        r = vn(r, 0, Math.PI * 2);
        const s = []
          , o = []
          , a = []
          , l = []
          , c = []
          , d = 1 / t
          , h = new D
          , p = new pe
          , m = new D
          , y = new D
          , v = new D;
        let _ = 0
          , x = 0;
        for (let A = 0; A <= e.length - 1; A++)
            switch (A) {
            case 0:
                _ = e[A + 1].x - e[A].x,
                x = e[A + 1].y - e[A].y,
                m.x = x * 1,
                m.y = -_,
                m.z = x * 0,
                v.copy(m),
                m.normalize(),
                l.push(m.x, m.y, m.z);
                break;
            case e.length - 1:
                l.push(v.x, v.y, v.z);
                break;
            default:
                _ = e[A + 1].x - e[A].x,
                x = e[A + 1].y - e[A].y,
                m.x = x * 1,
                m.y = -_,
                m.z = x * 0,
                y.copy(m),
                m.x += v.x,
                m.y += v.y,
                m.z += v.z,
                m.normalize(),
                l.push(m.x, m.y, m.z),
                v.copy(y)
            }
        for (let A = 0; A <= t; A++) {
            const M = i + A * d * r
              , S = Math.sin(M)
              , T = Math.cos(M);
            for (let P = 0; P <= e.length - 1; P++) {
                h.x = e[P].x * S,
                h.y = e[P].y,
                h.z = e[P].x * T,
                o.push(h.x, h.y, h.z),
                p.x = A / t,
                p.y = P / (e.length - 1),
                a.push(p.x, p.y);
                const R = l[3 * P + 0] * S
                  , E = l[3 * P + 1]
                  , B = l[3 * P + 0] * T;
                c.push(R, E, B)
            }
        }
        for (let A = 0; A < t; A++)
            for (let M = 0; M < e.length - 1; M++) {
                const S = M + A * e.length
                  , T = S
                  , P = S + e.length
                  , R = S + e.length + 1
                  , E = S + 1;
                s.push(T, P, E),
                s.push(R, E, P)
            }
        this.setIndex(s),
        this.setAttribute("position", new je(o,3)),
        this.setAttribute("uv", new je(a,2)),
        this.setAttribute("normal", new je(c,3))
    }
    static fromJSON(e) {
        return new tc(e.points,e.segments,e.phiStart,e.phiLength)
    }
}
class Id extends tc {
    constructor(e=1, t=1, i=4, r=8) {
        const s = new sd;
        s.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
        s.absarc(0, t / 2, e, 0, Math.PI * .5),
        super(s.getPoints(i), r),
        this.type = "CapsuleGeometry",
        this.parameters = {
            radius: e,
            height: t,
            capSegments: i,
            radialSegments: r
        }
    }
    static fromJSON(e) {
        return new Id(e.radius,e.length,e.capSegments,e.radialSegments)
    }
}
class Dd extends ct {
    constructor(e=1, t=32, i=0, r=Math.PI * 2) {
        super(),
        this.type = "CircleGeometry",
        this.parameters = {
            radius: e,
            segments: t,
            thetaStart: i,
            thetaLength: r
        },
        t = Math.max(3, t);
        const s = []
          , o = []
          , a = []
          , l = []
          , c = new D
          , d = new pe;
        o.push(0, 0, 0),
        a.push(0, 0, 1),
        l.push(.5, .5);
        for (let h = 0, p = 3; h <= t; h++,
        p += 3) {
            const m = i + h / t * r;
            c.x = e * Math.cos(m),
            c.y = e * Math.sin(m),
            o.push(c.x, c.y, c.z),
            a.push(0, 0, 1),
            d.x = (o[p] / e + 1) / 2,
            d.y = (o[p + 1] / e + 1) / 2,
            l.push(d.x, d.y)
        }
        for (let h = 1; h <= t; h++)
            s.push(h, h + 1, 0);
        this.setIndex(s),
        this.setAttribute("position", new je(o,3)),
        this.setAttribute("normal", new je(a,3)),
        this.setAttribute("uv", new je(l,2))
    }
    static fromJSON(e) {
        return new Dd(e.radius,e.segments,e.thetaStart,e.thetaLength)
    }
}
class hl extends ct {
    constructor(e=1, t=1, i=1, r=32, s=1, o=!1, a=0, l=Math.PI * 2) {
        super(),
        this.type = "CylinderGeometry",
        this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: i,
            radialSegments: r,
            heightSegments: s,
            openEnded: o,
            thetaStart: a,
            thetaLength: l
        };
        const c = this;
        r = Math.floor(r),
        s = Math.floor(s);
        const d = []
          , h = []
          , p = []
          , m = [];
        let y = 0;
        const v = []
          , _ = i / 2;
        let x = 0;
        A(),
        o === !1 && (e > 0 && M(!0),
        t > 0 && M(!1)),
        this.setIndex(d),
        this.setAttribute("position", new je(h,3)),
        this.setAttribute("normal", new je(p,3)),
        this.setAttribute("uv", new je(m,2));
        function A() {
            const S = new D
              , T = new D;
            let P = 0;
            const R = (t - e) / i;
            for (let E = 0; E <= s; E++) {
                const B = []
                  , L = E / s
                  , z = L * (t - e) + e;
                for (let Z = 0; Z <= r; Z++) {
                    const J = Z / r
                      , G = J * l + a
                      , X = Math.sin(G)
                      , ee = Math.cos(G);
                    T.x = z * X,
                    T.y = -L * i + _,
                    T.z = z * ee,
                    h.push(T.x, T.y, T.z),
                    S.set(X, R, ee).normalize(),
                    p.push(S.x, S.y, S.z),
                    m.push(J, 1 - L),
                    B.push(y++)
                }
                v.push(B)
            }
            for (let E = 0; E < r; E++)
                for (let B = 0; B < s; B++) {
                    const L = v[B][E]
                      , z = v[B + 1][E]
                      , Z = v[B + 1][E + 1]
                      , J = v[B][E + 1];
                    d.push(L, z, J),
                    d.push(z, Z, J),
                    P += 6
                }
            c.addGroup(x, P, 0),
            x += P
        }
        function M(S) {
            const T = y
              , P = new pe
              , R = new D;
            let E = 0;
            const B = S === !0 ? e : t
              , L = S === !0 ? 1 : -1;
            for (let Z = 1; Z <= r; Z++)
                h.push(0, _ * L, 0),
                p.push(0, L, 0),
                m.push(.5, .5),
                y++;
            const z = y;
            for (let Z = 0; Z <= r; Z++) {
                const G = Z / r * l + a
                  , X = Math.cos(G)
                  , ee = Math.sin(G);
                R.x = B * ee,
                R.y = _ * L,
                R.z = B * X,
                h.push(R.x, R.y, R.z),
                p.push(0, L, 0),
                P.x = X * .5 + .5,
                P.y = ee * .5 * L + .5,
                m.push(P.x, P.y),
                y++
            }
            for (let Z = 0; Z < r; Z++) {
                const J = T + Z
                  , G = z + Z;
                S === !0 ? d.push(G, G + 1, J) : d.push(G + 1, G, J),
                E += 3
            }
            c.addGroup(x, E, S === !0 ? 1 : 2),
            x += E
        }
    }
    static fromJSON(e) {
        return new hl(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
    }
}
class Fd extends hl {
    constructor(e=1, t=1, i=32, r=1, s=!1, o=0, a=Math.PI * 2) {
        super(0, e, t, i, r, s, o, a),
        this.type = "ConeGeometry",
        this.parameters = {
            radius: e,
            height: t,
            radialSegments: i,
            heightSegments: r,
            openEnded: s,
            thetaStart: o,
            thetaLength: a
        }
    }
    static fromJSON(e) {
        return new Fd(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
    }
}
class Zs extends ct {
    constructor(e=[], t=[], i=1, r=0) {
        super(),
        this.type = "PolyhedronGeometry",
        this.parameters = {
            vertices: e,
            indices: t,
            radius: i,
            detail: r
        };
        const s = []
          , o = [];
        a(r),
        c(i),
        d(),
        this.setAttribute("position", new je(s,3)),
        this.setAttribute("normal", new je(s.slice(),3)),
        this.setAttribute("uv", new je(o,2)),
        r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
        function a(A) {
            const M = new D
              , S = new D
              , T = new D;
            for (let P = 0; P < t.length; P += 3)
                m(t[P + 0], M),
                m(t[P + 1], S),
                m(t[P + 2], T),
                l(M, S, T, A)
        }
        function l(A, M, S, T) {
            const P = T + 1
              , R = [];
            for (let E = 0; E <= P; E++) {
                R[E] = [];
                const B = A.clone().lerp(S, E / P)
                  , L = M.clone().lerp(S, E / P)
                  , z = P - E;
                for (let Z = 0; Z <= z; Z++)
                    Z === 0 && E === P ? R[E][Z] = B : R[E][Z] = B.clone().lerp(L, Z / z)
            }
            for (let E = 0; E < P; E++)
                for (let B = 0; B < 2 * (P - E) - 1; B++) {
                    const L = Math.floor(B / 2);
                    B % 2 === 0 ? (p(R[E][L + 1]),
                    p(R[E + 1][L]),
                    p(R[E][L])) : (p(R[E][L + 1]),
                    p(R[E + 1][L + 1]),
                    p(R[E + 1][L]))
                }
        }
        function c(A) {
            const M = new D;
            for (let S = 0; S < s.length; S += 3)
                M.x = s[S + 0],
                M.y = s[S + 1],
                M.z = s[S + 2],
                M.normalize().multiplyScalar(A),
                s[S + 0] = M.x,
                s[S + 1] = M.y,
                s[S + 2] = M.z
        }
        function d() {
            const A = new D;
            for (let M = 0; M < s.length; M += 3) {
                A.x = s[M + 0],
                A.y = s[M + 1],
                A.z = s[M + 2];
                const S = _(A) / 2 / Math.PI + .5
                  , T = x(A) / Math.PI + .5;
                o.push(S, 1 - T)
            }
            y(),
            h()
        }
        function h() {
            for (let A = 0; A < o.length; A += 6) {
                const M = o[A + 0]
                  , S = o[A + 2]
                  , T = o[A + 4]
                  , P = Math.max(M, S, T)
                  , R = Math.min(M, S, T);
                P > .9 && R < .1 && (M < .2 && (o[A + 0] += 1),
                S < .2 && (o[A + 2] += 1),
                T < .2 && (o[A + 4] += 1))
            }
        }
        function p(A) {
            s.push(A.x, A.y, A.z)
        }
        function m(A, M) {
            const S = A * 3;
            M.x = e[S + 0],
            M.y = e[S + 1],
            M.z = e[S + 2]
        }
        function y() {
            const A = new D
              , M = new D
              , S = new D
              , T = new D
              , P = new pe
              , R = new pe
              , E = new pe;
            for (let B = 0, L = 0; B < s.length; B += 9,
            L += 6) {
                A.set(s[B + 0], s[B + 1], s[B + 2]),
                M.set(s[B + 3], s[B + 4], s[B + 5]),
                S.set(s[B + 6], s[B + 7], s[B + 8]),
                P.set(o[L + 0], o[L + 1]),
                R.set(o[L + 2], o[L + 3]),
                E.set(o[L + 4], o[L + 5]),
                T.copy(A).add(M).add(S).divideScalar(3);
                const z = _(T);
                v(P, L + 0, A, z),
                v(R, L + 2, M, z),
                v(E, L + 4, S, z)
            }
        }
        function v(A, M, S, T) {
            T < 0 && A.x === 1 && (o[M] = A.x - 1),
            S.x === 0 && S.z === 0 && (o[M] = T / 2 / Math.PI + .5)
        }
        function _(A) {
            return Math.atan2(A.z, -A.x)
        }
        function x(A) {
            return Math.atan2(-A.y, Math.sqrt(A.x * A.x + A.z * A.z))
        }
    }
    static fromJSON(e) {
        return new Zs(e.vertices,e.indices,e.radius,e.details)
    }
}
class kd extends Zs {
    constructor(e=1, t=0) {
        const i = (1 + Math.sqrt(5)) / 2
          , r = 1 / i
          , s = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, 0, -i, 0, -r, i, 0, -r, -i, 0, r, i, 0, r]
          , o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
        super(s, o, e, t),
        this.type = "DodecahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new kd(e.radius,e.detail)
    }
}
const Gp = new D
  , Hp = new D
  , Ev = new D
  , Vp = new pr;
class DB extends ct {
    constructor(e=null, t=1) {
        if (super(),
        this.type = "EdgesGeometry",
        this.parameters = {
            geometry: e,
            thresholdAngle: t
        },
        e !== null) {
            const r = Math.pow(10, 4)
              , s = Math.cos(Za * t)
              , o = e.getIndex()
              , a = e.getAttribute("position")
              , l = o ? o.count : a.count
              , c = [0, 0, 0]
              , d = ["a", "b", "c"]
              , h = new Array(3)
              , p = {}
              , m = [];
            for (let y = 0; y < l; y += 3) {
                o ? (c[0] = o.getX(y),
                c[1] = o.getX(y + 1),
                c[2] = o.getX(y + 2)) : (c[0] = y,
                c[1] = y + 1,
                c[2] = y + 2);
                const {a: v, b: _, c: x} = Vp;
                if (v.fromBufferAttribute(a, c[0]),
                _.fromBufferAttribute(a, c[1]),
                x.fromBufferAttribute(a, c[2]),
                Vp.getNormal(Ev),
                h[0] = `${Math.round(v.x * r)},${Math.round(v.y * r)},${Math.round(v.z * r)}`,
                h[1] = `${Math.round(_.x * r)},${Math.round(_.y * r)},${Math.round(_.z * r)}`,
                h[2] = `${Math.round(x.x * r)},${Math.round(x.y * r)},${Math.round(x.z * r)}`,
                !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0]))
                    for (let A = 0; A < 3; A++) {
                        const M = (A + 1) % 3
                          , S = h[A]
                          , T = h[M]
                          , P = Vp[d[A]]
                          , R = Vp[d[M]]
                          , E = `${S}_${T}`
                          , B = `${T}_${S}`;
                        B in p && p[B] ? (Ev.dot(p[B].normal) <= s && (m.push(P.x, P.y, P.z),
                        m.push(R.x, R.y, R.z)),
                        p[B] = null) : E in p || (p[E] = {
                            index0: c[A],
                            index1: c[M],
                            normal: Ev.clone()
                        })
                    }
            }
            for (const y in p)
                if (p[y]) {
                    const {index0: v, index1: _} = p[y];
                    Gp.fromBufferAttribute(a, v),
                    Hp.fromBufferAttribute(a, _),
                    m.push(Gp.x, Gp.y, Gp.z),
                    m.push(Hp.x, Hp.y, Hp.z)
                }
            this.setAttribute("position", new je(m,3))
        }
    }
}
class el extends sd {
    constructor(e) {
        super(e),
        this.uuid = Vi(),
        this.type = "Shape",
        this.holes = []
    }
    getPointsHoles(e) {
        const t = [];
        for (let i = 0, r = this.holes.length; i < r; i++)
            t[i] = this.holes[i].getPoints(e);
        return t
    }
    extractPoints(e) {
        return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
        }
    }
    copy(e) {
        super.copy(e),
        this.holes = [];
        for (let t = 0, i = e.holes.length; t < i; t++) {
            const r = e.holes[t];
            this.holes.push(r.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.uuid = this.uuid,
        e.holes = [];
        for (let t = 0, i = this.holes.length; t < i; t++) {
            const r = this.holes[t];
            e.holes.push(r.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.uuid = e.uuid,
        this.holes = [];
        for (let t = 0, i = e.holes.length; t < i; t++) {
            const r = e.holes[t];
            this.holes.push(new sd().fromJSON(r))
        }
        return this
    }
}
const U8 = {
    triangulate: function(n, e, t=2) {
        const i = e && e.length
          , r = i ? e[0] * t : n.length;
        let s = FB(n, 0, r, t, !0);
        const o = [];
        if (!s || s.next === s.prev)
            return o;
        let a, l, c, d, h, p, m;
        if (i && (s = W8(n, e, s, t)),
        n.length > 80 * t) {
            a = c = n[0],
            l = d = n[1];
            for (let y = t; y < r; y += t)
                h = n[y],
                p = n[y + 1],
                h < a && (a = h),
                p < l && (l = p),
                h > c && (c = h),
                p > d && (d = p);
            m = Math.max(c - a, d - l),
            m = m !== 0 ? 32767 / m : 0
        }
        return od(s, o, t, a, l, m, 0),
        o
    }
};
function FB(n, e, t, i, r) {
    let s, o;
    if (r === t9(n, e, t, i) > 0)
        for (s = e; s < t; s += i)
            o = FE(s, n[s], n[s + 1], o);
    else
        for (s = t - i; s >= e; s -= i)
            o = FE(s, n[s], n[s + 1], o);
    return o && r0(o, o.next) && (ld(o),
    o = o.next),
    o
}
function ll(n, e) {
    if (!n)
        return n;
    e || (e = n);
    let t = n, i;
    do
        if (i = !1,
        !t.steiner && (r0(t, t.next) || rn(t.prev, t, t.next) === 0)) {
            if (ld(t),
            t = e = t.prev,
            t === t.next)
                break;
            i = !0
        } else
            t = t.next;
    while (i || t !== e);
    return e
}
function od(n, e, t, i, r, s, o) {
    if (!n)
        return;
    !o && s && Y8(n, i, r, s);
    let a = n, l, c;
    for (; n.prev !== n.next; ) {
        if (l = n.prev,
        c = n.next,
        s ? G8(n, i, r, s) : z8(n)) {
            e.push(l.i / t | 0),
            e.push(n.i / t | 0),
            e.push(c.i / t | 0),
            ld(n),
            n = c.next,
            a = c.next;
            continue
        }
        if (n = c,
        n === a) {
            o ? o === 1 ? (n = H8(ll(n), e, t),
            od(n, e, t, i, r, s, 2)) : o === 2 && V8(n, e, t, i, r, s) : od(ll(n), e, t, i, r, s, 1);
            break
        }
    }
}
function z8(n) {
    const e = n.prev
      , t = n
      , i = n.next;
    if (rn(e, t, i) >= 0)
        return !1;
    const r = e.x
      , s = t.x
      , o = i.x
      , a = e.y
      , l = t.y
      , c = i.y
      , d = r < s ? r < o ? r : o : s < o ? s : o
      , h = a < l ? a < c ? a : c : l < c ? l : c
      , p = r > s ? r > o ? r : o : s > o ? s : o
      , m = a > l ? a > c ? a : c : l > c ? l : c;
    let y = i.next;
    for (; y !== e; ) {
        if (y.x >= d && y.x <= p && y.y >= h && y.y <= m && mu(r, a, s, l, o, c, y.x, y.y) && rn(y.prev, y, y.next) >= 0)
            return !1;
        y = y.next
    }
    return !0
}
function G8(n, e, t, i) {
    const r = n.prev
      , s = n
      , o = n.next;
    if (rn(r, s, o) >= 0)
        return !1;
    const a = r.x
      , l = s.x
      , c = o.x
      , d = r.y
      , h = s.y
      , p = o.y
      , m = a < l ? a < c ? a : c : l < c ? l : c
      , y = d < h ? d < p ? d : p : h < p ? h : p
      , v = a > l ? a > c ? a : c : l > c ? l : c
      , _ = d > h ? d > p ? d : p : h > p ? h : p
      , x = F1(m, y, e, t, i)
      , A = F1(v, _, e, t, i);
    let M = n.prevZ
      , S = n.nextZ;
    for (; M && M.z >= x && S && S.z <= A; ) {
        if (M.x >= m && M.x <= v && M.y >= y && M.y <= _ && M !== r && M !== o && mu(a, d, l, h, c, p, M.x, M.y) && rn(M.prev, M, M.next) >= 0 || (M = M.prevZ,
        S.x >= m && S.x <= v && S.y >= y && S.y <= _ && S !== r && S !== o && mu(a, d, l, h, c, p, S.x, S.y) && rn(S.prev, S, S.next) >= 0))
            return !1;
        S = S.nextZ
    }
    for (; M && M.z >= x; ) {
        if (M.x >= m && M.x <= v && M.y >= y && M.y <= _ && M !== r && M !== o && mu(a, d, l, h, c, p, M.x, M.y) && rn(M.prev, M, M.next) >= 0)
            return !1;
        M = M.prevZ
    }
    for (; S && S.z <= A; ) {
        if (S.x >= m && S.x <= v && S.y >= y && S.y <= _ && S !== r && S !== o && mu(a, d, l, h, c, p, S.x, S.y) && rn(S.prev, S, S.next) >= 0)
            return !1;
        S = S.nextZ
    }
    return !0
}
function H8(n, e, t) {
    let i = n;
    do {
        const r = i.prev
          , s = i.next.next;
        !r0(r, s) && kB(r, i, i.next, s) && ad(r, s) && ad(s, r) && (e.push(r.i / t | 0),
        e.push(i.i / t | 0),
        e.push(s.i / t | 0),
        ld(i),
        ld(i.next),
        i = n = s),
        i = i.next
    } while (i !== n);
    return ll(i)
}
function V8(n, e, t, i, r, s) {
    let o = n;
    do {
        let a = o.next.next;
        for (; a !== o.prev; ) {
            if (o.i !== a.i && q8(o, a)) {
                let l = NB(o, a);
                o = ll(o, o.next),
                l = ll(l, l.next),
                od(o, e, t, i, r, s, 0),
                od(l, e, t, i, r, s, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== n)
}
function W8(n, e, t, i) {
    const r = [];
    let s, o, a, l, c;
    for (s = 0,
    o = e.length; s < o; s++)
        a = e[s] * i,
        l = s < o - 1 ? e[s + 1] * i : n.length,
        c = FB(n, a, l, i, !1),
        c === c.next && (c.steiner = !0),
        r.push(Z8(c));
    for (r.sort(j8),
    s = 0; s < r.length; s++)
        t = J8(r[s], t);
    return t
}
function j8(n, e) {
    return n.x - e.x
}
function J8(n, e) {
    const t = X8(n, e);
    if (!t)
        return e;
    const i = NB(t, n);
    return ll(i, i.next),
    ll(t, t.next)
}
function X8(n, e) {
    let t = e, i = -1 / 0, r;
    const s = n.x
      , o = n.y;
    do {
        if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
            const p = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
            if (p <= s && p > i && (i = p,
            r = t.x < t.next.x ? t : t.next,
            p === s))
                return r
        }
        t = t.next
    } while (t !== e);
    if (!r)
        return null;
    const a = r
      , l = r.x
      , c = r.y;
    let d = 1 / 0, h;
    t = r;
    do
        s >= t.x && t.x >= l && s !== t.x && mu(o < c ? s : i, o, l, c, o < c ? i : s, o, t.x, t.y) && (h = Math.abs(o - t.y) / (s - t.x),
        ad(t, n) && (h < d || h === d && (t.x > r.x || t.x === r.x && K8(r, t))) && (r = t,
        d = h)),
        t = t.next;
    while (t !== a);
    return r
}
function K8(n, e) {
    return rn(n.prev, n, e.prev) < 0 && rn(e.next, n, n.next) < 0
}
function Y8(n, e, t, i) {
    let r = n;
    do
        r.z === 0 && (r.z = F1(r.x, r.y, e, t, i)),
        r.prevZ = r.prev,
        r.nextZ = r.next,
        r = r.next;
    while (r !== n);
    r.prevZ.nextZ = null,
    r.prevZ = null,
    Q8(r)
}
function Q8(n) {
    let e, t, i, r, s, o, a, l, c = 1;
    do {
        for (t = n,
        n = null,
        s = null,
        o = 0; t; ) {
            for (o++,
            i = t,
            a = 0,
            e = 0; e < c && (a++,
            i = i.nextZ,
            !!i); e++)
                ;
            for (l = c; a > 0 || l > 0 && i; )
                a !== 0 && (l === 0 || !i || t.z <= i.z) ? (r = t,
                t = t.nextZ,
                a--) : (r = i,
                i = i.nextZ,
                l--),
                s ? s.nextZ = r : n = r,
                r.prevZ = s,
                s = r;
            t = i
        }
        s.nextZ = null,
        c *= 2
    } while (o > 1);
    return n
}
function F1(n, e, t, i, r) {
    return n = (n - t) * r | 0,
    e = (e - i) * r | 0,
    n = (n | n << 8) & 16711935,
    n = (n | n << 4) & 252645135,
    n = (n | n << 2) & 858993459,
    n = (n | n << 1) & 1431655765,
    e = (e | e << 8) & 16711935,
    e = (e | e << 4) & 252645135,
    e = (e | e << 2) & 858993459,
    e = (e | e << 1) & 1431655765,
    n | e << 1
}
function Z8(n) {
    let e = n
      , t = n;
    do
        (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e),
        e = e.next;
    while (e !== n);
    return t
}
function mu(n, e, t, i, r, s, o, a) {
    return (r - o) * (e - a) >= (n - o) * (s - a) && (n - o) * (i - a) >= (t - o) * (e - a) && (t - o) * (s - a) >= (r - o) * (i - a)
}
function q8(n, e) {
    return n.next.i !== e.i && n.prev.i !== e.i && !$8(n, e) && (ad(n, e) && ad(e, n) && e9(n, e) && (rn(n.prev, n, e.prev) || rn(n, e.prev, e)) || r0(n, e) && rn(n.prev, n, n.next) > 0 && rn(e.prev, e, e.next) > 0)
}
function rn(n, e, t) {
    return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y)
}
function r0(n, e) {
    return n.x === e.x && n.y === e.y
}
function kB(n, e, t, i) {
    const r = jp(rn(n, e, t))
      , s = jp(rn(n, e, i))
      , o = jp(rn(t, i, n))
      , a = jp(rn(t, i, e));
    return !!(r !== s && o !== a || r === 0 && Wp(n, t, e) || s === 0 && Wp(n, i, e) || o === 0 && Wp(t, n, i) || a === 0 && Wp(t, e, i))
}
function Wp(n, e, t) {
    return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y)
}
function jp(n) {
    return n > 0 ? 1 : n < 0 ? -1 : 0
}
function $8(n, e) {
    let t = n;
    do {
        if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && kB(t, t.next, n, e))
            return !0;
        t = t.next
    } while (t !== n);
    return !1
}
function ad(n, e) {
    return rn(n.prev, n, n.next) < 0 ? rn(n, e, n.next) >= 0 && rn(n, n.prev, e) >= 0 : rn(n, e, n.prev) < 0 || rn(n, n.next, e) < 0
}
function e9(n, e) {
    let t = n
      , i = !1;
    const r = (n.x + e.x) / 2
      , s = (n.y + e.y) / 2;
    do
        t.y > s != t.next.y > s && t.next.y !== t.y && r < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (i = !i),
        t = t.next;
    while (t !== n);
    return i
}
function NB(n, e) {
    const t = new k1(n.i,n.x,n.y)
      , i = new k1(e.i,e.x,e.y)
      , r = n.next
      , s = e.prev;
    return n.next = e,
    e.prev = n,
    t.next = r,
    r.prev = t,
    i.next = t,
    t.prev = i,
    s.next = i,
    i.prev = s,
    i
}
function FE(n, e, t, i) {
    const r = new k1(n,e,t);
    return i ? (r.next = i.next,
    r.prev = i,
    i.next.prev = r,
    i.next = r) : (r.prev = r,
    r.next = r),
    r
}
function ld(n) {
    n.next.prev = n.prev,
    n.prev.next = n.next,
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ)
}
function k1(n, e, t) {
    this.i = n,
    this.x = e,
    this.y = t,
    this.prev = null,
    this.next = null,
    this.z = 0,
    this.prevZ = null,
    this.nextZ = null,
    this.steiner = !1
}
function t9(n, e, t, i) {
    let r = 0;
    for (let s = e, o = t - i; s < t; s += i)
        r += (n[o] - n[s]) * (n[s + 1] + n[o + 1]),
        o = s;
    return r
}
class rs {
    static area(e) {
        const t = e.length;
        let i = 0;
        for (let r = t - 1, s = 0; s < t; r = s++)
            i += e[r].x * e[s].y - e[s].x * e[r].y;
        return i * .5
    }
    static isClockWise(e) {
        return rs.area(e) < 0
    }
    static triangulateShape(e, t) {
        const i = []
          , r = []
          , s = [];
        kE(e),
        NE(i, e);
        let o = e.length;
        t.forEach(kE);
        for (let l = 0; l < t.length; l++)
            r.push(o),
            o += t[l].length,
            NE(i, t[l]);
        const a = U8.triangulate(i, r);
        for (let l = 0; l < a.length; l += 3)
            s.push(a.slice(l, l + 3));
        return s
    }
}
function kE(n) {
    const e = n.length;
    e > 2 && n[e - 1].equals(n[0]) && n.pop()
}
function NE(n, e) {
    for (let t = 0; t < e.length; t++)
        n.push(e[t].x),
        n.push(e[t].y)
}
class Nd extends ct {
    constructor(e=new el([new pe(.5,.5), new pe(-.5,.5), new pe(-.5,-.5), new pe(.5,-.5)]), t={}) {
        super(),
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: e,
            options: t
        },
        e = Array.isArray(e) ? e : [e];
        const i = this
          , r = []
          , s = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a];
            o(c)
        }
        this.setAttribute("position", new je(r,3)),
        this.setAttribute("uv", new je(s,2)),
        this.computeVertexNormals();
        function o(a) {
            const l = []
              , c = t.curveSegments !== void 0 ? t.curveSegments : 12
              , d = t.steps !== void 0 ? t.steps : 1
              , h = t.depth !== void 0 ? t.depth : 1;
            let p = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0
              , m = t.bevelThickness !== void 0 ? t.bevelThickness : .2
              , y = t.bevelSize !== void 0 ? t.bevelSize : m - .1
              , v = t.bevelOffset !== void 0 ? t.bevelOffset : 0
              , _ = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
            const x = t.extrudePath
              , A = t.UVGenerator !== void 0 ? t.UVGenerator : n9;
            let M, S = !1, T, P, R, E;
            x && (M = x.getSpacedPoints(d),
            S = !0,
            p = !1,
            T = x.computeFrenetFrames(d, !1),
            P = new D,
            R = new D,
            E = new D),
            p || (_ = 0,
            m = 0,
            y = 0,
            v = 0);
            const B = a.extractPoints(c);
            let L = B.shape;
            const z = B.holes;
            if (!rs.isClockWise(L)) {
                L = L.reverse();
                for (let de = 0, ae = z.length; de < ae; de++) {
                    const Ce = z[de];
                    rs.isClockWise(Ce) && (z[de] = Ce.reverse())
                }
            }
            const J = rs.triangulateShape(L, z)
              , G = L;
            for (let de = 0, ae = z.length; de < ae; de++) {
                const Ce = z[de];
                L = L.concat(Ce)
            }
            function X(de, ae, Ce) {
                return ae || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                ae.clone().multiplyScalar(Ce).add(de)
            }
            const ee = L.length
              , ie = J.length;
            function F(de, ae, Ce) {
                let ze, Be, Ze;
                const Je = de.x - ae.x
                  , We = de.y - ae.y
                  , xt = Ce.x - de.x
                  , St = Ce.y - de.y
                  , U = Je * Je + We * We
                  , I = Je * St - We * xt;
                if (Math.abs(I) > Number.EPSILON) {
                    const oe = Math.sqrt(U)
                      , we = Math.sqrt(xt * xt + St * St)
                      , Ee = ae.x - We / oe
                      , Pe = ae.y + Je / oe
                      , tt = Ce.x - St / we
                      , Fe = Ce.y + xt / we
                      , me = ((tt - Ee) * St - (Fe - Pe) * xt) / (Je * St - We * xt);
                    ze = Ee + Je * me - de.x,
                    Be = Pe + We * me - de.y;
                    const Xe = ze * ze + Be * Be;
                    if (Xe <= 2)
                        return new pe(ze,Be);
                    Ze = Math.sqrt(Xe / 2)
                } else {
                    let oe = !1;
                    Je > Number.EPSILON ? xt > Number.EPSILON && (oe = !0) : Je < -Number.EPSILON ? xt < -Number.EPSILON && (oe = !0) : Math.sign(We) === Math.sign(St) && (oe = !0),
                    oe ? (ze = -We,
                    Be = Je,
                    Ze = Math.sqrt(U)) : (ze = Je,
                    Be = We,
                    Ze = Math.sqrt(U / 2))
                }
                return new pe(ze / Ze,Be / Ze)
            }
            const V = [];
            for (let de = 0, ae = G.length, Ce = ae - 1, ze = de + 1; de < ae; de++,
            Ce++,
            ze++)
                Ce === ae && (Ce = 0),
                ze === ae && (ze = 0),
                V[de] = F(G[de], G[Ce], G[ze]);
            const j = [];
            let re, H = V.concat();
            for (let de = 0, ae = z.length; de < ae; de++) {
                const Ce = z[de];
                re = [];
                for (let ze = 0, Be = Ce.length, Ze = Be - 1, Je = ze + 1; ze < Be; ze++,
                Ze++,
                Je++)
                    Ze === Be && (Ze = 0),
                    Je === Be && (Je = 0),
                    re[ze] = F(Ce[ze], Ce[Ze], Ce[Je]);
                j.push(re),
                H = H.concat(re)
            }
            for (let de = 0; de < _; de++) {
                const ae = de / _
                  , Ce = m * Math.cos(ae * Math.PI / 2)
                  , ze = y * Math.sin(ae * Math.PI / 2) + v;
                for (let Be = 0, Ze = G.length; Be < Ze; Be++) {
                    const Je = X(G[Be], V[Be], ze);
                    Ie(Je.x, Je.y, -Ce)
                }
                for (let Be = 0, Ze = z.length; Be < Ze; Be++) {
                    const Je = z[Be];
                    re = j[Be];
                    for (let We = 0, xt = Je.length; We < xt; We++) {
                        const St = X(Je[We], re[We], ze);
                        Ie(St.x, St.y, -Ce)
                    }
                }
            }
            const se = y + v;
            for (let de = 0; de < ee; de++) {
                const ae = p ? X(L[de], H[de], se) : L[de];
                S ? (R.copy(T.normals[0]).multiplyScalar(ae.x),
                P.copy(T.binormals[0]).multiplyScalar(ae.y),
                E.copy(M[0]).add(R).add(P),
                Ie(E.x, E.y, E.z)) : Ie(ae.x, ae.y, 0)
            }
            for (let de = 1; de <= d; de++)
                for (let ae = 0; ae < ee; ae++) {
                    const Ce = p ? X(L[ae], H[ae], se) : L[ae];
                    S ? (R.copy(T.normals[de]).multiplyScalar(Ce.x),
                    P.copy(T.binormals[de]).multiplyScalar(Ce.y),
                    E.copy(M[de]).add(R).add(P),
                    Ie(E.x, E.y, E.z)) : Ie(Ce.x, Ce.y, h / d * de)
                }
            for (let de = _ - 1; de >= 0; de--) {
                const ae = de / _
                  , Ce = m * Math.cos(ae * Math.PI / 2)
                  , ze = y * Math.sin(ae * Math.PI / 2) + v;
                for (let Be = 0, Ze = G.length; Be < Ze; Be++) {
                    const Je = X(G[Be], V[Be], ze);
                    Ie(Je.x, Je.y, h + Ce)
                }
                for (let Be = 0, Ze = z.length; Be < Ze; Be++) {
                    const Je = z[Be];
                    re = j[Be];
                    for (let We = 0, xt = Je.length; We < xt; We++) {
                        const St = X(Je[We], re[We], ze);
                        S ? Ie(St.x, St.y + M[d - 1].y, M[d - 1].x + Ce) : Ie(St.x, St.y, h + Ce)
                    }
                }
            }
            ye(),
            ve();
            function ye() {
                const de = r.length / 3;
                if (p) {
                    let ae = 0
                      , Ce = ee * ae;
                    for (let ze = 0; ze < ie; ze++) {
                        const Be = J[ze];
                        Ne(Be[2] + Ce, Be[1] + Ce, Be[0] + Ce)
                    }
                    ae = d + _ * 2,
                    Ce = ee * ae;
                    for (let ze = 0; ze < ie; ze++) {
                        const Be = J[ze];
                        Ne(Be[0] + Ce, Be[1] + Ce, Be[2] + Ce)
                    }
                } else {
                    for (let ae = 0; ae < ie; ae++) {
                        const Ce = J[ae];
                        Ne(Ce[2], Ce[1], Ce[0])
                    }
                    for (let ae = 0; ae < ie; ae++) {
                        const Ce = J[ae];
                        Ne(Ce[0] + ee * d, Ce[1] + ee * d, Ce[2] + ee * d)
                    }
                }
                i.addGroup(de, r.length / 3 - de, 0)
            }
            function ve() {
                const de = r.length / 3;
                let ae = 0;
                q(G, ae),
                ae += G.length;
                for (let Ce = 0, ze = z.length; Ce < ze; Ce++) {
                    const Be = z[Ce];
                    q(Be, ae),
                    ae += Be.length
                }
                i.addGroup(de, r.length / 3 - de, 1)
            }
            function q(de, ae) {
                let Ce = de.length;
                for (; --Ce >= 0; ) {
                    const ze = Ce;
                    let Be = Ce - 1;
                    Be < 0 && (Be = de.length - 1);
                    for (let Ze = 0, Je = d + _ * 2; Ze < Je; Ze++) {
                        const We = ee * Ze
                          , xt = ee * (Ze + 1)
                          , St = ae + ze + We
                          , U = ae + Be + We
                          , I = ae + Be + xt
                          , oe = ae + ze + xt;
                        He(St, U, I, oe)
                    }
                }
            }
            function Ie(de, ae, Ce) {
                l.push(de),
                l.push(ae),
                l.push(Ce)
            }
            function Ne(de, ae, Ce) {
                Me(de),
                Me(ae),
                Me(Ce);
                const ze = r.length / 3
                  , Be = A.generateTopUV(i, r, ze - 3, ze - 2, ze - 1);
                De(Be[0]),
                De(Be[1]),
                De(Be[2])
            }
            function He(de, ae, Ce, ze) {
                Me(de),
                Me(ae),
                Me(ze),
                Me(ae),
                Me(Ce),
                Me(ze);
                const Be = r.length / 3
                  , Ze = A.generateSideWallUV(i, r, Be - 6, Be - 3, Be - 2, Be - 1);
                De(Ze[0]),
                De(Ze[1]),
                De(Ze[3]),
                De(Ze[1]),
                De(Ze[2]),
                De(Ze[3])
            }
            function Me(de) {
                r.push(l[de * 3 + 0]),
                r.push(l[de * 3 + 1]),
                r.push(l[de * 3 + 2])
            }
            function De(de) {
                s.push(de.x),
                s.push(de.y)
            }
        }
    }
    toJSON() {
        const e = super.toJSON()
          , t = this.parameters.shapes
          , i = this.parameters.options;
        return i9(t, i, e)
    }
    static fromJSON(e, t) {
        const i = [];
        for (let s = 0, o = e.shapes.length; s < o; s++) {
            const a = t[e.shapes[s]];
            i.push(a)
        }
        const r = e.options.extrudePath;
        return r !== void 0 && (e.options.extrudePath = new zA[r.type]().fromJSON(r)),
        new Nd(i,e.options)
    }
}
const n9 = {
    generateTopUV: function(n, e, t, i, r) {
        const s = e[t * 3]
          , o = e[t * 3 + 1]
          , a = e[i * 3]
          , l = e[i * 3 + 1]
          , c = e[r * 3]
          , d = e[r * 3 + 1];
        return [new pe(s,o), new pe(a,l), new pe(c,d)]
    },
    generateSideWallUV: function(n, e, t, i, r, s) {
        const o = e[t * 3]
          , a = e[t * 3 + 1]
          , l = e[t * 3 + 2]
          , c = e[i * 3]
          , d = e[i * 3 + 1]
          , h = e[i * 3 + 2]
          , p = e[r * 3]
          , m = e[r * 3 + 1]
          , y = e[r * 3 + 2]
          , v = e[s * 3]
          , _ = e[s * 3 + 1]
          , x = e[s * 3 + 2];
        return Math.abs(a - d) < Math.abs(o - c) ? [new pe(o,1 - l), new pe(c,1 - h), new pe(p,1 - y), new pe(v,1 - x)] : [new pe(a,1 - l), new pe(d,1 - h), new pe(m,1 - y), new pe(_,1 - x)]
    }
};
function i9(n, e, t) {
    if (t.shapes = [],
    Array.isArray(n))
        for (let i = 0, r = n.length; i < r; i++) {
            const s = n[i];
            t.shapes.push(s.uuid)
        }
    else
        t.shapes.push(n.uuid);
    return t.options = Object.assign({}, e),
    e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()),
    t
}
class Od extends Zs {
    constructor(e=1, t=0) {
        const i = (1 + Math.sqrt(5)) / 2
          , r = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1]
          , s = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
        super(r, s, e, t),
        this.type = "IcosahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Od(e.radius,e.detail)
    }
}
class nc extends Zs {
    constructor(e=1, t=0) {
        const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1]
          , r = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        super(i, r, e, t),
        this.type = "OctahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new nc(e.radius,e.detail)
    }
}
class Ud extends ct {
    constructor(e=.5, t=1, i=32, r=1, s=0, o=Math.PI * 2) {
        super(),
        this.type = "RingGeometry",
        this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: i,
            phiSegments: r,
            thetaStart: s,
            thetaLength: o
        },
        i = Math.max(3, i),
        r = Math.max(1, r);
        const a = []
          , l = []
          , c = []
          , d = [];
        let h = e;
        const p = (t - e) / r
          , m = new D
          , y = new pe;
        for (let v = 0; v <= r; v++) {
            for (let _ = 0; _ <= i; _++) {
                const x = s + _ / i * o;
                m.x = h * Math.cos(x),
                m.y = h * Math.sin(x),
                l.push(m.x, m.y, m.z),
                c.push(0, 0, 1),
                y.x = (m.x / t + 1) / 2,
                y.y = (m.y / t + 1) / 2,
                d.push(y.x, y.y)
            }
            h += p
        }
        for (let v = 0; v < r; v++) {
            const _ = v * (i + 1);
            for (let x = 0; x < i; x++) {
                const A = x + _
                  , M = A
                  , S = A + i + 1
                  , T = A + i + 2
                  , P = A + 1;
                a.push(M, S, P),
                a.push(S, T, P)
            }
        }
        this.setIndex(a),
        this.setAttribute("position", new je(l,3)),
        this.setAttribute("normal", new je(c,3)),
        this.setAttribute("uv", new je(d,2))
    }
    static fromJSON(e) {
        return new Ud(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)
    }
}
class zd extends ct {
    constructor(e=new el([new pe(0,.5), new pe(-.5,-.5), new pe(.5,-.5)]), t=12) {
        super(),
        this.type = "ShapeGeometry",
        this.parameters = {
            shapes: e,
            curveSegments: t
        };
        const i = []
          , r = []
          , s = []
          , o = [];
        let a = 0
          , l = 0;
        if (Array.isArray(e) === !1)
            c(e);
        else
            for (let d = 0; d < e.length; d++)
                c(e[d]),
                this.addGroup(a, l, d),
                a += l,
                l = 0;
        this.setIndex(i),
        this.setAttribute("position", new je(r,3)),
        this.setAttribute("normal", new je(s,3)),
        this.setAttribute("uv", new je(o,2));
        function c(d) {
            const h = r.length / 3
              , p = d.extractPoints(t);
            let m = p.shape;
            const y = p.holes;
            rs.isClockWise(m) === !1 && (m = m.reverse());
            for (let _ = 0, x = y.length; _ < x; _++) {
                const A = y[_];
                rs.isClockWise(A) === !0 && (y[_] = A.reverse())
            }
            const v = rs.triangulateShape(m, y);
            for (let _ = 0, x = y.length; _ < x; _++) {
                const A = y[_];
                m = m.concat(A)
            }
            for (let _ = 0, x = m.length; _ < x; _++) {
                const A = m[_];
                r.push(A.x, A.y, 0),
                s.push(0, 0, 1),
                o.push(A.x, A.y)
            }
            for (let _ = 0, x = v.length; _ < x; _++) {
                const A = v[_]
                  , M = A[0] + h
                  , S = A[1] + h
                  , T = A[2] + h;
                i.push(M, S, T),
                l += 3
            }
        }
    }
    toJSON() {
        const e = super.toJSON()
          , t = this.parameters.shapes;
        return r9(t, e)
    }
    static fromJSON(e, t) {
        const i = [];
        for (let r = 0, s = e.shapes.length; r < s; r++) {
            const o = t[e.shapes[r]];
            i.push(o)
        }
        return new zd(i,e.curveSegments)
    }
}
function r9(n, e) {
    if (e.shapes = [],
    Array.isArray(n))
        for (let t = 0, i = n.length; t < i; t++) {
            const r = n[t];
            e.shapes.push(r.uuid)
        }
    else
        e.shapes.push(n.uuid);
    return e
}
class ic extends ct {
    constructor(e=1, t=32, i=16, r=0, s=Math.PI * 2, o=0, a=Math.PI) {
        super(),
        this.type = "SphereGeometry",
        this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: r,
            phiLength: s,
            thetaStart: o,
            thetaLength: a
        },
        t = Math.max(3, Math.floor(t)),
        i = Math.max(2, Math.floor(i));
        const l = Math.min(o + a, Math.PI);
        let c = 0;
        const d = []
          , h = new D
          , p = new D
          , m = []
          , y = []
          , v = []
          , _ = [];
        for (let x = 0; x <= i; x++) {
            const A = []
              , M = x / i;
            let S = 0;
            x == 0 && o == 0 ? S = .5 / t : x == i && l == Math.PI && (S = -.5 / t);
            for (let T = 0; T <= t; T++) {
                const P = T / t;
                h.x = -e * Math.cos(r + P * s) * Math.sin(o + M * a),
                h.y = e * Math.cos(o + M * a),
                h.z = e * Math.sin(r + P * s) * Math.sin(o + M * a),
                y.push(h.x, h.y, h.z),
                p.copy(h).normalize(),
                v.push(p.x, p.y, p.z),
                _.push(P + S, 1 - M),
                A.push(c++)
            }
            d.push(A)
        }
        for (let x = 0; x < i; x++)
            for (let A = 0; A < t; A++) {
                const M = d[x][A + 1]
                  , S = d[x][A]
                  , T = d[x + 1][A]
                  , P = d[x + 1][A + 1];
                (x !== 0 || o > 0) && m.push(M, S, P),
                (x !== i - 1 || l < Math.PI) && m.push(S, T, P)
            }
        this.setIndex(m),
        this.setAttribute("position", new je(y,3)),
        this.setAttribute("normal", new je(v,3)),
        this.setAttribute("uv", new je(_,2))
    }
    static fromJSON(e) {
        return new ic(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)
    }
}
class Gd extends Zs {
    constructor(e=1, t=0) {
        const i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1]
          , r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        super(i, r, e, t),
        this.type = "TetrahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Gd(e.radius,e.detail)
    }
}
class Hd extends ct {
    constructor(e=1, t=.4, i=12, r=48, s=Math.PI * 2) {
        super(),
        this.type = "TorusGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            radialSegments: i,
            tubularSegments: r,
            arc: s
        },
        i = Math.floor(i),
        r = Math.floor(r);
        const o = []
          , a = []
          , l = []
          , c = []
          , d = new D
          , h = new D
          , p = new D;
        for (let m = 0; m <= i; m++)
            for (let y = 0; y <= r; y++) {
                const v = y / r * s
                  , _ = m / i * Math.PI * 2;
                h.x = (e + t * Math.cos(_)) * Math.cos(v),
                h.y = (e + t * Math.cos(_)) * Math.sin(v),
                h.z = t * Math.sin(_),
                a.push(h.x, h.y, h.z),
                d.x = e * Math.cos(v),
                d.y = e * Math.sin(v),
                p.subVectors(h, d).normalize(),
                l.push(p.x, p.y, p.z),
                c.push(y / r),
                c.push(m / i)
            }
        for (let m = 1; m <= i; m++)
            for (let y = 1; y <= r; y++) {
                const v = (r + 1) * m + y - 1
                  , _ = (r + 1) * (m - 1) + y - 1
                  , x = (r + 1) * (m - 1) + y
                  , A = (r + 1) * m + y;
                o.push(v, _, A),
                o.push(_, x, A)
            }
        this.setIndex(o),
        this.setAttribute("position", new je(a,3)),
        this.setAttribute("normal", new je(l,3)),
        this.setAttribute("uv", new je(c,2))
    }
    static fromJSON(e) {
        return new Hd(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)
    }
}
class Vd extends ct {
    constructor(e=1, t=.4, i=64, r=8, s=2, o=3) {
        super(),
        this.type = "TorusKnotGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: i,
            radialSegments: r,
            p: s,
            q: o
        },
        i = Math.floor(i),
        r = Math.floor(r);
        const a = []
          , l = []
          , c = []
          , d = []
          , h = new D
          , p = new D
          , m = new D
          , y = new D
          , v = new D
          , _ = new D
          , x = new D;
        for (let M = 0; M <= i; ++M) {
            const S = M / i * s * Math.PI * 2;
            A(S, s, o, e, m),
            A(S + .01, s, o, e, y),
            _.subVectors(y, m),
            x.addVectors(y, m),
            v.crossVectors(_, x),
            x.crossVectors(v, _),
            v.normalize(),
            x.normalize();
            for (let T = 0; T <= r; ++T) {
                const P = T / r * Math.PI * 2
                  , R = -t * Math.cos(P)
                  , E = t * Math.sin(P);
                h.x = m.x + (R * x.x + E * v.x),
                h.y = m.y + (R * x.y + E * v.y),
                h.z = m.z + (R * x.z + E * v.z),
                l.push(h.x, h.y, h.z),
                p.subVectors(h, m).normalize(),
                c.push(p.x, p.y, p.z),
                d.push(M / i),
                d.push(T / r)
            }
        }
        for (let M = 1; M <= i; M++)
            for (let S = 1; S <= r; S++) {
                const T = (r + 1) * (M - 1) + (S - 1)
                  , P = (r + 1) * M + (S - 1)
                  , R = (r + 1) * M + S
                  , E = (r + 1) * (M - 1) + S;
                a.push(T, P, E),
                a.push(P, R, E)
            }
        this.setIndex(a),
        this.setAttribute("position", new je(l,3)),
        this.setAttribute("normal", new je(c,3)),
        this.setAttribute("uv", new je(d,2));
        function A(M, S, T, P, R) {
            const E = Math.cos(M)
              , B = Math.sin(M)
              , L = T / S * M
              , z = Math.cos(L);
            R.x = P * (2 + z) * .5 * E,
            R.y = P * (2 + z) * B * .5,
            R.z = P * Math.sin(L) * .5
        }
    }
    static fromJSON(e) {
        return new Vd(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)
    }
}
class Wd extends ct {
    constructor(e=new OA(new D(-1,-1,0),new D(-1,1,0),new D(1,1,0)), t=64, i=1, r=8, s=!1) {
        super(),
        this.type = "TubeGeometry",
        this.parameters = {
            path: e,
            tubularSegments: t,
            radius: i,
            radialSegments: r,
            closed: s
        };
        const o = e.computeFrenetFrames(t, s);
        this.tangents = o.tangents,
        this.normals = o.normals,
        this.binormals = o.binormals;
        const a = new D
          , l = new D
          , c = new pe;
        let d = new D;
        const h = []
          , p = []
          , m = []
          , y = [];
        v(),
        this.setIndex(y),
        this.setAttribute("position", new je(h,3)),
        this.setAttribute("normal", new je(p,3)),
        this.setAttribute("uv", new je(m,2));
        function v() {
            for (let M = 0; M < t; M++)
                _(M);
            _(s === !1 ? t : 0),
            A(),
            x()
        }
        function _(M) {
            d = e.getPointAt(M / t, d);
            const S = o.normals[M]
              , T = o.binormals[M];
            for (let P = 0; P <= r; P++) {
                const R = P / r * Math.PI * 2
                  , E = Math.sin(R)
                  , B = -Math.cos(R);
                l.x = B * S.x + E * T.x,
                l.y = B * S.y + E * T.y,
                l.z = B * S.z + E * T.z,
                l.normalize(),
                p.push(l.x, l.y, l.z),
                a.x = d.x + i * l.x,
                a.y = d.y + i * l.y,
                a.z = d.z + i * l.z,
                h.push(a.x, a.y, a.z)
            }
        }
        function x() {
            for (let M = 1; M <= t; M++)
                for (let S = 1; S <= r; S++) {
                    const T = (r + 1) * (M - 1) + (S - 1)
                      , P = (r + 1) * M + (S - 1)
                      , R = (r + 1) * M + S
                      , E = (r + 1) * (M - 1) + S;
                    y.push(T, P, E),
                    y.push(P, R, E)
                }
        }
        function A() {
            for (let M = 0; M <= t; M++)
                for (let S = 0; S <= r; S++)
                    c.x = M / t,
                    c.y = S / r,
                    m.push(c.x, c.y)
        }
    }
    toJSON() {
        const e = super.toJSON();
        return e.path = this.parameters.path.toJSON(),
        e
    }
    static fromJSON(e) {
        return new Wd(new zA[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)
    }
}
class OB extends ct {
    constructor(e=null) {
        if (super(),
        this.type = "WireframeGeometry",
        this.parameters = {
            geometry: e
        },
        e !== null) {
            const t = []
              , i = new Set
              , r = new D
              , s = new D;
            if (e.index !== null) {
                const o = e.attributes.position
                  , a = e.index;
                let l = e.groups;
                l.length === 0 && (l = [{
                    start: 0,
                    count: a.count,
                    materialIndex: 0
                }]);
                for (let c = 0, d = l.length; c < d; ++c) {
                    const h = l[c]
                      , p = h.start
                      , m = h.count;
                    for (let y = p, v = p + m; y < v; y += 3)
                        for (let _ = 0; _ < 3; _++) {
                            const x = a.getX(y + _)
                              , A = a.getX(y + (_ + 1) % 3);
                            r.fromBufferAttribute(o, x),
                            s.fromBufferAttribute(o, A),
                            OE(r, s, i) === !0 && (t.push(r.x, r.y, r.z),
                            t.push(s.x, s.y, s.z))
                        }
                }
            } else {
                const o = e.attributes.position;
                for (let a = 0, l = o.count / 3; a < l; a++)
                    for (let c = 0; c < 3; c++) {
                        const d = 3 * a + c
                          , h = 3 * a + (c + 1) % 3;
                        r.fromBufferAttribute(o, d),
                        s.fromBufferAttribute(o, h),
                        OE(r, s, i) === !0 && (t.push(r.x, r.y, r.z),
                        t.push(s.x, s.y, s.z))
                    }
            }
            this.setAttribute("position", new je(t,3))
        }
    }
}
function OE(n, e, t) {
    const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`
      , r = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
    return t.has(i) === !0 || t.has(r) === !0 ? !1 : (t.add(i),
    t.add(r),
    !0)
}
var UE = Object.freeze({
    __proto__: null,
    BoxGeometry: ia,
    CapsuleGeometry: Id,
    CircleGeometry: Dd,
    ConeGeometry: Fd,
    CylinderGeometry: hl,
    DodecahedronGeometry: kd,
    EdgesGeometry: DB,
    ExtrudeGeometry: Nd,
    IcosahedronGeometry: Od,
    LatheGeometry: tc,
    OctahedronGeometry: nc,
    PlaneGeometry: $u,
    PolyhedronGeometry: Zs,
    RingGeometry: Ud,
    ShapeGeometry: zd,
    SphereGeometry: ic,
    TetrahedronGeometry: Gd,
    TorusGeometry: Hd,
    TorusKnotGeometry: Vd,
    TubeGeometry: Wd,
    WireframeGeometry: OB
});
class UB extends Sn {
    constructor(e) {
        super(),
        this.isShadowMaterial = !0,
        this.type = "ShadowMaterial",
        this.color = new Le(0),
        this.transparent = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.fog = e.fog,
        this
    }
}
class zB extends us {
    constructor(e) {
        super(e),
        this.isRawShaderMaterial = !0,
        this.type = "RawShaderMaterial"
    }
}
class rc extends Sn {
    constructor(e) {
        super(),
        this.isMeshStandardMaterial = !0,
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new Le(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Le(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Qs,
        this.normalScale = new pe(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapIntensity = e.envMapIntensity,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class qs extends rc {
    constructor(e) {
        super(),
        this.isMeshPhysicalMaterial = !0,
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new pe(1,1),
        this.clearcoatNormalMap = null,
        this.ior = 1.5,
        Object.defineProperty(this, "reflectivity", {
            get: function() {
                return vn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(t) {
                this.ior = (1 + .4 * t) / (1 - .4 * t)
            }
        }),
        this.iridescenceMap = null,
        this.iridescenceIOR = 1.3,
        this.iridescenceThicknessRange = [100, 400],
        this.iridescenceThicknessMap = null,
        this.sheenColor = new Le(0),
        this.sheenColorMap = null,
        this.sheenRoughness = 1,
        this.sheenRoughnessMap = null,
        this.transmissionMap = null,
        this.thickness = 0,
        this.thicknessMap = null,
        this.attenuationDistance = 1 / 0,
        this.attenuationColor = new Le(1,1,1),
        this.specularIntensity = 1,
        this.specularIntensityMap = null,
        this.specularColor = new Le(1,1,1),
        this.specularColorMap = null,
        this._sheen = 0,
        this._clearcoat = 0,
        this._iridescence = 0,
        this._transmission = 0,
        this.setValues(e)
    }
    get sheen() {
        return this._sheen
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++,
        this._sheen = e
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++,
        this._clearcoat = e
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++,
        this._iridescence = e
    }
    get transmission() {
        return this._transmission
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++,
        this._transmission = e
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.clearcoat = e.clearcoat,
        this.clearcoatMap = e.clearcoatMap,
        this.clearcoatRoughness = e.clearcoatRoughness,
        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
        this.clearcoatNormalMap = e.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
        this.ior = e.ior,
        this.iridescence = e.iridescence,
        this.iridescenceMap = e.iridescenceMap,
        this.iridescenceIOR = e.iridescenceIOR,
        this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
        this.iridescenceThicknessMap = e.iridescenceThicknessMap,
        this.sheen = e.sheen,
        this.sheenColor.copy(e.sheenColor),
        this.sheenColorMap = e.sheenColorMap,
        this.sheenRoughness = e.sheenRoughness,
        this.sheenRoughnessMap = e.sheenRoughnessMap,
        this.transmission = e.transmission,
        this.transmissionMap = e.transmissionMap,
        this.thickness = e.thickness,
        this.thicknessMap = e.thicknessMap,
        this.attenuationDistance = e.attenuationDistance,
        this.attenuationColor.copy(e.attenuationColor),
        this.specularIntensity = e.specularIntensity,
        this.specularIntensityMap = e.specularIntensityMap,
        this.specularColor.copy(e.specularColor),
        this.specularColorMap = e.specularColorMap,
        this
    }
}
class GB extends Sn {
    constructor(e) {
        super(),
        this.isMeshPhongMaterial = !0,
        this.type = "MeshPhongMaterial",
        this.color = new Le(16777215),
        this.specular = new Le(1118481),
        this.shininess = 30,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Le(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Qs,
        this.normalScale = new pe(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = Cd,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.specular.copy(e.specular),
        this.shininess = e.shininess,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class HB extends Sn {
    constructor(e) {
        super(),
        this.isMeshToonMaterial = !0,
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.color = new Le(16777215),
        this.map = null,
        this.gradientMap = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Le(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Qs,
        this.normalScale = new pe(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.gradientMap = e.gradientMap,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
class VB extends Sn {
    constructor(e) {
        super(),
        this.isMeshNormalMaterial = !0,
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Qs,
        this.normalScale = new pe(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.flatShading = !1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.flatShading = e.flatShading,
        this
    }
}
class WB extends Sn {
    constructor(e) {
        super(),
        this.isMeshLambertMaterial = !0,
        this.type = "MeshLambertMaterial",
        this.color = new Le(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Le(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Qs,
        this.normalScale = new pe(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = Cd,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class jB extends Sn {
    constructor(e) {
        super(),
        this.isMeshMatcapMaterial = !0,
        this.defines = {
            MATCAP: ""
        },
        this.type = "MeshMatcapMaterial",
        this.color = new Le(16777215),
        this.matcap = null,
        this.map = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Qs,
        this.normalScale = new pe(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            MATCAP: ""
        },
        this.color.copy(e.color),
        this.matcap = e.matcap,
        this.map = e.map,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class JB extends ri {
    constructor(e) {
        super(),
        this.isLineDashedMaterial = !0,
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.scale = e.scale,
        this.dashSize = e.dashSize,
        this.gapSize = e.gapSize,
        this
    }
}
function cr(n, e, t) {
    return GA(n) ? new n.constructor(n.subarray(e, t !== void 0 ? t : n.length)) : n.slice(e, t)
}
function Va(n, e, t) {
    return !n || !t && n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n)
}
function GA(n) {
    return ArrayBuffer.isView(n) && !(n instanceof DataView)
}
function XB(n) {
    function e(r, s) {
        return n[r] - n[s]
    }
    const t = n.length
      , i = new Array(t);
    for (let r = 0; r !== t; ++r)
        i[r] = r;
    return i.sort(e),
    i
}
function N1(n, e, t) {
    const i = n.length
      , r = new n.constructor(i);
    for (let s = 0, o = 0; o !== i; ++s) {
        const a = t[s] * e;
        for (let l = 0; l !== e; ++l)
            r[o++] = n[a + l]
    }
    return r
}
function HA(n, e, t, i) {
    let r = 1
      , s = n[0];
    for (; s !== void 0 && s[i] === void 0; )
        s = n[r++];
    if (s === void 0)
        return;
    let o = s[i];
    if (o !== void 0)
        if (Array.isArray(o))
            do
                o = s[i],
                o !== void 0 && (e.push(s.time),
                t.push.apply(t, o)),
                s = n[r++];
            while (s !== void 0);
        else if (o.toArray !== void 0)
            do
                o = s[i],
                o !== void 0 && (e.push(s.time),
                o.toArray(t, t.length)),
                s = n[r++];
            while (s !== void 0);
        else
            do
                o = s[i],
                o !== void 0 && (e.push(s.time),
                t.push(o)),
                s = n[r++];
            while (s !== void 0)
}
function s9(n, e, t, i, r=30) {
    const s = n.clone();
    s.name = e;
    const o = [];
    for (let l = 0; l < s.tracks.length; ++l) {
        const c = s.tracks[l]
          , d = c.getValueSize()
          , h = []
          , p = [];
        for (let m = 0; m < c.times.length; ++m) {
            const y = c.times[m] * r;
            if (!(y < t || y >= i)) {
                h.push(c.times[m]);
                for (let v = 0; v < d; ++v)
                    p.push(c.values[m * d + v])
            }
        }
        h.length !== 0 && (c.times = Va(h, c.times.constructor),
        c.values = Va(p, c.values.constructor),
        o.push(c))
    }
    s.tracks = o;
    let a = 1 / 0;
    for (let l = 0; l < s.tracks.length; ++l)
        a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
    for (let l = 0; l < s.tracks.length; ++l)
        s.tracks[l].shift(-1 * a);
    return s.resetDuration(),
    s
}
function o9(n, e=0, t=n, i=30) {
    i <= 0 && (i = 30);
    const r = t.tracks.length
      , s = e / i;
    for (let o = 0; o < r; ++o) {
        const a = t.tracks[o]
          , l = a.ValueTypeName;
        if (l === "bool" || l === "string")
            continue;
        const c = n.tracks.find(function(x) {
            return x.name === a.name && x.ValueTypeName === l
        });
        if (c === void 0)
            continue;
        let d = 0;
        const h = a.getValueSize();
        a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = h / 3);
        let p = 0;
        const m = c.getValueSize();
        c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (p = m / 3);
        const y = a.times.length - 1;
        let v;
        if (s <= a.times[0]) {
            const x = d
              , A = h - d;
            v = cr(a.values, x, A)
        } else if (s >= a.times[y]) {
            const x = y * h + d
              , A = x + h - d;
            v = cr(a.values, x, A)
        } else {
            const x = a.createInterpolant()
              , A = d
              , M = h - d;
            x.evaluate(s),
            v = cr(x.resultBuffer, A, M)
        }
        l === "quaternion" && new jn().fromArray(v).normalize().conjugate().toArray(v);
        const _ = c.times.length;
        for (let x = 0; x < _; ++x) {
            const A = x * m + p;
            if (l === "quaternion")
                jn.multiplyQuaternionsFlat(c.values, A, v, 0, c.values, A);
            else {
                const M = m - p * 2;
                for (let S = 0; S < M; ++S)
                    c.values[A + S] -= v[S]
            }
        }
    }
    return n.blendMode = gA,
    n
}
var a9 = Object.freeze({
    __proto__: null,
    arraySlice: cr,
    convertArray: Va,
    flattenJSON: HA,
    getKeyframeOrder: XB,
    isTypedArray: GA,
    makeClipAdditive: o9,
    sortedArray: N1,
    subclip: s9
});
class sc {
    constructor(e, t, i, r) {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = r !== void 0 ? r : new t.constructor(i),
        this.sampleValues = t,
        this.valueSize = i,
        this.settings = null,
        this.DefaultSettings_ = {}
    }
    evaluate(e) {
        const t = this.parameterPositions;
        let i = this._cachedIndex
          , r = t[i]
          , s = t[i - 1];
        e: {
            t: {
                let o;
                n: {
                    i: if (!(e < r)) {
                        for (let a = i + 2; ; ) {
                            if (r === void 0) {
                                if (e < s)
                                    break i;
                                return i = t.length,
                                this._cachedIndex = i,
                                this.copySampleValue_(i - 1)
                            }
                            if (i === a)
                                break;
                            if (s = r,
                            r = t[++i],
                            e < r)
                                break t
                        }
                        o = t.length;
                        break n
                    }
                    if (!(e >= s)) {
                        const a = t[1];
                        e < a && (i = 2,
                        s = a);
                        for (let l = i - 2; ; ) {
                            if (s === void 0)
                                return this._cachedIndex = 0,
                                this.copySampleValue_(0);
                            if (i === l)
                                break;
                            if (r = s,
                            s = t[--i - 1],
                            e >= s)
                                break t
                        }
                        o = i,
                        i = 0;
                        break n
                    }
                    break e
                }
                for (; i < o; ) {
                    const a = i + o >>> 1;
                    e < t[a] ? o = a : i = a + 1
                }
                if (r = t[i],
                s = t[i - 1],
                s === void 0)
                    return this._cachedIndex = 0,
                    this.copySampleValue_(0);
                if (r === void 0)
                    return i = t.length,
                    this._cachedIndex = i,
                    this.copySampleValue_(i - 1)
            }
            this._cachedIndex = i,
            this.intervalChanged_(i, s, r)
        }
        return this.interpolate_(i, s, e, r)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , i = this.sampleValues
          , r = this.valueSize
          , s = e * r;
        for (let o = 0; o !== r; ++o)
            t[o] = i[s + o];
        return t
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class KB extends sc {
    constructor(e, t, i, r) {
        super(e, t, i, r),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0,
        this.DefaultSettings_ = {
            endingStart: za,
            endingEnd: za
        }
    }
    intervalChanged_(e, t, i) {
        const r = this.parameterPositions;
        let s = e - 2
          , o = e + 1
          , a = r[s]
          , l = r[o];
        if (a === void 0)
            switch (this.getSettings_().endingStart) {
            case Ga:
                s = e,
                a = 2 * t - i;
                break;
            case td:
                s = r.length - 2,
                a = t + r[s] - r[s + 1];
                break;
            default:
                s = e,
                a = i
            }
        if (l === void 0)
            switch (this.getSettings_().endingEnd) {
            case Ga:
                o = e,
                l = 2 * i - t;
                break;
            case td:
                o = 1,
                l = i + r[1] - r[0];
                break;
            default:
                o = e - 1,
                l = t
            }
        const c = (i - t) * .5
          , d = this.valueSize;
        this._weightPrev = c / (t - a),
        this._weightNext = c / (l - i),
        this._offsetPrev = s * d,
        this._offsetNext = o * d
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = e * a
          , c = l - a
          , d = this._offsetPrev
          , h = this._offsetNext
          , p = this._weightPrev
          , m = this._weightNext
          , y = (i - t) / (r - t)
          , v = y * y
          , _ = v * y
          , x = -p * _ + 2 * p * v - p * y
          , A = (1 + p) * _ + (-1.5 - 2 * p) * v + (-.5 + p) * y + 1
          , M = (-1 - m) * _ + (1.5 + m) * v + .5 * y
          , S = m * _ - m * v;
        for (let T = 0; T !== a; ++T)
            s[T] = x * o[d + T] + A * o[c + T] + M * o[l + T] + S * o[h + T];
        return s
    }
}
class VA extends sc {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = e * a
          , c = l - a
          , d = (i - t) / (r - t)
          , h = 1 - d;
        for (let p = 0; p !== a; ++p)
            s[p] = o[c + p] * h + o[l + p] * d;
        return s
    }
}
class YB extends sc {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1)
    }
}
class Vr {
    constructor(e, t, i, r) {
        if (e === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (t === void 0 || t.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e,
        this.times = Va(t, this.TimeBufferType),
        this.values = Va(i, this.ValueBufferType),
        this.setInterpolation(r || this.DefaultInterpolation)
    }
    static toJSON(e) {
        const t = e.constructor;
        let i;
        if (t.toJSON !== this.toJSON)
            i = t.toJSON(e);
        else {
            i = {
                name: e.name,
                times: Va(e.times, Array),
                values: Va(e.values, Array)
            };
            const r = e.getInterpolation();
            r !== e.DefaultInterpolation && (i.interpolation = r)
        }
        return i.type = e.ValueTypeName,
        i
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new YB(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodLinear(e) {
        return new VA(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodSmooth(e) {
        return new KB(this.times,this.values,this.getValueSize(),e)
    }
    setInterpolation(e) {
        let t;
        switch (e) {
        case Ou:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
        case al:
            t = this.InterpolantFactoryMethodLinear;
            break;
        case Tm:
            t = this.InterpolantFactoryMethodSmooth;
            break
        }
        if (t === void 0) {
            const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if (e !== this.DefaultInterpolation)
                    this.setInterpolation(this.DefaultInterpolation);
                else
                    throw new Error(i);
            return console.warn("THREE.KeyframeTrack:", i),
            this
        }
        return this.createInterpolant = t,
        this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
            return Ou;
        case this.InterpolantFactoryMethodLinear:
            return al;
        case this.InterpolantFactoryMethodSmooth:
            return Tm
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(e) {
        if (e !== 0) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i)
                t[i] += e
        }
        return this
    }
    scale(e) {
        if (e !== 1) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i)
                t[i] *= e
        }
        return this
    }
    trim(e, t) {
        const i = this.times
          , r = i.length;
        let s = 0
          , o = r - 1;
        for (; s !== r && i[s] < e; )
            ++s;
        for (; o !== -1 && i[o] > t; )
            --o;
        if (++o,
        s !== 0 || o !== r) {
            s >= o && (o = Math.max(o, 1),
            s = o - 1);
            const a = this.getValueSize();
            this.times = cr(i, s, o),
            this.values = cr(this.values, s * a, o * a)
        }
        return this
    }
    validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
        e = !1);
        const i = this.times
          , r = this.values
          , s = i.length;
        s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this),
        e = !1);
        let o = null;
        for (let a = 0; a !== s; a++) {
            const l = i[a];
            if (typeof l == "number" && isNaN(l)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l),
                e = !1;
                break
            }
            if (o !== null && o > l) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o),
                e = !1;
                break
            }
            o = l
        }
        if (r !== void 0 && GA(r))
            for (let a = 0, l = r.length; a !== l; ++a) {
                const c = r[a];
                if (isNaN(c)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c),
                    e = !1;
                    break
                }
            }
        return e
    }
    optimize() {
        const e = cr(this.times)
          , t = cr(this.values)
          , i = this.getValueSize()
          , r = this.getInterpolation() === Tm
          , s = e.length - 1;
        let o = 1;
        for (let a = 1; a < s; ++a) {
            let l = !1;
            const c = e[a]
              , d = e[a + 1];
            if (c !== d && (a !== 1 || c !== e[0]))
                if (r)
                    l = !0;
                else {
                    const h = a * i
                      , p = h - i
                      , m = h + i;
                    for (let y = 0; y !== i; ++y) {
                        const v = t[h + y];
                        if (v !== t[p + y] || v !== t[m + y]) {
                            l = !0;
                            break
                        }
                    }
                }
            if (l) {
                if (a !== o) {
                    e[o] = e[a];
                    const h = a * i
                      , p = o * i;
                    for (let m = 0; m !== i; ++m)
                        t[p + m] = t[h + m]
                }
                ++o
            }
        }
        if (s > 0) {
            e[o] = e[s];
            for (let a = s * i, l = o * i, c = 0; c !== i; ++c)
                t[l + c] = t[a + c];
            ++o
        }
        return o !== e.length ? (this.times = cr(e, 0, o),
        this.values = cr(t, 0, o * i)) : (this.times = e,
        this.values = t),
        this
    }
    clone() {
        const e = cr(this.times, 0)
          , t = cr(this.values, 0)
          , i = this.constructor
          , r = new i(this.name,e,t);
        return r.createInterpolant = this.createInterpolant,
        r
    }
}
Vr.prototype.TimeBufferType = Float32Array;
Vr.prototype.ValueBufferType = Float32Array;
Vr.prototype.DefaultInterpolation = al;
class pl extends Vr {
}
pl.prototype.ValueTypeName = "bool";
pl.prototype.ValueBufferType = Array;
pl.prototype.DefaultInterpolation = Ou;
pl.prototype.InterpolantFactoryMethodLinear = void 0;
pl.prototype.InterpolantFactoryMethodSmooth = void 0;
class WA extends Vr {
}
WA.prototype.ValueTypeName = "color";
class Hu extends Vr {
}
Hu.prototype.ValueTypeName = "number";
class QB extends sc {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = (i - t) / (r - t);
        let c = e * a;
        for (let d = c + a; c !== d; c += 4)
            jn.slerpFlat(s, 0, o, c - a, o, c, l);
        return s
    }
}
class Xo extends Vr {
    InterpolantFactoryMethodLinear(e) {
        return new QB(this.times,this.values,this.getValueSize(),e)
    }
}
Xo.prototype.ValueTypeName = "quaternion";
Xo.prototype.DefaultInterpolation = al;
Xo.prototype.InterpolantFactoryMethodSmooth = void 0;
class ml extends Vr {
}
ml.prototype.ValueTypeName = "string";
ml.prototype.ValueBufferType = Array;
ml.prototype.DefaultInterpolation = Ou;
ml.prototype.InterpolantFactoryMethodLinear = void 0;
ml.prototype.InterpolantFactoryMethodSmooth = void 0;
class Vu extends Vr {
}
Vu.prototype.ValueTypeName = "vector";
class Wu {
    constructor(e, t=-1, i, r=Yg) {
        this.name = e,
        this.tracks = i,
        this.duration = t,
        this.blendMode = r,
        this.uuid = Vi(),
        this.duration < 0 && this.resetDuration()
    }
    static parse(e) {
        const t = []
          , i = e.tracks
          , r = 1 / (e.fps || 1);
        for (let o = 0, a = i.length; o !== a; ++o)
            t.push(u9(i[o]).scale(r));
        const s = new this(e.name,e.duration,t,e.blendMode);
        return s.uuid = e.uuid,
        s
    }
    static toJSON(e) {
        const t = []
          , i = e.tracks
          , r = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode
        };
        for (let s = 0, o = i.length; s !== o; ++s)
            t.push(Vr.toJSON(i[s]));
        return r
    }
    static CreateFromMorphTargetSequence(e, t, i, r) {
        const s = t.length
          , o = [];
        for (let a = 0; a < s; a++) {
            let l = []
              , c = [];
            l.push((a + s - 1) % s, a, (a + 1) % s),
            c.push(0, 1, 0);
            const d = XB(l);
            l = N1(l, 1, d),
            c = N1(c, 1, d),
            !r && l[0] === 0 && (l.push(s),
            c.push(c[0])),
            o.push(new Hu(".morphTargetInfluences[" + t[a].name + "]",l,c).scale(1 / i))
        }
        return new this(e,-1,o)
    }
    static findByName(e, t) {
        let i = e;
        if (!Array.isArray(e)) {
            const r = e;
            i = r.geometry && r.geometry.animations || r.animations
        }
        for (let r = 0; r < i.length; r++)
            if (i[r].name === t)
                return i[r];
        return null
    }
    static CreateClipsFromMorphTargetSequences(e, t, i) {
        const r = {}
          , s = /^([\w-]*?)([\d]+)$/;
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a]
              , d = c.name.match(s);
            if (d && d.length > 1) {
                const h = d[1];
                let p = r[h];
                p || (r[h] = p = []),
                p.push(c)
            }
        }
        const o = [];
        for (const a in r)
            o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i));
        return o
    }
    static parseAnimation(e, t) {
        if (!e)
            return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
            null;
        const i = function(h, p, m, y, v) {
            if (m.length !== 0) {
                const _ = []
                  , x = [];
                HA(m, _, x, y),
                _.length !== 0 && v.push(new h(p,_,x))
            }
        }
          , r = []
          , s = e.name || "default"
          , o = e.fps || 30
          , a = e.blendMode;
        let l = e.length || -1;
        const c = e.hierarchy || [];
        for (let h = 0; h < c.length; h++) {
            const p = c[h].keys;
            if (!(!p || p.length === 0))
                if (p[0].morphTargets) {
                    const m = {};
                    let y;
                    for (y = 0; y < p.length; y++)
                        if (p[y].morphTargets)
                            for (let v = 0; v < p[y].morphTargets.length; v++)
                                m[p[y].morphTargets[v]] = -1;
                    for (const v in m) {
                        const _ = []
                          , x = [];
                        for (let A = 0; A !== p[y].morphTargets.length; ++A) {
                            const M = p[y];
                            _.push(M.time),
                            x.push(M.morphTarget === v ? 1 : 0)
                        }
                        r.push(new Hu(".morphTargetInfluence[" + v + "]",_,x))
                    }
                    l = m.length * o
                } else {
                    const m = ".bones[" + t[h].name + "]";
                    i(Vu, m + ".position", p, "pos", r),
                    i(Xo, m + ".quaternion", p, "rot", r),
                    i(Vu, m + ".scale", p, "scl", r)
                }
        }
        return r.length === 0 ? null : new this(s,l,r,a)
    }
    resetDuration() {
        const e = this.tracks;
        let t = 0;
        for (let i = 0, r = e.length; i !== r; ++i) {
            const s = this.tracks[i];
            t = Math.max(t, s.times[s.times.length - 1])
        }
        return this.duration = t,
        this
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
        return this
    }
    validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
        return e
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
        return this
    }
    clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
        return new this.constructor(this.name,this.duration,e,this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}
function l9(n) {
    switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
        return Hu;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
        return Vu;
    case "color":
        return WA;
    case "quaternion":
        return Xo;
    case "bool":
    case "boolean":
        return pl;
    case "string":
        return ml
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n)
}
function u9(n) {
    if (n.type === void 0)
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = l9(n.type);
    if (n.times === void 0) {
        const t = []
          , i = [];
        HA(n.keys, t, i, "value"),
        n.times = t,
        n.values = i
    }
    return e.parse !== void 0 ? e.parse(n) : new e(n.name,n.times,n.values,n.interpolation)
}
const ul = {
    enabled: !1,
    files: {},
    add: function(n, e) {
        this.enabled !== !1 && (this.files[n] = e)
    },
    get: function(n) {
        if (this.enabled !== !1)
            return this.files[n]
    },
    remove: function(n) {
        delete this.files[n]
    },
    clear: function() {
        this.files = {}
    }
};
class jA {
    constructor(e, t, i) {
        const r = this;
        let s = !1, o = 0, a = 0, l;
        const c = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = i,
        this.itemStart = function(d) {
            a++,
            s === !1 && r.onStart !== void 0 && r.onStart(d, o, a),
            s = !0
        }
        ,
        this.itemEnd = function(d) {
            o++,
            r.onProgress !== void 0 && r.onProgress(d, o, a),
            o === a && (s = !1,
            r.onLoad !== void 0 && r.onLoad())
        }
        ,
        this.itemError = function(d) {
            r.onError !== void 0 && r.onError(d)
        }
        ,
        this.resolveURL = function(d) {
            return l ? l(d) : d
        }
        ,
        this.setURLModifier = function(d) {
            return l = d,
            this
        }
        ,
        this.addHandler = function(d, h) {
            return c.push(d, h),
            this
        }
        ,
        this.removeHandler = function(d) {
            const h = c.indexOf(d);
            return h !== -1 && c.splice(h, 2),
            this
        }
        ,
        this.getHandler = function(d) {
            for (let h = 0, p = c.length; h < p; h += 2) {
                const m = c[h]
                  , y = c[h + 1];
                if (m.global && (m.lastIndex = 0),
                m.test(d))
                    return y
            }
            return null
        }
    }
}
const gu = new jA;
class vi {
    constructor(e) {
        this.manager = e !== void 0 ? e : gu,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const i = this;
        return new Promise(function(r, s) {
            i.load(e, r, t, s)
        }
        )
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e,
        this
    }
    setWithCredentials(e) {
        return this.withCredentials = e,
        this
    }
    setPath(e) {
        return this.path = e,
        this
    }
    setResourcePath(e) {
        return this.resourcePath = e,
        this
    }
    setRequestHeader(e) {
        return this.requestHeader = e,
        this
    }
}
const Es = {};
class c9 extends Error {
    constructor(e, t) {
        super(e),
        this.response = t
    }
}
class ji extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = ul.get(e);
        if (s !== void 0)
            return this.manager.itemStart(e),
            setTimeout(()=>{
                t && t(s),
                this.manager.itemEnd(e)
            }
            , 0),
            s;
        if (Es[e] !== void 0) {
            Es[e].push({
                onLoad: t,
                onProgress: i,
                onError: r
            });
            return
        }
        Es[e] = [],
        Es[e].push({
            onLoad: t,
            onProgress: i,
            onError: r
        });
        const o = new Request(e,{
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        })
          , a = this.mimeType
          , l = this.responseType;
        fetch(o).then(c=>{
            if (c.status === 200 || c.status === 0) {
                if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0)
                    return c;
                const d = Es[e]
                  , h = c.body.getReader()
                  , p = c.headers.get("Content-Length") || c.headers.get("X-File-Size")
                  , m = p ? parseInt(p) : 0
                  , y = m !== 0;
                let v = 0;
                const _ = new ReadableStream({
                    start(x) {
                        A();
                        function A() {
                            h.read().then(({done: M, value: S})=>{
                                if (M)
                                    x.close();
                                else {
                                    v += S.byteLength;
                                    const T = new ProgressEvent("progress",{
                                        lengthComputable: y,
                                        loaded: v,
                                        total: m
                                    });
                                    for (let P = 0, R = d.length; P < R; P++) {
                                        const E = d[P];
                                        E.onProgress && E.onProgress(T)
                                    }
                                    x.enqueue(S),
                                    A()
                                }
                            }
                            )
                        }
                    }
                });
                return new Response(_)
            } else
                throw new c9(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,c)
        }
        ).then(c=>{
            switch (l) {
            case "arraybuffer":
                return c.arrayBuffer();
            case "blob":
                return c.blob();
            case "document":
                return c.text().then(d=>new DOMParser().parseFromString(d, a));
            case "json":
                return c.json();
            default:
                if (a === void 0)
                    return c.text();
                {
                    const h = /charset="?([^;"\s]*)"?/i.exec(a)
                      , p = h && h[1] ? h[1].toLowerCase() : void 0
                      , m = new TextDecoder(p);
                    return c.arrayBuffer().then(y=>m.decode(y))
                }
            }
        }
        ).then(c=>{
            ul.add(e, c);
            const d = Es[e];
            delete Es[e];
            for (let h = 0, p = d.length; h < p; h++) {
                const m = d[h];
                m.onLoad && m.onLoad(c)
            }
        }
        ).catch(c=>{
            const d = Es[e];
            if (d === void 0)
                throw this.manager.itemError(e),
                c;
            delete Es[e];
            for (let h = 0, p = d.length; h < p; h++) {
                const m = d[h];
                m.onError && m.onError(c)
            }
            this.manager.itemError(e)
        }
        ).finally(()=>{
            this.manager.itemEnd(e)
        }
        ),
        this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e,
        this
    }
    setMimeType(e) {
        return this.mimeType = e,
        this
    }
}
class f9 extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new ji(this.manager);
        o.setPath(this.path),
        o.setRequestHeader(this.requestHeader),
        o.setWithCredentials(this.withCredentials),
        o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (l) {
                r ? r(l) : console.error(l),
                s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e) {
        const t = [];
        for (let i = 0; i < e.length; i++) {
            const r = Wu.parse(e[i]);
            t.push(r)
        }
        return t
    }
}
class d9 extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = []
          , a = new DA
          , l = new ji(this.manager);
        l.setPath(this.path),
        l.setResponseType("arraybuffer"),
        l.setRequestHeader(this.requestHeader),
        l.setWithCredentials(s.withCredentials);
        let c = 0;
        function d(h) {
            l.load(e[h], function(p) {
                const m = s.parse(p, !0);
                o[h] = {
                    width: m.width,
                    height: m.height,
                    format: m.format,
                    mipmaps: m.mipmaps
                },
                c += 1,
                c === 6 && (m.mipmapCount === 1 && (a.minFilter = nn),
                a.image = o,
                a.format = m.format,
                a.needsUpdate = !0,
                t && t(a))
            }, i, r)
        }
        if (Array.isArray(e))
            for (let h = 0, p = e.length; h < p; ++h)
                d(h);
        else
            l.load(e, function(h) {
                const p = s.parse(h, !0);
                if (p.isCubemap) {
                    const m = p.mipmaps.length / p.mipmapCount;
                    for (let y = 0; y < m; y++) {
                        o[y] = {
                            mipmaps: []
                        };
                        for (let v = 0; v < p.mipmapCount; v++)
                            o[y].mipmaps.push(p.mipmaps[y * p.mipmapCount + v]),
                            o[y].format = p.format,
                            o[y].width = p.width,
                            o[y].height = p.height
                    }
                    a.image = o
                } else
                    a.image.width = p.width,
                    a.image.height = p.height,
                    a.mipmaps = p.mipmaps;
                p.mipmapCount === 1 && (a.minFilter = nn),
                a.format = p.format,
                a.needsUpdate = !0,
                t && t(a)
            }, i, r);
        return a
    }
}
class ud extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = this
          , o = ul.get(e);
        if (o !== void 0)
            return s.manager.itemStart(e),
            setTimeout(function() {
                t && t(o),
                s.manager.itemEnd(e)
            }, 0),
            o;
        const a = rd("img");
        function l() {
            d(),
            ul.add(e, this),
            t && t(this),
            s.manager.itemEnd(e)
        }
        function c(h) {
            d(),
            r && r(h),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }
        function d() {
            a.removeEventListener("load", l, !1),
            a.removeEventListener("error", c, !1)
        }
        return a.addEventListener("load", l, !1),
        a.addEventListener("error", c, !1),
        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin),
        s.manager.itemStart(e),
        a.src = e,
        a
    }
}
class h9 extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = new Pd
          , o = new ud(this.manager);
        o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path);
        let a = 0;
        function l(c) {
            o.load(e[c], function(d) {
                s.images[c] = d,
                a++,
                a === 6 && (s.needsUpdate = !0,
                t && t(s))
            }, void 0, r)
        }
        for (let c = 0; c < e.length; ++c)
            l(c);
        return s
    }
}
class p9 extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new Tu
          , a = new ji(this.manager);
        return a.setResponseType("arraybuffer"),
        a.setRequestHeader(this.requestHeader),
        a.setPath(this.path),
        a.setWithCredentials(s.withCredentials),
        a.load(e, function(l) {
            const c = s.parse(l);
            c && (c.image !== void 0 ? o.image = c.image : c.data !== void 0 && (o.image.width = c.width,
            o.image.height = c.height,
            o.image.data = c.data),
            o.wrapS = c.wrapS !== void 0 ? c.wrapS : Vn,
            o.wrapT = c.wrapT !== void 0 ? c.wrapT : Vn,
            o.magFilter = c.magFilter !== void 0 ? c.magFilter : nn,
            o.minFilter = c.minFilter !== void 0 ? c.minFilter : nn,
            o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1,
            c.encoding !== void 0 && (o.encoding = c.encoding),
            c.flipY !== void 0 && (o.flipY = c.flipY),
            c.format !== void 0 && (o.format = c.format),
            c.type !== void 0 && (o.type = c.type),
            c.mipmaps !== void 0 && (o.mipmaps = c.mipmaps,
            o.minFilter = ls),
            c.mipmapCount === 1 && (o.minFilter = nn),
            c.generateMipmaps !== void 0 && (o.generateMipmaps = c.generateMipmaps),
            o.needsUpdate = !0,
            t && t(o, c))
        }, i, r),
        o
    }
}
class ZB extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = new qt
          , o = new ud(this.manager);
        return o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path),
        o.load(e, function(a) {
            s.image = a,
            s.needsUpdate = !0,
            t !== void 0 && t(s)
        }, i, r),
        s
    }
}
class ra extends Rt {
    constructor(e, t=1) {
        super(),
        this.isLight = !0,
        this.type = "Light",
        this.color = new Le(e),
        this.intensity = t
    }
    dispose() {}
    copy(e, t) {
        return super.copy(e, t),
        this.color.copy(e.color),
        this.intensity = e.intensity,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(),
        t.object.intensity = this.intensity,
        this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (t.object.distance = this.distance),
        this.angle !== void 0 && (t.object.angle = this.angle),
        this.decay !== void 0 && (t.object.decay = this.decay),
        this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
        t
    }
}
class qB extends ra {
    constructor(e, t, i) {
        super(e, i),
        this.isHemisphereLight = !0,
        this.type = "HemisphereLight",
        this.position.copy(Rt.DEFAULT_UP),
        this.updateMatrix(),
        this.groundColor = new Le(t)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.groundColor.copy(e.groundColor),
        this
    }
}
const Tv = new rt
  , zE = new D
  , GE = new D;
class JA {
    constructor(e) {
        this.camera = e,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new pe(512,512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new rt,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new Zg,
        this._frameExtents = new pe(1,1),
        this._viewportCount = 1,
        this._viewports = [new Nt(0,0,1,1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const t = this.camera
          , i = this.matrix;
        zE.setFromMatrixPosition(e.matrixWorld),
        t.position.copy(zE),
        GE.setFromMatrixPosition(e.target.matrixWorld),
        t.lookAt(GE),
        t.updateMatrixWorld(),
        Tv.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(Tv),
        i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        i.multiply(Tv)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(),
        this.bias = e.bias,
        this.radius = e.radius,
        this.mapSize.copy(e.mapSize),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.bias !== 0 && (e.bias = this.bias),
        this.normalBias !== 0 && (e.normalBias = this.normalBias),
        this.radius !== 1 && (e.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
        e.camera = this.camera.toJSON(!1).object,
        delete e.camera.matrix,
        e
    }
}
class m9 extends JA {
    constructor() {
        super(new Ht(50,1,.5,500)),
        this.isSpotLightShadow = !0,
        this.focus = 1
    }
    updateMatrices(e) {
        const t = this.camera
          , i = id * 2 * e.angle * this.focus
          , r = this.mapSize.width / this.mapSize.height
          , s = e.distance || t.far;
        (i !== t.fov || r !== t.aspect || s !== t.far) && (t.fov = i,
        t.aspect = r,
        t.far = s,
        t.updateProjectionMatrix()),
        super.updateMatrices(e)
    }
    copy(e) {
        return super.copy(e),
        this.focus = e.focus,
        this
    }
}
class XA extends ra {
    constructor(e, t, i=0, r=Math.PI / 3, s=0, o=2) {
        super(e, t),
        this.isSpotLight = !0,
        this.type = "SpotLight",
        this.position.copy(Rt.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new Rt,
        this.distance = i,
        this.angle = r,
        this.penumbra = s,
        this.decay = o,
        this.map = null,
        this.shadow = new m9
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(e) {
        this.intensity = e / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.angle = e.angle,
        this.penumbra = e.penumbra,
        this.decay = e.decay,
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
const HE = new rt
  , jc = new D
  , bv = new D;
class g9 extends JA {
    constructor() {
        super(new Ht(90,1,.5,500)),
        this.isPointLightShadow = !0,
        this._frameExtents = new pe(4,2),
        this._viewportCount = 6,
        this._viewports = [new Nt(2,1,1,1), new Nt(0,1,1,1), new Nt(3,1,1,1), new Nt(1,1,1,1), new Nt(3,0,1,1), new Nt(1,0,1,1)],
        this._cubeDirections = [new D(1,0,0), new D(-1,0,0), new D(0,0,1), new D(0,0,-1), new D(0,1,0), new D(0,-1,0)],
        this._cubeUps = [new D(0,1,0), new D(0,1,0), new D(0,1,0), new D(0,1,0), new D(0,0,1), new D(0,0,-1)]
    }
    updateMatrices(e, t=0) {
        const i = this.camera
          , r = this.matrix
          , s = e.distance || i.far;
        s !== i.far && (i.far = s,
        i.updateProjectionMatrix()),
        jc.setFromMatrixPosition(e.matrixWorld),
        i.position.copy(jc),
        bv.copy(i.position),
        bv.add(this._cubeDirections[t]),
        i.up.copy(this._cubeUps[t]),
        i.lookAt(bv),
        i.updateMatrixWorld(),
        r.makeTranslation(-jc.x, -jc.y, -jc.z),
        HE.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(HE)
    }
}
class KA extends ra {
    constructor(e, t, i=0, r=2) {
        super(e, t),
        this.isPointLight = !0,
        this.type = "PointLight",
        this.distance = i,
        this.decay = r,
        this.shadow = new g9
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.decay = e.decay,
        this.shadow = e.shadow.clone(),
        this
    }
}
class y9 extends JA {
    constructor() {
        super(new Nr(-5,5,5,-5,.5,500)),
        this.isDirectionalLightShadow = !0
    }
}
class YA extends ra {
    constructor(e, t) {
        super(e, t),
        this.isDirectionalLight = !0,
        this.type = "DirectionalLight",
        this.position.copy(Rt.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new Rt,
        this.shadow = new y9
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e),
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
class $B extends ra {
    constructor(e, t) {
        super(e, t),
        this.isAmbientLight = !0,
        this.type = "AmbientLight"
    }
}
class eR extends ra {
    constructor(e, t, i=10, r=10) {
        super(e, t),
        this.isRectAreaLight = !0,
        this.type = "RectAreaLight",
        this.width = i,
        this.height = r
    }
    get power() {
        return this.intensity * this.width * this.height * Math.PI
    }
    set power(e) {
        this.intensity = e / (this.width * this.height * Math.PI)
    }
    copy(e) {
        return super.copy(e),
        this.width = e.width,
        this.height = e.height,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.width = this.width,
        t.object.height = this.height,
        t
    }
}
class tR {
    constructor() {
        this.isSphericalHarmonics3 = !0,
        this.coefficients = [];
        for (let e = 0; e < 9; e++)
            this.coefficients.push(new D)
    }
    set(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].copy(e[t]);
        return this
    }
    zero() {
        for (let e = 0; e < 9; e++)
            this.coefficients[e].set(0, 0, 0);
        return this
    }
    getAt(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z
          , o = this.coefficients;
        return t.copy(o[0]).multiplyScalar(.282095),
        t.addScaledVector(o[1], .488603 * r),
        t.addScaledVector(o[2], .488603 * s),
        t.addScaledVector(o[3], .488603 * i),
        t.addScaledVector(o[4], 1.092548 * (i * r)),
        t.addScaledVector(o[5], 1.092548 * (r * s)),
        t.addScaledVector(o[6], .315392 * (3 * s * s - 1)),
        t.addScaledVector(o[7], 1.092548 * (i * s)),
        t.addScaledVector(o[8], .546274 * (i * i - r * r)),
        t
    }
    getIrradianceAt(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z
          , o = this.coefficients;
        return t.copy(o[0]).multiplyScalar(.886227),
        t.addScaledVector(o[1], 2 * .511664 * r),
        t.addScaledVector(o[2], 2 * .511664 * s),
        t.addScaledVector(o[3], 2 * .511664 * i),
        t.addScaledVector(o[4], 2 * .429043 * i * r),
        t.addScaledVector(o[5], 2 * .429043 * r * s),
        t.addScaledVector(o[6], .743125 * s * s - .247708),
        t.addScaledVector(o[7], 2 * .429043 * i * s),
        t.addScaledVector(o[8], .429043 * (i * i - r * r)),
        t
    }
    add(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].add(e.coefficients[t]);
        return this
    }
    addScaledSH(e, t) {
        for (let i = 0; i < 9; i++)
            this.coefficients[i].addScaledVector(e.coefficients[i], t);
        return this
    }
    scale(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].multiplyScalar(e);
        return this
    }
    lerp(e, t) {
        for (let i = 0; i < 9; i++)
            this.coefficients[i].lerp(e.coefficients[i], t);
        return this
    }
    equals(e) {
        for (let t = 0; t < 9; t++)
            if (!this.coefficients[t].equals(e.coefficients[t]))
                return !1;
        return !0
    }
    copy(e) {
        return this.set(e.coefficients)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    fromArray(e, t=0) {
        const i = this.coefficients;
        for (let r = 0; r < 9; r++)
            i[r].fromArray(e, t + r * 3);
        return this
    }
    toArray(e=[], t=0) {
        const i = this.coefficients;
        for (let r = 0; r < 9; r++)
            i[r].toArray(e, t + r * 3);
        return e
    }
    static getBasisAt(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z;
        t[0] = .282095,
        t[1] = .488603 * r,
        t[2] = .488603 * s,
        t[3] = .488603 * i,
        t[4] = 1.092548 * i * r,
        t[5] = 1.092548 * r * s,
        t[6] = .315392 * (3 * s * s - 1),
        t[7] = 1.092548 * i * s,
        t[8] = .546274 * (i * i - r * r)
    }
}
class s0 extends ra {
    constructor(e=new tR, t=1) {
        super(void 0, t),
        this.isLightProbe = !0,
        this.sh = e
    }
    copy(e) {
        return super.copy(e),
        this.sh.copy(e.sh),
        this
    }
    fromJSON(e) {
        return this.intensity = e.intensity,
        this.sh.fromArray(e.sh),
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.sh = this.sh.toArray(),
        t
    }
}
class o0 extends vi {
    constructor(e) {
        super(e),
        this.textures = {}
    }
    load(e, t, i, r) {
        const s = this
          , o = new ji(s.manager);
        o.setPath(s.path),
        o.setRequestHeader(s.requestHeader),
        o.setWithCredentials(s.withCredentials),
        o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (l) {
                r ? r(l) : console.error(l),
                s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e) {
        const t = this.textures;
        function i(s) {
            return t[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s),
            t[s]
        }
        const r = o0.createMaterialFromType(e.type);
        if (e.uuid !== void 0 && (r.uuid = e.uuid),
        e.name !== void 0 && (r.name = e.name),
        e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color),
        e.roughness !== void 0 && (r.roughness = e.roughness),
        e.metalness !== void 0 && (r.metalness = e.metalness),
        e.sheen !== void 0 && (r.sheen = e.sheen),
        e.sheenColor !== void 0 && (r.sheenColor = new Le().setHex(e.sheenColor)),
        e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness),
        e.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(e.emissive),
        e.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(e.specular),
        e.specularIntensity !== void 0 && (r.specularIntensity = e.specularIntensity),
        e.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(e.specularColor),
        e.shininess !== void 0 && (r.shininess = e.shininess),
        e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat),
        e.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = e.clearcoatRoughness),
        e.iridescence !== void 0 && (r.iridescence = e.iridescence),
        e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR),
        e.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = e.iridescenceThicknessRange),
        e.transmission !== void 0 && (r.transmission = e.transmission),
        e.thickness !== void 0 && (r.thickness = e.thickness),
        e.attenuationDistance !== void 0 && (r.attenuationDistance = e.attenuationDistance),
        e.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(e.attenuationColor),
        e.fog !== void 0 && (r.fog = e.fog),
        e.flatShading !== void 0 && (r.flatShading = e.flatShading),
        e.blending !== void 0 && (r.blending = e.blending),
        e.combine !== void 0 && (r.combine = e.combine),
        e.side !== void 0 && (r.side = e.side),
        e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide),
        e.opacity !== void 0 && (r.opacity = e.opacity),
        e.transparent !== void 0 && (r.transparent = e.transparent),
        e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest),
        e.depthTest !== void 0 && (r.depthTest = e.depthTest),
        e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite),
        e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite),
        e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite),
        e.stencilWriteMask !== void 0 && (r.stencilWriteMask = e.stencilWriteMask),
        e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc),
        e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef),
        e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask),
        e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail),
        e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail),
        e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass),
        e.wireframe !== void 0 && (r.wireframe = e.wireframe),
        e.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = e.wireframeLinewidth),
        e.wireframeLinecap !== void 0 && (r.wireframeLinecap = e.wireframeLinecap),
        e.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = e.wireframeLinejoin),
        e.rotation !== void 0 && (r.rotation = e.rotation),
        e.linewidth !== 1 && (r.linewidth = e.linewidth),
        e.dashSize !== void 0 && (r.dashSize = e.dashSize),
        e.gapSize !== void 0 && (r.gapSize = e.gapSize),
        e.scale !== void 0 && (r.scale = e.scale),
        e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset),
        e.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = e.polygonOffsetFactor),
        e.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = e.polygonOffsetUnits),
        e.dithering !== void 0 && (r.dithering = e.dithering),
        e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage),
        e.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = e.premultipliedAlpha),
        e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass),
        e.visible !== void 0 && (r.visible = e.visible),
        e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped),
        e.userData !== void 0 && (r.userData = e.userData),
        e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors),
        e.uniforms !== void 0)
            for (const s in e.uniforms) {
                const o = e.uniforms[s];
                switch (r.uniforms[s] = {},
                o.type) {
                case "t":
                    r.uniforms[s].value = i(o.value);
                    break;
                case "c":
                    r.uniforms[s].value = new Le().setHex(o.value);
                    break;
                case "v2":
                    r.uniforms[s].value = new pe().fromArray(o.value);
                    break;
                case "v3":
                    r.uniforms[s].value = new D().fromArray(o.value);
                    break;
                case "v4":
                    r.uniforms[s].value = new Nt().fromArray(o.value);
                    break;
                case "m3":
                    r.uniforms[s].value = new hi().fromArray(o.value);
                    break;
                case "m4":
                    r.uniforms[s].value = new rt().fromArray(o.value);
                    break;
                default:
                    r.uniforms[s].value = o.value
                }
            }
        if (e.defines !== void 0 && (r.defines = e.defines),
        e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader),
        e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader),
        e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion),
        e.extensions !== void 0)
            for (const s in e.extensions)
                r.extensions[s] = e.extensions[s];
        if (e.size !== void 0 && (r.size = e.size),
        e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation),
        e.map !== void 0 && (r.map = i(e.map)),
        e.matcap !== void 0 && (r.matcap = i(e.matcap)),
        e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)),
        e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)),
        e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale),
        e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)),
        e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType),
        e.normalScale !== void 0) {
            let s = e.normalScale;
            Array.isArray(s) === !1 && (s = [s, s]),
            r.normalScale = new pe().fromArray(s)
        }
        return e.displacementMap !== void 0 && (r.displacementMap = i(e.displacementMap)),
        e.displacementScale !== void 0 && (r.displacementScale = e.displacementScale),
        e.displacementBias !== void 0 && (r.displacementBias = e.displacementBias),
        e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)),
        e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)),
        e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)),
        e.emissiveIntensity !== void 0 && (r.emissiveIntensity = e.emissiveIntensity),
        e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)),
        e.specularIntensityMap !== void 0 && (r.specularIntensityMap = i(e.specularIntensityMap)),
        e.specularColorMap !== void 0 && (r.specularColorMap = i(e.specularColorMap)),
        e.envMap !== void 0 && (r.envMap = i(e.envMap)),
        e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity),
        e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity),
        e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio),
        e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)),
        e.lightMapIntensity !== void 0 && (r.lightMapIntensity = e.lightMapIntensity),
        e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)),
        e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity),
        e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)),
        e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)),
        e.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)),
        e.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = i(e.clearcoatNormalMap)),
        e.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new pe().fromArray(e.clearcoatNormalScale)),
        e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)),
        e.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)),
        e.transmissionMap !== void 0 && (r.transmissionMap = i(e.transmissionMap)),
        e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)),
        e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)),
        e.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = i(e.sheenRoughnessMap)),
        r
    }
    setTextures(e) {
        return this.textures = e,
        this
    }
    static createMaterialFromType(e) {
        const t = {
            ShadowMaterial: UB,
            SpriteMaterial: BA,
            RawShaderMaterial: zB,
            ShaderMaterial: us,
            PointsMaterial: Ld,
            MeshPhysicalMaterial: qs,
            MeshStandardMaterial: rc,
            MeshPhongMaterial: GB,
            MeshToonMaterial: HB,
            MeshNormalMaterial: VB,
            MeshLambertMaterial: WB,
            MeshDepthMaterial: EA,
            MeshDistanceMaterial: TA,
            MeshBasicMaterial: Gi,
            MeshMatcapMaterial: jB,
            LineDashedMaterial: JB,
            LineBasicMaterial: ri,
            Material: Sn
        };
        return new t[e]
    }
}
class ss {
    static decodeText(e) {
        if (typeof TextDecoder < "u")
            return new TextDecoder().decode(e);
        let t = "";
        for (let i = 0, r = e.length; i < r; i++)
            t += String.fromCharCode(e[i]);
        try {
            return decodeURIComponent(escape(t))
        } catch {
            return t
        }
    }
    static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return t === -1 ? "./" : e.slice(0, t + 1)
    }
    static resolveURL(e, t) {
        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
    }
}
class nR extends ct {
    constructor() {
        super(),
        this.isInstancedBufferGeometry = !0,
        this.type = "InstancedBufferGeometry",
        this.instanceCount = 1 / 0
    }
    copy(e) {
        return super.copy(e),
        this.instanceCount = e.instanceCount,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.instanceCount = this.instanceCount,
        e.isInstancedBufferGeometry = !0,
        e
    }
}
class iR extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new ji(s.manager);
        o.setPath(s.path),
        o.setRequestHeader(s.requestHeader),
        o.setWithCredentials(s.withCredentials),
        o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (l) {
                r ? r(l) : console.error(l),
                s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e) {
        const t = {}
          , i = {};
        function r(m, y) {
            if (t[y] !== void 0)
                return t[y];
            const _ = m.interleavedBuffers[y]
              , x = s(m, _.buffer)
              , A = hu(_.type, x)
              , M = new Bd(A,_.stride);
            return M.uuid = _.uuid,
            t[y] = M,
            M
        }
        function s(m, y) {
            if (i[y] !== void 0)
                return i[y];
            const _ = m.arrayBuffers[y]
              , x = new Uint32Array(_).buffer;
            return i[y] = x,
            x
        }
        const o = e.isInstancedBufferGeometry ? new nR : new ct
          , a = e.data.index;
        if (a !== void 0) {
            const m = hu(a.type, a.array);
            o.setIndex(new Ft(m,1))
        }
        const l = e.data.attributes;
        for (const m in l) {
            const y = l[m];
            let v;
            if (y.isInterleavedBufferAttribute) {
                const _ = r(e.data, y.data);
                v = new Jo(_,y.itemSize,y.offset,y.normalized)
            } else {
                const _ = hu(y.type, y.array)
                  , x = y.isInstancedBufferAttribute ? Gu : Ft;
                v = new x(_,y.itemSize,y.normalized)
            }
            y.name !== void 0 && (v.name = y.name),
            y.usage !== void 0 && v.setUsage(y.usage),
            y.updateRange !== void 0 && (v.updateRange.offset = y.updateRange.offset,
            v.updateRange.count = y.updateRange.count),
            o.setAttribute(m, v)
        }
        const c = e.data.morphAttributes;
        if (c)
            for (const m in c) {
                const y = c[m]
                  , v = [];
                for (let _ = 0, x = y.length; _ < x; _++) {
                    const A = y[_];
                    let M;
                    if (A.isInterleavedBufferAttribute) {
                        const S = r(e.data, A.data);
                        M = new Jo(S,A.itemSize,A.offset,A.normalized)
                    } else {
                        const S = hu(A.type, A.array);
                        M = new Ft(S,A.itemSize,A.normalized)
                    }
                    A.name !== void 0 && (M.name = A.name),
                    v.push(M)
                }
                o.morphAttributes[m] = v
            }
        e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
        const h = e.data.groups || e.data.drawcalls || e.data.offsets;
        if (h !== void 0)
            for (let m = 0, y = h.length; m !== y; ++m) {
                const v = h[m];
                o.addGroup(v.start, v.count, v.materialIndex)
            }
        const p = e.data.boundingSphere;
        if (p !== void 0) {
            const m = new D;
            p.center !== void 0 && m.fromArray(p.center),
            o.boundingSphere = new na(m,p.radius)
        }
        return e.name && (o.name = e.name),
        e.userData && (o.userData = e.userData),
        o
    }
}
class v9 extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = this.path === "" ? ss.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || o;
        const a = new ji(this.manager);
        a.setPath(this.path),
        a.setRequestHeader(this.requestHeader),
        a.setWithCredentials(this.withCredentials),
        a.load(e, function(l) {
            let c = null;
            try {
                c = JSON.parse(l)
            } catch (h) {
                r !== void 0 && r(h),
                console.error("THREE:ObjectLoader: Can't parse " + e + ".", h.message);
                return
            }
            const d = c.metadata;
            if (d === void 0 || d.type === void 0 || d.type.toLowerCase() === "geometry") {
                r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)),
                console.error("THREE.ObjectLoader: Can't load " + e);
                return
            }
            s.parse(c, t)
        }, i, r)
    }
    async loadAsync(e, t) {
        const i = this
          , r = this.path === "" ? ss.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || r;
        const s = new ji(this.manager);
        s.setPath(this.path),
        s.setRequestHeader(this.requestHeader),
        s.setWithCredentials(this.withCredentials);
        const o = await s.loadAsync(e, t)
          , a = JSON.parse(o)
          , l = a.metadata;
        if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry")
            throw new Error("THREE.ObjectLoader: Can't load " + e);
        return await i.parseAsync(a)
    }
    parse(e, t) {
        const i = this.parseAnimations(e.animations)
          , r = this.parseShapes(e.shapes)
          , s = this.parseGeometries(e.geometries, r)
          , o = this.parseImages(e.images, function() {
            t !== void 0 && t(c)
        })
          , a = this.parseTextures(e.textures, o)
          , l = this.parseMaterials(e.materials, a)
          , c = this.parseObject(e.object, s, l, a, i)
          , d = this.parseSkeletons(e.skeletons, c);
        if (this.bindSkeletons(c, d),
        t !== void 0) {
            let h = !1;
            for (const p in o)
                if (o[p].data instanceof HTMLImageElement) {
                    h = !0;
                    break
                }
            h === !1 && t(c)
        }
        return c
    }
    async parseAsync(e) {
        const t = this.parseAnimations(e.animations)
          , i = this.parseShapes(e.shapes)
          , r = this.parseGeometries(e.geometries, i)
          , s = await this.parseImagesAsync(e.images)
          , o = this.parseTextures(e.textures, s)
          , a = this.parseMaterials(e.materials, o)
          , l = this.parseObject(e.object, r, a, o, t)
          , c = this.parseSkeletons(e.skeletons, l);
        return this.bindSkeletons(l, c),
        l
    }
    parseShapes(e) {
        const t = {};
        if (e !== void 0)
            for (let i = 0, r = e.length; i < r; i++) {
                const s = new el().fromJSON(e[i]);
                t[s.uuid] = s
            }
        return t
    }
    parseSkeletons(e, t) {
        const i = {}
          , r = {};
        if (t.traverse(function(s) {
            s.isBone && (r[s.uuid] = s)
        }),
        e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
                const a = new Rd().fromJSON(e[s], r);
                i[a.uuid] = a
            }
        return i
    }
    parseGeometries(e, t) {
        const i = {};
        if (e !== void 0) {
            const r = new iR;
            for (let s = 0, o = e.length; s < o; s++) {
                let a;
                const l = e[s];
                switch (l.type) {
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                    a = r.parse(l);
                    break;
                default:
                    l.type in UE ? a = UE[l.type].fromJSON(l, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)
                }
                a.uuid = l.uuid,
                l.name !== void 0 && (a.name = l.name),
                a.isBufferGeometry === !0 && l.userData !== void 0 && (a.userData = l.userData),
                i[l.uuid] = a
            }
        }
        return i
    }
    parseMaterials(e, t) {
        const i = {}
          , r = {};
        if (e !== void 0) {
            const s = new o0;
            s.setTextures(t);
            for (let o = 0, a = e.length; o < a; o++) {
                const l = e[o];
                i[l.uuid] === void 0 && (i[l.uuid] = s.parse(l)),
                r[l.uuid] = i[l.uuid]
            }
        }
        return r
    }
    parseAnimations(e) {
        const t = {};
        if (e !== void 0)
            for (let i = 0; i < e.length; i++) {
                const r = e[i]
                  , s = Wu.parse(r);
                t[s.uuid] = s
            }
        return t
    }
    parseImages(e, t) {
        const i = this
          , r = {};
        let s;
        function o(l) {
            return i.manager.itemStart(l),
            s.load(l, function() {
                i.manager.itemEnd(l)
            }, void 0, function() {
                i.manager.itemError(l),
                i.manager.itemEnd(l)
            })
        }
        function a(l) {
            if (typeof l == "string") {
                const c = l
                  , d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : i.resourcePath + c;
                return o(d)
            } else
                return l.data ? {
                    data: hu(l.type, l.data),
                    width: l.width,
                    height: l.height
                } : null
        }
        if (e !== void 0 && e.length > 0) {
            const l = new jA(t);
            s = new ud(l),
            s.setCrossOrigin(this.crossOrigin);
            for (let c = 0, d = e.length; c < d; c++) {
                const h = e[c]
                  , p = h.url;
                if (Array.isArray(p)) {
                    const m = [];
                    for (let y = 0, v = p.length; y < v; y++) {
                        const _ = p[y]
                          , x = a(_);
                        x !== null && (x instanceof HTMLImageElement ? m.push(x) : m.push(new Tu(x.data,x.width,x.height)))
                    }
                    r[h.uuid] = new Ha(m)
                } else {
                    const m = a(h.url);
                    r[h.uuid] = new Ha(m)
                }
            }
        }
        return r
    }
    async parseImagesAsync(e) {
        const t = this
          , i = {};
        let r;
        async function s(o) {
            if (typeof o == "string") {
                const a = o
                  , l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
                return await r.loadAsync(l)
            } else
                return o.data ? {
                    data: hu(o.type, o.data),
                    width: o.width,
                    height: o.height
                } : null
        }
        if (e !== void 0 && e.length > 0) {
            r = new ud(this.manager),
            r.setCrossOrigin(this.crossOrigin);
            for (let o = 0, a = e.length; o < a; o++) {
                const l = e[o]
                  , c = l.url;
                if (Array.isArray(c)) {
                    const d = [];
                    for (let h = 0, p = c.length; h < p; h++) {
                        const m = c[h]
                          , y = await s(m);
                        y !== null && (y instanceof HTMLImageElement ? d.push(y) : d.push(new Tu(y.data,y.width,y.height)))
                    }
                    i[l.uuid] = new Ha(d)
                } else {
                    const d = await s(l.url);
                    i[l.uuid] = new Ha(d)
                }
            }
        }
        return i
    }
    parseTextures(e, t) {
        function i(s, o) {
            return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s),
            o[s])
        }
        const r = {};
        if (e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
                const a = e[s];
                a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
                t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                const l = t[a.image]
                  , c = l.data;
                let d;
                Array.isArray(c) ? (d = new Pd,
                c.length === 6 && (d.needsUpdate = !0)) : (c && c.data ? d = new Tu : d = new qt,
                c && (d.needsUpdate = !0)),
                d.source = l,
                d.uuid = a.uuid,
                a.name !== void 0 && (d.name = a.name),
                a.mapping !== void 0 && (d.mapping = i(a.mapping, x9)),
                a.offset !== void 0 && d.offset.fromArray(a.offset),
                a.repeat !== void 0 && d.repeat.fromArray(a.repeat),
                a.center !== void 0 && d.center.fromArray(a.center),
                a.rotation !== void 0 && (d.rotation = a.rotation),
                a.wrap !== void 0 && (d.wrapS = i(a.wrap[0], VE),
                d.wrapT = i(a.wrap[1], VE)),
                a.format !== void 0 && (d.format = a.format),
                a.type !== void 0 && (d.type = a.type),
                a.encoding !== void 0 && (d.encoding = a.encoding),
                a.minFilter !== void 0 && (d.minFilter = i(a.minFilter, WE)),
                a.magFilter !== void 0 && (d.magFilter = i(a.magFilter, WE)),
                a.anisotropy !== void 0 && (d.anisotropy = a.anisotropy),
                a.flipY !== void 0 && (d.flipY = a.flipY),
                a.generateMipmaps !== void 0 && (d.generateMipmaps = a.generateMipmaps),
                a.premultiplyAlpha !== void 0 && (d.premultiplyAlpha = a.premultiplyAlpha),
                a.unpackAlignment !== void 0 && (d.unpackAlignment = a.unpackAlignment),
                a.userData !== void 0 && (d.userData = a.userData),
                r[a.uuid] = d
            }
        return r
    }
    parseObject(e, t, i, r, s) {
        let o;
        function a(p) {
            return t[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", p),
            t[p]
        }
        function l(p) {
            if (p !== void 0) {
                if (Array.isArray(p)) {
                    const m = [];
                    for (let y = 0, v = p.length; y < v; y++) {
                        const _ = p[y];
                        i[_] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", _),
                        m.push(i[_])
                    }
                    return m
                }
                return i[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", p),
                i[p]
            }
        }
        function c(p) {
            return r[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", p),
            r[p]
        }
        let d, h;
        switch (e.type) {
        case "Scene":
            o = new PA,
            e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new Le(e.background) : o.background = c(e.background)),
            e.environment !== void 0 && (o.environment = c(e.environment)),
            e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new e0(e.fog.color,e.fog.near,e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new $g(e.fog.color,e.fog.density))),
            e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness),
            e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity);
            break;
        case "PerspectiveCamera":
            o = new Ht(e.fov,e.aspect,e.near,e.far),
            e.focus !== void 0 && (o.focus = e.focus),
            e.zoom !== void 0 && (o.zoom = e.zoom),
            e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
            e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset),
            e.view !== void 0 && (o.view = Object.assign({}, e.view));
            break;
        case "OrthographicCamera":
            o = new Nr(e.left,e.right,e.top,e.bottom,e.near,e.far),
            e.zoom !== void 0 && (o.zoom = e.zoom),
            e.view !== void 0 && (o.view = Object.assign({}, e.view));
            break;
        case "AmbientLight":
            o = new $B(e.color,e.intensity);
            break;
        case "DirectionalLight":
            o = new YA(e.color,e.intensity);
            break;
        case "PointLight":
            o = new KA(e.color,e.intensity,e.distance,e.decay);
            break;
        case "RectAreaLight":
            o = new eR(e.color,e.intensity,e.width,e.height);
            break;
        case "SpotLight":
            o = new XA(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);
            break;
        case "HemisphereLight":
            o = new qB(e.color,e.groundColor,e.intensity);
            break;
        case "LightProbe":
            o = new s0().fromJSON(e);
            break;
        case "SkinnedMesh":
            d = a(e.geometry),
            h = l(e.material),
            o = new RA(d,h),
            e.bindMode !== void 0 && (o.bindMode = e.bindMode),
            e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix),
            e.skeleton !== void 0 && (o.skeleton = e.skeleton);
            break;
        case "Mesh":
            d = a(e.geometry),
            h = l(e.material),
            o = new Un(d,h);
            break;
        case "InstancedMesh":
            d = a(e.geometry),
            h = l(e.material);
            const p = e.count
              , m = e.instanceMatrix
              , y = e.instanceColor;
            o = new bB(d,h,p),
            o.instanceMatrix = new Gu(new Float32Array(m.array),16),
            y !== void 0 && (o.instanceColor = new Gu(new Float32Array(y.array),y.itemSize));
            break;
        case "LOD":
            o = new TB;
            break;
        case "Line":
            o = new Ks(a(e.geometry),l(e.material));
            break;
        case "LineLoop":
            o = new LA(a(e.geometry),l(e.material));
            break;
        case "LineSegments":
            o = new Gr(a(e.geometry),l(e.material));
            break;
        case "PointCloud":
        case "Points":
            o = new IA(a(e.geometry),l(e.material));
            break;
        case "Sprite":
            o = new EB(l(e.material));
            break;
        case "Group":
            o = new ks;
            break;
        case "Bone":
            o = new t0;
            break;
        default:
            o = new Rt
        }
        if (o.uuid = e.uuid,
        e.name !== void 0 && (o.name = e.name),
        e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix),
        e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate),
        o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position),
        e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
        e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion),
        e.scale !== void 0 && o.scale.fromArray(e.scale)),
        e.castShadow !== void 0 && (o.castShadow = e.castShadow),
        e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow),
        e.shadow && (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))),
        e.visible !== void 0 && (o.visible = e.visible),
        e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled),
        e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
        e.userData !== void 0 && (o.userData = e.userData),
        e.layers !== void 0 && (o.layers.mask = e.layers),
        e.children !== void 0) {
            const p = e.children;
            for (let m = 0; m < p.length; m++)
                o.add(this.parseObject(p[m], t, i, r, s))
        }
        if (e.animations !== void 0) {
            const p = e.animations;
            for (let m = 0; m < p.length; m++) {
                const y = p[m];
                o.animations.push(s[y])
            }
        }
        if (e.type === "LOD") {
            e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
            const p = e.levels;
            for (let m = 0; m < p.length; m++) {
                const y = p[m]
                  , v = o.getObjectByProperty("uuid", y.object);
                v !== void 0 && o.addLevel(v, y.distance, y.hysteresis)
            }
        }
        return o
    }
    bindSkeletons(e, t) {
        Object.keys(t).length !== 0 && e.traverse(function(i) {
            if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
                const r = t[i.skeleton];
                r === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", i.skeleton) : i.bind(r, i.bindMatrix)
            }
        })
    }
}
const x9 = {
    UVMapping: Xg,
    CubeReflectionMapping: Vo,
    CubeRefractionMapping: Wo,
    EquirectangularReflectionMapping: qf,
    EquirectangularRefractionMapping: $f,
    CubeUVReflectionMapping: qu
}
  , VE = {
    RepeatWrapping: jo,
    ClampToEdgeWrapping: Vn,
    MirroredRepeatWrapping: ku
}
  , WE = {
    NearestFilter: hn,
    NearestMipmapNearestFilter: ed,
    NearestMipmapLinearFilter: Eu,
    LinearFilter: nn,
    LinearMipmapNearestFilter: Kg,
    LinearMipmapLinearFilter: ls
};
class rR extends vi {
    constructor(e) {
        super(e),
        this.isImageBitmapLoader = !0,
        typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(e) {
        return this.options = e,
        this
    }
    load(e, t, i, r) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = this
          , o = ul.get(e);
        if (o !== void 0)
            return s.manager.itemStart(e),
            setTimeout(function() {
                t && t(o),
                s.manager.itemEnd(e)
            }, 0),
            o;
        const a = {};
        a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
        a.headers = this.requestHeader,
        fetch(e, a).then(function(l) {
            return l.blob()
        }).then(function(l) {
            return createImageBitmap(l, Object.assign(s.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function(l) {
            ul.add(e, l),
            t && t(l),
            s.manager.itemEnd(e)
        }).catch(function(l) {
            r && r(l),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }),
        s.manager.itemStart(e)
    }
}
let Jp;
class QA {
    static getContext() {
        return Jp === void 0 && (Jp = new (window.AudioContext || window.webkitAudioContext)),
        Jp
    }
    static setContext(e) {
        Jp = e
    }
}
class _9 extends vi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new ji(this.manager);
        o.setResponseType("arraybuffer"),
        o.setPath(this.path),
        o.setRequestHeader(this.requestHeader),
        o.setWithCredentials(this.withCredentials),
        o.load(e, function(a) {
            try {
                const l = a.slice(0);
                QA.getContext().decodeAudioData(l, function(d) {
                    t(d)
                })
            } catch (l) {
                r ? r(l) : console.error(l),
                s.manager.itemError(e)
            }
        }, i, r)
    }
}
class A9 extends s0 {
    constructor(e, t, i=1) {
        super(void 0, i),
        this.isHemisphereLightProbe = !0;
        const r = new Le().set(e)
          , s = new Le().set(t)
          , o = new D(r.r,r.g,r.b)
          , a = new D(s.r,s.g,s.b)
          , l = Math.sqrt(Math.PI)
          , c = l * Math.sqrt(.75);
        this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l),
        this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c)
    }
}
class M9 extends s0 {
    constructor(e, t=1) {
        super(void 0, t),
        this.isAmbientLightProbe = !0;
        const i = new Le().set(e);
        this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }
}
const jE = new rt
  , JE = new rt
  , xa = new rt;
class w9 {
    constructor() {
        this.type = "StereoCamera",
        this.aspect = 1,
        this.eyeSep = .064,
        this.cameraL = new Ht,
        this.cameraL.layers.enable(1),
        this.cameraL.matrixAutoUpdate = !1,
        this.cameraR = new Ht,
        this.cameraR.layers.enable(2),
        this.cameraR.matrixAutoUpdate = !1,
        this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        }
    }
    update(e) {
        const t = this._cache;
        if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
            t.focus = e.focus,
            t.fov = e.fov,
            t.aspect = e.aspect * this.aspect,
            t.near = e.near,
            t.far = e.far,
            t.zoom = e.zoom,
            t.eyeSep = this.eyeSep,
            xa.copy(e.projectionMatrix);
            const r = t.eyeSep / 2
              , s = r * t.near / t.focus
              , o = t.near * Math.tan(Za * t.fov * .5) / t.zoom;
            let a, l;
            JE.elements[12] = -r,
            jE.elements[12] = r,
            a = -o * t.aspect + s,
            l = o * t.aspect + s,
            xa.elements[0] = 2 * t.near / (l - a),
            xa.elements[8] = (l + a) / (l - a),
            this.cameraL.projectionMatrix.copy(xa),
            a = -o * t.aspect - s,
            l = o * t.aspect - s,
            xa.elements[0] = 2 * t.near / (l - a),
            xa.elements[8] = (l + a) / (l - a),
            this.cameraR.projectionMatrix.copy(xa)
        }
        this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(JE),
        this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(jE)
    }
}
class ZA {
    constructor(e=!0) {
        this.autoStart = e,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    start() {
        this.startTime = XE(),
        this.oldTime = this.startTime,
        this.elapsedTime = 0,
        this.running = !0
    }
    stop() {
        this.getElapsedTime(),
        this.running = !1,
        this.autoStart = !1
    }
    getElapsedTime() {
        return this.getDelta(),
        this.elapsedTime
    }
    getDelta() {
        let e = 0;
        if (this.autoStart && !this.running)
            return this.start(),
            0;
        if (this.running) {
            const t = XE();
            e = (t - this.oldTime) / 1e3,
            this.oldTime = t,
            this.elapsedTime += e
        }
        return e
    }
}
function XE() {
    return (typeof performance > "u" ? Date : performance).now()
}
const _a = new D
  , KE = new jn
  , S9 = new D
  , Aa = new D;
class C9 extends Rt {
    constructor() {
        super(),
        this.type = "AudioListener",
        this.context = QA.getContext(),
        this.gain = this.context.createGain(),
        this.gain.connect(this.context.destination),
        this.filter = null,
        this.timeDelta = 0,
        this._clock = new ZA
    }
    getInput() {
        return this.gain
    }
    removeFilter() {
        return this.filter !== null && (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        this.filter = null),
        this
    }
    getFilter() {
        return this.filter
    }
    setFilter(e) {
        return this.filter !== null ? (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
        this.filter = e,
        this.gain.connect(this.filter),
        this.filter.connect(this.context.destination),
        this
    }
    getMasterVolume() {
        return this.gain.gain.value
    }
    setMasterVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e);
        const t = this.context.listener
          , i = this.up;
        if (this.timeDelta = this._clock.getDelta(),
        this.matrixWorld.decompose(_a, KE, S9),
        Aa.set(0, 0, -1).applyQuaternion(KE),
        t.positionX) {
            const r = this.context.currentTime + this.timeDelta;
            t.positionX.linearRampToValueAtTime(_a.x, r),
            t.positionY.linearRampToValueAtTime(_a.y, r),
            t.positionZ.linearRampToValueAtTime(_a.z, r),
            t.forwardX.linearRampToValueAtTime(Aa.x, r),
            t.forwardY.linearRampToValueAtTime(Aa.y, r),
            t.forwardZ.linearRampToValueAtTime(Aa.z, r),
            t.upX.linearRampToValueAtTime(i.x, r),
            t.upY.linearRampToValueAtTime(i.y, r),
            t.upZ.linearRampToValueAtTime(i.z, r)
        } else
            t.setPosition(_a.x, _a.y, _a.z),
            t.setOrientation(Aa.x, Aa.y, Aa.z, i.x, i.y, i.z)
    }
}
class sR extends Rt {
    constructor(e) {
        super(),
        this.type = "Audio",
        this.listener = e,
        this.context = e.context,
        this.gain = this.context.createGain(),
        this.gain.connect(e.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.detune = 0,
        this.loop = !1,
        this.loopStart = 0,
        this.loopEnd = 0,
        this.offset = 0,
        this.duration = void 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.source = null,
        this.sourceType = "empty",
        this._startedAt = 0,
        this._progress = 0,
        this._connected = !1,
        this.filters = []
    }
    getOutput() {
        return this.gain
    }
    setNodeSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "audioNode",
        this.source = e,
        this.connect(),
        this
    }
    setMediaElementSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaNode",
        this.source = this.context.createMediaElementSource(e),
        this.connect(),
        this
    }
    setMediaStreamSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaStreamNode",
        this.source = this.context.createMediaStreamSource(e),
        this.connect(),
        this
    }
    setBuffer(e) {
        return this.buffer = e,
        this.sourceType = "buffer",
        this.autoplay && this.play(),
        this
    }
    play(e=0) {
        if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return
        }
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        this._startedAt = this.context.currentTime + e;
        const t = this.context.createBufferSource();
        return t.buffer = this.buffer,
        t.loop = this.loop,
        t.loopStart = this.loopStart,
        t.loopEnd = this.loopEnd,
        t.onended = this.onEnded.bind(this),
        t.start(this._startedAt, this._progress + this.offset, this.duration),
        this.isPlaying = !0,
        this.source = t,
        this.setDetune(this.detune),
        this.setPlaybackRate(this.playbackRate),
        this.connect()
    }
    pause() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
        this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        this.source.onended = null,
        this.isPlaying = !1),
        this
    }
    stop() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this._progress = 0,
        this.source.stop(),
        this.source.onended = null,
        this.isPlaying = !1,
        this
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput())
        } else
            this.source.connect(this.getOutput());
        return this._connected = !0,
        this
    }
    disconnect() {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].disconnect(this.filters[e]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput())
        } else
            this.source.disconnect(this.getOutput());
        return this._connected = !1,
        this
    }
    getFilters() {
        return this.filters
    }
    setFilters(e) {
        return e || (e = []),
        this._connected === !0 ? (this.disconnect(),
        this.filters = e.slice(),
        this.connect()) : this.filters = e.slice(),
        this
    }
    setDetune(e) {
        if (this.detune = e,
        this.source.detune !== void 0)
            return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
            this
    }
    getDetune() {
        return this.detune
    }
    getFilter() {
        return this.getFilters()[0]
    }
    setFilter(e) {
        return this.setFilters(e ? [e] : [])
    }
    setPlaybackRate(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.playbackRate = e,
        this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
        this
    }
    getPlaybackRate() {
        return this.playbackRate
    }
    onEnded() {
        this.isPlaying = !1
    }
    getLoop() {
        return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."),
        !1) : this.loop
    }
    setLoop(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.loop = e,
        this.isPlaying === !0 && (this.source.loop = this.loop),
        this
    }
    setLoopStart(e) {
        return this.loopStart = e,
        this
    }
    setLoopEnd(e) {
        return this.loopEnd = e,
        this
    }
    getVolume() {
        return this.gain.gain.value
    }
    setVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this
    }
}
const Ma = new D
  , YE = new jn
  , E9 = new D
  , wa = new D;
class T9 extends sR {
    constructor(e) {
        super(e),
        this.panner = this.context.createPanner(),
        this.panner.panningModel = "HRTF",
        this.panner.connect(this.gain)
    }
    disconnect() {
        super.disconnect(),
        this.panner.disconnect(this.gain)
    }
    getOutput() {
        return this.panner
    }
    getRefDistance() {
        return this.panner.refDistance
    }
    setRefDistance(e) {
        return this.panner.refDistance = e,
        this
    }
    getRolloffFactor() {
        return this.panner.rolloffFactor
    }
    setRolloffFactor(e) {
        return this.panner.rolloffFactor = e,
        this
    }
    getDistanceModel() {
        return this.panner.distanceModel
    }
    setDistanceModel(e) {
        return this.panner.distanceModel = e,
        this
    }
    getMaxDistance() {
        return this.panner.maxDistance
    }
    setMaxDistance(e) {
        return this.panner.maxDistance = e,
        this
    }
    setDirectionalCone(e, t, i) {
        return this.panner.coneInnerAngle = e,
        this.panner.coneOuterAngle = t,
        this.panner.coneOuterGain = i,
        this
    }
    updateMatrixWorld(e) {
        if (super.updateMatrixWorld(e),
        this.hasPlaybackControl === !0 && this.isPlaying === !1)
            return;
        this.matrixWorld.decompose(Ma, YE, E9),
        wa.set(0, 0, 1).applyQuaternion(YE);
        const t = this.panner;
        if (t.positionX) {
            const i = this.context.currentTime + this.listener.timeDelta;
            t.positionX.linearRampToValueAtTime(Ma.x, i),
            t.positionY.linearRampToValueAtTime(Ma.y, i),
            t.positionZ.linearRampToValueAtTime(Ma.z, i),
            t.orientationX.linearRampToValueAtTime(wa.x, i),
            t.orientationY.linearRampToValueAtTime(wa.y, i),
            t.orientationZ.linearRampToValueAtTime(wa.z, i)
        } else
            t.setPosition(Ma.x, Ma.y, Ma.z),
            t.setOrientation(wa.x, wa.y, wa.z)
    }
}
class b9 {
    constructor(e, t=2048) {
        this.analyser = e.context.createAnalyser(),
        this.analyser.fftSize = t,
        this.data = new Uint8Array(this.analyser.frequencyBinCount),
        e.getOutput().connect(this.analyser)
    }
    getFrequencyData() {
        return this.analyser.getByteFrequencyData(this.data),
        this.data
    }
    getAverageFrequency() {
        let e = 0;
        const t = this.getFrequencyData();
        for (let i = 0; i < t.length; i++)
            e += t[i];
        return e / t.length
    }
}
class oR {
    constructor(e, t, i) {
        this.binding = e,
        this.valueSize = i;
        let r, s, o;
        switch (t) {
        case "quaternion":
            r = this._slerp,
            s = this._slerpAdditive,
            o = this._setAdditiveIdentityQuaternion,
            this.buffer = new Float64Array(i * 6),
            this._workIndex = 5;
            break;
        case "string":
        case "bool":
            r = this._select,
            s = this._select,
            o = this._setAdditiveIdentityOther,
            this.buffer = new Array(i * 5);
            break;
        default:
            r = this._lerp,
            s = this._lerpAdditive,
            o = this._setAdditiveIdentityNumeric,
            this.buffer = new Float64Array(i * 5)
        }
        this._mixBufferRegion = r,
        this._mixBufferRegionAdditive = s,
        this._setIdentity = o,
        this._origIndex = 3,
        this._addIndex = 4,
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        this.useCount = 0,
        this.referenceCount = 0
    }
    accumulate(e, t) {
        const i = this.buffer
          , r = this.valueSize
          , s = e * r + r;
        let o = this.cumulativeWeight;
        if (o === 0) {
            for (let a = 0; a !== r; ++a)
                i[s + a] = i[a];
            o = t
        } else {
            o += t;
            const a = t / o;
            this._mixBufferRegion(i, s, 0, a, r)
        }
        this.cumulativeWeight = o
    }
    accumulateAdditive(e) {
        const t = this.buffer
          , i = this.valueSize
          , r = i * this._addIndex;
        this.cumulativeWeightAdditive === 0 && this._setIdentity(),
        this._mixBufferRegionAdditive(t, r, 0, e, i),
        this.cumulativeWeightAdditive += e
    }
    apply(e) {
        const t = this.valueSize
          , i = this.buffer
          , r = e * t + t
          , s = this.cumulativeWeight
          , o = this.cumulativeWeightAdditive
          , a = this.binding;
        if (this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        s < 1) {
            const l = t * this._origIndex;
            this._mixBufferRegion(i, r, l, 1 - s, t)
        }
        o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t);
        for (let l = t, c = t + t; l !== c; ++l)
            if (i[l] !== i[l + t]) {
                a.setValue(i, r);
                break
            }
    }
    saveOriginalState() {
        const e = this.binding
          , t = this.buffer
          , i = this.valueSize
          , r = i * this._origIndex;
        e.getValue(t, r);
        for (let s = i, o = r; s !== o; ++s)
            t[s] = t[r + s % i];
        this._setIdentity(),
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0
    }
    restoreOriginalState() {
        const e = this.valueSize * 3;
        this.binding.setValue(this.buffer, e)
    }
    _setAdditiveIdentityNumeric() {
        const e = this._addIndex * this.valueSize
          , t = e + this.valueSize;
        for (let i = e; i < t; i++)
            this.buffer[i] = 0
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(),
        this.buffer[this._addIndex * this.valueSize + 3] = 1
    }
    _setAdditiveIdentityOther() {
        const e = this._origIndex * this.valueSize
          , t = this._addIndex * this.valueSize;
        for (let i = 0; i < this.valueSize; i++)
            this.buffer[t + i] = this.buffer[e + i]
    }
    _select(e, t, i, r, s) {
        if (r >= .5)
            for (let o = 0; o !== s; ++o)
                e[t + o] = e[i + o]
    }
    _slerp(e, t, i, r) {
        jn.slerpFlat(e, t, e, t, e, i, r)
    }
    _slerpAdditive(e, t, i, r, s) {
        const o = this._workIndex * s;
        jn.multiplyQuaternionsFlat(e, o, e, t, e, i),
        jn.slerpFlat(e, t, e, t, e, o, r)
    }
    _lerp(e, t, i, r, s) {
        const o = 1 - r;
        for (let a = 0; a !== s; ++a) {
            const l = t + a;
            e[l] = e[l] * o + e[i + a] * r
        }
    }
    _lerpAdditive(e, t, i, r, s) {
        for (let o = 0; o !== s; ++o) {
            const a = t + o;
            e[a] = e[a] + e[i + o] * r
        }
    }
}
const qA = "\\[\\]\\.:\\/"
  , P9 = new RegExp("[" + qA + "]","g")
  , $A = "[^" + qA + "]"
  , B9 = "[^" + qA.replace("\\.", "") + "]"
  , R9 = /((?:WC+[\/:])*)/.source.replace("WC", $A)
  , L9 = /(WCOD+)?/.source.replace("WCOD", B9)
  , I9 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", $A)
  , D9 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", $A)
  , F9 = new RegExp("^" + R9 + L9 + I9 + D9 + "$")
  , k9 = ["material", "materials", "bones", "map"];
class N9 {
    constructor(e, t, i) {
        const r = i || bt.parseTrackName(t);
        this._targetGroup = e,
        this._bindings = e.subscribe_(t, r)
    }
    getValue(e, t) {
        this.bind();
        const i = this._targetGroup.nCachedObjects_
          , r = this._bindings[i];
        r !== void 0 && r.getValue(e, t)
    }
    setValue(e, t) {
        const i = this._bindings;
        for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)
            i[r].setValue(e, t)
    }
    bind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
            e[t].bind()
    }
    unbind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
            e[t].unbind()
    }
}
class bt {
    constructor(e, t, i) {
        this.path = t,
        this.parsedPath = i || bt.parseTrackName(t),
        this.node = bt.findNode(e, this.parsedPath.nodeName) || e,
        this.rootNode = e,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
    static create(e, t, i) {
        return e && e.isAnimationObjectGroup ? new bt.Composite(e,t,i) : new bt(e,t,i)
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(P9, "")
    }
    static parseTrackName(e) {
        const t = F9.exec(e);
        if (t === null)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const i = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6]
        }
          , r = i.nodeName && i.nodeName.lastIndexOf(".");
        if (r !== void 0 && r !== -1) {
            const s = i.nodeName.substring(r + 1);
            k9.indexOf(s) !== -1 && (i.nodeName = i.nodeName.substring(0, r),
            i.objectName = s)
        }
        if (i.propertyName === null || i.propertyName.length === 0)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return i
    }
    static findNode(e, t) {
        if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
            return e;
        if (e.skeleton) {
            const i = e.skeleton.getBoneByName(t);
            if (i !== void 0)
                return i
        }
        if (e.children) {
            const i = function(s) {
                for (let o = 0; o < s.length; o++) {
                    const a = s[o];
                    if (a.name === t || a.uuid === t)
                        return a;
                    const l = i(a.children);
                    if (l)
                        return l
                }
                return null
            }
              , r = i(e.children);
            if (r)
                return r
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName]
    }
    _getValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            e[t++] = i[r]
    }
    _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t)
    }
    _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t]
    }
    _setValue_direct_setNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            i[r] = e[t++]
    }
    _setValue_array_setNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            i[r] = e[t++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            i[r] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t]
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t)
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(e, t) {
        this.bind(),
        this.getValue(e, t)
    }
    _setValue_unbound(e, t) {
        this.bind(),
        this.setValue(e, t)
    }
    bind() {
        let e = this.node;
        const t = this.parsedPath
          , i = t.objectName
          , r = t.propertyName;
        let s = t.propertyIndex;
        if (e || (e = bt.findNode(this.rootNode, t.nodeName) || this.rootNode,
        this.node = e),
        this.getValue = this._getValue_unavailable,
        this.setValue = this._setValue_unavailable,
        !e) {
            console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            return
        }
        if (i) {
            let c = t.objectIndex;
            switch (i) {
            case "materials":
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.materials) {
                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    return
                }
                e = e.material.materials;
                break;
            case "bones":
                if (!e.skeleton) {
                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    return
                }
                e = e.skeleton.bones;
                for (let d = 0; d < e.length; d++)
                    if (e[d].name === c) {
                        c = d;
                        break
                    }
                break;
            case "map":
                if ("map"in e) {
                    e = e.map;
                    break
                }
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.map) {
                    console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                    return
                }
                e = e.material.map;
                break;
            default:
                if (e[i] === void 0) {
                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    return
                }
                e = e[i]
            }
            if (c !== void 0) {
                if (e[c] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    return
                }
                e = e[c]
            }
        }
        const o = e[r];
        if (o === void 0) {
            const c = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + r + " but it wasn't found.", e);
            return
        }
        let a = this.Versioning.None;
        this.targetObject = e,
        e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
        let l = this.BindingType.Direct;
        if (s !== void 0) {
            if (r === "morphTargetInfluences") {
                if (!e.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!e.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s])
            }
            l = this.BindingType.ArrayElement,
            this.resolvedProperty = o,
            this.propertyIndex = s
        } else
            o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray,
            this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray,
            this.resolvedProperty = o) : this.propertyName = r;
        this.getValue = this.GetterByBindingType[l],
        this.setValue = this.SetterByBindingTypeAndVersioning[l][a]
    }
    unbind() {
        this.node = null,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
}
bt.Composite = N9;
bt.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
bt.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
bt.prototype.GetterByBindingType = [bt.prototype._getValue_direct, bt.prototype._getValue_array, bt.prototype._getValue_arrayElement, bt.prototype._getValue_toArray];
bt.prototype.SetterByBindingTypeAndVersioning = [[bt.prototype._setValue_direct, bt.prototype._setValue_direct_setNeedsUpdate, bt.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [bt.prototype._setValue_array, bt.prototype._setValue_array_setNeedsUpdate, bt.prototype._setValue_array_setMatrixWorldNeedsUpdate], [bt.prototype._setValue_arrayElement, bt.prototype._setValue_arrayElement_setNeedsUpdate, bt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [bt.prototype._setValue_fromArray, bt.prototype._setValue_fromArray_setNeedsUpdate, bt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class O9 {
    constructor() {
        this.isAnimationObjectGroup = !0,
        this.uuid = Vi(),
        this._objects = Array.prototype.slice.call(arguments),
        this.nCachedObjects_ = 0;
        const e = {};
        this._indicesByUUID = e;
        for (let i = 0, r = arguments.length; i !== r; ++i)
            e[arguments[i].uuid] = i;
        this._paths = [],
        this._parsedPaths = [],
        this._bindings = [],
        this._bindingsIndicesByPath = {};
        const t = this;
        this.stats = {
            objects: {
                get total() {
                    return t._objects.length
                },
                get inUse() {
                    return this.total - t.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return t._bindings.length
            }
        }
    }
    add() {
        const e = this._objects
          , t = this._indicesByUUID
          , i = this._paths
          , r = this._parsedPaths
          , s = this._bindings
          , o = s.length;
        let a, l = e.length, c = this.nCachedObjects_;
        for (let d = 0, h = arguments.length; d !== h; ++d) {
            const p = arguments[d]
              , m = p.uuid;
            let y = t[m];
            if (y === void 0) {
                y = l++,
                t[m] = y,
                e.push(p);
                for (let v = 0, _ = o; v !== _; ++v)
                    s[v].push(new bt(p,i[v],r[v]))
            } else if (y < c) {
                a = e[y];
                const v = --c
                  , _ = e[v];
                t[_.uuid] = y,
                e[y] = _,
                t[m] = v,
                e[v] = p;
                for (let x = 0, A = o; x !== A; ++x) {
                    const M = s[x]
                      , S = M[v];
                    let T = M[y];
                    M[y] = S,
                    T === void 0 && (T = new bt(p,i[x],r[x])),
                    M[v] = T
                }
            } else
                e[y] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
        }
        this.nCachedObjects_ = c
    }
    remove() {
        const e = this._objects
          , t = this._indicesByUUID
          , i = this._bindings
          , r = i.length;
        let s = this.nCachedObjects_;
        for (let o = 0, a = arguments.length; o !== a; ++o) {
            const l = arguments[o]
              , c = l.uuid
              , d = t[c];
            if (d !== void 0 && d >= s) {
                const h = s++
                  , p = e[h];
                t[p.uuid] = d,
                e[d] = p,
                t[c] = h,
                e[h] = l;
                for (let m = 0, y = r; m !== y; ++m) {
                    const v = i[m]
                      , _ = v[h]
                      , x = v[d];
                    v[d] = _,
                    v[h] = x
                }
            }
        }
        this.nCachedObjects_ = s
    }
    uncache() {
        const e = this._objects
          , t = this._indicesByUUID
          , i = this._bindings
          , r = i.length;
        let s = this.nCachedObjects_
          , o = e.length;
        for (let a = 0, l = arguments.length; a !== l; ++a) {
            const c = arguments[a]
              , d = c.uuid
              , h = t[d];
            if (h !== void 0)
                if (delete t[d],
                h < s) {
                    const p = --s
                      , m = e[p]
                      , y = --o
                      , v = e[y];
                    t[m.uuid] = h,
                    e[h] = m,
                    t[v.uuid] = p,
                    e[p] = v,
                    e.pop();
                    for (let _ = 0, x = r; _ !== x; ++_) {
                        const A = i[_]
                          , M = A[p]
                          , S = A[y];
                        A[h] = M,
                        A[p] = S,
                        A.pop()
                    }
                } else {
                    const p = --o
                      , m = e[p];
                    p > 0 && (t[m.uuid] = h),
                    e[h] = m,
                    e.pop();
                    for (let y = 0, v = r; y !== v; ++y) {
                        const _ = i[y];
                        _[h] = _[p],
                        _.pop()
                    }
                }
        }
        this.nCachedObjects_ = s
    }
    subscribe_(e, t) {
        const i = this._bindingsIndicesByPath;
        let r = i[e];
        const s = this._bindings;
        if (r !== void 0)
            return s[r];
        const o = this._paths
          , a = this._parsedPaths
          , l = this._objects
          , c = l.length
          , d = this.nCachedObjects_
          , h = new Array(c);
        r = s.length,
        i[e] = r,
        o.push(e),
        a.push(t),
        s.push(h);
        for (let p = d, m = l.length; p !== m; ++p) {
            const y = l[p];
            h[p] = new bt(y,e,t)
        }
        return h
    }
    unsubscribe_(e) {
        const t = this._bindingsIndicesByPath
          , i = t[e];
        if (i !== void 0) {
            const r = this._paths
              , s = this._parsedPaths
              , o = this._bindings
              , a = o.length - 1
              , l = o[a]
              , c = e[a];
            t[c] = i,
            o[i] = l,
            o.pop(),
            s[i] = s[a],
            s.pop(),
            r[i] = r[a],
            r.pop()
        }
    }
}
class U9 {
    constructor(e, t, i=null, r=t.blendMode) {
        this._mixer = e,
        this._clip = t,
        this._localRoot = i,
        this.blendMode = r;
        const s = t.tracks
          , o = s.length
          , a = new Array(o)
          , l = {
            endingStart: za,
            endingEnd: za
        };
        for (let c = 0; c !== o; ++c) {
            const d = s[c].createInterpolant(null);
            a[c] = d,
            d.settings = l
        }
        this._interpolantSettings = l,
        this._interpolants = a,
        this._propertyBindings = new Array(o),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = iB,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0
    }
    play() {
        return this._mixer._activateAction(this),
        this
    }
    stop() {
        return this._mixer._deactivateAction(this),
        this.reset()
    }
    reset() {
        return this.paused = !1,
        this.enabled = !0,
        this.time = 0,
        this._loopCount = -1,
        this._startTime = null,
        this.stopFading().stopWarping()
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
    }
    isScheduled() {
        return this._mixer._isActiveAction(this)
    }
    startAt(e) {
        return this._startTime = e,
        this
    }
    setLoop(e, t) {
        return this.loop = e,
        this.repetitions = t,
        this
    }
    setEffectiveWeight(e) {
        return this.weight = e,
        this._effectiveWeight = this.enabled ? e : 0,
        this.stopFading()
    }
    getEffectiveWeight() {
        return this._effectiveWeight
    }
    fadeIn(e) {
        return this._scheduleFading(e, 0, 1)
    }
    fadeOut(e) {
        return this._scheduleFading(e, 1, 0)
    }
    crossFadeFrom(e, t, i) {
        if (e.fadeOut(t),
        this.fadeIn(t),
        i) {
            const r = this._clip.duration
              , s = e._clip.duration
              , o = s / r
              , a = r / s;
            e.warp(1, o, t),
            this.warp(a, 1, t)
        }
        return this
    }
    crossFadeTo(e, t, i) {
        return e.crossFadeFrom(this, t, i)
    }
    stopFading() {
        const e = this._weightInterpolant;
        return e !== null && (this._weightInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    setEffectiveTimeScale(e) {
        return this.timeScale = e,
        this._effectiveTimeScale = this.paused ? 0 : e,
        this.stopWarping()
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale
    }
    setDuration(e) {
        return this.timeScale = this._clip.duration / e,
        this.stopWarping()
    }
    syncWith(e) {
        return this.time = e.time,
        this.timeScale = e.timeScale,
        this.stopWarping()
    }
    halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e)
    }
    warp(e, t, i) {
        const r = this._mixer
          , s = r.time
          , o = this.timeScale;
        let a = this._timeScaleInterpolant;
        a === null && (a = r._lendControlInterpolant(),
        this._timeScaleInterpolant = a);
        const l = a.parameterPositions
          , c = a.sampleValues;
        return l[0] = s,
        l[1] = s + i,
        c[0] = e / o,
        c[1] = t / o,
        this
    }
    stopWarping() {
        const e = this._timeScaleInterpolant;
        return e !== null && (this._timeScaleInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    getMixer() {
        return this._mixer
    }
    getClip() {
        return this._clip
    }
    getRoot() {
        return this._localRoot || this._mixer._root
    }
    _update(e, t, i, r) {
        if (!this.enabled) {
            this._updateWeight(e);
            return
        }
        const s = this._startTime;
        if (s !== null) {
            const l = (e - s) * i;
            l < 0 || i === 0 ? t = 0 : (this._startTime = null,
            t = i * l)
        }
        t *= this._updateTimeScale(e);
        const o = this._updateTime(t)
          , a = this._updateWeight(e);
        if (a > 0) {
            const l = this._interpolants
              , c = this._propertyBindings;
            switch (this.blendMode) {
            case gA:
                for (let d = 0, h = l.length; d !== h; ++d)
                    l[d].evaluate(o),
                    c[d].accumulateAdditive(a);
                break;
            case Yg:
            default:
                for (let d = 0, h = l.length; d !== h; ++d)
                    l[d].evaluate(o),
                    c[d].accumulate(r, a)
            }
        }
    }
    _updateWeight(e) {
        let t = 0;
        if (this.enabled) {
            t = this.weight;
            const i = this._weightInterpolant;
            if (i !== null) {
                const r = i.evaluate(e)[0];
                t *= r,
                e > i.parameterPositions[1] && (this.stopFading(),
                r === 0 && (this.enabled = !1))
            }
        }
        return this._effectiveWeight = t,
        t
    }
    _updateTimeScale(e) {
        let t = 0;
        if (!this.paused) {
            t = this.timeScale;
            const i = this._timeScaleInterpolant;
            if (i !== null) {
                const r = i.evaluate(e)[0];
                t *= r,
                e > i.parameterPositions[1] && (this.stopWarping(),
                t === 0 ? this.paused = !0 : this.timeScale = t)
            }
        }
        return this._effectiveTimeScale = t,
        t
    }
    _updateTime(e) {
        const t = this._clip.duration
          , i = this.loop;
        let r = this.time + e
          , s = this._loopCount;
        const o = i === rB;
        if (e === 0)
            return s === -1 ? r : o && (s & 1) === 1 ? t - r : r;
        if (i === nB) {
            s === -1 && (this._loopCount = 0,
            this._setEndings(!0, !0, !1));
            e: {
                if (r >= t)
                    r = t;
                else if (r < 0)
                    r = 0;
                else {
                    this.time = r;
                    break e
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                this.time = r,
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e < 0 ? -1 : 1
                })
            }
        } else {
            if (s === -1 && (e >= 0 ? (s = 0,
            this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)),
            r >= t || r < 0) {
                const a = Math.floor(r / t);
                r -= t * a,
                s += Math.abs(a);
                const l = this.repetitions - s;
                if (l <= 0)
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    r = e > 0 ? t : 0,
                    this.time = r,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e > 0 ? 1 : -1
                    });
                else {
                    if (l === 1) {
                        const c = e < 0;
                        this._setEndings(c, !c, o)
                    } else
                        this._setEndings(!1, !1, o);
                    this._loopCount = s,
                    this.time = r,
                    this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: a
                    })
                }
            } else
                this.time = r;
            if (o && (s & 1) === 1)
                return t - r
        }
        return r
    }
    _setEndings(e, t, i) {
        const r = this._interpolantSettings;
        i ? (r.endingStart = Ga,
        r.endingEnd = Ga) : (e ? r.endingStart = this.zeroSlopeAtStart ? Ga : za : r.endingStart = td,
        t ? r.endingEnd = this.zeroSlopeAtEnd ? Ga : za : r.endingEnd = td)
    }
    _scheduleFading(e, t, i) {
        const r = this._mixer
          , s = r.time;
        let o = this._weightInterpolant;
        o === null && (o = r._lendControlInterpolant(),
        this._weightInterpolant = o);
        const a = o.parameterPositions
          , l = o.sampleValues;
        return a[0] = s,
        l[0] = t,
        a[1] = s + e,
        l[1] = i,
        this
    }
}
const z9 = new Float32Array(1);
class G9 extends cs {
    constructor(e) {
        super(),
        this._root = e,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1
    }
    _bindAction(e, t) {
        const i = e._localRoot || this._root
          , r = e._clip.tracks
          , s = r.length
          , o = e._propertyBindings
          , a = e._interpolants
          , l = i.uuid
          , c = this._bindingsByRootAndName;
        let d = c[l];
        d === void 0 && (d = {},
        c[l] = d);
        for (let h = 0; h !== s; ++h) {
            const p = r[h]
              , m = p.name;
            let y = d[m];
            if (y !== void 0)
                ++y.referenceCount,
                o[h] = y;
            else {
                if (y = o[h],
                y !== void 0) {
                    y._cacheIndex === null && (++y.referenceCount,
                    this._addInactiveBinding(y, l, m));
                    continue
                }
                const v = t && t._propertyBindings[h].binding.parsedPath;
                y = new oR(bt.create(i, m, v),p.ValueTypeName,p.getValueSize()),
                ++y.referenceCount,
                this._addInactiveBinding(y, l, m),
                o[h] = y
            }
            a[h].resultBuffer = y.buffer
        }
    }
    _activateAction(e) {
        if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
                const i = (e._localRoot || this._root).uuid
                  , r = e._clip.uuid
                  , s = this._actionsByClip[r];
                this._bindAction(e, s && s.knownActions[0]),
                this._addInactiveAction(e, r, i)
            }
            const t = e._propertyBindings;
            for (let i = 0, r = t.length; i !== r; ++i) {
                const s = t[i];
                s.useCount++ === 0 && (this._lendBinding(s),
                s.saveOriginalState())
            }
            this._lendAction(e)
        }
    }
    _deactivateAction(e) {
        if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let i = 0, r = t.length; i !== r; ++i) {
                const s = t[i];
                --s.useCount === 0 && (s.restoreOriginalState(),
                this._takeBackBinding(s))
            }
            this._takeBackAction(e)
        }
    }
    _initMemoryManager() {
        this._actions = [],
        this._nActiveActions = 0,
        this._actionsByClip = {},
        this._bindings = [],
        this._nActiveBindings = 0,
        this._bindingsByRootAndName = {},
        this._controlInterpolants = [],
        this._nActiveControlInterpolants = 0;
        const e = this;
        this.stats = {
            actions: {
                get total() {
                    return e._actions.length
                },
                get inUse() {
                    return e._nActiveActions
                }
            },
            bindings: {
                get total() {
                    return e._bindings.length
                },
                get inUse() {
                    return e._nActiveBindings
                }
            },
            controlInterpolants: {
                get total() {
                    return e._controlInterpolants.length
                },
                get inUse() {
                    return e._nActiveControlInterpolants
                }
            }
        }
    }
    _isActiveAction(e) {
        const t = e._cacheIndex;
        return t !== null && t < this._nActiveActions
    }
    _addInactiveAction(e, t, i) {
        const r = this._actions
          , s = this._actionsByClip;
        let o = s[t];
        if (o === void 0)
            o = {
                knownActions: [e],
                actionByRoot: {}
            },
            e._byClipCacheIndex = 0,
            s[t] = o;
        else {
            const a = o.knownActions;
            e._byClipCacheIndex = a.length,
            a.push(e)
        }
        e._cacheIndex = r.length,
        r.push(e),
        o.actionByRoot[i] = e
    }
    _removeInactiveAction(e) {
        const t = this._actions
          , i = t[t.length - 1]
          , r = e._cacheIndex;
        i._cacheIndex = r,
        t[r] = i,
        t.pop(),
        e._cacheIndex = null;
        const s = e._clip.uuid
          , o = this._actionsByClip
          , a = o[s]
          , l = a.knownActions
          , c = l[l.length - 1]
          , d = e._byClipCacheIndex;
        c._byClipCacheIndex = d,
        l[d] = c,
        l.pop(),
        e._byClipCacheIndex = null;
        const h = a.actionByRoot
          , p = (e._localRoot || this._root).uuid;
        delete h[p],
        l.length === 0 && delete o[s],
        this._removeInactiveBindingsForAction(e)
    }
    _removeInactiveBindingsForAction(e) {
        const t = e._propertyBindings;
        for (let i = 0, r = t.length; i !== r; ++i) {
            const s = t[i];
            --s.referenceCount === 0 && this._removeInactiveBinding(s)
        }
    }
    _lendAction(e) {
        const t = this._actions
          , i = e._cacheIndex
          , r = this._nActiveActions++
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _takeBackAction(e) {
        const t = this._actions
          , i = e._cacheIndex
          , r = --this._nActiveActions
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _addInactiveBinding(e, t, i) {
        const r = this._bindingsByRootAndName
          , s = this._bindings;
        let o = r[t];
        o === void 0 && (o = {},
        r[t] = o),
        o[i] = e,
        e._cacheIndex = s.length,
        s.push(e)
    }
    _removeInactiveBinding(e) {
        const t = this._bindings
          , i = e.binding
          , r = i.rootNode.uuid
          , s = i.path
          , o = this._bindingsByRootAndName
          , a = o[r]
          , l = t[t.length - 1]
          , c = e._cacheIndex;
        l._cacheIndex = c,
        t[c] = l,
        t.pop(),
        delete a[s],
        Object.keys(a).length === 0 && delete o[r]
    }
    _lendBinding(e) {
        const t = this._bindings
          , i = e._cacheIndex
          , r = this._nActiveBindings++
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _takeBackBinding(e) {
        const t = this._bindings
          , i = e._cacheIndex
          , r = --this._nActiveBindings
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _lendControlInterpolant() {
        const e = this._controlInterpolants
          , t = this._nActiveControlInterpolants++;
        let i = e[t];
        return i === void 0 && (i = new VA(new Float32Array(2),new Float32Array(2),1,z9),
        i.__cacheIndex = t,
        e[t] = i),
        i
    }
    _takeBackControlInterpolant(e) {
        const t = this._controlInterpolants
          , i = e.__cacheIndex
          , r = --this._nActiveControlInterpolants
          , s = t[r];
        e.__cacheIndex = r,
        t[r] = e,
        s.__cacheIndex = i,
        t[i] = s
    }
    clipAction(e, t, i) {
        const r = t || this._root
          , s = r.uuid;
        let o = typeof e == "string" ? Wu.findByName(r, e) : e;
        const a = o !== null ? o.uuid : e
          , l = this._actionsByClip[a];
        let c = null;
        if (i === void 0 && (o !== null ? i = o.blendMode : i = Yg),
        l !== void 0) {
            const h = l.actionByRoot[s];
            if (h !== void 0 && h.blendMode === i)
                return h;
            c = l.knownActions[0],
            o === null && (o = c._clip)
        }
        if (o === null)
            return null;
        const d = new U9(this,o,t,i);
        return this._bindAction(d, c),
        this._addInactiveAction(d, a, s),
        d
    }
    existingAction(e, t) {
        const i = t || this._root
          , r = i.uuid
          , s = typeof e == "string" ? Wu.findByName(i, e) : e
          , o = s ? s.uuid : e
          , a = this._actionsByClip[o];
        return a !== void 0 && a.actionByRoot[r] || null
    }
    stopAllAction() {
        const e = this._actions
          , t = this._nActiveActions;
        for (let i = t - 1; i >= 0; --i)
            e[i].stop();
        return this
    }
    update(e) {
        e *= this.timeScale;
        const t = this._actions
          , i = this._nActiveActions
          , r = this.time += e
          , s = Math.sign(e)
          , o = this._accuIndex ^= 1;
        for (let c = 0; c !== i; ++c)
            t[c]._update(r, e, s, o);
        const a = this._bindings
          , l = this._nActiveBindings;
        for (let c = 0; c !== l; ++c)
            a[c].apply(o);
        return this
    }
    setTime(e) {
        this.time = 0;
        for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0;
        return this.update(e)
    }
    getRoot() {
        return this._root
    }
    uncacheClip(e) {
        const t = this._actions
          , i = e.uuid
          , r = this._actionsByClip
          , s = r[i];
        if (s !== void 0) {
            const o = s.knownActions;
            for (let a = 0, l = o.length; a !== l; ++a) {
                const c = o[a];
                this._deactivateAction(c);
                const d = c._cacheIndex
                  , h = t[t.length - 1];
                c._cacheIndex = null,
                c._byClipCacheIndex = null,
                h._cacheIndex = d,
                t[d] = h,
                t.pop(),
                this._removeInactiveBindingsForAction(c)
            }
            delete r[i]
        }
    }
    uncacheRoot(e) {
        const t = e.uuid
          , i = this._actionsByClip;
        for (const o in i) {
            const a = i[o].actionByRoot
              , l = a[t];
            l !== void 0 && (this._deactivateAction(l),
            this._removeInactiveAction(l))
        }
        const r = this._bindingsByRootAndName
          , s = r[t];
        if (s !== void 0)
            for (const o in s) {
                const a = s[o];
                a.restoreOriginalState(),
                this._removeInactiveBinding(a)
            }
    }
    uncacheAction(e, t) {
        const i = this.existingAction(e, t);
        i !== null && (this._deactivateAction(i),
        this._removeInactiveAction(i))
    }
}
class eM {
    constructor(e) {
        this.value = e
    }
    clone() {
        return new eM(this.value.clone === void 0 ? this.value : this.value.clone())
    }
}
let H9 = 0;
class V9 extends cs {
    constructor() {
        super(),
        this.isUniformsGroup = !0,
        Object.defineProperty(this, "id", {
            value: H9++
        }),
        this.name = "",
        this.usage = nd,
        this.uniforms = []
    }
    add(e) {
        return this.uniforms.push(e),
        this
    }
    remove(e) {
        const t = this.uniforms.indexOf(e);
        return t !== -1 && this.uniforms.splice(t, 1),
        this
    }
    setName(e) {
        return this.name = e,
        this
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    dispose() {
        return this.dispatchEvent({
            type: "dispose"
        }),
        this
    }
    copy(e) {
        this.name = e.name,
        this.usage = e.usage;
        const t = e.uniforms;
        this.uniforms.length = 0;
        for (let i = 0, r = t.length; i < r; i++)
            this.uniforms.push(t[i].clone());
        return this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class W9 extends Bd {
    constructor(e, t, i=1) {
        super(e, t),
        this.isInstancedInterleavedBuffer = !0,
        this.meshPerAttribute = i
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    clone(e) {
        const t = super.clone(e);
        return t.meshPerAttribute = this.meshPerAttribute,
        t
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.isInstancedInterleavedBuffer = !0,
        t.meshPerAttribute = this.meshPerAttribute,
        t
    }
}
class j9 {
    constructor(e, t, i, r, s) {
        this.isGLBufferAttribute = !0,
        this.name = "",
        this.buffer = e,
        this.type = t,
        this.itemSize = i,
        this.elementSize = r,
        this.count = s,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setBuffer(e) {
        return this.buffer = e,
        this
    }
    setType(e, t) {
        return this.type = e,
        this.elementSize = t,
        this
    }
    setItemSize(e) {
        return this.itemSize = e,
        this
    }
    setCount(e) {
        return this.count = e,
        this
    }
}
class aR {
    constructor(e, t, i=0, r=1 / 0) {
        this.ray = new Ed(e,t),
        this.near = i,
        this.far = r,
        this.camera = null,
        this.layers = new $a,
        this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }
    }
    set(e, t) {
        this.ray.set(e, t)
    }
    setFromCamera(e, t) {
        t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
        this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
    }
    intersectObject(e, t=!0, i=[]) {
        return O1(e, this, i, t),
        i.sort(QE),
        i
    }
    intersectObjects(e, t=!0, i=[]) {
        for (let r = 0, s = e.length; r < s; r++)
            O1(e[r], this, i, t);
        return i.sort(QE),
        i
    }
}
function QE(n, e) {
    return n.distance - e.distance
}
function O1(n, e, t, i) {
    if (n.layers.test(e.layers) && n.raycast(e, t),
    i === !0) {
        const r = n.children;
        for (let s = 0, o = r.length; s < o; s++)
            O1(r[s], e, t, !0)
    }
}
class U1 {
    constructor(e=1, t=0, i=0) {
        return this.radius = e,
        this.phi = t,
        this.theta = i,
        this
    }
    set(e, t, i) {
        return this.radius = e,
        this.phi = t,
        this.theta = i,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.phi = e.phi,
        this.theta = e.theta,
        this
    }
    makeSafe() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, i) {
        return this.radius = Math.sqrt(e * e + t * t + i * i),
        this.radius === 0 ? (this.theta = 0,
        this.phi = 0) : (this.theta = Math.atan2(e, i),
        this.phi = Math.acos(vn(t / this.radius, -1, 1))),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class J9 {
    constructor(e=1, t=0, i=0) {
        return this.radius = e,
        this.theta = t,
        this.y = i,
        this
    }
    set(e, t, i) {
        return this.radius = e,
        this.theta = t,
        this.y = i,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.theta = e.theta,
        this.y = e.y,
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, i) {
        return this.radius = Math.sqrt(e * e + i * i),
        this.theta = Math.atan2(e, i),
        this.y = t,
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const ZE = new pe;
class X9 {
    constructor(e=new pe(1 / 0,1 / 0), t=new pe(-1 / 0,-1 / 0)) {
        this.isBox2 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const i = ZE.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(i),
        this.max.copy(e).add(i),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = 1 / 0,
        this.max.x = this.max.y = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return ZE.copy(e).clamp(this.min, this.max).sub(e).length()
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const qE = new D
  , Xp = new D;
class K9 {
    constructor(e=new D, t=new D) {
        this.start = e,
        this.end = t
    }
    set(e, t) {
        return this.start.copy(e),
        this.end.copy(t),
        this
    }
    copy(e) {
        return this.start.copy(e.start),
        this.end.copy(e.end),
        this
    }
    getCenter(e) {
        return e.addVectors(this.start, this.end).multiplyScalar(.5)
    }
    delta(e) {
        return e.subVectors(this.end, this.start)
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end)
    }
    distance() {
        return this.start.distanceTo(this.end)
    }
    at(e, t) {
        return this.delta(t).multiplyScalar(e).add(this.start)
    }
    closestPointToPointParameter(e, t) {
        qE.subVectors(e, this.start),
        Xp.subVectors(this.end, this.start);
        const i = Xp.dot(Xp);
        let s = Xp.dot(qE) / i;
        return t && (s = vn(s, 0, 1)),
        s
    }
    closestPointToPoint(e, t, i) {
        const r = this.closestPointToPointParameter(e, t);
        return this.delta(i).multiplyScalar(r).add(this.start)
    }
    applyMatrix4(e) {
        return this.start.applyMatrix4(e),
        this.end.applyMatrix4(e),
        this
    }
    equals(e) {
        return e.start.equals(this.start) && e.end.equals(this.end)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const $E = new D;
class Y9 extends Rt {
    constructor(e, t) {
        super(),
        this.light = e,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = t,
        this.type = "SpotLightHelper";
        const i = new ct
          , r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (let o = 0, a = 1, l = 32; o < l; o++,
        a++) {
            const c = o / l * Math.PI * 2
              , d = a / l * Math.PI * 2;
            r.push(Math.cos(c), Math.sin(c), 1, Math.cos(d), Math.sin(d), 1)
        }
        i.setAttribute("position", new je(r,3));
        const s = new ri({
            fog: !1,
            toneMapped: !1
        });
        this.cone = new Gr(i,s),
        this.add(this.cone),
        this.update()
    }
    dispose() {
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.light.target.updateWorldMatrix(!0, !1);
        const e = this.light.distance ? this.light.distance : 1e3
          , t = e * Math.tan(this.light.angle);
        this.cone.scale.set(t, t, e),
        $E.setFromMatrixPosition(this.light.target.matrixWorld),
        this.cone.lookAt($E),
        this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    }
}
const ho = new D
  , Kp = new rt
  , Pv = new rt;
class Q9 extends Gr {
    constructor(e) {
        const t = lR(e)
          , i = new ct
          , r = []
          , s = []
          , o = new Le(0,0,1)
          , a = new Le(0,1,0);
        for (let c = 0; c < t.length; c++) {
            const d = t[c];
            d.parent && d.parent.isBone && (r.push(0, 0, 0),
            r.push(0, 0, 0),
            s.push(o.r, o.g, o.b),
            s.push(a.r, a.g, a.b))
        }
        i.setAttribute("position", new je(r,3)),
        i.setAttribute("color", new je(s,3));
        const l = new ri({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0
        });
        super(i, l),
        this.isSkeletonHelper = !0,
        this.type = "SkeletonHelper",
        this.root = e,
        this.bones = t,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1
    }
    updateMatrixWorld(e) {
        const t = this.bones
          , i = this.geometry
          , r = i.getAttribute("position");
        Pv.copy(this.root.matrixWorld).invert();
        for (let s = 0, o = 0; s < t.length; s++) {
            const a = t[s];
            a.parent && a.parent.isBone && (Kp.multiplyMatrices(Pv, a.matrixWorld),
            ho.setFromMatrixPosition(Kp),
            r.setXYZ(o, ho.x, ho.y, ho.z),
            Kp.multiplyMatrices(Pv, a.parent.matrixWorld),
            ho.setFromMatrixPosition(Kp),
            r.setXYZ(o + 1, ho.x, ho.y, ho.z),
            o += 2)
        }
        i.getAttribute("position").needsUpdate = !0,
        super.updateMatrixWorld(e)
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
function lR(n) {
    const e = [];
    n.isBone === !0 && e.push(n);
    for (let t = 0; t < n.children.length; t++)
        e.push.apply(e, lR(n.children[t]));
    return e
}
class Z9 extends Un {
    constructor(e, t, i) {
        const r = new ic(t,4,2)
          , s = new Gi({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        });
        super(r, s),
        this.light = e,
        this.color = i,
        this.type = "PointLightHelper",
        this.matrix = this.light.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.update()
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
}
const q9 = new D
  , eT = new Le
  , tT = new Le;
class $9 extends Rt {
    constructor(e, t, i) {
        super(),
        this.light = e,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = i,
        this.type = "HemisphereLightHelper";
        const r = new nc(t);
        r.rotateY(Math.PI * .5),
        this.material = new Gi({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        }),
        this.color === void 0 && (this.material.vertexColors = !0);
        const s = r.getAttribute("position")
          , o = new Float32Array(s.count * 3);
        r.setAttribute("color", new Ft(o,3)),
        this.add(new Un(r,this.material)),
        this.update()
    }
    dispose() {
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    update() {
        const e = this.children[0];
        if (this.color !== void 0)
            this.material.color.set(this.color);
        else {
            const t = e.geometry.getAttribute("color");
            eT.copy(this.light.color),
            tT.copy(this.light.groundColor);
            for (let i = 0, r = t.count; i < r; i++) {
                const s = i < r / 2 ? eT : tT;
                t.setXYZ(i, s.r, s.g, s.b)
            }
            t.needsUpdate = !0
        }
        this.light.updateWorldMatrix(!0, !1),
        e.lookAt(q9.setFromMatrixPosition(this.light.matrixWorld).negate())
    }
}
class eH extends Gr {
    constructor(e=10, t=10, i=4473924, r=8947848) {
        i = new Le(i),
        r = new Le(r);
        const s = t / 2
          , o = e / t
          , a = e / 2
          , l = []
          , c = [];
        for (let p = 0, m = 0, y = -a; p <= t; p++,
        y += o) {
            l.push(-a, 0, y, a, 0, y),
            l.push(y, 0, -a, y, 0, a);
            const v = p === s ? i : r;
            v.toArray(c, m),
            m += 3,
            v.toArray(c, m),
            m += 3,
            v.toArray(c, m),
            m += 3,
            v.toArray(c, m),
            m += 3
        }
        const d = new ct;
        d.setAttribute("position", new je(l,3)),
        d.setAttribute("color", new je(c,3));
        const h = new ri({
            vertexColors: !0,
            toneMapped: !1
        });
        super(d, h),
        this.type = "GridHelper"
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class tH extends Gr {
    constructor(e=10, t=16, i=8, r=64, s=4473924, o=8947848) {
        s = new Le(s),
        o = new Le(o);
        const a = []
          , l = [];
        if (t > 1)
            for (let h = 0; h < t; h++) {
                const p = h / t * (Math.PI * 2)
                  , m = Math.sin(p) * e
                  , y = Math.cos(p) * e;
                a.push(0, 0, 0),
                a.push(m, 0, y);
                const v = h & 1 ? s : o;
                l.push(v.r, v.g, v.b),
                l.push(v.r, v.g, v.b)
            }
        for (let h = 0; h < i; h++) {
            const p = h & 1 ? s : o
              , m = e - e / i * h;
            for (let y = 0; y < r; y++) {
                let v = y / r * (Math.PI * 2)
                  , _ = Math.sin(v) * m
                  , x = Math.cos(v) * m;
                a.push(_, 0, x),
                l.push(p.r, p.g, p.b),
                v = (y + 1) / r * (Math.PI * 2),
                _ = Math.sin(v) * m,
                x = Math.cos(v) * m,
                a.push(_, 0, x),
                l.push(p.r, p.g, p.b)
            }
        }
        const c = new ct;
        c.setAttribute("position", new je(a,3)),
        c.setAttribute("color", new je(l,3));
        const d = new ri({
            vertexColors: !0,
            toneMapped: !1
        });
        super(c, d),
        this.type = "PolarGridHelper"
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
const nT = new D
  , Yp = new D
  , iT = new D;
class nH extends Rt {
    constructor(e, t, i) {
        super(),
        this.light = e,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = i,
        this.type = "DirectionalLightHelper",
        t === void 0 && (t = 1);
        let r = new ct;
        r.setAttribute("position", new je([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0],3));
        const s = new ri({
            fog: !1,
            toneMapped: !1
        });
        this.lightPlane = new Ks(r,s),
        this.add(this.lightPlane),
        r = new ct,
        r.setAttribute("position", new je([0, 0, 0, 0, 0, 1],3)),
        this.targetLine = new Ks(r,s),
        this.add(this.targetLine),
        this.update()
    }
    dispose() {
        this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.light.target.updateWorldMatrix(!0, !1),
        nT.setFromMatrixPosition(this.light.matrixWorld),
        Yp.setFromMatrixPosition(this.light.target.matrixWorld),
        iT.subVectors(Yp, nT),
        this.lightPlane.lookAt(Yp),
        this.color !== void 0 ? (this.lightPlane.material.color.set(this.color),
        this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
        this.targetLine.material.color.copy(this.light.color)),
        this.targetLine.lookAt(Yp),
        this.targetLine.scale.z = iT.length()
    }
}
const Qp = new D
  , fn = new bd;
class iH extends Gr {
    constructor(e) {
        const t = new ct
          , i = new ri({
            color: 16777215,
            vertexColors: !0,
            toneMapped: !1
        })
          , r = []
          , s = []
          , o = {};
        a("n1", "n2"),
        a("n2", "n4"),
        a("n4", "n3"),
        a("n3", "n1"),
        a("f1", "f2"),
        a("f2", "f4"),
        a("f4", "f3"),
        a("f3", "f1"),
        a("n1", "f1"),
        a("n2", "f2"),
        a("n3", "f3"),
        a("n4", "f4"),
        a("p", "n1"),
        a("p", "n2"),
        a("p", "n3"),
        a("p", "n4"),
        a("u1", "u2"),
        a("u2", "u3"),
        a("u3", "u1"),
        a("c", "t"),
        a("p", "c"),
        a("cn1", "cn2"),
        a("cn3", "cn4"),
        a("cf1", "cf2"),
        a("cf3", "cf4");
        function a(y, v) {
            l(y),
            l(v)
        }
        function l(y) {
            r.push(0, 0, 0),
            s.push(0, 0, 0),
            o[y] === void 0 && (o[y] = []),
            o[y].push(r.length / 3 - 1)
        }
        t.setAttribute("position", new je(r,3)),
        t.setAttribute("color", new je(s,3)),
        super(t, i),
        this.type = "CameraHelper",
        this.camera = e,
        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.pointMap = o,
        this.update();
        const c = new Le(16755200)
          , d = new Le(16711680)
          , h = new Le(43775)
          , p = new Le(16777215)
          , m = new Le(3355443);
        this.setColors(c, d, h, p, m)
    }
    setColors(e, t, i, r, s) {
        const a = this.geometry.getAttribute("color");
        a.setXYZ(0, e.r, e.g, e.b),
        a.setXYZ(1, e.r, e.g, e.b),
        a.setXYZ(2, e.r, e.g, e.b),
        a.setXYZ(3, e.r, e.g, e.b),
        a.setXYZ(4, e.r, e.g, e.b),
        a.setXYZ(5, e.r, e.g, e.b),
        a.setXYZ(6, e.r, e.g, e.b),
        a.setXYZ(7, e.r, e.g, e.b),
        a.setXYZ(8, e.r, e.g, e.b),
        a.setXYZ(9, e.r, e.g, e.b),
        a.setXYZ(10, e.r, e.g, e.b),
        a.setXYZ(11, e.r, e.g, e.b),
        a.setXYZ(12, e.r, e.g, e.b),
        a.setXYZ(13, e.r, e.g, e.b),
        a.setXYZ(14, e.r, e.g, e.b),
        a.setXYZ(15, e.r, e.g, e.b),
        a.setXYZ(16, e.r, e.g, e.b),
        a.setXYZ(17, e.r, e.g, e.b),
        a.setXYZ(18, e.r, e.g, e.b),
        a.setXYZ(19, e.r, e.g, e.b),
        a.setXYZ(20, e.r, e.g, e.b),
        a.setXYZ(21, e.r, e.g, e.b),
        a.setXYZ(22, e.r, e.g, e.b),
        a.setXYZ(23, e.r, e.g, e.b),
        a.setXYZ(24, t.r, t.g, t.b),
        a.setXYZ(25, t.r, t.g, t.b),
        a.setXYZ(26, t.r, t.g, t.b),
        a.setXYZ(27, t.r, t.g, t.b),
        a.setXYZ(28, t.r, t.g, t.b),
        a.setXYZ(29, t.r, t.g, t.b),
        a.setXYZ(30, t.r, t.g, t.b),
        a.setXYZ(31, t.r, t.g, t.b),
        a.setXYZ(32, i.r, i.g, i.b),
        a.setXYZ(33, i.r, i.g, i.b),
        a.setXYZ(34, i.r, i.g, i.b),
        a.setXYZ(35, i.r, i.g, i.b),
        a.setXYZ(36, i.r, i.g, i.b),
        a.setXYZ(37, i.r, i.g, i.b),
        a.setXYZ(38, r.r, r.g, r.b),
        a.setXYZ(39, r.r, r.g, r.b),
        a.setXYZ(40, s.r, s.g, s.b),
        a.setXYZ(41, s.r, s.g, s.b),
        a.setXYZ(42, s.r, s.g, s.b),
        a.setXYZ(43, s.r, s.g, s.b),
        a.setXYZ(44, s.r, s.g, s.b),
        a.setXYZ(45, s.r, s.g, s.b),
        a.setXYZ(46, s.r, s.g, s.b),
        a.setXYZ(47, s.r, s.g, s.b),
        a.setXYZ(48, s.r, s.g, s.b),
        a.setXYZ(49, s.r, s.g, s.b),
        a.needsUpdate = !0
    }
    update() {
        const e = this.geometry
          , t = this.pointMap
          , i = 1
          , r = 1;
        fn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
        gn("c", t, e, fn, 0, 0, -1),
        gn("t", t, e, fn, 0, 0, 1),
        gn("n1", t, e, fn, -i, -r, -1),
        gn("n2", t, e, fn, i, -r, -1),
        gn("n3", t, e, fn, -i, r, -1),
        gn("n4", t, e, fn, i, r, -1),
        gn("f1", t, e, fn, -i, -r, 1),
        gn("f2", t, e, fn, i, -r, 1),
        gn("f3", t, e, fn, -i, r, 1),
        gn("f4", t, e, fn, i, r, 1),
        gn("u1", t, e, fn, i * .7, r * 1.1, -1),
        gn("u2", t, e, fn, -i * .7, r * 1.1, -1),
        gn("u3", t, e, fn, 0, r * 2, -1),
        gn("cf1", t, e, fn, -i, 0, 1),
        gn("cf2", t, e, fn, i, 0, 1),
        gn("cf3", t, e, fn, 0, -r, 1),
        gn("cf4", t, e, fn, 0, r, 1),
        gn("cn1", t, e, fn, -i, 0, -1),
        gn("cn2", t, e, fn, i, 0, -1),
        gn("cn3", t, e, fn, 0, -r, -1),
        gn("cn4", t, e, fn, 0, r, -1),
        e.getAttribute("position").needsUpdate = !0
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
function gn(n, e, t, i, r, s, o) {
    Qp.set(r, s, o).unproject(i);
    const a = e[n];
    if (a !== void 0) {
        const l = t.getAttribute("position");
        for (let c = 0, d = a.length; c < d; c++)
            l.setXYZ(a[c], Qp.x, Qp.y, Qp.z)
    }
}
const Zp = new ta;
class rH extends Gr {
    constructor(e, t=16776960) {
        const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , r = new Float32Array(8 * 3)
          , s = new ct;
        s.setIndex(new Ft(i,1)),
        s.setAttribute("position", new Ft(r,3)),
        super(s, new ri({
            color: t,
            toneMapped: !1
        })),
        this.object = e,
        this.type = "BoxHelper",
        this.matrixAutoUpdate = !1,
        this.update()
    }
    update(e) {
        if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
        this.object !== void 0 && Zp.setFromObject(this.object),
        Zp.isEmpty())
            return;
        const t = Zp.min
          , i = Zp.max
          , r = this.geometry.attributes.position
          , s = r.array;
        s[0] = i.x,
        s[1] = i.y,
        s[2] = i.z,
        s[3] = t.x,
        s[4] = i.y,
        s[5] = i.z,
        s[6] = t.x,
        s[7] = t.y,
        s[8] = i.z,
        s[9] = i.x,
        s[10] = t.y,
        s[11] = i.z,
        s[12] = i.x,
        s[13] = i.y,
        s[14] = t.z,
        s[15] = t.x,
        s[16] = i.y,
        s[17] = t.z,
        s[18] = t.x,
        s[19] = t.y,
        s[20] = t.z,
        s[21] = i.x,
        s[22] = t.y,
        s[23] = t.z,
        r.needsUpdate = !0,
        this.geometry.computeBoundingSphere()
    }
    setFromObject(e) {
        return this.object = e,
        this.update(),
        this
    }
    copy(e, t) {
        return super.copy(e, t),
        this.object = e.object,
        this
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class sH extends Gr {
    constructor(e, t=16776960) {
        const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1]
          , s = new ct;
        s.setIndex(new Ft(i,1)),
        s.setAttribute("position", new je(r,3)),
        super(s, new ri({
            color: t,
            toneMapped: !1
        })),
        this.box = e,
        this.type = "Box3Helper",
        this.geometry.computeBoundingSphere()
    }
    updateMatrixWorld(e) {
        const t = this.box;
        t.isEmpty() || (t.getCenter(this.position),
        t.getSize(this.scale),
        this.scale.multiplyScalar(.5),
        super.updateMatrixWorld(e))
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class oH extends Ks {
    constructor(e, t=1, i=16776960) {
        const r = i
          , s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0]
          , o = new ct;
        o.setAttribute("position", new je(s,3)),
        o.computeBoundingSphere(),
        super(o, new ri({
            color: r,
            toneMapped: !1
        })),
        this.type = "PlaneHelper",
        this.plane = e,
        this.size = t;
        const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0]
          , l = new ct;
        l.setAttribute("position", new je(a,3)),
        l.computeBoundingSphere(),
        this.add(new Un(l,new Gi({
            color: r,
            opacity: .2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1
        })))
    }
    updateMatrixWorld(e) {
        this.position.set(0, 0, 0),
        this.scale.set(.5 * this.size, .5 * this.size, 1),
        this.lookAt(this.plane.normal),
        this.translateZ(-this.plane.constant),
        super.updateMatrixWorld(e)
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose(),
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
}
const rT = new D;
let qp, Bv;
class aH extends Rt {
    constructor(e=new D(0,0,1), t=new D(0,0,0), i=1, r=16776960, s=i * .2, o=s * .2) {
        super(),
        this.type = "ArrowHelper",
        qp === void 0 && (qp = new ct,
        qp.setAttribute("position", new je([0, 0, 0, 0, 1, 0],3)),
        Bv = new hl(0,.5,1,5,1),
        Bv.translate(0, -.5, 0)),
        this.position.copy(t),
        this.line = new Ks(qp,new ri({
            color: r,
            toneMapped: !1
        })),
        this.line.matrixAutoUpdate = !1,
        this.add(this.line),
        this.cone = new Un(Bv,new Gi({
            color: r,
            toneMapped: !1
        })),
        this.cone.matrixAutoUpdate = !1,
        this.add(this.cone),
        this.setDirection(e),
        this.setLength(i, s, o)
    }
    setDirection(e) {
        if (e.y > .99999)
            this.quaternion.set(0, 0, 0, 1);
        else if (e.y < -.99999)
            this.quaternion.set(1, 0, 0, 0);
        else {
            rT.set(e.z, 0, -e.x).normalize();
            const t = Math.acos(e.y);
            this.quaternion.setFromAxisAngle(rT, t)
        }
    }
    setLength(e, t=e * .2, i=t * .2) {
        this.line.scale.set(1, Math.max(1e-4, e - t), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(i, t, i),
        this.cone.position.y = e,
        this.cone.updateMatrix()
    }
    setColor(e) {
        this.line.material.color.set(e),
        this.cone.material.color.set(e)
    }
    copy(e) {
        return super.copy(e, !1),
        this.line.copy(e.line),
        this.cone.copy(e.cone),
        this
    }
    dispose() {
        this.line.geometry.dispose(),
        this.line.material.dispose(),
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
}
class lH extends Gr {
    constructor(e=1) {
        const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]
          , i = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]
          , r = new ct;
        r.setAttribute("position", new je(t,3)),
        r.setAttribute("color", new je(i,3));
        const s = new ri({
            vertexColors: !0,
            toneMapped: !1
        });
        super(r, s),
        this.type = "AxesHelper"
    }
    setColors(e, t, i) {
        const r = new Le
          , s = this.geometry.attributes.color.array;
        return r.set(e),
        r.toArray(s, 0),
        r.toArray(s, 3),
        r.set(t),
        r.toArray(s, 6),
        r.toArray(s, 9),
        r.set(i),
        r.toArray(s, 12),
        r.toArray(s, 15),
        this.geometry.attributes.color.needsUpdate = !0,
        this
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class uH {
    constructor() {
        this.type = "ShapePath",
        this.color = new Le,
        this.subPaths = [],
        this.currentPath = null
    }
    moveTo(e, t) {
        return this.currentPath = new sd,
        this.subPaths.push(this.currentPath),
        this.currentPath.moveTo(e, t),
        this
    }
    lineTo(e, t) {
        return this.currentPath.lineTo(e, t),
        this
    }
    quadraticCurveTo(e, t, i, r) {
        return this.currentPath.quadraticCurveTo(e, t, i, r),
        this
    }
    bezierCurveTo(e, t, i, r, s, o) {
        return this.currentPath.bezierCurveTo(e, t, i, r, s, o),
        this
    }
    splineThru(e) {
        return this.currentPath.splineThru(e),
        this
    }
    toShapes(e) {
        function t(x) {
            const A = [];
            for (let M = 0, S = x.length; M < S; M++) {
                const T = x[M]
                  , P = new el;
                P.curves = T.curves,
                A.push(P)
            }
            return A
        }
        function i(x, A) {
            const M = A.length;
            let S = !1;
            for (let T = M - 1, P = 0; P < M; T = P++) {
                let R = A[T]
                  , E = A[P]
                  , B = E.x - R.x
                  , L = E.y - R.y;
                if (Math.abs(L) > Number.EPSILON) {
                    if (L < 0 && (R = A[P],
                    B = -B,
                    E = A[T],
                    L = -L),
                    x.y < R.y || x.y > E.y)
                        continue;
                    if (x.y === R.y) {
                        if (x.x === R.x)
                            return !0
                    } else {
                        const z = L * (x.x - R.x) - B * (x.y - R.y);
                        if (z === 0)
                            return !0;
                        if (z < 0)
                            continue;
                        S = !S
                    }
                } else {
                    if (x.y !== R.y)
                        continue;
                    if (E.x <= x.x && x.x <= R.x || R.x <= x.x && x.x <= E.x)
                        return !0
                }
            }
            return S
        }
        const r = rs.isClockWise
          , s = this.subPaths;
        if (s.length === 0)
            return [];
        let o, a, l;
        const c = [];
        if (s.length === 1)
            return a = s[0],
            l = new el,
            l.curves = a.curves,
            c.push(l),
            c;
        let d = !r(s[0].getPoints());
        d = e ? !d : d;
        const h = []
          , p = [];
        let m = [], y = 0, v;
        p[y] = void 0,
        m[y] = [];
        for (let x = 0, A = s.length; x < A; x++)
            a = s[x],
            v = a.getPoints(),
            o = r(v),
            o = e ? !o : o,
            o ? (!d && p[y] && y++,
            p[y] = {
                s: new el,
                p: v
            },
            p[y].s.curves = a.curves,
            d && y++,
            m[y] = []) : m[y].push({
                h: a,
                p: v[0]
            });
        if (!p[0])
            return t(s);
        if (p.length > 1) {
            let x = !1
              , A = 0;
            for (let M = 0, S = p.length; M < S; M++)
                h[M] = [];
            for (let M = 0, S = p.length; M < S; M++) {
                const T = m[M];
                for (let P = 0; P < T.length; P++) {
                    const R = T[P];
                    let E = !0;
                    for (let B = 0; B < p.length; B++)
                        i(R.p, p[B].p) && (M !== B && A++,
                        E ? (E = !1,
                        h[B].push(R)) : x = !0);
                    E && h[M].push(R)
                }
            }
            A > 0 && x === !1 && (m = h)
        }
        let _;
        for (let x = 0, A = p.length; x < A; x++) {
            l = p[x].s,
            c.push(l),
            _ = m[x];
            for (let M = 0, S = _.length; M < S; M++)
                l.holes.push(_[M].h)
        }
        return c
    }
}
const Bs = cH();
function cH() {
    const n = new ArrayBuffer(4)
      , e = new Float32Array(n)
      , t = new Uint32Array(n)
      , i = new Uint32Array(512)
      , r = new Uint32Array(512);
    for (let l = 0; l < 256; ++l) {
        const c = l - 127;
        c < -27 ? (i[l] = 0,
        i[l | 256] = 32768,
        r[l] = 24,
        r[l | 256] = 24) : c < -14 ? (i[l] = 1024 >> -c - 14,
        i[l | 256] = 1024 >> -c - 14 | 32768,
        r[l] = -c - 1,
        r[l | 256] = -c - 1) : c <= 15 ? (i[l] = c + 15 << 10,
        i[l | 256] = c + 15 << 10 | 32768,
        r[l] = 13,
        r[l | 256] = 13) : c < 128 ? (i[l] = 31744,
        i[l | 256] = 64512,
        r[l] = 24,
        r[l | 256] = 24) : (i[l] = 31744,
        i[l | 256] = 64512,
        r[l] = 13,
        r[l | 256] = 13)
    }
    const s = new Uint32Array(2048)
      , o = new Uint32Array(64)
      , a = new Uint32Array(64);
    for (let l = 1; l < 1024; ++l) {
        let c = l << 13
          , d = 0;
        for (; !(c & 8388608); )
            c <<= 1,
            d -= 8388608;
        c &= -8388609,
        d += 947912704,
        s[l] = c | d
    }
    for (let l = 1024; l < 2048; ++l)
        s[l] = 939524096 + (l - 1024 << 13);
    for (let l = 1; l < 31; ++l)
        o[l] = l << 23;
    o[31] = 1199570944,
    o[32] = 2147483648;
    for (let l = 33; l < 63; ++l)
        o[l] = 2147483648 + (l - 32 << 23);
    o[63] = 3347054592;
    for (let l = 1; l < 64; ++l)
        l !== 32 && (a[l] = 1024);
    return {
        floatView: e,
        uint32View: t,
        baseTable: i,
        shiftTable: r,
        mantissaTable: s,
        exponentTable: o,
        offsetTable: a
    }
}
function fH(n) {
    Math.abs(n) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    n = vn(n, -65504, 65504),
    Bs.floatView[0] = n;
    const e = Bs.uint32View[0]
      , t = e >> 23 & 511;
    return Bs.baseTable[t] + ((e & 8388607) >> Bs.shiftTable[t])
}
function dH(n) {
    const e = n >> 10;
    return Bs.uint32View[0] = Bs.mantissaTable[Bs.offsetTable[e] + (n & 1023)] + Bs.exponentTable[e],
    Bs.floatView[0]
}
var hH = Object.freeze({
    __proto__: null,
    fromHalfFloat: dH,
    toHalfFloat: fH
});
class pH extends ia {
    constructor(e, t, i, r, s, o) {
        console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."),
        super(e, t, i, r, s, o)
    }
}
class mH extends Id {
    constructor(e, t, i, r) {
        console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."),
        super(e, t, i, r)
    }
}
class gH extends Dd {
    constructor(e, t, i, r) {
        console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."),
        super(e, t, i, r)
    }
}
class yH extends Fd {
    constructor(e, t, i, r, s, o, a) {
        console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."),
        super(e, t, i, r, s, o, a)
    }
}
class vH extends hl {
    constructor(e, t, i, r, s, o, a, l) {
        console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."),
        super(e, t, i, r, s, o, a, l)
    }
}
class xH extends kd {
    constructor(e, t) {
        console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."),
        super(e, t)
    }
}
class _H extends Nd {
    constructor(e, t) {
        console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."),
        super(e, t)
    }
}
class AH extends Od {
    constructor(e, t) {
        console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."),
        super(e, t)
    }
}
class MH extends tc {
    constructor(e, t, i, r) {
        console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."),
        super(e, t, i, r)
    }
}
class wH extends nc {
    constructor(e, t) {
        console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."),
        super(e, t)
    }
}
class SH extends $u {
    constructor(e, t, i, r) {
        console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."),
        super(e, t, i, r)
    }
}
class CH extends Zs {
    constructor(e, t, i, r) {
        console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."),
        super(e, t, i, r)
    }
}
class EH extends Ud {
    constructor(e, t, i, r, s, o) {
        console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."),
        super(e, t, i, r, s, o)
    }
}
class TH extends zd {
    constructor(e, t) {
        console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."),
        super(e, t)
    }
}
class bH extends ic {
    constructor(e, t, i, r, s, o, a) {
        console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."),
        super(e, t, i, r, s, o, a)
    }
}
class PH extends Gd {
    constructor(e, t) {
        console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."),
        super(e, t)
    }
}
class BH extends Hd {
    constructor(e, t, i, r, s) {
        console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."),
        super(e, t, i, r, s)
    }
}
class RH extends Vd {
    constructor(e, t, i, r, s, o) {
        console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."),
        super(e, t, i, r, s, o)
    }
}
class LH extends Wd {
    constructor(e, t, i, r, s) {
        console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."),
        super(e, t, i, r, s)
    }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: jg
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = jg);
const z1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    ACESFilmicToneMapping: pA,
    AddEquation: Da,
    AddOperation: k3,
    AdditiveAnimationBlendMode: gA,
    AdditiveBlending: n1,
    AlphaFormat: J3,
    AlwaysDepth: P3,
    AlwaysStencilFunc: uB,
    AmbientLight: $B,
    AmbientLightProbe: M9,
    AnimationClip: Wu,
    AnimationLoader: f9,
    AnimationMixer: G9,
    AnimationObjectGroup: O9,
    AnimationUtils: a9,
    ArcCurve: PB,
    ArrayCamera: MB,
    ArrowHelper: aH,
    Audio: sR,
    AudioAnalyser: b9,
    AudioContext: QA,
    AudioListener: C9,
    AudioLoader: _9,
    AxesHelper: lH,
    BackSide: Bi,
    BasicDepthPacking: oB,
    BasicShadowMap: m3,
    Bone: t0,
    BooleanKeyframeTrack: pl,
    Box2: X9,
    Box3: ta,
    Box3Helper: sH,
    BoxBufferGeometry: pH,
    BoxGeometry: ia,
    BoxHelper: rH,
    BufferAttribute: Ft,
    BufferGeometry: ct,
    BufferGeometryLoader: iR,
    ByteType: G3,
    Cache: ul,
    Camera: bd,
    CameraHelper: iH,
    CanvasTexture: R8,
    CapsuleBufferGeometry: mH,
    CapsuleGeometry: Id,
    CatmullRomCurve3: BB,
    CineonToneMapping: U3,
    CircleBufferGeometry: gH,
    CircleGeometry: Dd,
    ClampToEdgeWrapping: Vn,
    Clock: ZA,
    Color: Le,
    ColorKeyframeTrack: WA,
    ColorManagement: ei,
    CompressedArrayTexture: B8,
    CompressedTexture: DA,
    CompressedTextureLoader: d9,
    ConeBufferGeometry: yH,
    ConeGeometry: Fd,
    CubeCamera: wA,
    CubeReflectionMapping: Vo,
    CubeRefractionMapping: Wo,
    CubeTexture: Pd,
    CubeTextureLoader: h9,
    CubeUVReflectionMapping: qu,
    CubicBezierCurve: kA,
    CubicBezierCurve3: RB,
    CubicInterpolant: KB,
    CullFaceBack: t1,
    CullFaceFront: p3,
    CullFaceFrontBack: kO,
    CullFaceNone: h3,
    Curve: Hr,
    CurvePath: IB,
    CustomBlending: g3,
    CustomToneMapping: z3,
    CylinderBufferGeometry: vH,
    CylinderGeometry: hl,
    Cylindrical: J9,
    Data3DTexture: _A,
    DataArrayTexture: Qg,
    DataTexture: Tu,
    DataTextureLoader: p9,
    DataUtils: hH,
    DecrementStencilOp: XO,
    DecrementWrapStencilOp: YO,
    DefaultLoadingManager: gu,
    DepthFormat: Uo,
    DepthStencilFormat: ol,
    DepthTexture: wB,
    DirectionalLight: YA,
    DirectionalLightHelper: nH,
    DiscreteInterpolant: YB,
    DodecahedronBufferGeometry: xH,
    DodecahedronGeometry: kd,
    DoubleSide: Ir,
    DstAlphaFactor: w3,
    DstColorFactor: C3,
    DynamicCopyUsage: u4,
    DynamicDrawUsage: Qa,
    DynamicReadUsage: o4,
    EdgesGeometry: DB,
    EllipseCurve: n0,
    EqualDepth: R3,
    EqualStencilFunc: $O,
    EquirectangularReflectionMapping: qf,
    EquirectangularRefractionMapping: $f,
    Euler: Td,
    EventDispatcher: cs,
    ExtrudeBufferGeometry: _H,
    ExtrudeGeometry: Nd,
    FileLoader: ji,
    Float16BufferAttribute: V4,
    Float32BufferAttribute: je,
    Float64BufferAttribute: W4,
    FloatType: Ds,
    Fog: e0,
    FogExp2: $g,
    FramebufferTexture: P8,
    FrontSide: as,
    Frustum: Zg,
    GLBufferAttribute: j9,
    GLSL1: f4,
    GLSL3: B1,
    GreaterDepth: I3,
    GreaterEqualDepth: L3,
    GreaterEqualStencilFunc: i4,
    GreaterStencilFunc: t4,
    GridHelper: eH,
    Group: ks,
    HalfFloatType: Nu,
    HemisphereLight: qB,
    HemisphereLightHelper: $9,
    HemisphereLightProbe: A9,
    IcosahedronBufferGeometry: AH,
    IcosahedronGeometry: Od,
    ImageBitmapLoader: rR,
    ImageLoader: ud,
    ImageUtils: xA,
    IncrementStencilOp: JO,
    IncrementWrapStencilOp: KO,
    InstancedBufferAttribute: Gu,
    InstancedBufferGeometry: nR,
    InstancedInterleavedBuffer: W9,
    InstancedMesh: bB,
    Int16BufferAttribute: G4,
    Int32BufferAttribute: H4,
    Int8BufferAttribute: O4,
    IntType: V3,
    InterleavedBuffer: Bd,
    InterleavedBufferAttribute: Jo,
    Interpolant: sc,
    InterpolateDiscrete: Ou,
    InterpolateLinear: al,
    InterpolateSmooth: Tm,
    InvertStencilOp: QO,
    KeepStencilOp: bm,
    KeyframeTrack: Vr,
    LOD: TB,
    LatheBufferGeometry: MH,
    LatheGeometry: tc,
    Layers: $a,
    LessDepth: B3,
    LessEqualDepth: lg,
    LessEqualStencilFunc: e4,
    LessStencilFunc: qO,
    Light: ra,
    LightProbe: s0,
    Line: Ks,
    Line3: K9,
    LineBasicMaterial: ri,
    LineCurve: i0,
    LineCurve3: LB,
    LineDashedMaterial: JB,
    LineLoop: LA,
    LineSegments: Gr,
    LinearEncoding: Xs,
    LinearFilter: nn,
    LinearInterpolant: VA,
    LinearMipMapLinearFilter: GO,
    LinearMipMapNearestFilter: zO,
    LinearMipmapLinearFilter: ls,
    LinearMipmapNearestFilter: Kg,
    LinearSRGBColorSpace: Uu,
    LinearToneMapping: N3,
    Loader: vi,
    LoaderUtils: ss,
    LoadingManager: jA,
    LoopOnce: nB,
    LoopPingPong: rB,
    LoopRepeat: iB,
    LuminanceAlphaFormat: K3,
    LuminanceFormat: X3,
    MOUSE: ba,
    Material: Sn,
    MaterialLoader: o0,
    MathUtils: fB,
    Matrix3: hi,
    Matrix4: rt,
    MaxEquation: o1,
    Mesh: Un,
    MeshBasicMaterial: Gi,
    MeshDepthMaterial: EA,
    MeshDistanceMaterial: TA,
    MeshLambertMaterial: WB,
    MeshMatcapMaterial: jB,
    MeshNormalMaterial: VB,
    MeshPhongMaterial: GB,
    MeshPhysicalMaterial: qs,
    MeshStandardMaterial: rc,
    MeshToonMaterial: HB,
    MinEquation: s1,
    MirroredRepeatWrapping: ku,
    MixOperation: F3,
    MultiplyBlending: r1,
    MultiplyOperation: Cd,
    NearestFilter: hn,
    NearestMipMapLinearFilter: UO,
    NearestMipMapNearestFilter: OO,
    NearestMipmapLinearFilter: Eu,
    NearestMipmapNearestFilter: ed,
    NeverDepth: b3,
    NeverStencilFunc: ZO,
    NoBlending: Us,
    NoColorSpace: VO,
    NoToneMapping: kr,
    NormalAnimationBlendMode: Yg,
    NormalBlending: Ka,
    NotEqualDepth: D3,
    NotEqualStencilFunc: n4,
    NumberKeyframeTrack: Hu,
    Object3D: Rt,
    ObjectLoader: v9,
    ObjectSpaceNormalMap: lB,
    OctahedronBufferGeometry: wH,
    OctahedronGeometry: nc,
    OneFactor: _3,
    OneMinusDstAlphaFactor: S3,
    OneMinusDstColorFactor: E3,
    OneMinusSrcAlphaFactor: hA,
    OneMinusSrcColorFactor: M3,
    OrthographicCamera: Nr,
    PCFShadowMap: Jg,
    PCFSoftShadowMap: Af,
    PMREMGenerator: L1,
    Path: sd,
    PerspectiveCamera: Ht,
    Plane: _o,
    PlaneBufferGeometry: SH,
    PlaneGeometry: $u,
    PlaneHelper: oH,
    PointLight: KA,
    PointLightHelper: Z9,
    Points: IA,
    PointsMaterial: Ld,
    PolarGridHelper: tH,
    PolyhedronBufferGeometry: CH,
    PolyhedronGeometry: Zs,
    PositionalAudio: T9,
    PropertyBinding: bt,
    PropertyMixer: oR,
    QuadraticBezierCurve: NA,
    QuadraticBezierCurve3: OA,
    Quaternion: jn,
    QuaternionKeyframeTrack: Xo,
    QuaternionLinearInterpolant: QB,
    RED_GREEN_RGTC2_Format: b1,
    RED_RGTC1_Format: tB,
    REVISION: jg,
    RGBADepthPacking: aB,
    RGBAFormat: Ci,
    RGBAIntegerFormat: $3,
    RGBA_ASTC_10x10_Format: S1,
    RGBA_ASTC_10x5_Format: A1,
    RGBA_ASTC_10x6_Format: M1,
    RGBA_ASTC_10x8_Format: w1,
    RGBA_ASTC_12x10_Format: C1,
    RGBA_ASTC_12x12_Format: E1,
    RGBA_ASTC_4x4_Format: h1,
    RGBA_ASTC_5x4_Format: p1,
    RGBA_ASTC_5x5_Format: m1,
    RGBA_ASTC_6x5_Format: g1,
    RGBA_ASTC_6x6_Format: y1,
    RGBA_ASTC_8x5_Format: v1,
    RGBA_ASTC_8x6_Format: x1,
    RGBA_ASTC_8x8_Format: _1,
    RGBA_BPTC_Format: Em,
    RGBA_ETC2_EAC_Format: d1,
    RGBA_PVRTC_2BPPV1_Format: c1,
    RGBA_PVRTC_4BPPV1_Format: u1,
    RGBA_S3TC_DXT1_Format: wm,
    RGBA_S3TC_DXT3_Format: Sm,
    RGBA_S3TC_DXT5_Format: Cm,
    RGB_ETC1_Format: eB,
    RGB_ETC2_Format: f1,
    RGB_PVRTC_2BPPV1_Format: l1,
    RGB_PVRTC_4BPPV1_Format: a1,
    RGB_S3TC_DXT1_Format: Mm,
    RGFormat: Z3,
    RGIntegerFormat: q3,
    RawShaderMaterial: zB,
    Ray: Ed,
    Raycaster: aR,
    RectAreaLight: eR,
    RedFormat: Y3,
    RedIntegerFormat: Q3,
    ReinhardToneMapping: O3,
    RepeatWrapping: jo,
    ReplaceStencilOp: jO,
    ReverseSubtractEquation: v3,
    RingBufferGeometry: EH,
    RingGeometry: Ud,
    SIGNED_RED_GREEN_RGTC2_Format: P1,
    SIGNED_RED_RGTC1_Format: T1,
    SRGBColorSpace: Br,
    Scene: PA,
    ShaderChunk: mt,
    ShaderLib: Lr,
    ShaderMaterial: us,
    ShadowMaterial: UB,
    Shape: el,
    ShapeBufferGeometry: TH,
    ShapeGeometry: zd,
    ShapePath: uH,
    ShapeUtils: rs,
    ShortType: H3,
    Skeleton: Rd,
    SkeletonHelper: Q9,
    SkinnedMesh: RA,
    Source: Ha,
    Sphere: na,
    SphereBufferGeometry: bH,
    SphereGeometry: ic,
    Spherical: U1,
    SphericalHarmonics3: tR,
    SplineCurve: UA,
    SpotLight: XA,
    SpotLightHelper: Y9,
    Sprite: EB,
    SpriteMaterial: BA,
    SrcAlphaFactor: dA,
    SrcAlphaSaturateFactor: T3,
    SrcColorFactor: A3,
    StaticCopyUsage: l4,
    StaticDrawUsage: nd,
    StaticReadUsage: s4,
    StereoCamera: w9,
    StreamCopyUsage: c4,
    StreamDrawUsage: r4,
    StreamReadUsage: a4,
    StringKeyframeTrack: ml,
    SubtractEquation: y3,
    SubtractiveBlending: i1,
    TOUCH: Pa,
    TangentSpaceNormalMap: Qs,
    TetrahedronBufferGeometry: PH,
    TetrahedronGeometry: Gd,
    Texture: qt,
    TextureLoader: ZB,
    TorusBufferGeometry: BH,
    TorusGeometry: Hd,
    TorusKnotBufferGeometry: RH,
    TorusKnotGeometry: Vd,
    Triangle: pr,
    TriangleFanDrawMode: yA,
    TriangleStripDrawMode: sB,
    TrianglesDrawMode: HO,
    TubeBufferGeometry: LH,
    TubeGeometry: Wd,
    TwoPassDoubleSide: NO,
    UVMapping: Xg,
    Uint16BufferAttribute: AA,
    Uint32BufferAttribute: MA,
    Uint8BufferAttribute: U4,
    Uint8ClampedBufferAttribute: z4,
    Uniform: eM,
    UniformsGroup: V9,
    UniformsLib: Re,
    UniformsUtils: mB,
    UnsignedByteType: Js,
    UnsignedInt248Type: Ya,
    UnsignedIntType: bo,
    UnsignedShort4444Type: W3,
    UnsignedShort5551Type: j3,
    UnsignedShortType: mA,
    VSMShadowMap: Ua,
    Vector2: pe,
    Vector3: D,
    Vector4: Nt,
    VectorKeyframeTrack: Vu,
    VideoTexture: b8,
    WebGL1Renderer: SB,
    WebGL3DRenderTarget: b4,
    WebGLArrayRenderTarget: T4,
    WebGLCubeRenderTarget: SA,
    WebGLMultipleRenderTargets: P4,
    WebGLRenderTarget: Ur,
    WebGLRenderer: bA,
    WebGLUtils: AB,
    WireframeGeometry: OB,
    WrapAroundEnding: td,
    ZeroCurvatureEnding: za,
    ZeroFactor: x3,
    ZeroSlopeEnding: Ga,
    ZeroStencilOp: WO,
    _SRGBAFormat: ug,
    sRGBEncoding: Et
}, Symbol.toStringTag, {
    value: "Module"
}));
var Po = {}
  , IH = {
    get exports() {
        return Po
    },
    set exports(n) {
        Po = n
    }
}
  , gl = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
gl.ConcurrentRoot = 1;
gl.ContinuousEventPriority = 4;
gl.DefaultEventPriority = 16;
gl.DiscreteEventPriority = 1;
gl.IdleEventPriority = 536870912;
gl.LegacyRoot = 0;
(function(n) {
    n.exports = gl
}
)(IH);
function DH(n) {
    let e;
    const t = new Set
      , i = (c,d)=>{
        const h = typeof c == "function" ? c(e) : c;
        if (h !== e) {
            const p = e;
            e = d ? h : Object.assign({}, e, h),
            t.forEach(m=>m(e, p))
        }
    }
      , r = ()=>e
      , s = (c,d=r,h=Object.is)=>{
        console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
        let p = d(e);
        function m() {
            const y = d(e);
            if (!h(p, y)) {
                const v = p;
                c(p = y, v)
            }
        }
        return t.add(m),
        ()=>t.delete(m)
    }
      , l = {
        setState: i,
        getState: r,
        subscribe: (c,d,h)=>d || h ? s(c, d, h) : (t.add(c),
        ()=>t.delete(c)),
        destroy: ()=>t.clear()
    };
    return e = n(i, r, l),
    l
}
const FH = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent)
  , sT = FH ? O.useEffect : O.useLayoutEffect;
function uR(n) {
    const e = typeof n == "function" ? DH(n) : n
      , t = (i=e.getState,r=Object.is)=>{
        const [,s] = O.useReducer(_=>_ + 1, 0)
          , o = e.getState()
          , a = O.useRef(o)
          , l = O.useRef(i)
          , c = O.useRef(r)
          , d = O.useRef(!1)
          , h = O.useRef();
        h.current === void 0 && (h.current = i(o));
        let p, m = !1;
        (a.current !== o || l.current !== i || c.current !== r || d.current) && (p = i(o),
        m = !r(h.current, p)),
        sT(()=>{
            m && (h.current = p),
            a.current = o,
            l.current = i,
            c.current = r,
            d.current = !1
        }
        );
        const y = O.useRef(o);
        sT(()=>{
            const _ = ()=>{
                try {
                    const A = e.getState()
                      , M = l.current(A);
                    c.current(h.current, M) || (a.current = A,
                    h.current = M,
                    s())
                } catch {
                    d.current = !0,
                    s()
                }
            }
              , x = e.subscribe(_);
            return e.getState() !== y.current && _(),
            x
        }
        , []);
        const v = m ? p : h.current;
        return O.useDebugValue(v),
        v
    }
    ;
    return Object.assign(t, e),
    t[Symbol.iterator] = function() {
        console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
        const i = [t, e];
        return {
            next() {
                const r = i.length <= 0;
                return {
                    value: i.shift(),
                    done: r
                }
            }
        }
    }
    ,
    t
}
var G1 = {}
  , kH = {
    get exports() {
        return G1
    },
    set exports(n) {
        G1 = n
    }
}
  , cd = {}
  , NH = {
    get exports() {
        return cd
    },
    set exports(n) {
        cd = n
    }
}
  , cR = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(n) {
    function e(F, V) {
        var j = F.length;
        F.push(V);
        e: for (; 0 < j; ) {
            var re = j - 1 >>> 1
              , H = F[re];
            if (0 < r(H, V))
                F[re] = V,
                F[j] = H,
                j = re;
            else
                break e
        }
    }
    function t(F) {
        return F.length === 0 ? null : F[0]
    }
    function i(F) {
        if (F.length === 0)
            return null;
        var V = F[0]
          , j = F.pop();
        if (j !== V) {
            F[0] = j;
            e: for (var re = 0, H = F.length, se = H >>> 1; re < se; ) {
                var ye = 2 * (re + 1) - 1
                  , ve = F[ye]
                  , q = ye + 1
                  , Ie = F[q];
                if (0 > r(ve, j))
                    q < H && 0 > r(Ie, ve) ? (F[re] = Ie,
                    F[q] = j,
                    re = q) : (F[re] = ve,
                    F[ye] = j,
                    re = ye);
                else if (q < H && 0 > r(Ie, j))
                    F[re] = Ie,
                    F[q] = j,
                    re = q;
                else
                    break e
            }
        }
        return V
    }
    function r(F, V) {
        var j = F.sortIndex - V.sortIndex;
        return j !== 0 ? j : F.id - V.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        n.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date
          , a = o.now();
        n.unstable_now = function() {
            return o.now() - a
        }
    }
    var l = []
      , c = []
      , d = 1
      , h = null
      , p = 3
      , m = !1
      , y = !1
      , v = !1
      , _ = typeof setTimeout == "function" ? setTimeout : null
      , x = typeof clearTimeout == "function" ? clearTimeout : null
      , A = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function M(F) {
        for (var V = t(c); V !== null; ) {
            if (V.callback === null)
                i(c);
            else if (V.startTime <= F)
                i(c),
                V.sortIndex = V.expirationTime,
                e(l, V);
            else
                break;
            V = t(c)
        }
    }
    function S(F) {
        if (v = !1,
        M(F),
        !y)
            if (t(l) !== null)
                y = !0,
                ee(T);
            else {
                var V = t(c);
                V !== null && ie(S, V.startTime - F)
            }
    }
    function T(F, V) {
        y = !1,
        v && (v = !1,
        x(E),
        E = -1),
        m = !0;
        var j = p;
        try {
            for (M(V),
            h = t(l); h !== null && (!(h.expirationTime > V) || F && !z()); ) {
                var re = h.callback;
                if (typeof re == "function") {
                    h.callback = null,
                    p = h.priorityLevel;
                    var H = re(h.expirationTime <= V);
                    V = n.unstable_now(),
                    typeof H == "function" ? h.callback = H : h === t(l) && i(l),
                    M(V)
                } else
                    i(l);
                h = t(l)
            }
            if (h !== null)
                var se = !0;
            else {
                var ye = t(c);
                ye !== null && ie(S, ye.startTime - V),
                se = !1
            }
            return se
        } finally {
            h = null,
            p = j,
            m = !1
        }
    }
    var P = !1
      , R = null
      , E = -1
      , B = 5
      , L = -1;
    function z() {
        return !(n.unstable_now() - L < B)
    }
    function Z() {
        if (R !== null) {
            var F = n.unstable_now();
            L = F;
            var V = !0;
            try {
                V = R(!0, F)
            } finally {
                V ? J() : (P = !1,
                R = null)
            }
        } else
            P = !1
    }
    var J;
    if (typeof A == "function")
        J = function() {
            A(Z)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var G = new MessageChannel
          , X = G.port2;
        G.port1.onmessage = Z,
        J = function() {
            X.postMessage(null)
        }
    } else
        J = function() {
            _(Z, 0)
        }
        ;
    function ee(F) {
        R = F,
        P || (P = !0,
        J())
    }
    function ie(F, V) {
        E = _(function() {
            F(n.unstable_now())
        }, V)
    }
    n.unstable_IdlePriority = 5,
    n.unstable_ImmediatePriority = 1,
    n.unstable_LowPriority = 4,
    n.unstable_NormalPriority = 3,
    n.unstable_Profiling = null,
    n.unstable_UserBlockingPriority = 2,
    n.unstable_cancelCallback = function(F) {
        F.callback = null
    }
    ,
    n.unstable_continueExecution = function() {
        y || m || (y = !0,
        ee(T))
    }
    ,
    n.unstable_forceFrameRate = function(F) {
        0 > F || 125 < F ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : B = 0 < F ? Math.floor(1e3 / F) : 5
    }
    ,
    n.unstable_getCurrentPriorityLevel = function() {
        return p
    }
    ,
    n.unstable_getFirstCallbackNode = function() {
        return t(l)
    }
    ,
    n.unstable_next = function(F) {
        switch (p) {
        case 1:
        case 2:
        case 3:
            var V = 3;
            break;
        default:
            V = p
        }
        var j = p;
        p = V;
        try {
            return F()
        } finally {
            p = j
        }
    }
    ,
    n.unstable_pauseExecution = function() {}
    ,
    n.unstable_requestPaint = function() {}
    ,
    n.unstable_runWithPriority = function(F, V) {
        switch (F) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            F = 3
        }
        var j = p;
        p = F;
        try {
            return V()
        } finally {
            p = j
        }
    }
    ,
    n.unstable_scheduleCallback = function(F, V, j) {
        var re = n.unstable_now();
        switch (typeof j == "object" && j !== null ? (j = j.delay,
        j = typeof j == "number" && 0 < j ? re + j : re) : j = re,
        F) {
        case 1:
            var H = -1;
            break;
        case 2:
            H = 250;
            break;
        case 5:
            H = 1073741823;
            break;
        case 4:
            H = 1e4;
            break;
        default:
            H = 5e3
        }
        return H = j + H,
        F = {
            id: d++,
            callback: V,
            priorityLevel: F,
            startTime: j,
            expirationTime: H,
            sortIndex: -1
        },
        j > re ? (F.sortIndex = j,
        e(c, F),
        t(l) === null && F === t(c) && (v ? (x(E),
        E = -1) : v = !0,
        ie(S, j - re))) : (F.sortIndex = H,
        e(l, F),
        y || m || (y = !0,
        ee(T))),
        F
    }
    ,
    n.unstable_shouldYield = z,
    n.unstable_wrapCallback = function(F) {
        var V = p;
        return function() {
            var j = p;
            p = V;
            try {
                return F.apply(this, arguments)
            } finally {
                p = j
            }
        }
    }
}
)(cR);
(function(n) {
    n.exports = cR
}
)(NH);
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var OH = function(e) {
    var t = {}
      , i = O
      , r = cd
      , s = Object.assign;
    function o(u) {
        for (var f = "https://reactjs.org/docs/error-decoder.html?invariant=" + u, g = 1; g < arguments.length; g++)
            f += "&args[]=" + encodeURIComponent(arguments[g]);
        return "Minified React error #" + u + "; visit " + f + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    var a = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
      , l = Symbol.for("react.element")
      , c = Symbol.for("react.portal")
      , d = Symbol.for("react.fragment")
      , h = Symbol.for("react.strict_mode")
      , p = Symbol.for("react.profiler")
      , m = Symbol.for("react.provider")
      , y = Symbol.for("react.context")
      , v = Symbol.for("react.forward_ref")
      , _ = Symbol.for("react.suspense")
      , x = Symbol.for("react.suspense_list")
      , A = Symbol.for("react.memo")
      , M = Symbol.for("react.lazy")
      , S = Symbol.for("react.offscreen")
      , T = Symbol.iterator;
    function P(u) {
        return u === null || typeof u != "object" ? null : (u = T && u[T] || u["@@iterator"],
        typeof u == "function" ? u : null)
    }
    function R(u) {
        if (u == null)
            return null;
        if (typeof u == "function")
            return u.displayName || u.name || null;
        if (typeof u == "string")
            return u;
        switch (u) {
        case d:
            return "Fragment";
        case c:
            return "Portal";
        case p:
            return "Profiler";
        case h:
            return "StrictMode";
        case _:
            return "Suspense";
        case x:
            return "SuspenseList"
        }
        if (typeof u == "object")
            switch (u.$$typeof) {
            case y:
                return (u.displayName || "Context") + ".Consumer";
            case m:
                return (u._context.displayName || "Context") + ".Provider";
            case v:
                var f = u.render;
                return u = u.displayName,
                u || (u = f.displayName || f.name || "",
                u = u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef"),
                u;
            case A:
                return f = u.displayName || null,
                f !== null ? f : R(u.type) || "Memo";
            case M:
                f = u._payload,
                u = u._init;
                try {
                    return R(u(f))
                } catch {}
            }
        return null
    }
    function E(u) {
        var f = u.type;
        switch (u.tag) {
        case 24:
            return "Cache";
        case 9:
            return (f.displayName || "Context") + ".Consumer";
        case 10:
            return (f._context.displayName || "Context") + ".Provider";
        case 18:
            return "DehydratedFragment";
        case 11:
            return u = f.render,
            u = u.displayName || u.name || "",
            f.displayName || (u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef");
        case 7:
            return "Fragment";
        case 5:
            return f;
        case 4:
            return "Portal";
        case 3:
            return "Root";
        case 6:
            return "Text";
        case 16:
            return R(f);
        case 8:
            return f === h ? "StrictMode" : "Mode";
        case 22:
            return "Offscreen";
        case 12:
            return "Profiler";
        case 21:
            return "Scope";
        case 13:
            return "Suspense";
        case 19:
            return "SuspenseList";
        case 25:
            return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
            if (typeof f == "function")
                return f.displayName || f.name || null;
            if (typeof f == "string")
                return f
        }
        return null
    }
    function B(u) {
        var f = u
          , g = u;
        if (u.alternate)
            for (; f.return; )
                f = f.return;
        else {
            u = f;
            do
                f = u,
                f.flags & 4098 && (g = f.return),
                u = f.return;
            while (u)
        }
        return f.tag === 3 ? g : null
    }
    function L(u) {
        if (B(u) !== u)
            throw Error(o(188))
    }
    function z(u) {
        var f = u.alternate;
        if (!f) {
            if (f = B(u),
            f === null)
                throw Error(o(188));
            return f !== u ? null : u
        }
        for (var g = u, w = f; ; ) {
            var C = g.return;
            if (C === null)
                break;
            var b = C.alternate;
            if (b === null) {
                if (w = C.return,
                w !== null) {
                    g = w;
                    continue
                }
                break
            }
            if (C.child === b.child) {
                for (b = C.child; b; ) {
                    if (b === g)
                        return L(C),
                        u;
                    if (b === w)
                        return L(C),
                        f;
                    b = b.sibling
                }
                throw Error(o(188))
            }
            if (g.return !== w.return)
                g = C,
                w = b;
            else {
                for (var N = !1, K = C.child; K; ) {
                    if (K === g) {
                        N = !0,
                        g = C,
                        w = b;
                        break
                    }
                    if (K === w) {
                        N = !0,
                        w = C,
                        g = b;
                        break
                    }
                    K = K.sibling
                }
                if (!N) {
                    for (K = b.child; K; ) {
                        if (K === g) {
                            N = !0,
                            g = b,
                            w = C;
                            break
                        }
                        if (K === w) {
                            N = !0,
                            w = b,
                            g = C;
                            break
                        }
                        K = K.sibling
                    }
                    if (!N)
                        throw Error(o(189))
                }
            }
            if (g.alternate !== w)
                throw Error(o(190))
        }
        if (g.tag !== 3)
            throw Error(o(188));
        return g.stateNode.current === g ? u : f
    }
    function Z(u) {
        return u = z(u),
        u !== null ? J(u) : null
    }
    function J(u) {
        if (u.tag === 5 || u.tag === 6)
            return u;
        for (u = u.child; u !== null; ) {
            var f = J(u);
            if (f !== null)
                return f;
            u = u.sibling
        }
        return null
    }
    function G(u) {
        if (u.tag === 5 || u.tag === 6)
            return u;
        for (u = u.child; u !== null; ) {
            if (u.tag !== 4) {
                var f = G(u);
                if (f !== null)
                    return f
            }
            u = u.sibling
        }
        return null
    }
    var X = Array.isArray, ee = e.getPublicInstance, ie = e.getRootHostContext, F = e.getChildHostContext, V = e.prepareForCommit, j = e.resetAfterCommit, re = e.createInstance, H = e.appendInitialChild, se = e.finalizeInitialChildren, ye = e.prepareUpdate, ve = e.shouldSetTextContent, q = e.createTextInstance, Ie = e.scheduleTimeout, Ne = e.cancelTimeout, He = e.noTimeout, Me = e.isPrimaryRenderer, De = e.supportsMutation, de = e.supportsPersistence, ae = e.supportsHydration, Ce = e.getInstanceFromNode, ze = e.preparePortalMount, Be = e.getCurrentEventPriority, Ze = e.detachDeletedInstance, Je = e.supportsMicrotasks, We = e.scheduleMicrotask, xt = e.supportsTestSelectors, St = e.findFiberRoot, U = e.getBoundingRect, I = e.getTextContent, oe = e.isHiddenSubtree, we = e.matchAccessibilityRole, Ee = e.setFocusIfFocusable, Pe = e.setupIntersectionObserver, tt = e.appendChild, Fe = e.appendChildToContainer, me = e.commitTextUpdate, Xe = e.commitMount, W = e.commitUpdate, le = e.insertBefore, Ae = e.insertInContainerBefore, be = e.removeChild, $e = e.removeChildFromContainer, vt = e.resetTextContent, Wt = e.hideInstance, Y = e.hideTextInstance, ce = e.unhideInstance, _e = e.unhideTextInstance, Ue = e.clearContainer, Ye = e.cloneInstance, Pt = e.createContainerChildSet, pn = e.appendChildToContainerChildSet, Ln = e.finalizeContainerChildren, Wr = e.replaceContainerChildren, Ut = e.cloneHiddenInstance, Yi = e.cloneHiddenTextInstance, xi = e.canHydrateInstance, $d = e.canHydrateTextInstance, y0 = e.canHydrateSuspenseInstance, eh = e.isSuspenseInstancePending, oc = e.isSuspenseInstanceFallback, k = e.registerSuspenseInstanceRetry, te = e.getNextHydratableSibling, he = e.getFirstHydratableChild, $ = e.getFirstHydratableChildWithinContainer, ge = e.getFirstHydratableChildWithinSuspenseInstance, qe = e.hydrateInstance, it = e.hydrateTextInstance, dt = e.hydrateSuspenseInstance, gt = e.getNextHydratableInstanceAfterSuspenseInstance, Ct = e.commitHydratedContainer, At = e.commitHydratedSuspenseInstance, Mt = e.clearSuspenseBoundary, ln = e.clearSuspenseBoundaryFromContainer, si = e.shouldDeleteUnhydratedTailInstances, _r = e.didNotMatchHydratedContainerTextInstance, fs = e.didNotMatchHydratedTextInstance, Kt;
    function ht(u) {
        if (Kt === void 0)
            try {
                throw Error()
            } catch (g) {
                var f = g.stack.trim().match(/\n( *(at )?)/);
                Kt = f && f[1] || ""
            }
        return `
` + Kt + u
    }
    var oa = !1;
    function un(u, f) {
        if (!u || oa)
            return "";
        oa = !0;
        var g = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            if (f)
                if (f = function() {
                    throw Error()
                }
                ,
                Object.defineProperty(f.prototype, "props", {
                    set: function() {
                        throw Error()
                    }
                }),
                typeof Reflect == "object" && Reflect.construct) {
                    try {
                        Reflect.construct(f, [])
                    } catch (Te) {
                        var w = Te
                    }
                    Reflect.construct(u, [], f)
                } else {
                    try {
                        f.call()
                    } catch (Te) {
                        w = Te
                    }
                    u.call(f.prototype)
                }
            else {
                try {
                    throw Error()
                } catch (Te) {
                    w = Te
                }
                u()
            }
        } catch (Te) {
            if (Te && w && typeof Te.stack == "string") {
                for (var C = Te.stack.split(`
`), b = w.stack.split(`
`), N = C.length - 1, K = b.length - 1; 1 <= N && 0 <= K && C[N] !== b[K]; )
                    K--;
                for (; 1 <= N && 0 <= K; N--,
                K--)
                    if (C[N] !== b[K]) {
                        if (N !== 1 || K !== 1)
                            do
                                if (N--,
                                K--,
                                0 > K || C[N] !== b[K]) {
                                    var fe = `
` + C[N].replace(" at new ", " at ");
                                    return u.displayName && fe.includes("<anonymous>") && (fe = fe.replace("<anonymous>", u.displayName)),
                                    fe
                                }
                            while (1 <= N && 0 <= K);
                        break
                    }
            }
        } finally {
            oa = !1,
            Error.prepareStackTrace = g
        }
        return (u = u ? u.displayName || u.name : "") ? ht(u) : ""
    }
    var ds = Object.prototype.hasOwnProperty
      , xl = []
      , Qi = -1;
    function Zi(u) {
        return {
            current: u
        }
    }
    function ft(u) {
        0 > Qi || (u.current = xl[Qi],
        xl[Qi] = null,
        Qi--)
    }
    function Tt(u, f) {
        Qi++,
        xl[Qi] = u.current,
        u.current = f
    }
    var qi = {}
      , kt = Zi(qi)
      , In = Zi(!1)
      , hs = qi;
    function ps(u, f) {
        var g = u.type.contextTypes;
        if (!g)
            return qi;
        var w = u.stateNode;
        if (w && w.__reactInternalMemoizedUnmaskedChildContext === f)
            return w.__reactInternalMemoizedMaskedChildContext;
        var C = {}, b;
        for (b in g)
            C[b] = f[b];
        return w && (u = u.stateNode,
        u.__reactInternalMemoizedUnmaskedChildContext = f,
        u.__reactInternalMemoizedMaskedChildContext = C),
        C
    }
    function _i(u) {
        return u = u.childContextTypes,
        u != null
    }
    function th() {
        ft(In),
        ft(kt)
    }
    function kM(u, f, g) {
        if (kt.current !== qi)
            throw Error(o(168));
        Tt(kt, f),
        Tt(In, g)
    }
    function NM(u, f, g) {
        var w = u.stateNode;
        if (f = f.childContextTypes,
        typeof w.getChildContext != "function")
            return g;
        w = w.getChildContext();
        for (var C in w)
            if (!(C in f))
                throw Error(o(108, E(u) || "Unknown", C));
        return s({}, g, w)
    }
    function nh(u) {
        return u = (u = u.stateNode) && u.__reactInternalMemoizedMergedChildContext || qi,
        hs = kt.current,
        Tt(kt, u),
        Tt(In, In.current),
        !0
    }
    function OM(u, f, g) {
        var w = u.stateNode;
        if (!w)
            throw Error(o(169));
        g ? (u = NM(u, f, hs),
        w.__reactInternalMemoizedMergedChildContext = u,
        ft(In),
        ft(kt),
        Tt(kt, u)) : ft(In),
        Tt(In, g)
    }
    var Ar = Math.clz32 ? Math.clz32 : uI
      , aI = Math.log
      , lI = Math.LN2;
    function uI(u) {
        return u >>>= 0,
        u === 0 ? 32 : 31 - (aI(u) / lI | 0) | 0
    }
    var ih = 64
      , rh = 4194304;
    function ac(u) {
        switch (u & -u) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return u & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return u & 130023424;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 1073741824;
        default:
            return u
        }
    }
    function sh(u, f) {
        var g = u.pendingLanes;
        if (g === 0)
            return 0;
        var w = 0
          , C = u.suspendedLanes
          , b = u.pingedLanes
          , N = g & 268435455;
        if (N !== 0) {
            var K = N & ~C;
            K !== 0 ? w = ac(K) : (b &= N,
            b !== 0 && (w = ac(b)))
        } else
            N = g & ~C,
            N !== 0 ? w = ac(N) : b !== 0 && (w = ac(b));
        if (w === 0)
            return 0;
        if (f !== 0 && f !== w && !(f & C) && (C = w & -w,
        b = f & -f,
        C >= b || C === 16 && (b & 4194240) !== 0))
            return f;
        if (w & 4 && (w |= g & 16),
        f = u.entangledLanes,
        f !== 0)
            for (u = u.entanglements,
            f &= w; 0 < f; )
                g = 31 - Ar(f),
                C = 1 << g,
                w |= u[g],
                f &= ~C;
        return w
    }
    function cI(u, f) {
        switch (u) {
        case 1:
        case 2:
        case 4:
            return f + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return f + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
        }
    }
    function fI(u, f) {
        for (var g = u.suspendedLanes, w = u.pingedLanes, C = u.expirationTimes, b = u.pendingLanes; 0 < b; ) {
            var N = 31 - Ar(b)
              , K = 1 << N
              , fe = C[N];
            fe === -1 ? (!(K & g) || K & w) && (C[N] = cI(K, f)) : fe <= f && (u.expiredLanes |= K),
            b &= ~K
        }
    }
    function v0(u) {
        return u = u.pendingLanes & -1073741825,
        u !== 0 ? u : u & 1073741824 ? 1073741824 : 0
    }
    function x0(u) {
        for (var f = [], g = 0; 31 > g; g++)
            f.push(u);
        return f
    }
    function lc(u, f, g) {
        u.pendingLanes |= f,
        f !== 536870912 && (u.suspendedLanes = 0,
        u.pingedLanes = 0),
        u = u.eventTimes,
        f = 31 - Ar(f),
        u[f] = g
    }
    function dI(u, f) {
        var g = u.pendingLanes & ~f;
        u.pendingLanes = f,
        u.suspendedLanes = 0,
        u.pingedLanes = 0,
        u.expiredLanes &= f,
        u.mutableReadLanes &= f,
        u.entangledLanes &= f,
        f = u.entanglements;
        var w = u.eventTimes;
        for (u = u.expirationTimes; 0 < g; ) {
            var C = 31 - Ar(g)
              , b = 1 << C;
            f[C] = 0,
            w[C] = -1,
            u[C] = -1,
            g &= ~b
        }
    }
    function _0(u, f) {
        var g = u.entangledLanes |= f;
        for (u = u.entanglements; g; ) {
            var w = 31 - Ar(g)
              , C = 1 << w;
            C & f | u[w] & f && (u[w] |= f),
            g &= ~C
        }
    }
    var Lt = 0;
    function UM(u) {
        return u &= -u,
        1 < u ? 4 < u ? u & 268435455 ? 16 : 536870912 : 4 : 1
    }
    var A0 = r.unstable_scheduleCallback
      , zM = r.unstable_cancelCallback
      , hI = r.unstable_shouldYield
      , pI = r.unstable_requestPaint
      , Dn = r.unstable_now
      , M0 = r.unstable_ImmediatePriority
      , mI = r.unstable_UserBlockingPriority
      , w0 = r.unstable_NormalPriority
      , gI = r.unstable_IdlePriority
      , oh = null
      , jr = null;
    function yI(u) {
        if (jr && typeof jr.onCommitFiberRoot == "function")
            try {
                jr.onCommitFiberRoot(oh, u, void 0, (u.current.flags & 128) === 128)
            } catch {}
    }
    function vI(u, f) {
        return u === f && (u !== 0 || 1 / u === 1 / f) || u !== u && f !== f
    }
    var Jr = typeof Object.is == "function" ? Object.is : vI
      , ms = null
      , ah = !1
      , S0 = !1;
    function GM(u) {
        ms === null ? ms = [u] : ms.push(u)
    }
    function xI(u) {
        ah = !0,
        GM(u)
    }
    function Xr() {
        if (!S0 && ms !== null) {
            S0 = !0;
            var u = 0
              , f = Lt;
            try {
                var g = ms;
                for (Lt = 1; u < g.length; u++) {
                    var w = g[u];
                    do
                        w = w(!0);
                    while (w !== null)
                }
                ms = null,
                ah = !1
            } catch (C) {
                throw ms !== null && (ms = ms.slice(u + 1)),
                A0(M0, Xr),
                C
            } finally {
                Lt = f,
                S0 = !1
            }
        }
        return null
    }
    var _I = a.ReactCurrentBatchConfig;
    function lh(u, f) {
        if (Jr(u, f))
            return !0;
        if (typeof u != "object" || u === null || typeof f != "object" || f === null)
            return !1;
        var g = Object.keys(u)
          , w = Object.keys(f);
        if (g.length !== w.length)
            return !1;
        for (w = 0; w < g.length; w++) {
            var C = g[w];
            if (!ds.call(f, C) || !Jr(u[C], f[C]))
                return !1
        }
        return !0
    }
    function AI(u) {
        switch (u.tag) {
        case 5:
            return ht(u.type);
        case 16:
            return ht("Lazy");
        case 13:
            return ht("Suspense");
        case 19:
            return ht("SuspenseList");
        case 0:
        case 2:
        case 15:
            return u = un(u.type, !1),
            u;
        case 11:
            return u = un(u.type.render, !1),
            u;
        case 1:
            return u = un(u.type, !0),
            u;
        default:
            return ""
        }
    }
    function Mr(u, f) {
        if (u && u.defaultProps) {
            f = s({}, f),
            u = u.defaultProps;
            for (var g in u)
                f[g] === void 0 && (f[g] = u[g]);
            return f
        }
        return f
    }
    var uh = Zi(null)
      , ch = null
      , _l = null
      , C0 = null;
    function E0() {
        C0 = _l = ch = null
    }
    function HM(u, f, g) {
        Me ? (Tt(uh, f._currentValue),
        f._currentValue = g) : (Tt(uh, f._currentValue2),
        f._currentValue2 = g)
    }
    function T0(u) {
        var f = uh.current;
        ft(uh),
        Me ? u._currentValue = f : u._currentValue2 = f
    }
    function b0(u, f, g) {
        for (; u !== null; ) {
            var w = u.alternate;
            if ((u.childLanes & f) !== f ? (u.childLanes |= f,
            w !== null && (w.childLanes |= f)) : w !== null && (w.childLanes & f) !== f && (w.childLanes |= f),
            u === g)
                break;
            u = u.return
        }
    }
    function Al(u, f) {
        ch = u,
        C0 = _l = null,
        u = u.dependencies,
        u !== null && u.firstContext !== null && (u.lanes & f && (Di = !0),
        u.firstContext = null)
    }
    function $i(u) {
        var f = Me ? u._currentValue : u._currentValue2;
        if (C0 !== u)
            if (u = {
                context: u,
                memoizedValue: f,
                next: null
            },
            _l === null) {
                if (ch === null)
                    throw Error(o(308));
                _l = u,
                ch.dependencies = {
                    lanes: 0,
                    firstContext: u
                }
            } else
                _l = _l.next = u;
        return f
    }
    var Kr = null
      , $s = !1;
    function P0(u) {
        u.updateQueue = {
            baseState: u.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                interleaved: null,
                lanes: 0
            },
            effects: null
        }
    }
    function VM(u, f) {
        u = u.updateQueue,
        f.updateQueue === u && (f.updateQueue = {
            baseState: u.baseState,
            firstBaseUpdate: u.firstBaseUpdate,
            lastBaseUpdate: u.lastBaseUpdate,
            shared: u.shared,
            effects: u.effects
        })
    }
    function gs(u, f) {
        return {
            eventTime: u,
            lane: f,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }
    function eo(u, f) {
        var g = u.updateQueue;
        g !== null && (g = g.shared,
        xn !== null && u.mode & 1 && !(yt & 2) ? (u = g.interleaved,
        u === null ? (f.next = f,
        Kr === null ? Kr = [g] : Kr.push(g)) : (f.next = u.next,
        u.next = f),
        g.interleaved = f) : (u = g.pending,
        u === null ? f.next = f : (f.next = u.next,
        u.next = f),
        g.pending = f))
    }
    function fh(u, f, g) {
        if (f = f.updateQueue,
        f !== null && (f = f.shared,
        (g & 4194240) !== 0)) {
            var w = f.lanes;
            w &= u.pendingLanes,
            g |= w,
            f.lanes = g,
            _0(u, g)
        }
    }
    function WM(u, f) {
        var g = u.updateQueue
          , w = u.alternate;
        if (w !== null && (w = w.updateQueue,
        g === w)) {
            var C = null
              , b = null;
            if (g = g.firstBaseUpdate,
            g !== null) {
                do {
                    var N = {
                        eventTime: g.eventTime,
                        lane: g.lane,
                        tag: g.tag,
                        payload: g.payload,
                        callback: g.callback,
                        next: null
                    };
                    b === null ? C = b = N : b = b.next = N,
                    g = g.next
                } while (g !== null);
                b === null ? C = b = f : b = b.next = f
            } else
                C = b = f;
            g = {
                baseState: w.baseState,
                firstBaseUpdate: C,
                lastBaseUpdate: b,
                shared: w.shared,
                effects: w.effects
            },
            u.updateQueue = g;
            return
        }
        u = g.lastBaseUpdate,
        u === null ? g.firstBaseUpdate = f : u.next = f,
        g.lastBaseUpdate = f
    }
    function dh(u, f, g, w) {
        var C = u.updateQueue;
        $s = !1;
        var b = C.firstBaseUpdate
          , N = C.lastBaseUpdate
          , K = C.shared.pending;
        if (K !== null) {
            C.shared.pending = null;
            var fe = K
              , Te = fe.next;
            fe.next = null,
            N === null ? b = Te : N.next = Te,
            N = fe;
            var Ve = u.alternate;
            Ve !== null && (Ve = Ve.updateQueue,
            K = Ve.lastBaseUpdate,
            K !== N && (K === null ? Ve.firstBaseUpdate = Te : K.next = Te,
            Ve.lastBaseUpdate = fe))
        }
        if (b !== null) {
            var st = C.baseState;
            N = 0,
            Ve = Te = fe = null,
            K = b;
            do {
                var et = K.lane
                  , zt = K.eventTime;
                if ((w & et) === et) {
                    Ve !== null && (Ve = Ve.next = {
                        eventTime: zt,
                        lane: 0,
                        tag: K.tag,
                        payload: K.payload,
                        callback: K.callback,
                        next: null
                    });
                    e: {
                        var Qe = u
                          , Qn = K;
                        switch (et = f,
                        zt = g,
                        Qn.tag) {
                        case 1:
                            if (Qe = Qn.payload,
                            typeof Qe == "function") {
                                st = Qe.call(zt, st, et);
                                break e
                            }
                            st = Qe;
                            break e;
                        case 3:
                            Qe.flags = Qe.flags & -65537 | 128;
                        case 0:
                            if (Qe = Qn.payload,
                            et = typeof Qe == "function" ? Qe.call(zt, st, et) : Qe,
                            et == null)
                                break e;
                            st = s({}, st, et);
                            break e;
                        case 2:
                            $s = !0
                        }
                    }
                    K.callback !== null && K.lane !== 0 && (u.flags |= 64,
                    et = C.effects,
                    et === null ? C.effects = [K] : et.push(K))
                } else
                    zt = {
                        eventTime: zt,
                        lane: et,
                        tag: K.tag,
                        payload: K.payload,
                        callback: K.callback,
                        next: null
                    },
                    Ve === null ? (Te = Ve = zt,
                    fe = st) : Ve = Ve.next = zt,
                    N |= et;
                if (K = K.next,
                K === null) {
                    if (K = C.shared.pending,
                    K === null)
                        break;
                    et = K,
                    K = et.next,
                    et.next = null,
                    C.lastBaseUpdate = et,
                    C.shared.pending = null
                }
            } while (1);
            if (Ve === null && (fe = st),
            C.baseState = fe,
            C.firstBaseUpdate = Te,
            C.lastBaseUpdate = Ve,
            f = C.shared.interleaved,
            f !== null) {
                C = f;
                do
                    N |= C.lane,
                    C = C.next;
                while (C !== f)
            } else
                b === null && (C.shared.lanes = 0);
            Bl |= N,
            u.lanes = N,
            u.memoizedState = st
        }
    }
    function jM(u, f, g) {
        if (u = f.effects,
        f.effects = null,
        u !== null)
            for (f = 0; f < u.length; f++) {
                var w = u[f]
                  , C = w.callback;
                if (C !== null) {
                    if (w.callback = null,
                    w = g,
                    typeof C != "function")
                        throw Error(o(191, C));
                    C.call(w)
                }
            }
    }
    var JM = new i.Component().refs;
    function B0(u, f, g, w) {
        f = u.memoizedState,
        g = g(w, f),
        g = g == null ? f : s({}, f, g),
        u.memoizedState = g,
        u.lanes === 0 && (u.updateQueue.baseState = g)
    }
    var hh = {
        isMounted: function(u) {
            return (u = u._reactInternals) ? B(u) === u : !1
        },
        enqueueSetState: function(u, f, g) {
            u = u._reactInternals;
            var w = ai()
              , C = io(u)
              , b = gs(w, C);
            b.payload = f,
            g != null && (b.callback = g),
            eo(u, b),
            f = rr(u, C, w),
            f !== null && fh(f, u, C)
        },
        enqueueReplaceState: function(u, f, g) {
            u = u._reactInternals;
            var w = ai()
              , C = io(u)
              , b = gs(w, C);
            b.tag = 1,
            b.payload = f,
            g != null && (b.callback = g),
            eo(u, b),
            f = rr(u, C, w),
            f !== null && fh(f, u, C)
        },
        enqueueForceUpdate: function(u, f) {
            u = u._reactInternals;
            var g = ai()
              , w = io(u)
              , C = gs(g, w);
            C.tag = 2,
            f != null && (C.callback = f),
            eo(u, C),
            f = rr(u, w, g),
            f !== null && fh(f, u, w)
        }
    };
    function XM(u, f, g, w, C, b, N) {
        return u = u.stateNode,
        typeof u.shouldComponentUpdate == "function" ? u.shouldComponentUpdate(w, b, N) : f.prototype && f.prototype.isPureReactComponent ? !lh(g, w) || !lh(C, b) : !0
    }
    function KM(u, f, g) {
        var w = !1
          , C = qi
          , b = f.contextType;
        return typeof b == "object" && b !== null ? b = $i(b) : (C = _i(f) ? hs : kt.current,
        w = f.contextTypes,
        b = (w = w != null) ? ps(u, C) : qi),
        f = new f(g,b),
        u.memoizedState = f.state !== null && f.state !== void 0 ? f.state : null,
        f.updater = hh,
        u.stateNode = f,
        f._reactInternals = u,
        w && (u = u.stateNode,
        u.__reactInternalMemoizedUnmaskedChildContext = C,
        u.__reactInternalMemoizedMaskedChildContext = b),
        f
    }
    function YM(u, f, g, w) {
        u = f.state,
        typeof f.componentWillReceiveProps == "function" && f.componentWillReceiveProps(g, w),
        typeof f.UNSAFE_componentWillReceiveProps == "function" && f.UNSAFE_componentWillReceiveProps(g, w),
        f.state !== u && hh.enqueueReplaceState(f, f.state, null)
    }
    function R0(u, f, g, w) {
        var C = u.stateNode;
        C.props = g,
        C.state = u.memoizedState,
        C.refs = JM,
        P0(u);
        var b = f.contextType;
        typeof b == "object" && b !== null ? C.context = $i(b) : (b = _i(f) ? hs : kt.current,
        C.context = ps(u, b)),
        C.state = u.memoizedState,
        b = f.getDerivedStateFromProps,
        typeof b == "function" && (B0(u, f, b, g),
        C.state = u.memoizedState),
        typeof f.getDerivedStateFromProps == "function" || typeof C.getSnapshotBeforeUpdate == "function" || typeof C.UNSAFE_componentWillMount != "function" && typeof C.componentWillMount != "function" || (f = C.state,
        typeof C.componentWillMount == "function" && C.componentWillMount(),
        typeof C.UNSAFE_componentWillMount == "function" && C.UNSAFE_componentWillMount(),
        f !== C.state && hh.enqueueReplaceState(C, C.state, null),
        dh(u, g, C, w),
        C.state = u.memoizedState),
        typeof C.componentDidMount == "function" && (u.flags |= 4194308)
    }
    var Ml = []
      , wl = 0
      , ph = null
      , mh = 0
      , er = []
      , tr = 0
      , aa = null
      , ys = 1
      , vs = "";
    function la(u, f) {
        Ml[wl++] = mh,
        Ml[wl++] = ph,
        ph = u,
        mh = f
    }
    function QM(u, f, g) {
        er[tr++] = ys,
        er[tr++] = vs,
        er[tr++] = aa,
        aa = u;
        var w = ys;
        u = vs;
        var C = 32 - Ar(w) - 1;
        w &= ~(1 << C),
        g += 1;
        var b = 32 - Ar(f) + C;
        if (30 < b) {
            var N = C - C % 5;
            b = (w & (1 << N) - 1).toString(32),
            w >>= N,
            C -= N,
            ys = 1 << 32 - Ar(f) + C | g << C | w,
            vs = b + u
        } else
            ys = 1 << b | g << C | w,
            vs = u
    }
    function L0(u) {
        u.return !== null && (la(u, 1),
        QM(u, 1, 0))
    }
    function I0(u) {
        for (; u === ph; )
            ph = Ml[--wl],
            Ml[wl] = null,
            mh = Ml[--wl],
            Ml[wl] = null;
        for (; u === aa; )
            aa = er[--tr],
            er[tr] = null,
            vs = er[--tr],
            er[tr] = null,
            ys = er[--tr],
            er[tr] = null
    }
    var Li = null
      , Ii = null
      , Yt = !1
      , uc = !1
      , wr = null;
    function ZM(u, f) {
        var g = sr(5, null, null, 0);
        g.elementType = "DELETED",
        g.stateNode = f,
        g.return = u,
        f = u.deletions,
        f === null ? (u.deletions = [g],
        u.flags |= 16) : f.push(g)
    }
    function qM(u, f) {
        switch (u.tag) {
        case 5:
            return f = xi(f, u.type, u.pendingProps),
            f !== null ? (u.stateNode = f,
            Li = u,
            Ii = he(f),
            !0) : !1;
        case 6:
            return f = $d(f, u.pendingProps),
            f !== null ? (u.stateNode = f,
            Li = u,
            Ii = null,
            !0) : !1;
        case 13:
            if (f = y0(f),
            f !== null) {
                var g = aa !== null ? {
                    id: ys,
                    overflow: vs
                } : null;
                return u.memoizedState = {
                    dehydrated: f,
                    treeContext: g,
                    retryLane: 1073741824
                },
                g = sr(18, null, null, 0),
                g.stateNode = f,
                g.return = u,
                u.child = g,
                Li = u,
                Ii = null,
                !0
            }
            return !1;
        default:
            return !1
        }
    }
    function D0(u) {
        return (u.mode & 1) !== 0 && (u.flags & 128) === 0
    }
    function F0(u) {
        if (Yt) {
            var f = Ii;
            if (f) {
                var g = f;
                if (!qM(u, f)) {
                    if (D0(u))
                        throw Error(o(418));
                    f = te(g);
                    var w = Li;
                    f && qM(u, f) ? ZM(w, g) : (u.flags = u.flags & -4097 | 2,
                    Yt = !1,
                    Li = u)
                }
            } else {
                if (D0(u))
                    throw Error(o(418));
                u.flags = u.flags & -4097 | 2,
                Yt = !1,
                Li = u
            }
        }
    }
    function $M(u) {
        for (u = u.return; u !== null && u.tag !== 5 && u.tag !== 3 && u.tag !== 13; )
            u = u.return;
        Li = u
    }
    function cc(u) {
        if (!ae || u !== Li)
            return !1;
        if (!Yt)
            return $M(u),
            Yt = !0,
            !1;
        if (u.tag !== 3 && (u.tag !== 5 || si(u.type) && !ve(u.type, u.memoizedProps))) {
            var f = Ii;
            if (f) {
                if (D0(u)) {
                    for (u = Ii; u; )
                        u = te(u);
                    throw Error(o(418))
                }
                for (; f; )
                    ZM(u, f),
                    f = te(f)
            }
        }
        if ($M(u),
        u.tag === 13) {
            if (!ae)
                throw Error(o(316));
            if (u = u.memoizedState,
            u = u !== null ? u.dehydrated : null,
            !u)
                throw Error(o(317));
            Ii = gt(u)
        } else
            Ii = Li ? te(u.stateNode) : null;
        return !0
    }
    function Sl() {
        ae && (Ii = Li = null,
        uc = Yt = !1)
    }
    function k0(u) {
        wr === null ? wr = [u] : wr.push(u)
    }
    function fc(u, f, g) {
        if (u = g.ref,
        u !== null && typeof u != "function" && typeof u != "object") {
            if (g._owner) {
                if (g = g._owner,
                g) {
                    if (g.tag !== 1)
                        throw Error(o(309));
                    var w = g.stateNode
                }
                if (!w)
                    throw Error(o(147, u));
                var C = w
                  , b = "" + u;
                return f !== null && f.ref !== null && typeof f.ref == "function" && f.ref._stringRef === b ? f.ref : (f = function(N) {
                    var K = C.refs;
                    K === JM && (K = C.refs = {}),
                    N === null ? delete K[b] : K[b] = N
                }
                ,
                f._stringRef = b,
                f)
            }
            if (typeof u != "string")
                throw Error(o(284));
            if (!g._owner)
                throw Error(o(290, u))
        }
        return u
    }
    function gh(u, f) {
        throw u = Object.prototype.toString.call(f),
        Error(o(31, u === "[object Object]" ? "object with keys {" + Object.keys(f).join(", ") + "}" : u))
    }
    function ew(u) {
        var f = u._init;
        return f(u._payload)
    }
    function tw(u) {
        function f(ne, Q) {
            if (u) {
                var ue = ne.deletions;
                ue === null ? (ne.deletions = [Q],
                ne.flags |= 16) : ue.push(Q)
            }
        }
        function g(ne, Q) {
            if (!u)
                return null;
            for (; Q !== null; )
                f(ne, Q),
                Q = Q.sibling;
            return null
        }
        function w(ne, Q) {
            for (ne = new Map; Q !== null; )
                Q.key !== null ? ne.set(Q.key, Q) : ne.set(Q.index, Q),
                Q = Q.sibling;
            return ne
        }
        function C(ne, Q) {
            return ne = so(ne, Q),
            ne.index = 0,
            ne.sibling = null,
            ne
        }
        function b(ne, Q, ue) {
            return ne.index = ue,
            u ? (ue = ne.alternate,
            ue !== null ? (ue = ue.index,
            ue < Q ? (ne.flags |= 2,
            Q) : ue) : (ne.flags |= 2,
            Q)) : (ne.flags |= 1048576,
            Q)
        }
        function N(ne) {
            return u && ne.alternate === null && (ne.flags |= 2),
            ne
        }
        function K(ne, Q, ue, Oe) {
            return Q === null || Q.tag !== 6 ? (Q = xy(ue, ne.mode, Oe),
            Q.return = ne,
            Q) : (Q = C(Q, ue),
            Q.return = ne,
            Q)
        }
        function fe(ne, Q, ue, Oe) {
            var Ke = ue.type;
            return Ke === d ? Ve(ne, Q, ue.props.children, Oe, ue.key) : Q !== null && (Q.elementType === Ke || typeof Ke == "object" && Ke !== null && Ke.$$typeof === M && ew(Ke) === Q.type) ? (Oe = C(Q, ue.props),
            Oe.ref = fc(ne, Q, ue),
            Oe.return = ne,
            Oe) : (Oe = Xh(ue.type, ue.key, ue.props, null, ne.mode, Oe),
            Oe.ref = fc(ne, Q, ue),
            Oe.return = ne,
            Oe)
        }
        function Te(ne, Q, ue, Oe) {
            return Q === null || Q.tag !== 4 || Q.stateNode.containerInfo !== ue.containerInfo || Q.stateNode.implementation !== ue.implementation ? (Q = _y(ue, ne.mode, Oe),
            Q.return = ne,
            Q) : (Q = C(Q, ue.children || []),
            Q.return = ne,
            Q)
        }
        function Ve(ne, Q, ue, Oe, Ke) {
            return Q === null || Q.tag !== 7 ? (Q = ma(ue, ne.mode, Oe, Ke),
            Q.return = ne,
            Q) : (Q = C(Q, ue),
            Q.return = ne,
            Q)
        }
        function st(ne, Q, ue) {
            if (typeof Q == "string" && Q !== "" || typeof Q == "number")
                return Q = xy("" + Q, ne.mode, ue),
                Q.return = ne,
                Q;
            if (typeof Q == "object" && Q !== null) {
                switch (Q.$$typeof) {
                case l:
                    return ue = Xh(Q.type, Q.key, Q.props, null, ne.mode, ue),
                    ue.ref = fc(ne, null, Q),
                    ue.return = ne,
                    ue;
                case c:
                    return Q = _y(Q, ne.mode, ue),
                    Q.return = ne,
                    Q;
                case M:
                    var Oe = Q._init;
                    return st(ne, Oe(Q._payload), ue)
                }
                if (X(Q) || P(Q))
                    return Q = ma(Q, ne.mode, ue, null),
                    Q.return = ne,
                    Q;
                gh(ne, Q)
            }
            return null
        }
        function et(ne, Q, ue, Oe) {
            var Ke = Q !== null ? Q.key : null;
            if (typeof ue == "string" && ue !== "" || typeof ue == "number")
                return Ke !== null ? null : K(ne, Q, "" + ue, Oe);
            if (typeof ue == "object" && ue !== null) {
                switch (ue.$$typeof) {
                case l:
                    return ue.key === Ke ? fe(ne, Q, ue, Oe) : null;
                case c:
                    return ue.key === Ke ? Te(ne, Q, ue, Oe) : null;
                case M:
                    return Ke = ue._init,
                    et(ne, Q, Ke(ue._payload), Oe)
                }
                if (X(ue) || P(ue))
                    return Ke !== null ? null : Ve(ne, Q, ue, Oe, null);
                gh(ne, ue)
            }
            return null
        }
        function zt(ne, Q, ue, Oe, Ke) {
            if (typeof Oe == "string" && Oe !== "" || typeof Oe == "number")
                return ne = ne.get(ue) || null,
                K(Q, ne, "" + Oe, Ke);
            if (typeof Oe == "object" && Oe !== null) {
                switch (Oe.$$typeof) {
                case l:
                    return ne = ne.get(Oe.key === null ? ue : Oe.key) || null,
                    fe(Q, ne, Oe, Ke);
                case c:
                    return ne = ne.get(Oe.key === null ? ue : Oe.key) || null,
                    Te(Q, ne, Oe, Ke);
                case M:
                    var pt = Oe._init;
                    return zt(ne, Q, ue, pt(Oe._payload), Ke)
                }
                if (X(Oe) || P(Oe))
                    return ne = ne.get(ue) || null,
                    Ve(Q, ne, Oe, Ke, null);
                gh(Q, Oe)
            }
            return null
        }
        function Qe(ne, Q, ue, Oe) {
            for (var Ke = null, pt = null, ot = Q, It = Q = 0, kn = null; ot !== null && It < ue.length; It++) {
                ot.index > It ? (kn = ot,
                ot = null) : kn = ot.sibling;
                var Dt = et(ne, ot, ue[It], Oe);
                if (Dt === null) {
                    ot === null && (ot = kn);
                    break
                }
                u && ot && Dt.alternate === null && f(ne, ot),
                Q = b(Dt, Q, It),
                pt === null ? Ke = Dt : pt.sibling = Dt,
                pt = Dt,
                ot = kn
            }
            if (It === ue.length)
                return g(ne, ot),
                Yt && la(ne, It),
                Ke;
            if (ot === null) {
                for (; It < ue.length; It++)
                    ot = st(ne, ue[It], Oe),
                    ot !== null && (Q = b(ot, Q, It),
                    pt === null ? Ke = ot : pt.sibling = ot,
                    pt = ot);
                return Yt && la(ne, It),
                Ke
            }
            for (ot = w(ne, ot); It < ue.length; It++)
                kn = zt(ot, ne, It, ue[It], Oe),
                kn !== null && (u && kn.alternate !== null && ot.delete(kn.key === null ? It : kn.key),
                Q = b(kn, Q, It),
                pt === null ? Ke = kn : pt.sibling = kn,
                pt = kn);
            return u && ot.forEach(function(oo) {
                return f(ne, oo)
            }),
            Yt && la(ne, It),
            Ke
        }
        function Qn(ne, Q, ue, Oe) {
            var Ke = P(ue);
            if (typeof Ke != "function")
                throw Error(o(150));
            if (ue = Ke.call(ue),
            ue == null)
                throw Error(o(151));
            for (var pt = Ke = null, ot = Q, It = Q = 0, kn = null, Dt = ue.next(); ot !== null && !Dt.done; It++,
            Dt = ue.next()) {
                ot.index > It ? (kn = ot,
                ot = null) : kn = ot.sibling;
                var oo = et(ne, ot, Dt.value, Oe);
                if (oo === null) {
                    ot === null && (ot = kn);
                    break
                }
                u && ot && oo.alternate === null && f(ne, ot),
                Q = b(oo, Q, It),
                pt === null ? Ke = oo : pt.sibling = oo,
                pt = oo,
                ot = kn
            }
            if (Dt.done)
                return g(ne, ot),
                Yt && la(ne, It),
                Ke;
            if (ot === null) {
                for (; !Dt.done; It++,
                Dt = ue.next())
                    Dt = st(ne, Dt.value, Oe),
                    Dt !== null && (Q = b(Dt, Q, It),
                    pt === null ? Ke = Dt : pt.sibling = Dt,
                    pt = Dt);
                return Yt && la(ne, It),
                Ke
            }
            for (ot = w(ne, ot); !Dt.done; It++,
            Dt = ue.next())
                Dt = zt(ot, ne, It, Dt.value, Oe),
                Dt !== null && (u && Dt.alternate !== null && ot.delete(Dt.key === null ? It : Dt.key),
                Q = b(Dt, Q, It),
                pt === null ? Ke = Dt : pt.sibling = Dt,
                pt = Dt);
            return u && ot.forEach(function(ZI) {
                return f(ne, ZI)
            }),
            Yt && la(ne, It),
            Ke
        }
        function or(ne, Q, ue, Oe) {
            if (typeof ue == "object" && ue !== null && ue.type === d && ue.key === null && (ue = ue.props.children),
            typeof ue == "object" && ue !== null) {
                switch (ue.$$typeof) {
                case l:
                    e: {
                        for (var Ke = ue.key, pt = Q; pt !== null; ) {
                            if (pt.key === Ke) {
                                if (Ke = ue.type,
                                Ke === d) {
                                    if (pt.tag === 7) {
                                        g(ne, pt.sibling),
                                        Q = C(pt, ue.props.children),
                                        Q.return = ne,
                                        ne = Q;
                                        break e
                                    }
                                } else if (pt.elementType === Ke || typeof Ke == "object" && Ke !== null && Ke.$$typeof === M && ew(Ke) === pt.type) {
                                    g(ne, pt.sibling),
                                    Q = C(pt, ue.props),
                                    Q.ref = fc(ne, pt, ue),
                                    Q.return = ne,
                                    ne = Q;
                                    break e
                                }
                                g(ne, pt);
                                break
                            } else
                                f(ne, pt);
                            pt = pt.sibling
                        }
                        ue.type === d ? (Q = ma(ue.props.children, ne.mode, Oe, ue.key),
                        Q.return = ne,
                        ne = Q) : (Oe = Xh(ue.type, ue.key, ue.props, null, ne.mode, Oe),
                        Oe.ref = fc(ne, Q, ue),
                        Oe.return = ne,
                        ne = Oe)
                    }
                    return N(ne);
                case c:
                    e: {
                        for (pt = ue.key; Q !== null; ) {
                            if (Q.key === pt)
                                if (Q.tag === 4 && Q.stateNode.containerInfo === ue.containerInfo && Q.stateNode.implementation === ue.implementation) {
                                    g(ne, Q.sibling),
                                    Q = C(Q, ue.children || []),
                                    Q.return = ne,
                                    ne = Q;
                                    break e
                                } else {
                                    g(ne, Q);
                                    break
                                }
                            else
                                f(ne, Q);
                            Q = Q.sibling
                        }
                        Q = _y(ue, ne.mode, Oe),
                        Q.return = ne,
                        ne = Q
                    }
                    return N(ne);
                case M:
                    return pt = ue._init,
                    or(ne, Q, pt(ue._payload), Oe)
                }
                if (X(ue))
                    return Qe(ne, Q, ue, Oe);
                if (P(ue))
                    return Qn(ne, Q, ue, Oe);
                gh(ne, ue)
            }
            return typeof ue == "string" && ue !== "" || typeof ue == "number" ? (ue = "" + ue,
            Q !== null && Q.tag === 6 ? (g(ne, Q.sibling),
            Q = C(Q, ue),
            Q.return = ne,
            ne = Q) : (g(ne, Q),
            Q = xy(ue, ne.mode, Oe),
            Q.return = ne,
            ne = Q),
            N(ne)) : g(ne, Q)
        }
        return or
    }
    var Cl = tw(!0)
      , nw = tw(!1)
      , dc = {}
      , nr = Zi(dc)
      , hc = Zi(dc)
      , El = Zi(dc);
    function Yr(u) {
        if (u === dc)
            throw Error(o(174));
        return u
    }
    function N0(u, f) {
        Tt(El, f),
        Tt(hc, u),
        Tt(nr, dc),
        u = ie(f),
        ft(nr),
        Tt(nr, u)
    }
    function Tl() {
        ft(nr),
        ft(hc),
        ft(El)
    }
    function iw(u) {
        var f = Yr(El.current)
          , g = Yr(nr.current);
        f = F(g, u.type, f),
        g !== f && (Tt(hc, u),
        Tt(nr, f))
    }
    function O0(u) {
        hc.current === u && (ft(nr),
        ft(hc))
    }
    var $t = Zi(0);
    function yh(u) {
        for (var f = u; f !== null; ) {
            if (f.tag === 13) {
                var g = f.memoizedState;
                if (g !== null && (g = g.dehydrated,
                g === null || eh(g) || oc(g)))
                    return f
            } else if (f.tag === 19 && f.memoizedProps.revealOrder !== void 0) {
                if (f.flags & 128)
                    return f
            } else if (f.child !== null) {
                f.child.return = f,
                f = f.child;
                continue
            }
            if (f === u)
                break;
            for (; f.sibling === null; ) {
                if (f.return === null || f.return === u)
                    return null;
                f = f.return
            }
            f.sibling.return = f.return,
            f = f.sibling
        }
        return null
    }
    var U0 = [];
    function z0() {
        for (var u = 0; u < U0.length; u++) {
            var f = U0[u];
            Me ? f._workInProgressVersionPrimary = null : f._workInProgressVersionSecondary = null
        }
        U0.length = 0
    }
    var vh = a.ReactCurrentDispatcher
      , ir = a.ReactCurrentBatchConfig
      , bl = 0
      , cn = null
      , Xn = null
      , Fn = null
      , xh = !1
      , pc = !1
      , mc = 0
      , MI = 0;
    function Kn() {
        throw Error(o(321))
    }
    function G0(u, f) {
        if (f === null)
            return !1;
        for (var g = 0; g < f.length && g < u.length; g++)
            if (!Jr(u[g], f[g]))
                return !1;
        return !0
    }
    function H0(u, f, g, w, C, b) {
        if (bl = b,
        cn = f,
        f.memoizedState = null,
        f.updateQueue = null,
        f.lanes = 0,
        vh.current = u === null || u.memoizedState === null ? EI : TI,
        u = g(w, C),
        pc) {
            b = 0;
            do {
                if (pc = !1,
                mc = 0,
                25 <= b)
                    throw Error(o(301));
                b += 1,
                Fn = Xn = null,
                f.updateQueue = null,
                vh.current = bI,
                u = g(w, C)
            } while (pc)
        }
        if (vh.current = Sh,
        f = Xn !== null && Xn.next !== null,
        bl = 0,
        Fn = Xn = cn = null,
        xh = !1,
        f)
            throw Error(o(300));
        return u
    }
    function V0() {
        var u = mc !== 0;
        return mc = 0,
        u
    }
    function xs() {
        var u = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return Fn === null ? cn.memoizedState = Fn = u : Fn = Fn.next = u,
        Fn
    }
    function Qr() {
        if (Xn === null) {
            var u = cn.alternate;
            u = u !== null ? u.memoizedState : null
        } else
            u = Xn.next;
        var f = Fn === null ? cn.memoizedState : Fn.next;
        if (f !== null)
            Fn = f,
            Xn = u;
        else {
            if (u === null)
                throw Error(o(310));
            Xn = u,
            u = {
                memoizedState: Xn.memoizedState,
                baseState: Xn.baseState,
                baseQueue: Xn.baseQueue,
                queue: Xn.queue,
                next: null
            },
            Fn === null ? cn.memoizedState = Fn = u : Fn = Fn.next = u
        }
        return Fn
    }
    function ua(u, f) {
        return typeof f == "function" ? f(u) : f
    }
    function _h(u) {
        var f = Qr()
          , g = f.queue;
        if (g === null)
            throw Error(o(311));
        g.lastRenderedReducer = u;
        var w = Xn
          , C = w.baseQueue
          , b = g.pending;
        if (b !== null) {
            if (C !== null) {
                var N = C.next;
                C.next = b.next,
                b.next = N
            }
            w.baseQueue = C = b,
            g.pending = null
        }
        if (C !== null) {
            b = C.next,
            w = w.baseState;
            var K = N = null
              , fe = null
              , Te = b;
            do {
                var Ve = Te.lane;
                if ((bl & Ve) === Ve)
                    fe !== null && (fe = fe.next = {
                        lane: 0,
                        action: Te.action,
                        hasEagerState: Te.hasEagerState,
                        eagerState: Te.eagerState,
                        next: null
                    }),
                    w = Te.hasEagerState ? Te.eagerState : u(w, Te.action);
                else {
                    var st = {
                        lane: Ve,
                        action: Te.action,
                        hasEagerState: Te.hasEagerState,
                        eagerState: Te.eagerState,
                        next: null
                    };
                    fe === null ? (K = fe = st,
                    N = w) : fe = fe.next = st,
                    cn.lanes |= Ve,
                    Bl |= Ve
                }
                Te = Te.next
            } while (Te !== null && Te !== b);
            fe === null ? N = w : fe.next = K,
            Jr(w, f.memoizedState) || (Di = !0),
            f.memoizedState = w,
            f.baseState = N,
            f.baseQueue = fe,
            g.lastRenderedState = w
        }
        if (u = g.interleaved,
        u !== null) {
            C = u;
            do
                b = C.lane,
                cn.lanes |= b,
                Bl |= b,
                C = C.next;
            while (C !== u)
        } else
            C === null && (g.lanes = 0);
        return [f.memoizedState, g.dispatch]
    }
    function Ah(u) {
        var f = Qr()
          , g = f.queue;
        if (g === null)
            throw Error(o(311));
        g.lastRenderedReducer = u;
        var w = g.dispatch
          , C = g.pending
          , b = f.memoizedState;
        if (C !== null) {
            g.pending = null;
            var N = C = C.next;
            do
                b = u(b, N.action),
                N = N.next;
            while (N !== C);
            Jr(b, f.memoizedState) || (Di = !0),
            f.memoizedState = b,
            f.baseQueue === null && (f.baseState = b),
            g.lastRenderedState = b
        }
        return [b, w]
    }
    function rw() {}
    function sw(u, f) {
        var g = cn
          , w = Qr()
          , C = f()
          , b = !Jr(w.memoizedState, C);
        if (b && (w.memoizedState = C,
        Di = !0),
        w = w.queue,
        yc(lw.bind(null, g, w, u), [u]),
        w.getSnapshot !== f || b || Fn !== null && Fn.memoizedState.tag & 1) {
            if (g.flags |= 2048,
            gc(9, aw.bind(null, g, w, C, f), void 0, null),
            xn === null)
                throw Error(o(349));
            bl & 30 || ow(g, f, C)
        }
        return C
    }
    function ow(u, f, g) {
        u.flags |= 16384,
        u = {
            getSnapshot: f,
            value: g
        },
        f = cn.updateQueue,
        f === null ? (f = {
            lastEffect: null,
            stores: null
        },
        cn.updateQueue = f,
        f.stores = [u]) : (g = f.stores,
        g === null ? f.stores = [u] : g.push(u))
    }
    function aw(u, f, g, w) {
        f.value = g,
        f.getSnapshot = w,
        uw(f) && rr(u, 1, -1)
    }
    function lw(u, f, g) {
        return g(function() {
            uw(f) && rr(u, 1, -1)
        })
    }
    function uw(u) {
        var f = u.getSnapshot;
        u = u.value;
        try {
            var g = f();
            return !Jr(u, g)
        } catch {
            return !0
        }
    }
    function W0(u) {
        var f = xs();
        return typeof u == "function" && (u = u()),
        f.memoizedState = f.baseState = u,
        u = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: ua,
            lastRenderedState: u
        },
        f.queue = u,
        u = u.dispatch = CI.bind(null, cn, u),
        [f.memoizedState, u]
    }
    function gc(u, f, g, w) {
        return u = {
            tag: u,
            create: f,
            destroy: g,
            deps: w,
            next: null
        },
        f = cn.updateQueue,
        f === null ? (f = {
            lastEffect: null,
            stores: null
        },
        cn.updateQueue = f,
        f.lastEffect = u.next = u) : (g = f.lastEffect,
        g === null ? f.lastEffect = u.next = u : (w = g.next,
        g.next = u,
        u.next = w,
        f.lastEffect = u)),
        u
    }
    function cw() {
        return Qr().memoizedState
    }
    function Mh(u, f, g, w) {
        var C = xs();
        cn.flags |= u,
        C.memoizedState = gc(1 | f, g, void 0, w === void 0 ? null : w)
    }
    function wh(u, f, g, w) {
        var C = Qr();
        w = w === void 0 ? null : w;
        var b = void 0;
        if (Xn !== null) {
            var N = Xn.memoizedState;
            if (b = N.destroy,
            w !== null && G0(w, N.deps)) {
                C.memoizedState = gc(f, g, b, w);
                return
            }
        }
        cn.flags |= u,
        C.memoizedState = gc(1 | f, g, b, w)
    }
    function j0(u, f) {
        return Mh(8390656, 8, u, f)
    }
    function yc(u, f) {
        return wh(2048, 8, u, f)
    }
    function fw(u, f) {
        return wh(4, 2, u, f)
    }
    function dw(u, f) {
        return wh(4, 4, u, f)
    }
    function hw(u, f) {
        if (typeof f == "function")
            return u = u(),
            f(u),
            function() {
                f(null)
            }
            ;
        if (f != null)
            return u = u(),
            f.current = u,
            function() {
                f.current = null
            }
    }
    function pw(u, f, g) {
        return g = g != null ? g.concat([u]) : null,
        wh(4, 4, hw.bind(null, f, u), g)
    }
    function J0() {}
    function mw(u, f) {
        var g = Qr();
        f = f === void 0 ? null : f;
        var w = g.memoizedState;
        return w !== null && f !== null && G0(f, w[1]) ? w[0] : (g.memoizedState = [u, f],
        u)
    }
    function gw(u, f) {
        var g = Qr();
        f = f === void 0 ? null : f;
        var w = g.memoizedState;
        return w !== null && f !== null && G0(f, w[1]) ? w[0] : (u = u(),
        g.memoizedState = [u, f],
        u)
    }
    function wI(u, f) {
        var g = Lt;
        Lt = g !== 0 && 4 > g ? g : 4,
        u(!0);
        var w = ir.transition;
        ir.transition = {};
        try {
            u(!1),
            f()
        } finally {
            Lt = g,
            ir.transition = w
        }
    }
    function yw() {
        return Qr().memoizedState
    }
    function SI(u, f, g) {
        var w = io(u);
        g = {
            lane: w,
            action: g,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        vw(u) ? xw(f, g) : (_w(u, f, g),
        g = ai(),
        u = rr(u, w, g),
        u !== null && Aw(u, f, w))
    }
    function CI(u, f, g) {
        var w = io(u)
          , C = {
            lane: w,
            action: g,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        if (vw(u))
            xw(f, C);
        else {
            _w(u, f, C);
            var b = u.alternate;
            if (u.lanes === 0 && (b === null || b.lanes === 0) && (b = f.lastRenderedReducer,
            b !== null))
                try {
                    var N = f.lastRenderedState
                      , K = b(N, g);
                    if (C.hasEagerState = !0,
                    C.eagerState = K,
                    Jr(K, N))
                        return
                } catch {} finally {}
            g = ai(),
            u = rr(u, w, g),
            u !== null && Aw(u, f, w)
        }
    }
    function vw(u) {
        var f = u.alternate;
        return u === cn || f !== null && f === cn
    }
    function xw(u, f) {
        pc = xh = !0;
        var g = u.pending;
        g === null ? f.next = f : (f.next = g.next,
        g.next = f),
        u.pending = f
    }
    function _w(u, f, g) {
        xn !== null && u.mode & 1 && !(yt & 2) ? (u = f.interleaved,
        u === null ? (g.next = g,
        Kr === null ? Kr = [f] : Kr.push(f)) : (g.next = u.next,
        u.next = g),
        f.interleaved = g) : (u = f.pending,
        u === null ? g.next = g : (g.next = u.next,
        u.next = g),
        f.pending = g)
    }
    function Aw(u, f, g) {
        if (g & 4194240) {
            var w = f.lanes;
            w &= u.pendingLanes,
            g |= w,
            f.lanes = g,
            _0(u, g)
        }
    }
    var Sh = {
        readContext: $i,
        useCallback: Kn,
        useContext: Kn,
        useEffect: Kn,
        useImperativeHandle: Kn,
        useInsertionEffect: Kn,
        useLayoutEffect: Kn,
        useMemo: Kn,
        useReducer: Kn,
        useRef: Kn,
        useState: Kn,
        useDebugValue: Kn,
        useDeferredValue: Kn,
        useTransition: Kn,
        useMutableSource: Kn,
        useSyncExternalStore: Kn,
        useId: Kn,
        unstable_isNewReconciler: !1
    }
      , EI = {
        readContext: $i,
        useCallback: function(u, f) {
            return xs().memoizedState = [u, f === void 0 ? null : f],
            u
        },
        useContext: $i,
        useEffect: j0,
        useImperativeHandle: function(u, f, g) {
            return g = g != null ? g.concat([u]) : null,
            Mh(4194308, 4, hw.bind(null, f, u), g)
        },
        useLayoutEffect: function(u, f) {
            return Mh(4194308, 4, u, f)
        },
        useInsertionEffect: function(u, f) {
            return Mh(4, 2, u, f)
        },
        useMemo: function(u, f) {
            var g = xs();
            return f = f === void 0 ? null : f,
            u = u(),
            g.memoizedState = [u, f],
            u
        },
        useReducer: function(u, f, g) {
            var w = xs();
            return f = g !== void 0 ? g(f) : f,
            w.memoizedState = w.baseState = f,
            u = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: u,
                lastRenderedState: f
            },
            w.queue = u,
            u = u.dispatch = SI.bind(null, cn, u),
            [w.memoizedState, u]
        },
        useRef: function(u) {
            var f = xs();
            return u = {
                current: u
            },
            f.memoizedState = u
        },
        useState: W0,
        useDebugValue: J0,
        useDeferredValue: function(u) {
            var f = W0(u)
              , g = f[0]
              , w = f[1];
            return j0(function() {
                var C = ir.transition;
                ir.transition = {};
                try {
                    w(u)
                } finally {
                    ir.transition = C
                }
            }, [u]),
            g
        },
        useTransition: function() {
            var u = W0(!1)
              , f = u[0];
            return u = wI.bind(null, u[1]),
            xs().memoizedState = u,
            [f, u]
        },
        useMutableSource: function() {},
        useSyncExternalStore: function(u, f, g) {
            var w = cn
              , C = xs();
            if (Yt) {
                if (g === void 0)
                    throw Error(o(407));
                g = g()
            } else {
                if (g = f(),
                xn === null)
                    throw Error(o(349));
                bl & 30 || ow(w, f, g)
            }
            C.memoizedState = g;
            var b = {
                value: g,
                getSnapshot: f
            };
            return C.queue = b,
            j0(lw.bind(null, w, b, u), [u]),
            w.flags |= 2048,
            gc(9, aw.bind(null, w, b, g, f), void 0, null),
            g
        },
        useId: function() {
            var u = xs()
              , f = xn.identifierPrefix;
            if (Yt) {
                var g = vs
                  , w = ys;
                g = (w & ~(1 << 32 - Ar(w) - 1)).toString(32) + g,
                f = ":" + f + "R" + g,
                g = mc++,
                0 < g && (f += "H" + g.toString(32)),
                f += ":"
            } else
                g = MI++,
                f = ":" + f + "r" + g.toString(32) + ":";
            return u.memoizedState = f
        },
        unstable_isNewReconciler: !1
    }
      , TI = {
        readContext: $i,
        useCallback: mw,
        useContext: $i,
        useEffect: yc,
        useImperativeHandle: pw,
        useInsertionEffect: fw,
        useLayoutEffect: dw,
        useMemo: gw,
        useReducer: _h,
        useRef: cw,
        useState: function() {
            return _h(ua)
        },
        useDebugValue: J0,
        useDeferredValue: function(u) {
            var f = _h(ua)
              , g = f[0]
              , w = f[1];
            return yc(function() {
                var C = ir.transition;
                ir.transition = {};
                try {
                    w(u)
                } finally {
                    ir.transition = C
                }
            }, [u]),
            g
        },
        useTransition: function() {
            var u = _h(ua)[0]
              , f = Qr().memoizedState;
            return [u, f]
        },
        useMutableSource: rw,
        useSyncExternalStore: sw,
        useId: yw,
        unstable_isNewReconciler: !1
    }
      , bI = {
        readContext: $i,
        useCallback: mw,
        useContext: $i,
        useEffect: yc,
        useImperativeHandle: pw,
        useInsertionEffect: fw,
        useLayoutEffect: dw,
        useMemo: gw,
        useReducer: Ah,
        useRef: cw,
        useState: function() {
            return Ah(ua)
        },
        useDebugValue: J0,
        useDeferredValue: function(u) {
            var f = Ah(ua)
              , g = f[0]
              , w = f[1];
            return yc(function() {
                var C = ir.transition;
                ir.transition = {};
                try {
                    w(u)
                } finally {
                    ir.transition = C
                }
            }, [u]),
            g
        },
        useTransition: function() {
            var u = Ah(ua)[0]
              , f = Qr().memoizedState;
            return [u, f]
        },
        useMutableSource: rw,
        useSyncExternalStore: sw,
        useId: yw,
        unstable_isNewReconciler: !1
    };
    function X0(u, f) {
        try {
            var g = ""
              , w = f;
            do
                g += AI(w),
                w = w.return;
            while (w);
            var C = g
        } catch (b) {
            C = `
Error generating stack: ` + b.message + `
` + b.stack
        }
        return {
            value: u,
            source: f,
            stack: C
        }
    }
    function K0(u, f) {
        try {
            console.error(f.value)
        } catch (g) {
            setTimeout(function() {
                throw g
            })
        }
    }
    var PI = typeof WeakMap == "function" ? WeakMap : Map;
    function Mw(u, f, g) {
        g = gs(-1, g),
        g.tag = 3,
        g.payload = {
            element: null
        };
        var w = f.value;
        return g.callback = function() {
            zh || (zh = !0,
            dy = w),
            K0(u, f)
        }
        ,
        g
    }
    function ww(u, f, g) {
        g = gs(-1, g),
        g.tag = 3;
        var w = u.type.getDerivedStateFromError;
        if (typeof w == "function") {
            var C = f.value;
            g.payload = function() {
                return w(C)
            }
            ,
            g.callback = function() {
                K0(u, f)
            }
        }
        var b = u.stateNode;
        return b !== null && typeof b.componentDidCatch == "function" && (g.callback = function() {
            K0(u, f),
            typeof w != "function" && (to === null ? to = new Set([this]) : to.add(this));
            var N = f.stack;
            this.componentDidCatch(f.value, {
                componentStack: N !== null ? N : ""
            })
        }
        ),
        g
    }
    function Sw(u, f, g) {
        var w = u.pingCache;
        if (w === null) {
            w = u.pingCache = new PI;
            var C = new Set;
            w.set(f, C)
        } else
            C = w.get(f),
            C === void 0 && (C = new Set,
            w.set(f, C));
        C.has(g) || (C.add(g),
        u = VI.bind(null, u, f, g),
        f.then(u, u))
    }
    function Cw(u) {
        do {
            var f;
            if ((f = u.tag === 13) && (f = u.memoizedState,
            f = f !== null ? f.dehydrated !== null : !0),
            f)
                return u;
            u = u.return
        } while (u !== null);
        return null
    }
    function Ew(u, f, g, w, C) {
        return u.mode & 1 ? (u.flags |= 65536,
        u.lanes = C,
        u) : (u === f ? u.flags |= 65536 : (u.flags |= 128,
        g.flags |= 131072,
        g.flags &= -52805,
        g.tag === 1 && (g.alternate === null ? g.tag = 17 : (f = gs(-1, 1),
        f.tag = 2,
        eo(g, f))),
        g.lanes |= 1),
        u)
    }
    function Zr(u) {
        u.flags |= 4
    }
    function Tw(u, f) {
        if (u !== null && u.child === f.child)
            return !0;
        if (f.flags & 16)
            return !1;
        for (u = f.child; u !== null; ) {
            if (u.flags & 12854 || u.subtreeFlags & 12854)
                return !1;
            u = u.sibling
        }
        return !0
    }
    var vc, xc, Ch, Eh;
    if (De)
        vc = function(u, f) {
            for (var g = f.child; g !== null; ) {
                if (g.tag === 5 || g.tag === 6)
                    H(u, g.stateNode);
                else if (g.tag !== 4 && g.child !== null) {
                    g.child.return = g,
                    g = g.child;
                    continue
                }
                if (g === f)
                    break;
                for (; g.sibling === null; ) {
                    if (g.return === null || g.return === f)
                        return;
                    g = g.return
                }
                g.sibling.return = g.return,
                g = g.sibling
            }
        }
        ,
        xc = function() {}
        ,
        Ch = function(u, f, g, w, C) {
            if (u = u.memoizedProps,
            u !== w) {
                var b = f.stateNode
                  , N = Yr(nr.current);
                g = ye(b, g, u, w, C, N),
                (f.updateQueue = g) && Zr(f)
            }
        }
        ,
        Eh = function(u, f, g, w) {
            g !== w && Zr(f)
        }
        ;
    else if (de) {
        vc = function(u, f, g, w) {
            for (var C = f.child; C !== null; ) {
                if (C.tag === 5) {
                    var b = C.stateNode;
                    g && w && (b = Ut(b, C.type, C.memoizedProps, C)),
                    H(u, b)
                } else if (C.tag === 6)
                    b = C.stateNode,
                    g && w && (b = Yi(b, C.memoizedProps, C)),
                    H(u, b);
                else if (C.tag !== 4) {
                    if (C.tag === 22 && C.memoizedState !== null)
                        b = C.child,
                        b !== null && (b.return = C),
                        vc(u, C, !0, !0);
                    else if (C.child !== null) {
                        C.child.return = C,
                        C = C.child;
                        continue
                    }
                }
                if (C === f)
                    break;
                for (; C.sibling === null; ) {
                    if (C.return === null || C.return === f)
                        return;
                    C = C.return
                }
                C.sibling.return = C.return,
                C = C.sibling
            }
        }
        ;
        var bw = function(u, f, g, w) {
            for (var C = f.child; C !== null; ) {
                if (C.tag === 5) {
                    var b = C.stateNode;
                    g && w && (b = Ut(b, C.type, C.memoizedProps, C)),
                    pn(u, b)
                } else if (C.tag === 6)
                    b = C.stateNode,
                    g && w && (b = Yi(b, C.memoizedProps, C)),
                    pn(u, b);
                else if (C.tag !== 4) {
                    if (C.tag === 22 && C.memoizedState !== null)
                        b = C.child,
                        b !== null && (b.return = C),
                        bw(u, C, !0, !0);
                    else if (C.child !== null) {
                        C.child.return = C,
                        C = C.child;
                        continue
                    }
                }
                if (C === f)
                    break;
                for (; C.sibling === null; ) {
                    if (C.return === null || C.return === f)
                        return;
                    C = C.return
                }
                C.sibling.return = C.return,
                C = C.sibling
            }
        };
        xc = function(u, f) {
            var g = f.stateNode;
            if (!Tw(u, f)) {
                u = g.containerInfo;
                var w = Pt(u);
                bw(w, f, !1, !1),
                g.pendingChildren = w,
                Zr(f),
                Ln(u, w)
            }
        }
        ,
        Ch = function(u, f, g, w, C) {
            var b = u.stateNode
              , N = u.memoizedProps;
            if ((u = Tw(u, f)) && N === w)
                f.stateNode = b;
            else {
                var K = f.stateNode
                  , fe = Yr(nr.current)
                  , Te = null;
                N !== w && (Te = ye(K, g, N, w, C, fe)),
                u && Te === null ? f.stateNode = b : (b = Ye(b, Te, g, N, w, f, u, K),
                se(b, g, w, C, fe) && Zr(f),
                f.stateNode = b,
                u ? Zr(f) : vc(b, f, !1, !1))
            }
        }
        ,
        Eh = function(u, f, g, w) {
            g !== w ? (u = Yr(El.current),
            g = Yr(nr.current),
            f.stateNode = q(w, u, g, f),
            Zr(f)) : f.stateNode = u.stateNode
        }
    } else
        xc = function() {}
        ,
        Ch = function() {}
        ,
        Eh = function() {}
        ;
    function _c(u, f) {
        if (!Yt)
            switch (u.tailMode) {
            case "hidden":
                f = u.tail;
                for (var g = null; f !== null; )
                    f.alternate !== null && (g = f),
                    f = f.sibling;
                g === null ? u.tail = null : g.sibling = null;
                break;
            case "collapsed":
                g = u.tail;
                for (var w = null; g !== null; )
                    g.alternate !== null && (w = g),
                    g = g.sibling;
                w === null ? f || u.tail === null ? u.tail = null : u.tail.sibling = null : w.sibling = null
            }
    }
    function Yn(u) {
        var f = u.alternate !== null && u.alternate.child === u.child
          , g = 0
          , w = 0;
        if (f)
            for (var C = u.child; C !== null; )
                g |= C.lanes | C.childLanes,
                w |= C.subtreeFlags & 14680064,
                w |= C.flags & 14680064,
                C.return = u,
                C = C.sibling;
        else
            for (C = u.child; C !== null; )
                g |= C.lanes | C.childLanes,
                w |= C.subtreeFlags,
                w |= C.flags,
                C.return = u,
                C = C.sibling;
        return u.subtreeFlags |= w,
        u.childLanes = g,
        f
    }
    function BI(u, f, g) {
        var w = f.pendingProps;
        switch (I0(f),
        f.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return Yn(f),
            null;
        case 1:
            return _i(f.type) && th(),
            Yn(f),
            null;
        case 3:
            return w = f.stateNode,
            Tl(),
            ft(In),
            ft(kt),
            z0(),
            w.pendingContext && (w.context = w.pendingContext,
            w.pendingContext = null),
            (u === null || u.child === null) && (cc(f) ? Zr(f) : u === null || u.memoizedState.isDehydrated && !(f.flags & 256) || (f.flags |= 1024,
            wr !== null && (my(wr),
            wr = null))),
            xc(u, f),
            Yn(f),
            null;
        case 5:
            O0(f),
            g = Yr(El.current);
            var C = f.type;
            if (u !== null && f.stateNode != null)
                Ch(u, f, C, w, g),
                u.ref !== f.ref && (f.flags |= 512,
                f.flags |= 2097152);
            else {
                if (!w) {
                    if (f.stateNode === null)
                        throw Error(o(166));
                    return Yn(f),
                    null
                }
                if (u = Yr(nr.current),
                cc(f)) {
                    if (!ae)
                        throw Error(o(175));
                    u = qe(f.stateNode, f.type, f.memoizedProps, g, u, f, !uc),
                    f.updateQueue = u,
                    u !== null && Zr(f)
                } else {
                    var b = re(C, w, g, u, f);
                    vc(b, f, !1, !1),
                    f.stateNode = b,
                    se(b, C, w, g, u) && Zr(f)
                }
                f.ref !== null && (f.flags |= 512,
                f.flags |= 2097152)
            }
            return Yn(f),
            null;
        case 6:
            if (u && f.stateNode != null)
                Eh(u, f, u.memoizedProps, w);
            else {
                if (typeof w != "string" && f.stateNode === null)
                    throw Error(o(166));
                if (u = Yr(El.current),
                g = Yr(nr.current),
                cc(f)) {
                    if (!ae)
                        throw Error(o(176));
                    if (u = f.stateNode,
                    w = f.memoizedProps,
                    (g = it(u, w, f, !uc)) && (C = Li,
                    C !== null))
                        switch (b = (C.mode & 1) !== 0,
                        C.tag) {
                        case 3:
                            _r(C.stateNode.containerInfo, u, w, b);
                            break;
                        case 5:
                            fs(C.type, C.memoizedProps, C.stateNode, u, w, b)
                        }
                    g && Zr(f)
                } else
                    f.stateNode = q(w, u, g, f)
            }
            return Yn(f),
            null;
        case 13:
            if (ft($t),
            w = f.memoizedState,
            Yt && Ii !== null && f.mode & 1 && !(f.flags & 128)) {
                for (u = Ii; u; )
                    u = te(u);
                return Sl(),
                f.flags |= 98560,
                f
            }
            if (w !== null && w.dehydrated !== null) {
                if (w = cc(f),
                u === null) {
                    if (!w)
                        throw Error(o(318));
                    if (!ae)
                        throw Error(o(344));
                    if (u = f.memoizedState,
                    u = u !== null ? u.dehydrated : null,
                    !u)
                        throw Error(o(317));
                    dt(u, f)
                } else
                    Sl(),
                    !(f.flags & 128) && (f.memoizedState = null),
                    f.flags |= 4;
                return Yn(f),
                null
            }
            return wr !== null && (my(wr),
            wr = null),
            f.flags & 128 ? (f.lanes = g,
            f) : (w = w !== null,
            g = !1,
            u === null ? cc(f) : g = u.memoizedState !== null,
            w && !g && (f.child.flags |= 8192,
            f.mode & 1 && (u === null || $t.current & 1 ? Cn === 0 && (Cn = 3) : yy())),
            f.updateQueue !== null && (f.flags |= 4),
            Yn(f),
            null);
        case 4:
            return Tl(),
            xc(u, f),
            u === null && ze(f.stateNode.containerInfo),
            Yn(f),
            null;
        case 10:
            return T0(f.type._context),
            Yn(f),
            null;
        case 17:
            return _i(f.type) && th(),
            Yn(f),
            null;
        case 19:
            if (ft($t),
            C = f.memoizedState,
            C === null)
                return Yn(f),
                null;
            if (w = (f.flags & 128) !== 0,
            b = C.rendering,
            b === null)
                if (w)
                    _c(C, !1);
                else {
                    if (Cn !== 0 || u !== null && u.flags & 128)
                        for (u = f.child; u !== null; ) {
                            if (b = yh(u),
                            b !== null) {
                                for (f.flags |= 128,
                                _c(C, !1),
                                u = b.updateQueue,
                                u !== null && (f.updateQueue = u,
                                f.flags |= 4),
                                f.subtreeFlags = 0,
                                u = g,
                                w = f.child; w !== null; )
                                    g = w,
                                    C = u,
                                    g.flags &= 14680066,
                                    b = g.alternate,
                                    b === null ? (g.childLanes = 0,
                                    g.lanes = C,
                                    g.child = null,
                                    g.subtreeFlags = 0,
                                    g.memoizedProps = null,
                                    g.memoizedState = null,
                                    g.updateQueue = null,
                                    g.dependencies = null,
                                    g.stateNode = null) : (g.childLanes = b.childLanes,
                                    g.lanes = b.lanes,
                                    g.child = b.child,
                                    g.subtreeFlags = 0,
                                    g.deletions = null,
                                    g.memoizedProps = b.memoizedProps,
                                    g.memoizedState = b.memoizedState,
                                    g.updateQueue = b.updateQueue,
                                    g.type = b.type,
                                    C = b.dependencies,
                                    g.dependencies = C === null ? null : {
                                        lanes: C.lanes,
                                        firstContext: C.firstContext
                                    }),
                                    w = w.sibling;
                                return Tt($t, $t.current & 1 | 2),
                                f.child
                            }
                            u = u.sibling
                        }
                    C.tail !== null && Dn() > fy && (f.flags |= 128,
                    w = !0,
                    _c(C, !1),
                    f.lanes = 4194304)
                }
            else {
                if (!w)
                    if (u = yh(b),
                    u !== null) {
                        if (f.flags |= 128,
                        w = !0,
                        u = u.updateQueue,
                        u !== null && (f.updateQueue = u,
                        f.flags |= 4),
                        _c(C, !0),
                        C.tail === null && C.tailMode === "hidden" && !b.alternate && !Yt)
                            return Yn(f),
                            null
                    } else
                        2 * Dn() - C.renderingStartTime > fy && g !== 1073741824 && (f.flags |= 128,
                        w = !0,
                        _c(C, !1),
                        f.lanes = 4194304);
                C.isBackwards ? (b.sibling = f.child,
                f.child = b) : (u = C.last,
                u !== null ? u.sibling = b : f.child = b,
                C.last = b)
            }
            return C.tail !== null ? (f = C.tail,
            C.rendering = f,
            C.tail = f.sibling,
            C.renderingStartTime = Dn(),
            f.sibling = null,
            u = $t.current,
            Tt($t, w ? u & 1 | 2 : u & 1),
            f) : (Yn(f),
            null);
        case 22:
        case 23:
            return gy(),
            w = f.memoizedState !== null,
            u !== null && u.memoizedState !== null !== w && (f.flags |= 8192),
            w && f.mode & 1 ? Fi & 1073741824 && (Yn(f),
            De && f.subtreeFlags & 6 && (f.flags |= 8192)) : Yn(f),
            null;
        case 24:
            return null;
        case 25:
            return null
        }
        throw Error(o(156, f.tag))
    }
    var RI = a.ReactCurrentOwner
      , Di = !1;
    function oi(u, f, g, w) {
        f.child = u === null ? nw(f, null, g, w) : Cl(f, u.child, g, w)
    }
    function Pw(u, f, g, w, C) {
        g = g.render;
        var b = f.ref;
        return Al(f, C),
        w = H0(u, f, g, w, b, C),
        g = V0(),
        u !== null && !Di ? (f.updateQueue = u.updateQueue,
        f.flags &= -2053,
        u.lanes &= ~C,
        _s(u, f, C)) : (Yt && g && L0(f),
        f.flags |= 1,
        oi(u, f, w, C),
        f.child)
    }
    function Bw(u, f, g, w, C) {
        if (u === null) {
            var b = g.type;
            return typeof b == "function" && !vy(b) && b.defaultProps === void 0 && g.compare === null && g.defaultProps === void 0 ? (f.tag = 15,
            f.type = b,
            Rw(u, f, b, w, C)) : (u = Xh(g.type, null, w, f, f.mode, C),
            u.ref = f.ref,
            u.return = f,
            f.child = u)
        }
        if (b = u.child,
        !(u.lanes & C)) {
            var N = b.memoizedProps;
            if (g = g.compare,
            g = g !== null ? g : lh,
            g(N, w) && u.ref === f.ref)
                return _s(u, f, C)
        }
        return f.flags |= 1,
        u = so(b, w),
        u.ref = f.ref,
        u.return = f,
        f.child = u
    }
    function Rw(u, f, g, w, C) {
        if (u !== null && lh(u.memoizedProps, w) && u.ref === f.ref)
            if (Di = !1,
            (u.lanes & C) !== 0)
                u.flags & 131072 && (Di = !0);
            else
                return f.lanes = u.lanes,
                _s(u, f, C);
        return Y0(u, f, g, w, C)
    }
    function Lw(u, f, g) {
        var w = f.pendingProps
          , C = w.children
          , b = u !== null ? u.memoizedState : null;
        if (w.mode === "hidden")
            if (!(f.mode & 1))
                f.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                },
                Tt(Pl, Fi),
                Fi |= g;
            else if (g & 1073741824)
                f.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                },
                w = b !== null ? b.baseLanes : g,
                Tt(Pl, Fi),
                Fi |= w;
            else
                return u = b !== null ? b.baseLanes | g : g,
                f.lanes = f.childLanes = 1073741824,
                f.memoizedState = {
                    baseLanes: u,
                    cachePool: null
                },
                f.updateQueue = null,
                Tt(Pl, Fi),
                Fi |= u,
                null;
        else
            b !== null ? (w = b.baseLanes | g,
            f.memoizedState = null) : w = g,
            Tt(Pl, Fi),
            Fi |= w;
        return oi(u, f, C, g),
        f.child
    }
    function Iw(u, f) {
        var g = f.ref;
        (u === null && g !== null || u !== null && u.ref !== g) && (f.flags |= 512,
        f.flags |= 2097152)
    }
    function Y0(u, f, g, w, C) {
        var b = _i(g) ? hs : kt.current;
        return b = ps(f, b),
        Al(f, C),
        g = H0(u, f, g, w, b, C),
        w = V0(),
        u !== null && !Di ? (f.updateQueue = u.updateQueue,
        f.flags &= -2053,
        u.lanes &= ~C,
        _s(u, f, C)) : (Yt && w && L0(f),
        f.flags |= 1,
        oi(u, f, g, C),
        f.child)
    }
    function Dw(u, f, g, w, C) {
        if (_i(g)) {
            var b = !0;
            nh(f)
        } else
            b = !1;
        if (Al(f, C),
        f.stateNode === null)
            u !== null && (u.alternate = null,
            f.alternate = null,
            f.flags |= 2),
            KM(f, g, w),
            R0(f, g, w, C),
            w = !0;
        else if (u === null) {
            var N = f.stateNode
              , K = f.memoizedProps;
            N.props = K;
            var fe = N.context
              , Te = g.contextType;
            typeof Te == "object" && Te !== null ? Te = $i(Te) : (Te = _i(g) ? hs : kt.current,
            Te = ps(f, Te));
            var Ve = g.getDerivedStateFromProps
              , st = typeof Ve == "function" || typeof N.getSnapshotBeforeUpdate == "function";
            st || typeof N.UNSAFE_componentWillReceiveProps != "function" && typeof N.componentWillReceiveProps != "function" || (K !== w || fe !== Te) && YM(f, N, w, Te),
            $s = !1;
            var et = f.memoizedState;
            N.state = et,
            dh(f, w, N, C),
            fe = f.memoizedState,
            K !== w || et !== fe || In.current || $s ? (typeof Ve == "function" && (B0(f, g, Ve, w),
            fe = f.memoizedState),
            (K = $s || XM(f, g, K, w, et, fe, Te)) ? (st || typeof N.UNSAFE_componentWillMount != "function" && typeof N.componentWillMount != "function" || (typeof N.componentWillMount == "function" && N.componentWillMount(),
            typeof N.UNSAFE_componentWillMount == "function" && N.UNSAFE_componentWillMount()),
            typeof N.componentDidMount == "function" && (f.flags |= 4194308)) : (typeof N.componentDidMount == "function" && (f.flags |= 4194308),
            f.memoizedProps = w,
            f.memoizedState = fe),
            N.props = w,
            N.state = fe,
            N.context = Te,
            w = K) : (typeof N.componentDidMount == "function" && (f.flags |= 4194308),
            w = !1)
        } else {
            N = f.stateNode,
            VM(u, f),
            K = f.memoizedProps,
            Te = f.type === f.elementType ? K : Mr(f.type, K),
            N.props = Te,
            st = f.pendingProps,
            et = N.context,
            fe = g.contextType,
            typeof fe == "object" && fe !== null ? fe = $i(fe) : (fe = _i(g) ? hs : kt.current,
            fe = ps(f, fe));
            var zt = g.getDerivedStateFromProps;
            (Ve = typeof zt == "function" || typeof N.getSnapshotBeforeUpdate == "function") || typeof N.UNSAFE_componentWillReceiveProps != "function" && typeof N.componentWillReceiveProps != "function" || (K !== st || et !== fe) && YM(f, N, w, fe),
            $s = !1,
            et = f.memoizedState,
            N.state = et,
            dh(f, w, N, C);
            var Qe = f.memoizedState;
            K !== st || et !== Qe || In.current || $s ? (typeof zt == "function" && (B0(f, g, zt, w),
            Qe = f.memoizedState),
            (Te = $s || XM(f, g, Te, w, et, Qe, fe) || !1) ? (Ve || typeof N.UNSAFE_componentWillUpdate != "function" && typeof N.componentWillUpdate != "function" || (typeof N.componentWillUpdate == "function" && N.componentWillUpdate(w, Qe, fe),
            typeof N.UNSAFE_componentWillUpdate == "function" && N.UNSAFE_componentWillUpdate(w, Qe, fe)),
            typeof N.componentDidUpdate == "function" && (f.flags |= 4),
            typeof N.getSnapshotBeforeUpdate == "function" && (f.flags |= 1024)) : (typeof N.componentDidUpdate != "function" || K === u.memoizedProps && et === u.memoizedState || (f.flags |= 4),
            typeof N.getSnapshotBeforeUpdate != "function" || K === u.memoizedProps && et === u.memoizedState || (f.flags |= 1024),
            f.memoizedProps = w,
            f.memoizedState = Qe),
            N.props = w,
            N.state = Qe,
            N.context = fe,
            w = Te) : (typeof N.componentDidUpdate != "function" || K === u.memoizedProps && et === u.memoizedState || (f.flags |= 4),
            typeof N.getSnapshotBeforeUpdate != "function" || K === u.memoizedProps && et === u.memoizedState || (f.flags |= 1024),
            w = !1)
        }
        return Q0(u, f, g, w, b, C)
    }
    function Q0(u, f, g, w, C, b) {
        Iw(u, f);
        var N = (f.flags & 128) !== 0;
        if (!w && !N)
            return C && OM(f, g, !1),
            _s(u, f, b);
        w = f.stateNode,
        RI.current = f;
        var K = N && typeof g.getDerivedStateFromError != "function" ? null : w.render();
        return f.flags |= 1,
        u !== null && N ? (f.child = Cl(f, u.child, null, b),
        f.child = Cl(f, null, K, b)) : oi(u, f, K, b),
        f.memoizedState = w.state,
        C && OM(f, g, !0),
        f.child
    }
    function Fw(u) {
        var f = u.stateNode;
        f.pendingContext ? kM(u, f.pendingContext, f.pendingContext !== f.context) : f.context && kM(u, f.context, !1),
        N0(u, f.containerInfo)
    }
    function kw(u, f, g, w, C) {
        return Sl(),
        k0(C),
        f.flags |= 256,
        oi(u, f, g, w),
        f.child
    }
    var Th = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
    };
    function bh(u) {
        return {
            baseLanes: u,
            cachePool: null
        }
    }
    function Nw(u, f, g) {
        var w = f.pendingProps, C = $t.current, b = !1, N = (f.flags & 128) !== 0, K;
        if ((K = N) || (K = u !== null && u.memoizedState === null ? !1 : (C & 2) !== 0),
        K ? (b = !0,
        f.flags &= -129) : (u === null || u.memoizedState !== null) && (C |= 1),
        Tt($t, C & 1),
        u === null)
            return F0(f),
            u = f.memoizedState,
            u !== null && (u = u.dehydrated,
            u !== null) ? (f.mode & 1 ? oc(u) ? f.lanes = 8 : f.lanes = 1073741824 : f.lanes = 1,
            null) : (C = w.children,
            u = w.fallback,
            b ? (w = f.mode,
            b = f.child,
            C = {
                mode: "hidden",
                children: C
            },
            !(w & 1) && b !== null ? (b.childLanes = 0,
            b.pendingProps = C) : b = Kh(C, w, 0, null),
            u = ma(u, w, g, null),
            b.return = f,
            u.return = f,
            b.sibling = u,
            f.child = b,
            f.child.memoizedState = bh(g),
            f.memoizedState = Th,
            u) : Z0(f, C));
        if (C = u.memoizedState,
        C !== null) {
            if (K = C.dehydrated,
            K !== null) {
                if (N)
                    return f.flags & 256 ? (f.flags &= -257,
                    Ph(u, f, g, Error(o(422)))) : f.memoizedState !== null ? (f.child = u.child,
                    f.flags |= 128,
                    null) : (b = w.fallback,
                    C = f.mode,
                    w = Kh({
                        mode: "visible",
                        children: w.children
                    }, C, 0, null),
                    b = ma(b, C, g, null),
                    b.flags |= 2,
                    w.return = f,
                    b.return = f,
                    w.sibling = b,
                    f.child = w,
                    f.mode & 1 && Cl(f, u.child, null, g),
                    f.child.memoizedState = bh(g),
                    f.memoizedState = Th,
                    b);
                if (!(f.mode & 1))
                    f = Ph(u, f, g, null);
                else if (oc(K))
                    f = Ph(u, f, g, Error(o(419)));
                else if (w = (g & u.childLanes) !== 0,
                Di || w) {
                    if (w = xn,
                    w !== null) {
                        switch (g & -g) {
                        case 4:
                            b = 2;
                            break;
                        case 16:
                            b = 8;
                            break;
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                        case 67108864:
                            b = 32;
                            break;
                        case 536870912:
                            b = 268435456;
                            break;
                        default:
                            b = 0
                        }
                        w = b & (w.suspendedLanes | g) ? 0 : b,
                        w !== 0 && w !== C.retryLane && (C.retryLane = w,
                        rr(u, w, -1))
                    }
                    yy(),
                    f = Ph(u, f, g, Error(o(421)))
                } else
                    eh(K) ? (f.flags |= 128,
                    f.child = u.child,
                    f = WI.bind(null, u),
                    k(K, f),
                    f = null) : (g = C.treeContext,
                    ae && (Ii = ge(K),
                    Li = f,
                    Yt = !0,
                    wr = null,
                    uc = !1,
                    g !== null && (er[tr++] = ys,
                    er[tr++] = vs,
                    er[tr++] = aa,
                    ys = g.id,
                    vs = g.overflow,
                    aa = f)),
                    f = Z0(f, f.pendingProps.children),
                    f.flags |= 4096);
                return f
            }
            return b ? (w = Uw(u, f, w.children, w.fallback, g),
            b = f.child,
            C = u.child.memoizedState,
            b.memoizedState = C === null ? bh(g) : {
                baseLanes: C.baseLanes | g,
                cachePool: null
            },
            b.childLanes = u.childLanes & ~g,
            f.memoizedState = Th,
            w) : (g = Ow(u, f, w.children, g),
            f.memoizedState = null,
            g)
        }
        return b ? (w = Uw(u, f, w.children, w.fallback, g),
        b = f.child,
        C = u.child.memoizedState,
        b.memoizedState = C === null ? bh(g) : {
            baseLanes: C.baseLanes | g,
            cachePool: null
        },
        b.childLanes = u.childLanes & ~g,
        f.memoizedState = Th,
        w) : (g = Ow(u, f, w.children, g),
        f.memoizedState = null,
        g)
    }
    function Z0(u, f) {
        return f = Kh({
            mode: "visible",
            children: f
        }, u.mode, 0, null),
        f.return = u,
        u.child = f
    }
    function Ow(u, f, g, w) {
        var C = u.child;
        return u = C.sibling,
        g = so(C, {
            mode: "visible",
            children: g
        }),
        !(f.mode & 1) && (g.lanes = w),
        g.return = f,
        g.sibling = null,
        u !== null && (w = f.deletions,
        w === null ? (f.deletions = [u],
        f.flags |= 16) : w.push(u)),
        f.child = g
    }
    function Uw(u, f, g, w, C) {
        var b = f.mode;
        u = u.child;
        var N = u.sibling
          , K = {
            mode: "hidden",
            children: g
        };
        return !(b & 1) && f.child !== u ? (g = f.child,
        g.childLanes = 0,
        g.pendingProps = K,
        f.deletions = null) : (g = so(u, K),
        g.subtreeFlags = u.subtreeFlags & 14680064),
        N !== null ? w = so(N, w) : (w = ma(w, b, C, null),
        w.flags |= 2),
        w.return = f,
        g.return = f,
        g.sibling = w,
        f.child = g,
        w
    }
    function Ph(u, f, g, w) {
        return w !== null && k0(w),
        Cl(f, u.child, null, g),
        u = Z0(f, f.pendingProps.children),
        u.flags |= 2,
        f.memoizedState = null,
        u
    }
    function zw(u, f, g) {
        u.lanes |= f;
        var w = u.alternate;
        w !== null && (w.lanes |= f),
        b0(u.return, f, g)
    }
    function q0(u, f, g, w, C) {
        var b = u.memoizedState;
        b === null ? u.memoizedState = {
            isBackwards: f,
            rendering: null,
            renderingStartTime: 0,
            last: w,
            tail: g,
            tailMode: C
        } : (b.isBackwards = f,
        b.rendering = null,
        b.renderingStartTime = 0,
        b.last = w,
        b.tail = g,
        b.tailMode = C)
    }
    function Gw(u, f, g) {
        var w = f.pendingProps
          , C = w.revealOrder
          , b = w.tail;
        if (oi(u, f, w.children, g),
        w = $t.current,
        w & 2)
            w = w & 1 | 2,
            f.flags |= 128;
        else {
            if (u !== null && u.flags & 128)
                e: for (u = f.child; u !== null; ) {
                    if (u.tag === 13)
                        u.memoizedState !== null && zw(u, g, f);
                    else if (u.tag === 19)
                        zw(u, g, f);
                    else if (u.child !== null) {
                        u.child.return = u,
                        u = u.child;
                        continue
                    }
                    if (u === f)
                        break e;
                    for (; u.sibling === null; ) {
                        if (u.return === null || u.return === f)
                            break e;
                        u = u.return
                    }
                    u.sibling.return = u.return,
                    u = u.sibling
                }
            w &= 1
        }
        if (Tt($t, w),
        !(f.mode & 1))
            f.memoizedState = null;
        else
            switch (C) {
            case "forwards":
                for (g = f.child,
                C = null; g !== null; )
                    u = g.alternate,
                    u !== null && yh(u) === null && (C = g),
                    g = g.sibling;
                g = C,
                g === null ? (C = f.child,
                f.child = null) : (C = g.sibling,
                g.sibling = null),
                q0(f, !1, C, g, b);
                break;
            case "backwards":
                for (g = null,
                C = f.child,
                f.child = null; C !== null; ) {
                    if (u = C.alternate,
                    u !== null && yh(u) === null) {
                        f.child = C;
                        break
                    }
                    u = C.sibling,
                    C.sibling = g,
                    g = C,
                    C = u
                }
                q0(f, !0, g, null, b);
                break;
            case "together":
                q0(f, !1, null, null, void 0);
                break;
            default:
                f.memoizedState = null
            }
        return f.child
    }
    function _s(u, f, g) {
        if (u !== null && (f.dependencies = u.dependencies),
        Bl |= f.lanes,
        !(g & f.childLanes))
            return null;
        if (u !== null && f.child !== u.child)
            throw Error(o(153));
        if (f.child !== null) {
            for (u = f.child,
            g = so(u, u.pendingProps),
            f.child = g,
            g.return = f; u.sibling !== null; )
                u = u.sibling,
                g = g.sibling = so(u, u.pendingProps),
                g.return = f;
            g.sibling = null
        }
        return f.child
    }
    function LI(u, f, g) {
        switch (f.tag) {
        case 3:
            Fw(f),
            Sl();
            break;
        case 5:
            iw(f);
            break;
        case 1:
            _i(f.type) && nh(f);
            break;
        case 4:
            N0(f, f.stateNode.containerInfo);
            break;
        case 10:
            HM(f, f.type._context, f.memoizedProps.value);
            break;
        case 13:
            var w = f.memoizedState;
            if (w !== null)
                return w.dehydrated !== null ? (Tt($t, $t.current & 1),
                f.flags |= 128,
                null) : g & f.child.childLanes ? Nw(u, f, g) : (Tt($t, $t.current & 1),
                u = _s(u, f, g),
                u !== null ? u.sibling : null);
            Tt($t, $t.current & 1);
            break;
        case 19:
            if (w = (g & f.childLanes) !== 0,
            u.flags & 128) {
                if (w)
                    return Gw(u, f, g);
                f.flags |= 128
            }
            var C = f.memoizedState;
            if (C !== null && (C.rendering = null,
            C.tail = null,
            C.lastEffect = null),
            Tt($t, $t.current),
            w)
                break;
            return null;
        case 22:
        case 23:
            return f.lanes = 0,
            Lw(u, f, g)
        }
        return _s(u, f, g)
    }
    function II(u, f) {
        switch (I0(f),
        f.tag) {
        case 1:
            return _i(f.type) && th(),
            u = f.flags,
            u & 65536 ? (f.flags = u & -65537 | 128,
            f) : null;
        case 3:
            return Tl(),
            ft(In),
            ft(kt),
            z0(),
            u = f.flags,
            u & 65536 && !(u & 128) ? (f.flags = u & -65537 | 128,
            f) : null;
        case 5:
            return O0(f),
            null;
        case 13:
            if (ft($t),
            u = f.memoizedState,
            u !== null && u.dehydrated !== null) {
                if (f.alternate === null)
                    throw Error(o(340));
                Sl()
            }
            return u = f.flags,
            u & 65536 ? (f.flags = u & -65537 | 128,
            f) : null;
        case 19:
            return ft($t),
            null;
        case 4:
            return Tl(),
            null;
        case 10:
            return T0(f.type._context),
            null;
        case 22:
        case 23:
            return gy(),
            null;
        case 24:
            return null;
        default:
            return null
        }
    }
    var Bh = !1
      , ca = !1
      , DI = typeof WeakSet == "function" ? WeakSet : Set
      , ke = null;
    function Rh(u, f) {
        var g = u.ref;
        if (g !== null)
            if (typeof g == "function")
                try {
                    g(null)
                } catch (w) {
                    wi(u, f, w)
                }
            else
                g.current = null
    }
    function $0(u, f, g) {
        try {
            g()
        } catch (w) {
            wi(u, f, w)
        }
    }
    var Hw = !1;
    function FI(u, f) {
        for (V(u.containerInfo),
        ke = f; ke !== null; )
            if (u = ke,
            f = u.child,
            (u.subtreeFlags & 1028) !== 0 && f !== null)
                f.return = u,
                ke = f;
            else
                for (; ke !== null; ) {
                    u = ke;
                    try {
                        var g = u.alternate;
                        if (u.flags & 1024)
                            switch (u.tag) {
                            case 0:
                            case 11:
                            case 15:
                                break;
                            case 1:
                                if (g !== null) {
                                    var w = g.memoizedProps
                                      , C = g.memoizedState
                                      , b = u.stateNode
                                      , N = b.getSnapshotBeforeUpdate(u.elementType === u.type ? w : Mr(u.type, w), C);
                                    b.__reactInternalSnapshotBeforeUpdate = N
                                }
                                break;
                            case 3:
                                De && Ue(u.stateNode.containerInfo);
                                break;
                            case 5:
                            case 6:
                            case 4:
                            case 17:
                                break;
                            default:
                                throw Error(o(163))
                            }
                    } catch (K) {
                        wi(u, u.return, K)
                    }
                    if (f = u.sibling,
                    f !== null) {
                        f.return = u.return,
                        ke = f;
                        break
                    }
                    ke = u.return
                }
        return g = Hw,
        Hw = !1,
        g
    }
    function fa(u, f, g) {
        var w = f.updateQueue;
        if (w = w !== null ? w.lastEffect : null,
        w !== null) {
            var C = w = w.next;
            do {
                if ((C.tag & u) === u) {
                    var b = C.destroy;
                    C.destroy = void 0,
                    b !== void 0 && $0(f, g, b)
                }
                C = C.next
            } while (C !== w)
        }
    }
    function Ac(u, f) {
        if (f = f.updateQueue,
        f = f !== null ? f.lastEffect : null,
        f !== null) {
            var g = f = f.next;
            do {
                if ((g.tag & u) === u) {
                    var w = g.create;
                    g.destroy = w()
                }
                g = g.next
            } while (g !== f)
        }
    }
    function ey(u) {
        var f = u.ref;
        if (f !== null) {
            var g = u.stateNode;
            switch (u.tag) {
            case 5:
                u = ee(g);
                break;
            default:
                u = g
            }
            typeof f == "function" ? f(u) : f.current = u
        }
    }
    function Vw(u, f, g) {
        if (jr && typeof jr.onCommitFiberUnmount == "function")
            try {
                jr.onCommitFiberUnmount(oh, f)
            } catch {}
        switch (f.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            if (u = f.updateQueue,
            u !== null && (u = u.lastEffect,
            u !== null)) {
                var w = u = u.next;
                do {
                    var C = w
                      , b = C.destroy;
                    C = C.tag,
                    b !== void 0 && (C & 2 || C & 4) && $0(f, g, b),
                    w = w.next
                } while (w !== u)
            }
            break;
        case 1:
            if (Rh(f, g),
            u = f.stateNode,
            typeof u.componentWillUnmount == "function")
                try {
                    u.props = f.memoizedProps,
                    u.state = f.memoizedState,
                    u.componentWillUnmount()
                } catch (N) {
                    wi(f, g, N)
                }
            break;
        case 5:
            Rh(f, g);
            break;
        case 4:
            De ? Yw(u, f, g) : de && de && (f = f.stateNode.containerInfo,
            g = Pt(f),
            Wr(f, g))
        }
    }
    function Ww(u, f, g) {
        for (var w = f; ; )
            if (Vw(u, w, g),
            w.child === null || De && w.tag === 4) {
                if (w === f)
                    break;
                for (; w.sibling === null; ) {
                    if (w.return === null || w.return === f)
                        return;
                    w = w.return
                }
                w.sibling.return = w.return,
                w = w.sibling
            } else
                w.child.return = w,
                w = w.child
    }
    function jw(u) {
        var f = u.alternate;
        f !== null && (u.alternate = null,
        jw(f)),
        u.child = null,
        u.deletions = null,
        u.sibling = null,
        u.tag === 5 && (f = u.stateNode,
        f !== null && Ze(f)),
        u.stateNode = null,
        u.return = null,
        u.dependencies = null,
        u.memoizedProps = null,
        u.memoizedState = null,
        u.pendingProps = null,
        u.stateNode = null,
        u.updateQueue = null
    }
    function Jw(u) {
        return u.tag === 5 || u.tag === 3 || u.tag === 4
    }
    function Xw(u) {
        e: for (; ; ) {
            for (; u.sibling === null; ) {
                if (u.return === null || Jw(u.return))
                    return null;
                u = u.return
            }
            for (u.sibling.return = u.return,
            u = u.sibling; u.tag !== 5 && u.tag !== 6 && u.tag !== 18; ) {
                if (u.flags & 2 || u.child === null || u.tag === 4)
                    continue e;
                u.child.return = u,
                u = u.child
            }
            if (!(u.flags & 2))
                return u.stateNode
        }
    }
    function Kw(u) {
        if (De) {
            e: {
                for (var f = u.return; f !== null; ) {
                    if (Jw(f))
                        break e;
                    f = f.return
                }
                throw Error(o(160))
            }
            var g = f;
            switch (g.tag) {
            case 5:
                f = g.stateNode,
                g.flags & 32 && (vt(f),
                g.flags &= -33),
                g = Xw(u),
                ny(u, g, f);
                break;
            case 3:
            case 4:
                f = g.stateNode.containerInfo,
                g = Xw(u),
                ty(u, g, f);
                break;
            default:
                throw Error(o(161))
            }
        }
    }
    function ty(u, f, g) {
        var w = u.tag;
        if (w === 5 || w === 6)
            u = u.stateNode,
            f ? Ae(g, u, f) : Fe(g, u);
        else if (w !== 4 && (u = u.child,
        u !== null))
            for (ty(u, f, g),
            u = u.sibling; u !== null; )
                ty(u, f, g),
                u = u.sibling
    }
    function ny(u, f, g) {
        var w = u.tag;
        if (w === 5 || w === 6)
            u = u.stateNode,
            f ? le(g, u, f) : tt(g, u);
        else if (w !== 4 && (u = u.child,
        u !== null))
            for (ny(u, f, g),
            u = u.sibling; u !== null; )
                ny(u, f, g),
                u = u.sibling
    }
    function Yw(u, f, g) {
        for (var w = f, C = !1, b, N; ; ) {
            if (!C) {
                C = w.return;
                e: for (; ; ) {
                    if (C === null)
                        throw Error(o(160));
                    switch (b = C.stateNode,
                    C.tag) {
                    case 5:
                        N = !1;
                        break e;
                    case 3:
                        b = b.containerInfo,
                        N = !0;
                        break e;
                    case 4:
                        b = b.containerInfo,
                        N = !0;
                        break e
                    }
                    C = C.return
                }
                C = !0
            }
            if (w.tag === 5 || w.tag === 6)
                Ww(u, w, g),
                N ? $e(b, w.stateNode) : be(b, w.stateNode);
            else if (w.tag === 18)
                N ? ln(b, w.stateNode) : Mt(b, w.stateNode);
            else if (w.tag === 4) {
                if (w.child !== null) {
                    b = w.stateNode.containerInfo,
                    N = !0,
                    w.child.return = w,
                    w = w.child;
                    continue
                }
            } else if (Vw(u, w, g),
            w.child !== null) {
                w.child.return = w,
                w = w.child;
                continue
            }
            if (w === f)
                break;
            for (; w.sibling === null; ) {
                if (w.return === null || w.return === f)
                    return;
                w = w.return,
                w.tag === 4 && (C = !1)
            }
            w.sibling.return = w.return,
            w = w.sibling
        }
    }
    function iy(u, f) {
        if (De) {
            switch (f.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                fa(3, f, f.return),
                Ac(3, f),
                fa(5, f, f.return);
                return;
            case 1:
                return;
            case 5:
                var g = f.stateNode;
                if (g != null) {
                    var w = f.memoizedProps;
                    u = u !== null ? u.memoizedProps : w;
                    var C = f.type
                      , b = f.updateQueue;
                    f.updateQueue = null,
                    b !== null && W(g, b, C, u, w, f)
                }
                return;
            case 6:
                if (f.stateNode === null)
                    throw Error(o(162));
                g = f.memoizedProps,
                me(f.stateNode, u !== null ? u.memoizedProps : g, g);
                return;
            case 3:
                ae && u !== null && u.memoizedState.isDehydrated && Ct(f.stateNode.containerInfo);
                return;
            case 12:
                return;
            case 13:
                Lh(f);
                return;
            case 19:
                Lh(f);
                return;
            case 17:
                return
            }
            throw Error(o(163))
        }
        switch (f.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            fa(3, f, f.return),
            Ac(3, f),
            fa(5, f, f.return);
            return;
        case 12:
            return;
        case 13:
            Lh(f);
            return;
        case 19:
            Lh(f);
            return;
        case 3:
            ae && u !== null && u.memoizedState.isDehydrated && Ct(f.stateNode.containerInfo);
            break;
        case 22:
        case 23:
            return
        }
        e: if (de) {
            switch (f.tag) {
            case 1:
            case 5:
            case 6:
                break e;
            case 3:
            case 4:
                f = f.stateNode,
                Wr(f.containerInfo, f.pendingChildren);
                break e
            }
            throw Error(o(163))
        }
    }
    function Lh(u) {
        var f = u.updateQueue;
        if (f !== null) {
            u.updateQueue = null;
            var g = u.stateNode;
            g === null && (g = u.stateNode = new DI),
            f.forEach(function(w) {
                var C = jI.bind(null, u, w);
                g.has(w) || (g.add(w),
                w.then(C, C))
            })
        }
    }
    function kI(u, f) {
        for (ke = f; ke !== null; ) {
            f = ke;
            var g = f.deletions;
            if (g !== null)
                for (var w = 0; w < g.length; w++) {
                    var C = g[w];
                    try {
                        var b = u;
                        De ? Yw(b, C, f) : Ww(b, C, f);
                        var N = C.alternate;
                        N !== null && (N.return = null),
                        C.return = null
                    } catch (Ke) {
                        wi(C, f, Ke)
                    }
                }
            if (g = f.child,
            f.subtreeFlags & 12854 && g !== null)
                g.return = f,
                ke = g;
            else
                for (; ke !== null; ) {
                    f = ke;
                    try {
                        var K = f.flags;
                        if (K & 32 && De && vt(f.stateNode),
                        K & 512) {
                            var fe = f.alternate;
                            if (fe !== null) {
                                var Te = fe.ref;
                                Te !== null && (typeof Te == "function" ? Te(null) : Te.current = null)
                            }
                        }
                        if (K & 8192)
                            switch (f.tag) {
                            case 13:
                                if (f.memoizedState !== null) {
                                    var Ve = f.alternate;
                                    (Ve === null || Ve.memoizedState === null) && (cy = Dn())
                                }
                                break;
                            case 22:
                                var st = f.memoizedState !== null
                                  , et = f.alternate
                                  , zt = et !== null && et.memoizedState !== null;
                                if (g = f,
                                De) {
                                    e: if (w = g,
                                    C = st,
                                    b = null,
                                    De)
                                        for (var Qe = w; ; ) {
                                            if (Qe.tag === 5) {
                                                if (b === null) {
                                                    b = Qe;
                                                    var Qn = Qe.stateNode;
                                                    C ? Wt(Qn) : ce(Qe.stateNode, Qe.memoizedProps)
                                                }
                                            } else if (Qe.tag === 6) {
                                                if (b === null) {
                                                    var or = Qe.stateNode;
                                                    C ? Y(or) : _e(or, Qe.memoizedProps)
                                                }
                                            } else if ((Qe.tag !== 22 && Qe.tag !== 23 || Qe.memoizedState === null || Qe === w) && Qe.child !== null) {
                                                Qe.child.return = Qe,
                                                Qe = Qe.child;
                                                continue
                                            }
                                            if (Qe === w)
                                                break;
                                            for (; Qe.sibling === null; ) {
                                                if (Qe.return === null || Qe.return === w)
                                                    break e;
                                                b === Qe && (b = null),
                                                Qe = Qe.return
                                            }
                                            b === Qe && (b = null),
                                            Qe.sibling.return = Qe.return,
                                            Qe = Qe.sibling
                                        }
                                }
                                if (st && !zt && g.mode & 1) {
                                    ke = g;
                                    for (var ne = g.child; ne !== null; ) {
                                        for (g = ke = ne; ke !== null; ) {
                                            w = ke;
                                            var Q = w.child;
                                            switch (w.tag) {
                                            case 0:
                                            case 11:
                                            case 14:
                                            case 15:
                                                fa(4, w, w.return);
                                                break;
                                            case 1:
                                                Rh(w, w.return);
                                                var ue = w.stateNode;
                                                if (typeof ue.componentWillUnmount == "function") {
                                                    var Oe = w.return;
                                                    try {
                                                        ue.props = w.memoizedProps,
                                                        ue.state = w.memoizedState,
                                                        ue.componentWillUnmount()
                                                    } catch (Ke) {
                                                        wi(w, Oe, Ke)
                                                    }
                                                }
                                                break;
                                            case 5:
                                                Rh(w, w.return);
                                                break;
                                            case 22:
                                                if (w.memoizedState !== null) {
                                                    qw(g);
                                                    continue
                                                }
                                            }
                                            Q !== null ? (Q.return = w,
                                            ke = Q) : qw(g)
                                        }
                                        ne = ne.sibling
                                    }
                                }
                            }
                        switch (K & 4102) {
                        case 2:
                            Kw(f),
                            f.flags &= -3;
                            break;
                        case 6:
                            Kw(f),
                            f.flags &= -3,
                            iy(f.alternate, f);
                            break;
                        case 4096:
                            f.flags &= -4097;
                            break;
                        case 4100:
                            f.flags &= -4097,
                            iy(f.alternate, f);
                            break;
                        case 4:
                            iy(f.alternate, f)
                        }
                    } catch (Ke) {
                        wi(f, f.return, Ke)
                    }
                    if (g = f.sibling,
                    g !== null) {
                        g.return = f.return,
                        ke = g;
                        break
                    }
                    ke = f.return
                }
        }
    }
    function NI(u, f, g) {
        ke = u,
        Qw(u)
    }
    function Qw(u, f, g) {
        for (var w = (u.mode & 1) !== 0; ke !== null; ) {
            var C = ke
              , b = C.child;
            if (C.tag === 22 && w) {
                var N = C.memoizedState !== null || Bh;
                if (!N) {
                    var K = C.alternate
                      , fe = K !== null && K.memoizedState !== null || ca;
                    K = Bh;
                    var Te = ca;
                    if (Bh = N,
                    (ca = fe) && !Te)
                        for (ke = C; ke !== null; )
                            N = ke,
                            fe = N.child,
                            N.tag === 22 && N.memoizedState !== null ? $w(C) : fe !== null ? (fe.return = N,
                            ke = fe) : $w(C);
                    for (; b !== null; )
                        ke = b,
                        Qw(b),
                        b = b.sibling;
                    ke = C,
                    Bh = K,
                    ca = Te
                }
                Zw(u)
            } else
                C.subtreeFlags & 8772 && b !== null ? (b.return = C,
                ke = b) : Zw(u)
        }
    }
    function Zw(u) {
        for (; ke !== null; ) {
            var f = ke;
            if (f.flags & 8772) {
                var g = f.alternate;
                try {
                    if (f.flags & 8772)
                        switch (f.tag) {
                        case 0:
                        case 11:
                        case 15:
                            ca || Ac(5, f);
                            break;
                        case 1:
                            var w = f.stateNode;
                            if (f.flags & 4 && !ca)
                                if (g === null)
                                    w.componentDidMount();
                                else {
                                    var C = f.elementType === f.type ? g.memoizedProps : Mr(f.type, g.memoizedProps);
                                    w.componentDidUpdate(C, g.memoizedState, w.__reactInternalSnapshotBeforeUpdate)
                                }
                            var b = f.updateQueue;
                            b !== null && jM(f, b, w);
                            break;
                        case 3:
                            var N = f.updateQueue;
                            if (N !== null) {
                                if (g = null,
                                f.child !== null)
                                    switch (f.child.tag) {
                                    case 5:
                                        g = ee(f.child.stateNode);
                                        break;
                                    case 1:
                                        g = f.child.stateNode
                                    }
                                jM(f, N, g)
                            }
                            break;
                        case 5:
                            var K = f.stateNode;
                            g === null && f.flags & 4 && Xe(K, f.type, f.memoizedProps, f);
                            break;
                        case 6:
                            break;
                        case 4:
                            break;
                        case 12:
                            break;
                        case 13:
                            if (ae && f.memoizedState === null) {
                                var fe = f.alternate;
                                if (fe !== null) {
                                    var Te = fe.memoizedState;
                                    if (Te !== null) {
                                        var Ve = Te.dehydrated;
                                        Ve !== null && At(Ve)
                                    }
                                }
                            }
                            break;
                        case 19:
                        case 17:
                        case 21:
                        case 22:
                        case 23:
                            break;
                        default:
                            throw Error(o(163))
                        }
                    ca || f.flags & 512 && ey(f)
                } catch (st) {
                    wi(f, f.return, st)
                }
            }
            if (f === u) {
                ke = null;
                break
            }
            if (g = f.sibling,
            g !== null) {
                g.return = f.return,
                ke = g;
                break
            }
            ke = f.return
        }
    }
    function qw(u) {
        for (; ke !== null; ) {
            var f = ke;
            if (f === u) {
                ke = null;
                break
            }
            var g = f.sibling;
            if (g !== null) {
                g.return = f.return,
                ke = g;
                break
            }
            ke = f.return
        }
    }
    function $w(u) {
        for (; ke !== null; ) {
            var f = ke;
            try {
                switch (f.tag) {
                case 0:
                case 11:
                case 15:
                    var g = f.return;
                    try {
                        Ac(4, f)
                    } catch (fe) {
                        wi(f, g, fe)
                    }
                    break;
                case 1:
                    var w = f.stateNode;
                    if (typeof w.componentDidMount == "function") {
                        var C = f.return;
                        try {
                            w.componentDidMount()
                        } catch (fe) {
                            wi(f, C, fe)
                        }
                    }
                    var b = f.return;
                    try {
                        ey(f)
                    } catch (fe) {
                        wi(f, b, fe)
                    }
                    break;
                case 5:
                    var N = f.return;
                    try {
                        ey(f)
                    } catch (fe) {
                        wi(f, N, fe)
                    }
                }
            } catch (fe) {
                wi(f, f.return, fe)
            }
            if (f === u) {
                ke = null;
                break
            }
            var K = f.sibling;
            if (K !== null) {
                K.return = f.return,
                ke = K;
                break
            }
            ke = f.return
        }
    }
    var Ih = 0
      , Dh = 1
      , Fh = 2
      , kh = 3
      , Nh = 4;
    if (typeof Symbol == "function" && Symbol.for) {
        var Mc = Symbol.for;
        Ih = Mc("selector.component"),
        Dh = Mc("selector.has_pseudo_class"),
        Fh = Mc("selector.role"),
        kh = Mc("selector.test_id"),
        Nh = Mc("selector.text")
    }
    function ry(u) {
        var f = Ce(u);
        if (f != null) {
            if (typeof f.memoizedProps["data-testname"] != "string")
                throw Error(o(364));
            return f
        }
        if (u = St(u),
        u === null)
            throw Error(o(362));
        return u.stateNode.current
    }
    function sy(u, f) {
        switch (f.$$typeof) {
        case Ih:
            if (u.type === f.value)
                return !0;
            break;
        case Dh:
            e: {
                f = f.value,
                u = [u, 0];
                for (var g = 0; g < u.length; ) {
                    var w = u[g++]
                      , C = u[g++]
                      , b = f[C];
                    if (w.tag !== 5 || !oe(w)) {
                        for (; b != null && sy(w, b); )
                            C++,
                            b = f[C];
                        if (C === f.length) {
                            f = !0;
                            break e
                        } else
                            for (w = w.child; w !== null; )
                                u.push(w, C),
                                w = w.sibling
                    }
                }
                f = !1
            }
            return f;
        case Fh:
            if (u.tag === 5 && we(u.stateNode, f.value))
                return !0;
            break;
        case Nh:
            if ((u.tag === 5 || u.tag === 6) && (u = I(u),
            u !== null && 0 <= u.indexOf(f.value)))
                return !0;
            break;
        case kh:
            if (u.tag === 5 && (u = u.memoizedProps["data-testname"],
            typeof u == "string" && u.toLowerCase() === f.value.toLowerCase()))
                return !0;
            break;
        default:
            throw Error(o(365))
        }
        return !1
    }
    function oy(u) {
        switch (u.$$typeof) {
        case Ih:
            return "<" + (R(u.value) || "Unknown") + ">";
        case Dh:
            return ":has(" + (oy(u) || "") + ")";
        case Fh:
            return '[role="' + u.value + '"]';
        case Nh:
            return '"' + u.value + '"';
        case kh:
            return '[data-testname="' + u.value + '"]';
        default:
            throw Error(o(365))
        }
    }
    function eS(u, f) {
        var g = [];
        u = [u, 0];
        for (var w = 0; w < u.length; ) {
            var C = u[w++]
              , b = u[w++]
              , N = f[b];
            if (C.tag !== 5 || !oe(C)) {
                for (; N != null && sy(C, N); )
                    b++,
                    N = f[b];
                if (b === f.length)
                    g.push(C);
                else
                    for (C = C.child; C !== null; )
                        u.push(C, b),
                        C = C.sibling
            }
        }
        return g
    }
    function ay(u, f) {
        if (!xt)
            throw Error(o(363));
        u = ry(u),
        u = eS(u, f),
        f = [],
        u = Array.from(u);
        for (var g = 0; g < u.length; ) {
            var w = u[g++];
            if (w.tag === 5)
                oe(w) || f.push(w.stateNode);
            else
                for (w = w.child; w !== null; )
                    u.push(w),
                    w = w.sibling
        }
        return f
    }
    var OI = Math.ceil
      , Oh = a.ReactCurrentDispatcher
      , ly = a.ReactCurrentOwner
      , mn = a.ReactCurrentBatchConfig
      , yt = 0
      , xn = null
      , _n = null
      , Gn = 0
      , Fi = 0
      , Pl = Zi(0)
      , Cn = 0
      , wc = null
      , Bl = 0
      , Uh = 0
      , uy = 0
      , Sc = null
      , Ai = null
      , cy = 0
      , fy = 1 / 0;
    function Rl() {
        fy = Dn() + 500
    }
    var zh = !1
      , dy = null
      , to = null
      , Gh = !1
      , no = null
      , Hh = 0
      , Cc = 0
      , hy = null
      , Vh = -1
      , Wh = 0;
    function ai() {
        return yt & 6 ? Dn() : Vh !== -1 ? Vh : Vh = Dn()
    }
    function io(u) {
        return u.mode & 1 ? yt & 2 && Gn !== 0 ? Gn & -Gn : _I.transition !== null ? (Wh === 0 && (u = ih,
        ih <<= 1,
        !(ih & 4194240) && (ih = 64),
        Wh = u),
        Wh) : (u = Lt,
        u !== 0 ? u : Be()) : 1
    }
    function rr(u, f, g) {
        if (50 < Cc)
            throw Cc = 0,
            hy = null,
            Error(o(185));
        var w = jh(u, f);
        return w === null ? null : (lc(w, f, g),
        (!(yt & 2) || w !== xn) && (w === xn && (!(yt & 2) && (Uh |= f),
        Cn === 4 && ro(w, Gn)),
        Mi(w, g),
        f === 1 && yt === 0 && !(u.mode & 1) && (Rl(),
        ah && Xr())),
        w)
    }
    function jh(u, f) {
        u.lanes |= f;
        var g = u.alternate;
        for (g !== null && (g.lanes |= f),
        g = u,
        u = u.return; u !== null; )
            u.childLanes |= f,
            g = u.alternate,
            g !== null && (g.childLanes |= f),
            g = u,
            u = u.return;
        return g.tag === 3 ? g.stateNode : null
    }
    function Mi(u, f) {
        var g = u.callbackNode;
        fI(u, f);
        var w = sh(u, u === xn ? Gn : 0);
        if (w === 0)
            g !== null && zM(g),
            u.callbackNode = null,
            u.callbackPriority = 0;
        else if (f = w & -w,
        u.callbackPriority !== f) {
            if (g != null && zM(g),
            f === 1)
                u.tag === 0 ? xI(nS.bind(null, u)) : GM(nS.bind(null, u)),
                Je ? We(function() {
                    yt === 0 && Xr()
                }) : A0(M0, Xr),
                g = null;
            else {
                switch (UM(w)) {
                case 1:
                    g = M0;
                    break;
                case 4:
                    g = mI;
                    break;
                case 16:
                    g = w0;
                    break;
                case 536870912:
                    g = gI;
                    break;
                default:
                    g = w0
                }
                g = fS(g, tS.bind(null, u))
            }
            u.callbackPriority = f,
            u.callbackNode = g
        }
    }
    function tS(u, f) {
        if (Vh = -1,
        Wh = 0,
        yt & 6)
            throw Error(o(327));
        var g = u.callbackNode;
        if (pa() && u.callbackNode !== g)
            return null;
        var w = sh(u, u === xn ? Gn : 0);
        if (w === 0)
            return null;
        if (w & 30 || w & u.expiredLanes || f)
            f = Jh(u, w);
        else {
            f = w;
            var C = yt;
            yt |= 2;
            var b = sS();
            (xn !== u || Gn !== f) && (Rl(),
            da(u, f));
            do
                try {
                    GI();
                    break
                } catch (K) {
                    rS(u, K)
                }
            while (1);
            E0(),
            Oh.current = b,
            yt = C,
            _n !== null ? f = 0 : (xn = null,
            Gn = 0,
            f = Cn)
        }
        if (f !== 0) {
            if (f === 2 && (C = v0(u),
            C !== 0 && (w = C,
            f = py(u, C))),
            f === 1)
                throw g = wc,
                da(u, 0),
                ro(u, w),
                Mi(u, Dn()),
                g;
            if (f === 6)
                ro(u, w);
            else {
                if (C = u.current.alternate,
                !(w & 30) && !UI(C) && (f = Jh(u, w),
                f === 2 && (b = v0(u),
                b !== 0 && (w = b,
                f = py(u, b))),
                f === 1))
                    throw g = wc,
                    da(u, 0),
                    ro(u, w),
                    Mi(u, Dn()),
                    g;
                switch (u.finishedWork = C,
                u.finishedLanes = w,
                f) {
                case 0:
                case 1:
                    throw Error(o(345));
                case 2:
                    ha(u, Ai);
                    break;
                case 3:
                    if (ro(u, w),
                    (w & 130023424) === w && (f = cy + 500 - Dn(),
                    10 < f)) {
                        if (sh(u, 0) !== 0)
                            break;
                        if (C = u.suspendedLanes,
                        (C & w) !== w) {
                            ai(),
                            u.pingedLanes |= u.suspendedLanes & C;
                            break
                        }
                        u.timeoutHandle = Ie(ha.bind(null, u, Ai), f);
                        break
                    }
                    ha(u, Ai);
                    break;
                case 4:
                    if (ro(u, w),
                    (w & 4194240) === w)
                        break;
                    for (f = u.eventTimes,
                    C = -1; 0 < w; ) {
                        var N = 31 - Ar(w);
                        b = 1 << N,
                        N = f[N],
                        N > C && (C = N),
                        w &= ~b
                    }
                    if (w = C,
                    w = Dn() - w,
                    w = (120 > w ? 120 : 480 > w ? 480 : 1080 > w ? 1080 : 1920 > w ? 1920 : 3e3 > w ? 3e3 : 4320 > w ? 4320 : 1960 * OI(w / 1960)) - w,
                    10 < w) {
                        u.timeoutHandle = Ie(ha.bind(null, u, Ai), w);
                        break
                    }
                    ha(u, Ai);
                    break;
                case 5:
                    ha(u, Ai);
                    break;
                default:
                    throw Error(o(329))
                }
            }
        }
        return Mi(u, Dn()),
        u.callbackNode === g ? tS.bind(null, u) : null
    }
    function py(u, f) {
        var g = Sc;
        return u.current.memoizedState.isDehydrated && (da(u, f).flags |= 256),
        u = Jh(u, f),
        u !== 2 && (f = Ai,
        Ai = g,
        f !== null && my(f)),
        u
    }
    function my(u) {
        Ai === null ? Ai = u : Ai.push.apply(Ai, u)
    }
    function UI(u) {
        for (var f = u; ; ) {
            if (f.flags & 16384) {
                var g = f.updateQueue;
                if (g !== null && (g = g.stores,
                g !== null))
                    for (var w = 0; w < g.length; w++) {
                        var C = g[w]
                          , b = C.getSnapshot;
                        C = C.value;
                        try {
                            if (!Jr(b(), C))
                                return !1
                        } catch {
                            return !1
                        }
                    }
            }
            if (g = f.child,
            f.subtreeFlags & 16384 && g !== null)
                g.return = f,
                f = g;
            else {
                if (f === u)
                    break;
                for (; f.sibling === null; ) {
                    if (f.return === null || f.return === u)
                        return !0;
                    f = f.return
                }
                f.sibling.return = f.return,
                f = f.sibling
            }
        }
        return !0
    }
    function ro(u, f) {
        for (f &= ~uy,
        f &= ~Uh,
        u.suspendedLanes |= f,
        u.pingedLanes &= ~f,
        u = u.expirationTimes; 0 < f; ) {
            var g = 31 - Ar(f)
              , w = 1 << g;
            u[g] = -1,
            f &= ~w
        }
    }
    function nS(u) {
        if (yt & 6)
            throw Error(o(327));
        pa();
        var f = sh(u, 0);
        if (!(f & 1))
            return Mi(u, Dn()),
            null;
        var g = Jh(u, f);
        if (u.tag !== 0 && g === 2) {
            var w = v0(u);
            w !== 0 && (f = w,
            g = py(u, w))
        }
        if (g === 1)
            throw g = wc,
            da(u, 0),
            ro(u, f),
            Mi(u, Dn()),
            g;
        if (g === 6)
            throw Error(o(345));
        return u.finishedWork = u.current.alternate,
        u.finishedLanes = f,
        ha(u, Ai),
        Mi(u, Dn()),
        null
    }
    function iS(u) {
        no !== null && no.tag === 0 && !(yt & 6) && pa();
        var f = yt;
        yt |= 1;
        var g = mn.transition
          , w = Lt;
        try {
            if (mn.transition = null,
            Lt = 1,
            u)
                return u()
        } finally {
            Lt = w,
            mn.transition = g,
            yt = f,
            !(yt & 6) && Xr()
        }
    }
    function gy() {
        Fi = Pl.current,
        ft(Pl)
    }
    function da(u, f) {
        u.finishedWork = null,
        u.finishedLanes = 0;
        var g = u.timeoutHandle;
        if (g !== He && (u.timeoutHandle = He,
        Ne(g)),
        _n !== null)
            for (g = _n.return; g !== null; ) {
                var w = g;
                switch (I0(w),
                w.tag) {
                case 1:
                    w = w.type.childContextTypes,
                    w != null && th();
                    break;
                case 3:
                    Tl(),
                    ft(In),
                    ft(kt),
                    z0();
                    break;
                case 5:
                    O0(w);
                    break;
                case 4:
                    Tl();
                    break;
                case 13:
                    ft($t);
                    break;
                case 19:
                    ft($t);
                    break;
                case 10:
                    T0(w.type._context);
                    break;
                case 22:
                case 23:
                    gy()
                }
                g = g.return
            }
        if (xn = u,
        _n = u = so(u.current, null),
        Gn = Fi = f,
        Cn = 0,
        wc = null,
        uy = Uh = Bl = 0,
        Ai = Sc = null,
        Kr !== null) {
            for (f = 0; f < Kr.length; f++)
                if (g = Kr[f],
                w = g.interleaved,
                w !== null) {
                    g.interleaved = null;
                    var C = w.next
                      , b = g.pending;
                    if (b !== null) {
                        var N = b.next;
                        b.next = C,
                        w.next = N
                    }
                    g.pending = w
                }
            Kr = null
        }
        return u
    }
    function rS(u, f) {
        do {
            var g = _n;
            try {
                if (E0(),
                vh.current = Sh,
                xh) {
                    for (var w = cn.memoizedState; w !== null; ) {
                        var C = w.queue;
                        C !== null && (C.pending = null),
                        w = w.next
                    }
                    xh = !1
                }
                if (bl = 0,
                Fn = Xn = cn = null,
                pc = !1,
                mc = 0,
                ly.current = null,
                g === null || g.return === null) {
                    Cn = 1,
                    wc = f,
                    _n = null;
                    break
                }
                e: {
                    var b = u
                      , N = g.return
                      , K = g
                      , fe = f;
                    if (f = Gn,
                    K.flags |= 32768,
                    fe !== null && typeof fe == "object" && typeof fe.then == "function") {
                        var Te = fe
                          , Ve = K
                          , st = Ve.tag;
                        if (!(Ve.mode & 1) && (st === 0 || st === 11 || st === 15)) {
                            var et = Ve.alternate;
                            et ? (Ve.updateQueue = et.updateQueue,
                            Ve.memoizedState = et.memoizedState,
                            Ve.lanes = et.lanes) : (Ve.updateQueue = null,
                            Ve.memoizedState = null)
                        }
                        var zt = Cw(N);
                        if (zt !== null) {
                            zt.flags &= -257,
                            Ew(zt, N, K, b, f),
                            zt.mode & 1 && Sw(b, Te, f),
                            f = zt,
                            fe = Te;
                            var Qe = f.updateQueue;
                            if (Qe === null) {
                                var Qn = new Set;
                                Qn.add(fe),
                                f.updateQueue = Qn
                            } else
                                Qe.add(fe);
                            break e
                        } else {
                            if (!(f & 1)) {
                                Sw(b, Te, f),
                                yy();
                                break e
                            }
                            fe = Error(o(426))
                        }
                    } else if (Yt && K.mode & 1) {
                        var or = Cw(N);
                        if (or !== null) {
                            !(or.flags & 65536) && (or.flags |= 256),
                            Ew(or, N, K, b, f),
                            k0(fe);
                            break e
                        }
                    }
                    b = fe,
                    Cn !== 4 && (Cn = 2),
                    Sc === null ? Sc = [b] : Sc.push(b),
                    fe = X0(fe, K),
                    K = N;
                    do {
                        switch (K.tag) {
                        case 3:
                            K.flags |= 65536,
                            f &= -f,
                            K.lanes |= f;
                            var ne = Mw(K, fe, f);
                            WM(K, ne);
                            break e;
                        case 1:
                            b = fe;
                            var Q = K.type
                              , ue = K.stateNode;
                            if (!(K.flags & 128) && (typeof Q.getDerivedStateFromError == "function" || ue !== null && typeof ue.componentDidCatch == "function" && (to === null || !to.has(ue)))) {
                                K.flags |= 65536,
                                f &= -f,
                                K.lanes |= f;
                                var Oe = ww(K, b, f);
                                WM(K, Oe);
                                break e
                            }
                        }
                        K = K.return
                    } while (K !== null)
                }
                aS(g)
            } catch (Ke) {
                f = Ke,
                _n === g && g !== null && (_n = g = g.return);
                continue
            }
            break
        } while (1)
    }
    function sS() {
        var u = Oh.current;
        return Oh.current = Sh,
        u === null ? Sh : u
    }
    function yy() {
        (Cn === 0 || Cn === 3 || Cn === 2) && (Cn = 4),
        xn === null || !(Bl & 268435455) && !(Uh & 268435455) || ro(xn, Gn)
    }
    function Jh(u, f) {
        var g = yt;
        yt |= 2;
        var w = sS();
        xn === u && Gn === f || da(u, f);
        do
            try {
                zI();
                break
            } catch (C) {
                rS(u, C)
            }
        while (1);
        if (E0(),
        yt = g,
        Oh.current = w,
        _n !== null)
            throw Error(o(261));
        return xn = null,
        Gn = 0,
        Cn
    }
    function zI() {
        for (; _n !== null; )
            oS(_n)
    }
    function GI() {
        for (; _n !== null && !hI(); )
            oS(_n)
    }
    function oS(u) {
        var f = cS(u.alternate, u, Fi);
        u.memoizedProps = u.pendingProps,
        f === null ? aS(u) : _n = f,
        ly.current = null
    }
    function aS(u) {
        var f = u;
        do {
            var g = f.alternate;
            if (u = f.return,
            f.flags & 32768) {
                if (g = II(g, f),
                g !== null) {
                    g.flags &= 32767,
                    _n = g;
                    return
                }
                if (u !== null)
                    u.flags |= 32768,
                    u.subtreeFlags = 0,
                    u.deletions = null;
                else {
                    Cn = 6,
                    _n = null;
                    return
                }
            } else if (g = BI(g, f, Fi),
            g !== null) {
                _n = g;
                return
            }
            if (f = f.sibling,
            f !== null) {
                _n = f;
                return
            }
            _n = f = u
        } while (f !== null);
        Cn === 0 && (Cn = 5)
    }
    function ha(u, f) {
        var g = Lt
          , w = mn.transition;
        try {
            mn.transition = null,
            Lt = 1,
            HI(u, f, g)
        } finally {
            mn.transition = w,
            Lt = g
        }
        return null
    }
    function HI(u, f, g) {
        do
            pa();
        while (no !== null);
        if (yt & 6)
            throw Error(o(327));
        var w = u.finishedWork
          , C = u.finishedLanes;
        if (w === null)
            return null;
        if (u.finishedWork = null,
        u.finishedLanes = 0,
        w === u.current)
            throw Error(o(177));
        u.callbackNode = null,
        u.callbackPriority = 0;
        var b = w.lanes | w.childLanes;
        if (dI(u, b),
        u === xn && (_n = xn = null,
        Gn = 0),
        !(w.subtreeFlags & 2064) && !(w.flags & 2064) || Gh || (Gh = !0,
        fS(w0, function() {
            return pa(),
            null
        })),
        b = (w.flags & 15990) !== 0,
        w.subtreeFlags & 15990 || b) {
            b = mn.transition,
            mn.transition = null;
            var N = Lt;
            Lt = 1;
            var K = yt;
            yt |= 4,
            ly.current = null,
            FI(u, w),
            kI(u, w),
            j(u.containerInfo),
            u.current = w,
            NI(w),
            pI(),
            yt = K,
            Lt = N,
            mn.transition = b
        } else
            u.current = w;
        if (Gh && (Gh = !1,
        no = u,
        Hh = C),
        b = u.pendingLanes,
        b === 0 && (to = null),
        yI(w.stateNode),
        Mi(u, Dn()),
        f !== null)
            for (g = u.onRecoverableError,
            w = 0; w < f.length; w++)
                g(f[w]);
        if (zh)
            throw zh = !1,
            u = dy,
            dy = null,
            u;
        return Hh & 1 && u.tag !== 0 && pa(),
        b = u.pendingLanes,
        b & 1 ? u === hy ? Cc++ : (Cc = 0,
        hy = u) : Cc = 0,
        Xr(),
        null
    }
    function pa() {
        if (no !== null) {
            var u = UM(Hh)
              , f = mn.transition
              , g = Lt;
            try {
                if (mn.transition = null,
                Lt = 16 > u ? 16 : u,
                no === null)
                    var w = !1;
                else {
                    if (u = no,
                    no = null,
                    Hh = 0,
                    yt & 6)
                        throw Error(o(331));
                    var C = yt;
                    for (yt |= 4,
                    ke = u.current; ke !== null; ) {
                        var b = ke
                          , N = b.child;
                        if (ke.flags & 16) {
                            var K = b.deletions;
                            if (K !== null) {
                                for (var fe = 0; fe < K.length; fe++) {
                                    var Te = K[fe];
                                    for (ke = Te; ke !== null; ) {
                                        var Ve = ke;
                                        switch (Ve.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            fa(8, Ve, b)
                                        }
                                        var st = Ve.child;
                                        if (st !== null)
                                            st.return = Ve,
                                            ke = st;
                                        else
                                            for (; ke !== null; ) {
                                                Ve = ke;
                                                var et = Ve.sibling
                                                  , zt = Ve.return;
                                                if (jw(Ve),
                                                Ve === Te) {
                                                    ke = null;
                                                    break
                                                }
                                                if (et !== null) {
                                                    et.return = zt,
                                                    ke = et;
                                                    break
                                                }
                                                ke = zt
                                            }
                                    }
                                }
                                var Qe = b.alternate;
                                if (Qe !== null) {
                                    var Qn = Qe.child;
                                    if (Qn !== null) {
                                        Qe.child = null;
                                        do {
                                            var or = Qn.sibling;
                                            Qn.sibling = null,
                                            Qn = or
                                        } while (Qn !== null)
                                    }
                                }
                                ke = b
                            }
                        }
                        if (b.subtreeFlags & 2064 && N !== null)
                            N.return = b,
                            ke = N;
                        else
                            e: for (; ke !== null; ) {
                                if (b = ke,
                                b.flags & 2048)
                                    switch (b.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        fa(9, b, b.return)
                                    }
                                var ne = b.sibling;
                                if (ne !== null) {
                                    ne.return = b.return,
                                    ke = ne;
                                    break e
                                }
                                ke = b.return
                            }
                    }
                    var Q = u.current;
                    for (ke = Q; ke !== null; ) {
                        N = ke;
                        var ue = N.child;
                        if (N.subtreeFlags & 2064 && ue !== null)
                            ue.return = N,
                            ke = ue;
                        else
                            e: for (N = Q; ke !== null; ) {
                                if (K = ke,
                                K.flags & 2048)
                                    try {
                                        switch (K.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            Ac(9, K)
                                        }
                                    } catch (Ke) {
                                        wi(K, K.return, Ke)
                                    }
                                if (K === N) {
                                    ke = null;
                                    break e
                                }
                                var Oe = K.sibling;
                                if (Oe !== null) {
                                    Oe.return = K.return,
                                    ke = Oe;
                                    break e
                                }
                                ke = K.return
                            }
                    }
                    if (yt = C,
                    Xr(),
                    jr && typeof jr.onPostCommitFiberRoot == "function")
                        try {
                            jr.onPostCommitFiberRoot(oh, u)
                        } catch {}
                    w = !0
                }
                return w
            } finally {
                Lt = g,
                mn.transition = f
            }
        }
        return !1
    }
    function lS(u, f, g) {
        f = X0(g, f),
        f = Mw(u, f, 1),
        eo(u, f),
        f = ai(),
        u = jh(u, 1),
        u !== null && (lc(u, 1, f),
        Mi(u, f))
    }
    function wi(u, f, g) {
        if (u.tag === 3)
            lS(u, u, g);
        else
            for (; f !== null; ) {
                if (f.tag === 3) {
                    lS(f, u, g);
                    break
                } else if (f.tag === 1) {
                    var w = f.stateNode;
                    if (typeof f.type.getDerivedStateFromError == "function" || typeof w.componentDidCatch == "function" && (to === null || !to.has(w))) {
                        u = X0(g, u),
                        u = ww(f, u, 1),
                        eo(f, u),
                        u = ai(),
                        f = jh(f, 1),
                        f !== null && (lc(f, 1, u),
                        Mi(f, u));
                        break
                    }
                }
                f = f.return
            }
    }
    function VI(u, f, g) {
        var w = u.pingCache;
        w !== null && w.delete(f),
        f = ai(),
        u.pingedLanes |= u.suspendedLanes & g,
        xn === u && (Gn & g) === g && (Cn === 4 || Cn === 3 && (Gn & 130023424) === Gn && 500 > Dn() - cy ? da(u, 0) : uy |= g),
        Mi(u, f)
    }
    function uS(u, f) {
        f === 0 && (u.mode & 1 ? (f = rh,
        rh <<= 1,
        !(rh & 130023424) && (rh = 4194304)) : f = 1);
        var g = ai();
        u = jh(u, f),
        u !== null && (lc(u, f, g),
        Mi(u, g))
    }
    function WI(u) {
        var f = u.memoizedState
          , g = 0;
        f !== null && (g = f.retryLane),
        uS(u, g)
    }
    function jI(u, f) {
        var g = 0;
        switch (u.tag) {
        case 13:
            var w = u.stateNode
              , C = u.memoizedState;
            C !== null && (g = C.retryLane);
            break;
        case 19:
            w = u.stateNode;
            break;
        default:
            throw Error(o(314))
        }
        w !== null && w.delete(f),
        uS(u, g)
    }
    var cS;
    cS = function(u, f, g) {
        if (u !== null)
            if (u.memoizedProps !== f.pendingProps || In.current)
                Di = !0;
            else {
                if (!(u.lanes & g) && !(f.flags & 128))
                    return Di = !1,
                    LI(u, f, g);
                Di = !!(u.flags & 131072)
            }
        else
            Di = !1,
            Yt && f.flags & 1048576 && QM(f, mh, f.index);
        switch (f.lanes = 0,
        f.tag) {
        case 2:
            var w = f.type;
            u !== null && (u.alternate = null,
            f.alternate = null,
            f.flags |= 2),
            u = f.pendingProps;
            var C = ps(f, kt.current);
            Al(f, g),
            C = H0(null, f, w, u, C, g);
            var b = V0();
            return f.flags |= 1,
            typeof C == "object" && C !== null && typeof C.render == "function" && C.$$typeof === void 0 ? (f.tag = 1,
            f.memoizedState = null,
            f.updateQueue = null,
            _i(w) ? (b = !0,
            nh(f)) : b = !1,
            f.memoizedState = C.state !== null && C.state !== void 0 ? C.state : null,
            P0(f),
            C.updater = hh,
            f.stateNode = C,
            C._reactInternals = f,
            R0(f, w, u, g),
            f = Q0(null, f, w, !0, b, g)) : (f.tag = 0,
            Yt && b && L0(f),
            oi(null, f, C, g),
            f = f.child),
            f;
        case 16:
            w = f.elementType;
            e: {
                switch (u !== null && (u.alternate = null,
                f.alternate = null,
                f.flags |= 2),
                u = f.pendingProps,
                C = w._init,
                w = C(w._payload),
                f.type = w,
                C = f.tag = XI(w),
                u = Mr(w, u),
                C) {
                case 0:
                    f = Y0(null, f, w, u, g);
                    break e;
                case 1:
                    f = Dw(null, f, w, u, g);
                    break e;
                case 11:
                    f = Pw(null, f, w, u, g);
                    break e;
                case 14:
                    f = Bw(null, f, w, Mr(w.type, u), g);
                    break e
                }
                throw Error(o(306, w, ""))
            }
            return f;
        case 0:
            return w = f.type,
            C = f.pendingProps,
            C = f.elementType === w ? C : Mr(w, C),
            Y0(u, f, w, C, g);
        case 1:
            return w = f.type,
            C = f.pendingProps,
            C = f.elementType === w ? C : Mr(w, C),
            Dw(u, f, w, C, g);
        case 3:
            e: {
                if (Fw(f),
                u === null)
                    throw Error(o(387));
                w = f.pendingProps,
                b = f.memoizedState,
                C = b.element,
                VM(u, f),
                dh(f, w, null, g);
                var N = f.memoizedState;
                if (w = N.element,
                ae && b.isDehydrated)
                    if (b = {
                        element: w,
                        isDehydrated: !1,
                        cache: N.cache,
                        transitions: N.transitions
                    },
                    f.updateQueue.baseState = b,
                    f.memoizedState = b,
                    f.flags & 256) {
                        C = Error(o(423)),
                        f = kw(u, f, w, g, C);
                        break e
                    } else if (w !== C) {
                        C = Error(o(424)),
                        f = kw(u, f, w, g, C);
                        break e
                    } else
                        for (ae && (Ii = $(f.stateNode.containerInfo),
                        Li = f,
                        Yt = !0,
                        wr = null,
                        uc = !1),
                        g = nw(f, null, w, g),
                        f.child = g; g; )
                            g.flags = g.flags & -3 | 4096,
                            g = g.sibling;
                else {
                    if (Sl(),
                    w === C) {
                        f = _s(u, f, g);
                        break e
                    }
                    oi(u, f, w, g)
                }
                f = f.child
            }
            return f;
        case 5:
            return iw(f),
            u === null && F0(f),
            w = f.type,
            C = f.pendingProps,
            b = u !== null ? u.memoizedProps : null,
            N = C.children,
            ve(w, C) ? N = null : b !== null && ve(w, b) && (f.flags |= 32),
            Iw(u, f),
            oi(u, f, N, g),
            f.child;
        case 6:
            return u === null && F0(f),
            null;
        case 13:
            return Nw(u, f, g);
        case 4:
            return N0(f, f.stateNode.containerInfo),
            w = f.pendingProps,
            u === null ? f.child = Cl(f, null, w, g) : oi(u, f, w, g),
            f.child;
        case 11:
            return w = f.type,
            C = f.pendingProps,
            C = f.elementType === w ? C : Mr(w, C),
            Pw(u, f, w, C, g);
        case 7:
            return oi(u, f, f.pendingProps, g),
            f.child;
        case 8:
            return oi(u, f, f.pendingProps.children, g),
            f.child;
        case 12:
            return oi(u, f, f.pendingProps.children, g),
            f.child;
        case 10:
            e: {
                if (w = f.type._context,
                C = f.pendingProps,
                b = f.memoizedProps,
                N = C.value,
                HM(f, w, N),
                b !== null)
                    if (Jr(b.value, N)) {
                        if (b.children === C.children && !In.current) {
                            f = _s(u, f, g);
                            break e
                        }
                    } else
                        for (b = f.child,
                        b !== null && (b.return = f); b !== null; ) {
                            var K = b.dependencies;
                            if (K !== null) {
                                N = b.child;
                                for (var fe = K.firstContext; fe !== null; ) {
                                    if (fe.context === w) {
                                        if (b.tag === 1) {
                                            fe = gs(-1, g & -g),
                                            fe.tag = 2;
                                            var Te = b.updateQueue;
                                            if (Te !== null) {
                                                Te = Te.shared;
                                                var Ve = Te.pending;
                                                Ve === null ? fe.next = fe : (fe.next = Ve.next,
                                                Ve.next = fe),
                                                Te.pending = fe
                                            }
                                        }
                                        b.lanes |= g,
                                        fe = b.alternate,
                                        fe !== null && (fe.lanes |= g),
                                        b0(b.return, g, f),
                                        K.lanes |= g;
                                        break
                                    }
                                    fe = fe.next
                                }
                            } else if (b.tag === 10)
                                N = b.type === f.type ? null : b.child;
                            else if (b.tag === 18) {
                                if (N = b.return,
                                N === null)
                                    throw Error(o(341));
                                N.lanes |= g,
                                K = N.alternate,
                                K !== null && (K.lanes |= g),
                                b0(N, g, f),
                                N = b.sibling
                            } else
                                N = b.child;
                            if (N !== null)
                                N.return = b;
                            else
                                for (N = b; N !== null; ) {
                                    if (N === f) {
                                        N = null;
                                        break
                                    }
                                    if (b = N.sibling,
                                    b !== null) {
                                        b.return = N.return,
                                        N = b;
                                        break
                                    }
                                    N = N.return
                                }
                            b = N
                        }
                oi(u, f, C.children, g),
                f = f.child
            }
            return f;
        case 9:
            return C = f.type,
            w = f.pendingProps.children,
            Al(f, g),
            C = $i(C),
            w = w(C),
            f.flags |= 1,
            oi(u, f, w, g),
            f.child;
        case 14:
            return w = f.type,
            C = Mr(w, f.pendingProps),
            C = Mr(w.type, C),
            Bw(u, f, w, C, g);
        case 15:
            return Rw(u, f, f.type, f.pendingProps, g);
        case 17:
            return w = f.type,
            C = f.pendingProps,
            C = f.elementType === w ? C : Mr(w, C),
            u !== null && (u.alternate = null,
            f.alternate = null,
            f.flags |= 2),
            f.tag = 1,
            _i(w) ? (u = !0,
            nh(f)) : u = !1,
            Al(f, g),
            KM(f, w, C),
            R0(f, w, C, g),
            Q0(null, f, w, !0, u, g);
        case 19:
            return Gw(u, f, g);
        case 22:
            return Lw(u, f, g)
        }
        throw Error(o(156, f.tag))
    }
    ;
    function fS(u, f) {
        return A0(u, f)
    }
    function JI(u, f, g, w) {
        this.tag = u,
        this.key = g,
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
        this.index = 0,
        this.ref = null,
        this.pendingProps = f,
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
        this.mode = w,
        this.subtreeFlags = this.flags = 0,
        this.deletions = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null
    }
    function sr(u, f, g, w) {
        return new JI(u,f,g,w)
    }
    function vy(u) {
        return u = u.prototype,
        !(!u || !u.isReactComponent)
    }
    function XI(u) {
        if (typeof u == "function")
            return vy(u) ? 1 : 0;
        if (u != null) {
            if (u = u.$$typeof,
            u === v)
                return 11;
            if (u === A)
                return 14
        }
        return 2
    }
    function so(u, f) {
        var g = u.alternate;
        return g === null ? (g = sr(u.tag, f, u.key, u.mode),
        g.elementType = u.elementType,
        g.type = u.type,
        g.stateNode = u.stateNode,
        g.alternate = u,
        u.alternate = g) : (g.pendingProps = f,
        g.type = u.type,
        g.flags = 0,
        g.subtreeFlags = 0,
        g.deletions = null),
        g.flags = u.flags & 14680064,
        g.childLanes = u.childLanes,
        g.lanes = u.lanes,
        g.child = u.child,
        g.memoizedProps = u.memoizedProps,
        g.memoizedState = u.memoizedState,
        g.updateQueue = u.updateQueue,
        f = u.dependencies,
        g.dependencies = f === null ? null : {
            lanes: f.lanes,
            firstContext: f.firstContext
        },
        g.sibling = u.sibling,
        g.index = u.index,
        g.ref = u.ref,
        g
    }
    function Xh(u, f, g, w, C, b) {
        var N = 2;
        if (w = u,
        typeof u == "function")
            vy(u) && (N = 1);
        else if (typeof u == "string")
            N = 5;
        else
            e: switch (u) {
            case d:
                return ma(g.children, C, b, f);
            case h:
                N = 8,
                C |= 8;
                break;
            case p:
                return u = sr(12, g, f, C | 2),
                u.elementType = p,
                u.lanes = b,
                u;
            case _:
                return u = sr(13, g, f, C),
                u.elementType = _,
                u.lanes = b,
                u;
            case x:
                return u = sr(19, g, f, C),
                u.elementType = x,
                u.lanes = b,
                u;
            case S:
                return Kh(g, C, b, f);
            default:
                if (typeof u == "object" && u !== null)
                    switch (u.$$typeof) {
                    case m:
                        N = 10;
                        break e;
                    case y:
                        N = 9;
                        break e;
                    case v:
                        N = 11;
                        break e;
                    case A:
                        N = 14;
                        break e;
                    case M:
                        N = 16,
                        w = null;
                        break e
                    }
                throw Error(o(130, u == null ? u : typeof u, ""))
            }
        return f = sr(N, g, f, C),
        f.elementType = u,
        f.type = w,
        f.lanes = b,
        f
    }
    function ma(u, f, g, w) {
        return u = sr(7, u, w, f),
        u.lanes = g,
        u
    }
    function Kh(u, f, g, w) {
        return u = sr(22, u, w, f),
        u.elementType = S,
        u.lanes = g,
        u.stateNode = {},
        u
    }
    function xy(u, f, g) {
        return u = sr(6, u, null, f),
        u.lanes = g,
        u
    }
    function _y(u, f, g) {
        return f = sr(4, u.children !== null ? u.children : [], u.key, f),
        f.lanes = g,
        f.stateNode = {
            containerInfo: u.containerInfo,
            pendingChildren: null,
            implementation: u.implementation
        },
        f
    }
    function KI(u, f, g, w, C) {
        this.tag = f,
        this.containerInfo = u,
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
        this.timeoutHandle = He,
        this.callbackNode = this.pendingContext = this.context = null,
        this.callbackPriority = 0,
        this.eventTimes = x0(0),
        this.expirationTimes = x0(-1),
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
        this.entanglements = x0(0),
        this.identifierPrefix = w,
        this.onRecoverableError = C,
        ae && (this.mutableSourceEagerHydrationData = null)
    }
    function dS(u, f, g, w, C, b, N, K, fe) {
        return u = new KI(u,f,g,K,fe),
        f === 1 ? (f = 1,
        b === !0 && (f |= 8)) : f = 0,
        b = sr(3, null, null, f),
        u.current = b,
        b.stateNode = u,
        b.memoizedState = {
            element: w,
            isDehydrated: g,
            cache: null,
            transitions: null
        },
        P0(b),
        u
    }
    function hS(u) {
        if (!u)
            return qi;
        u = u._reactInternals;
        e: {
            if (B(u) !== u || u.tag !== 1)
                throw Error(o(170));
            var f = u;
            do {
                switch (f.tag) {
                case 3:
                    f = f.stateNode.context;
                    break e;
                case 1:
                    if (_i(f.type)) {
                        f = f.stateNode.__reactInternalMemoizedMergedChildContext;
                        break e
                    }
                }
                f = f.return
            } while (f !== null);
            throw Error(o(171))
        }
        if (u.tag === 1) {
            var g = u.type;
            if (_i(g))
                return NM(u, g, f)
        }
        return f
    }
    function pS(u) {
        var f = u._reactInternals;
        if (f === void 0)
            throw typeof u.render == "function" ? Error(o(188)) : (u = Object.keys(u).join(","),
            Error(o(268, u)));
        return u = Z(f),
        u === null ? null : u.stateNode
    }
    function mS(u, f) {
        if (u = u.memoizedState,
        u !== null && u.dehydrated !== null) {
            var g = u.retryLane;
            u.retryLane = g !== 0 && g < f ? g : f
        }
    }
    function Ay(u, f) {
        mS(u, f),
        (u = u.alternate) && mS(u, f)
    }
    function YI(u) {
        return u = Z(u),
        u === null ? null : u.stateNode
    }
    function QI() {
        return null
    }
    return t.attemptContinuousHydration = function(u) {
        if (u.tag === 13) {
            var f = ai();
            rr(u, 134217728, f),
            Ay(u, 134217728)
        }
    }
    ,
    t.attemptHydrationAtCurrentPriority = function(u) {
        if (u.tag === 13) {
            var f = ai()
              , g = io(u);
            rr(u, g, f),
            Ay(u, g)
        }
    }
    ,
    t.attemptSynchronousHydration = function(u) {
        switch (u.tag) {
        case 3:
            var f = u.stateNode;
            if (f.current.memoizedState.isDehydrated) {
                var g = ac(f.pendingLanes);
                g !== 0 && (_0(f, g | 1),
                Mi(f, Dn()),
                !(yt & 6) && (Rl(),
                Xr()))
            }
            break;
        case 13:
            var w = ai();
            iS(function() {
                return rr(u, 1, w)
            }),
            Ay(u, 1)
        }
    }
    ,
    t.batchedUpdates = function(u, f) {
        var g = yt;
        yt |= 1;
        try {
            return u(f)
        } finally {
            yt = g,
            yt === 0 && (Rl(),
            ah && Xr())
        }
    }
    ,
    t.createComponentSelector = function(u) {
        return {
            $$typeof: Ih,
            value: u
        }
    }
    ,
    t.createContainer = function(u, f, g, w, C, b, N) {
        return dS(u, f, !1, null, g, w, C, b, N)
    }
    ,
    t.createHasPseudoClassSelector = function(u) {
        return {
            $$typeof: Dh,
            value: u
        }
    }
    ,
    t.createHydrationContainer = function(u, f, g, w, C, b, N, K, fe) {
        return u = dS(g, w, !0, u, C, b, N, K, fe),
        u.context = hS(null),
        g = u.current,
        w = ai(),
        C = io(g),
        b = gs(w, C),
        b.callback = f ?? null,
        eo(g, b),
        u.current.lanes = C,
        lc(u, C, w),
        Mi(u, w),
        u
    }
    ,
    t.createPortal = function(u, f, g) {
        var w = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: c,
            key: w == null ? null : "" + w,
            children: u,
            containerInfo: f,
            implementation: g
        }
    }
    ,
    t.createRoleSelector = function(u) {
        return {
            $$typeof: Fh,
            value: u
        }
    }
    ,
    t.createTestNameSelector = function(u) {
        return {
            $$typeof: kh,
            value: u
        }
    }
    ,
    t.createTextSelector = function(u) {
        return {
            $$typeof: Nh,
            value: u
        }
    }
    ,
    t.deferredUpdates = function(u) {
        var f = Lt
          , g = mn.transition;
        try {
            return mn.transition = null,
            Lt = 16,
            u()
        } finally {
            Lt = f,
            mn.transition = g
        }
    }
    ,
    t.discreteUpdates = function(u, f, g, w, C) {
        var b = Lt
          , N = mn.transition;
        try {
            return mn.transition = null,
            Lt = 1,
            u(f, g, w, C)
        } finally {
            Lt = b,
            mn.transition = N,
            yt === 0 && Rl()
        }
    }
    ,
    t.findAllNodes = ay,
    t.findBoundingRects = function(u, f) {
        if (!xt)
            throw Error(o(363));
        f = ay(u, f),
        u = [];
        for (var g = 0; g < f.length; g++)
            u.push(U(f[g]));
        for (f = u.length - 1; 0 < f; f--) {
            g = u[f];
            for (var w = g.x, C = w + g.width, b = g.y, N = b + g.height, K = f - 1; 0 <= K; K--)
                if (f !== K) {
                    var fe = u[K]
                      , Te = fe.x
                      , Ve = Te + fe.width
                      , st = fe.y
                      , et = st + fe.height;
                    if (w >= Te && b >= st && C <= Ve && N <= et) {
                        u.splice(f, 1);
                        break
                    } else if (w !== Te || g.width !== fe.width || et < b || st > N) {
                        if (!(b !== st || g.height !== fe.height || Ve < w || Te > C)) {
                            Te > w && (fe.width += Te - w,
                            fe.x = w),
                            Ve < C && (fe.width = C - Te),
                            u.splice(f, 1);
                            break
                        }
                    } else {
                        st > b && (fe.height += st - b,
                        fe.y = b),
                        et < N && (fe.height = N - st),
                        u.splice(f, 1);
                        break
                    }
                }
        }
        return u
    }
    ,
    t.findHostInstance = pS,
    t.findHostInstanceWithNoPortals = function(u) {
        return u = z(u),
        u = u !== null ? G(u) : null,
        u === null ? null : u.stateNode
    }
    ,
    t.findHostInstanceWithWarning = function(u) {
        return pS(u)
    }
    ,
    t.flushControlled = function(u) {
        var f = yt;
        yt |= 1;
        var g = mn.transition
          , w = Lt;
        try {
            mn.transition = null,
            Lt = 1,
            u()
        } finally {
            Lt = w,
            mn.transition = g,
            yt = f,
            yt === 0 && (Rl(),
            Xr())
        }
    }
    ,
    t.flushPassiveEffects = pa,
    t.flushSync = iS,
    t.focusWithin = function(u, f) {
        if (!xt)
            throw Error(o(363));
        for (u = ry(u),
        f = eS(u, f),
        f = Array.from(f),
        u = 0; u < f.length; ) {
            var g = f[u++];
            if (!oe(g)) {
                if (g.tag === 5 && Ee(g.stateNode))
                    return !0;
                for (g = g.child; g !== null; )
                    f.push(g),
                    g = g.sibling
            }
        }
        return !1
    }
    ,
    t.getCurrentUpdatePriority = function() {
        return Lt
    }
    ,
    t.getFindAllNodesFailureDescription = function(u, f) {
        if (!xt)
            throw Error(o(363));
        var g = 0
          , w = [];
        u = [ry(u), 0];
        for (var C = 0; C < u.length; ) {
            var b = u[C++]
              , N = u[C++]
              , K = f[N];
            if ((b.tag !== 5 || !oe(b)) && (sy(b, K) && (w.push(oy(K)),
            N++,
            N > g && (g = N)),
            N < f.length))
                for (b = b.child; b !== null; )
                    u.push(b, N),
                    b = b.sibling
        }
        if (g < f.length) {
            for (u = []; g < f.length; g++)
                u.push(oy(f[g]));
            return `findAllNodes was able to match part of the selector:
  ` + (w.join(" > ") + `

No matching component was found for:
  `) + u.join(" > ")
        }
        return null
    }
    ,
    t.getPublicRootInstance = function(u) {
        if (u = u.current,
        !u.child)
            return null;
        switch (u.child.tag) {
        case 5:
            return ee(u.child.stateNode);
        default:
            return u.child.stateNode
        }
    }
    ,
    t.injectIntoDevTools = function(u) {
        if (u = {
            bundleType: u.bundleType,
            version: u.version,
            rendererPackageName: u.rendererPackageName,
            rendererConfig: u.rendererConfig,
            overrideHookState: null,
            overrideHookStateDeletePath: null,
            overrideHookStateRenamePath: null,
            overrideProps: null,
            overridePropsDeletePath: null,
            overridePropsRenamePath: null,
            setErrorHandler: null,
            setSuspenseHandler: null,
            scheduleUpdate: null,
            currentDispatcherRef: a.ReactCurrentDispatcher,
            findHostInstanceByFiber: YI,
            findFiberByHostInstance: u.findFiberByHostInstance || QI,
            findHostInstancesForRefresh: null,
            scheduleRefresh: null,
            scheduleRoot: null,
            setRefreshHandler: null,
            getCurrentFiber: null,
            reconcilerVersion: "18.0.0-fc46dba67-20220329"
        },
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
            u = !1;
        else {
            var f = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (f.isDisabled || !f.supportsFiber)
                u = !0;
            else {
                try {
                    oh = f.inject(u),
                    jr = f
                } catch {}
                u = !!f.checkDCE
            }
        }
        return u
    }
    ,
    t.isAlreadyRendering = function() {
        return !1
    }
    ,
    t.observeVisibleRects = function(u, f, g, w) {
        if (!xt)
            throw Error(o(363));
        u = ay(u, f);
        var C = Pe(u, g, w).disconnect;
        return {
            disconnect: function() {
                C()
            }
        }
    }
    ,
    t.registerMutableSourceForHydration = function(u, f) {
        var g = f._getVersion;
        g = g(f._source),
        u.mutableSourceEagerHydrationData == null ? u.mutableSourceEagerHydrationData = [f, g] : u.mutableSourceEagerHydrationData.push(f, g)
    }
    ,
    t.runWithPriority = function(u, f) {
        var g = Lt;
        try {
            return Lt = u,
            f()
        } finally {
            Lt = g
        }
    }
    ,
    t.shouldError = function() {
        return null
    }
    ,
    t.shouldSuspend = function() {
        return !1
    }
    ,
    t.updateContainer = function(u, f, g, w) {
        var C = f.current
          , b = ai()
          , N = io(C);
        return g = hS(g),
        f.context === null ? f.context = g : f.pendingContext = g,
        f = gs(b, N),
        f.payload = {
            element: u
        },
        w = w === void 0 ? null : w,
        w !== null && (f.callback = w),
        eo(C, f),
        u = rr(C, N, b),
        u !== null && fh(u, C, N),
        N
    }
    ,
    t
};
(function(n) {
    n.exports = OH
}
)(kH);
const UH = zb(G1);
function fR(n, e, t=(i,r)=>i === r) {
    if (n === e)
        return !0;
    if (!n || !e)
        return !1;
    const i = n.length;
    if (e.length !== i)
        return !1;
    for (let r = 0; r < i; r++)
        if (!t(n[r], e[r]))
            return !1;
    return !0
}
const Rs = [];
function dR(n, e, t=!1, i={}) {
    for (const s of Rs)
        if (fR(e, s.keys, s.equal)) {
            if (t)
                return;
            if (Object.prototype.hasOwnProperty.call(s, "error"))
                throw s.error;
            if (Object.prototype.hasOwnProperty.call(s, "response"))
                return s.response;
            if (!t)
                throw s.promise
        }
    const r = {
        keys: e,
        equal: i.equal,
        promise: n(...e).then(s=>r.response = s).then(()=>{
            i.lifespan && i.lifespan > 0 && setTimeout(()=>{
                const s = Rs.indexOf(r);
                s !== -1 && Rs.splice(s, 1)
            }
            , i.lifespan)
        }
        ).catch(s=>r.error = s)
    };
    if (Rs.push(r),
    !t)
        throw r.promise
}
const zH = (n,e,t)=>dR(n, e, !1, t)
  , GH = (n,e,t)=>void dR(n, e, !0, t)
  , HH = n=>{
    if (n === void 0 || n.length === 0)
        Rs.splice(0, Rs.length);
    else {
        const e = Rs.find(t=>fR(n, t.keys, t.equal));
        if (e) {
            const t = Rs.indexOf(e);
            t !== -1 && Rs.splice(t, 1)
        }
    }
}
;
var oT, aT;
const VH = (n,...e)=>e.reduce((t,i)=>t == null ? void 0 : t[i], n)
  , ql = "ColorManagement"in z1 && VH(z1, "ColorManagement") || null
  , hR = n=>n && n.isOrthographicCamera
  , WH = n=>n && n.hasOwnProperty("current")
  , jd = typeof window < "u" && ((oT = window.document) != null && oT.createElement || ((aT = window.navigator) == null ? void 0 : aT.product) === "ReactNative") ? O.useLayoutEffect : O.useEffect;
function pR(n) {
    const e = O.useRef(n);
    return jd(()=>void (e.current = n), [n]),
    e
}
function jH({set: n}) {
    return jd(()=>(n(new Promise(()=>null)),
    ()=>n(!1)), [n]),
    null
}
class mR extends O.Component {
    constructor(...e) {
        super(...e),
        this.state = {
            error: !1
        }
    }
    componentDidCatch(e) {
        this.props.set(e)
    }
    render() {
        return this.state.error ? null : this.props.children
    }
}
mR.getDerivedStateFromError = ()=>({
    error: !0
});
const gR = "__default"
  , lT = new Map
  , JH = n=>n && !!n.memoized && !!n.changes;
function yR(n) {
    const e = typeof window < "u" ? window.devicePixelRatio : 1;
    return Array.isArray(n) ? Math.min(Math.max(n[0], e), n[1]) : n
}
const Jc = n=>{
    var e;
    return (e = n.__r3f) == null ? void 0 : e.root.getState()
}
  , en = {
    obj: n=>n === Object(n) && !en.arr(n) && typeof n != "function",
    fun: n=>typeof n == "function",
    str: n=>typeof n == "string",
    num: n=>typeof n == "number",
    boo: n=>typeof n == "boolean",
    und: n=>n === void 0,
    arr: n=>Array.isArray(n),
    equ(n, e, {arrays: t="shallow", objects: i="reference", strict: r=!0}={}) {
        if (typeof n != typeof e || !!n != !!e)
            return !1;
        if (en.str(n) || en.num(n))
            return n === e;
        const s = en.obj(n);
        if (s && i === "reference")
            return n === e;
        const o = en.arr(n);
        if (o && t === "reference")
            return n === e;
        if ((o || s) && n === e)
            return !0;
        let a;
        for (a in n)
            if (!(a in e))
                return !1;
        for (a in r ? e : n)
            if (n[a] !== e[a])
                return !1;
        if (en.und(a)) {
            if (o && n.length === 0 && e.length === 0 || s && Object.keys(n).length === 0 && Object.keys(e).length === 0)
                return !0;
            if (n !== e)
                return !1
        }
        return !0
    }
};
function XH(n) {
    const e = {
        nodes: {},
        materials: {}
    };
    return n && n.traverse(t=>{
        t.name && (e.nodes[t.name] = t),
        t.material && !e.materials[t.material.name] && (e.materials[t.material.name] = t.material)
    }
    ),
    e
}
function KH(n) {
    n.dispose && n.type !== "Scene" && n.dispose();
    for (const e in n)
        e.dispose == null || e.dispose(),
        delete n[e]
}
function $l(n, e) {
    const t = n;
    return (e != null && e.primitive || !t.__r3f) && (t.__r3f = {
        type: "",
        root: null,
        previousAttach: null,
        memoizedProps: {},
        eventCount: 0,
        handlers: {},
        objects: [],
        parent: null,
        ...e
    }),
    n
}
function H1(n, e) {
    let t = n;
    if (e.includes("-")) {
        const i = e.split("-")
          , r = i.pop();
        return t = i.reduce((s,o)=>s[o], n),
        {
            target: t,
            key: r
        }
    } else
        return {
            target: t,
            key: e
        }
}
const uT = /-\d+$/;
function Rv(n, e, t) {
    if (en.str(t)) {
        if (uT.test(t)) {
            const s = t.replace(uT, "")
              , {target: o, key: a} = H1(n, s);
            Array.isArray(o[a]) || (o[a] = [])
        }
        const {target: i, key: r} = H1(n, t);
        e.__r3f.previousAttach = i[r],
        i[r] = e
    } else
        e.__r3f.previousAttach = t(n, e)
}
function cT(n, e, t) {
    var i, r;
    if (en.str(t)) {
        const {target: s, key: o} = H1(n, t)
          , a = e.__r3f.previousAttach;
        a === void 0 ? delete s[o] : s[o] = a
    } else
        (i = e.__r3f) == null || i.previousAttach == null || i.previousAttach(n, e);
    (r = e.__r3f) == null || delete r.previousAttach
}
function vR(n, {children: e, key: t, ref: i, ...r}, {children: s, key: o, ref: a, ...l}={}, c=!1) {
    var d;
    const h = (d = n == null ? void 0 : n.__r3f) != null ? d : {}
      , p = Object.entries(r)
      , m = [];
    if (c) {
        const v = Object.keys(l);
        for (let _ = 0; _ < v.length; _++)
            r.hasOwnProperty(v[_]) || p.unshift([v[_], gR + "remove"])
    }
    p.forEach(([v,_])=>{
        var x;
        if ((x = n.__r3f) != null && x.primitive && v === "object" || en.equ(_, l[v]))
            return;
        if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(v))
            return m.push([v, _, !0, []]);
        let A = [];
        v.includes("-") && (A = v.split("-")),
        m.push([v, _, !1, A]);
        for (const M in r) {
            const S = r[M];
            M.startsWith(`${v}-`) && m.push([M, S, !1, M.split("-")])
        }
    }
    );
    const y = {
        ...r
    };
    return h.memoizedProps && h.memoizedProps.args && (y.args = h.memoizedProps.args),
    h.memoizedProps && h.memoizedProps.attach && (y.attach = h.memoizedProps.attach),
    {
        memoized: y,
        changes: m
    }
}
function Lv(n, e) {
    var t, i, r;
    const s = (t = n.__r3f) != null ? t : {}
      , o = s.root
      , a = (i = o == null || o.getState == null ? void 0 : o.getState()) != null ? i : {}
      , {memoized: l, changes: c} = JH(e) ? e : vR(n, e)
      , d = s.eventCount;
    n.__r3f && (n.__r3f.memoizedProps = l);
    for (let p = 0; p < c.length; p++) {
        let[m,y,v,_] = c[p]
          , x = n
          , A = x[m];
        if (_.length && (A = _.reduce((M,S)=>M[S], n),
        !(A && A.set))) {
            const [M,...S] = _.reverse();
            x = S.reverse().reduce((T,P)=>T[P], n),
            m = M
        }
        if (y === gR + "remove")
            if (x.constructor) {
                let M = lT.get(x.constructor);
                M || (M = new x.constructor,
                lT.set(x.constructor, M)),
                y = M[m]
            } else
                y = 0;
        if (v)
            y ? s.handlers[m] = y : delete s.handlers[m],
            s.eventCount = Object.keys(s.handlers).length;
        else if (A && A.set && (A.copy || A instanceof $a)) {
            if (Array.isArray(y))
                A.fromArray ? A.fromArray(y) : A.set(...y);
            else if (A.copy && y && y.constructor && A.constructor === y.constructor)
                A.copy(y);
            else if (y !== void 0) {
                const M = A instanceof Le;
                !M && A.setScalar ? A.setScalar(y) : A instanceof $a && y instanceof $a ? A.mask = y.mask : A.set(y),
                !ql && !a.linear && M && A.convertSRGBToLinear()
            }
        } else
            x[m] = y,
            !a.linear && x[m]instanceof qt && x[m].format === Ci && x[m].type === Js && (x[m].encoding = Et);
        eu(n)
    }
    if (s.parent && a.internal && n.raycast && d !== s.eventCount) {
        const p = a.internal.interaction.indexOf(n);
        p > -1 && a.internal.interaction.splice(p, 1),
        s.eventCount && a.internal.interaction.push(n)
    }
    return !(c.length === 1 && c[0][0] === "onUpdate") && c.length && (r = n.__r3f) != null && r.parent && V1(n),
    n
}
function eu(n) {
    var e, t;
    const i = (e = n.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
    i && i.internal.frames === 0 && i.invalidate()
}
function V1(n) {
    n.onUpdate == null || n.onUpdate(n)
}
function YH(n, e) {
    n.manual || (hR(n) ? (n.left = e.width / -2,
    n.right = e.width / 2,
    n.top = e.height / 2,
    n.bottom = e.height / -2) : n.aspect = e.width / e.height,
    n.updateProjectionMatrix(),
    n.updateMatrixWorld())
}
function $p(n) {
    return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId
}
function QH() {
    var n;
    const e = typeof self < "u" && self || typeof window < "u" && window;
    if (!e)
        return Po.DefaultEventPriority;
    switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
        return Po.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
        return Po.ContinuousEventPriority;
    default:
        return Po.DefaultEventPriority
    }
}
function xR(n, e, t, i) {
    const r = t.get(e);
    r && (t.delete(e),
    t.size === 0 && (n.delete(i),
    r.target.releasePointerCapture(i)))
}
function ZH(n, e) {
    const {internal: t} = n.getState();
    t.interaction = t.interaction.filter(i=>i !== e),
    t.initialHits = t.initialHits.filter(i=>i !== e),
    t.hovered.forEach((i,r)=>{
        (i.eventObject === e || i.object === e) && t.hovered.delete(r)
    }
    ),
    t.capturedMap.forEach((i,r)=>{
        xR(t.capturedMap, e, i, r)
    }
    )
}
function qH(n) {
    function e(l) {
        const {internal: c} = n.getState()
          , d = l.offsetX - c.initialClick[0]
          , h = l.offsetY - c.initialClick[1];
        return Math.round(Math.sqrt(d * d + h * h))
    }
    function t(l) {
        return l.filter(c=>["Move", "Over", "Enter", "Out", "Leave"].some(d=>{
            var h;
            return (h = c.__r3f) == null ? void 0 : h.handlers["onPointer" + d]
        }
        ))
    }
    function i(l, c) {
        const d = n.getState()
          , h = new Set
          , p = []
          , m = c ? c(d.internal.interaction) : d.internal.interaction;
        for (let x = 0; x < m.length; x++) {
            const A = Jc(m[x]);
            A && (A.raycaster.camera = void 0)
        }
        d.previousRoot || d.events.compute == null || d.events.compute(l, d);
        function y(x) {
            const A = Jc(x);
            if (!A || !A.events.enabled || A.raycaster.camera === null)
                return [];
            if (A.raycaster.camera === void 0) {
                var M;
                A.events.compute == null || A.events.compute(l, A, (M = A.previousRoot) == null ? void 0 : M.getState()),
                A.raycaster.camera === void 0 && (A.raycaster.camera = null)
            }
            return A.raycaster.camera ? A.raycaster.intersectObject(x, !0) : []
        }
        let v = m.flatMap(y).sort((x,A)=>{
            const M = Jc(x.object)
              , S = Jc(A.object);
            return !M || !S ? x.distance - A.distance : S.events.priority - M.events.priority || x.distance - A.distance
        }
        ).filter(x=>{
            const A = $p(x);
            return h.has(A) ? !1 : (h.add(A),
            !0)
        }
        );
        d.events.filter && (v = d.events.filter(v, d));
        for (const x of v) {
            let A = x.object;
            for (; A; ) {
                var _;
                (_ = A.__r3f) != null && _.eventCount && p.push({
                    ...x,
                    eventObject: A
                }),
                A = A.parent
            }
        }
        if ("pointerId"in l && d.internal.capturedMap.has(l.pointerId))
            for (let x of d.internal.capturedMap.get(l.pointerId).values())
                h.has($p(x.intersection)) || p.push(x.intersection);
        return p
    }
    function r(l, c, d, h) {
        const p = n.getState();
        if (l.length) {
            const m = {
                stopped: !1
            };
            for (const y of l) {
                const v = Jc(y.object) || p
                  , {raycaster: _, pointer: x, camera: A, internal: M} = v
                  , S = new D(x.x,x.y,0).unproject(A)
                  , T = L=>{
                    var z, Z;
                    return (z = (Z = M.capturedMap.get(L)) == null ? void 0 : Z.has(y.eventObject)) != null ? z : !1
                }
                  , P = L=>{
                    const z = {
                        intersection: y,
                        target: c.target
                    };
                    M.capturedMap.has(L) ? M.capturedMap.get(L).set(y.eventObject, z) : M.capturedMap.set(L, new Map([[y.eventObject, z]])),
                    c.target.setPointerCapture(L)
                }
                  , R = L=>{
                    const z = M.capturedMap.get(L);
                    z && xR(M.capturedMap, y.eventObject, z, L)
                }
                ;
                let E = {};
                for (let L in c) {
                    let z = c[L];
                    typeof z != "function" && (E[L] = z)
                }
                let B = {
                    ...y,
                    ...E,
                    pointer: x,
                    intersections: l,
                    stopped: m.stopped,
                    delta: d,
                    unprojectedPoint: S,
                    ray: _.ray,
                    camera: A,
                    stopPropagation() {
                        const L = "pointerId"in c && M.capturedMap.get(c.pointerId);
                        if ((!L || L.has(y.eventObject)) && (B.stopped = m.stopped = !0,
                        M.hovered.size && Array.from(M.hovered.values()).find(z=>z.eventObject === y.eventObject))) {
                            const z = l.slice(0, l.indexOf(y));
                            s([...z, y])
                        }
                    },
                    target: {
                        hasPointerCapture: T,
                        setPointerCapture: P,
                        releasePointerCapture: R
                    },
                    currentTarget: {
                        hasPointerCapture: T,
                        setPointerCapture: P,
                        releasePointerCapture: R
                    },
                    nativeEvent: c
                };
                if (h(B),
                m.stopped === !0)
                    break
            }
        }
        return l
    }
    function s(l) {
        const {internal: c} = n.getState();
        for (const d of c.hovered.values())
            if (!l.length || !l.find(h=>h.object === d.object && h.index === d.index && h.instanceId === d.instanceId)) {
                const p = d.eventObject.__r3f
                  , m = p == null ? void 0 : p.handlers;
                if (c.hovered.delete($p(d)),
                p != null && p.eventCount) {
                    const y = {
                        ...d,
                        intersections: l
                    };
                    m.onPointerOut == null || m.onPointerOut(y),
                    m.onPointerLeave == null || m.onPointerLeave(y)
                }
            }
    }
    function o(l, c) {
        for (let d = 0; d < c.length; d++) {
            const h = c[d].__r3f;
            h == null || h.handlers.onPointerMissed == null || h.handlers.onPointerMissed(l)
        }
    }
    function a(l) {
        switch (l) {
        case "onPointerLeave":
        case "onPointerCancel":
            return ()=>s([]);
        case "onLostPointerCapture":
            return c=>{
                const {internal: d} = n.getState();
                "pointerId"in c && d.capturedMap.has(c.pointerId) && (d.capturedMap.delete(c.pointerId),
                s([]))
            }
        }
        return function(d) {
            const {onPointerMissed: h, internal: p} = n.getState();
            p.lastEvent.current = d;
            const m = l === "onPointerMove"
              , y = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick"
              , _ = i(d, m ? t : void 0)
              , x = y ? e(d) : 0;
            l === "onPointerDown" && (p.initialClick = [d.offsetX, d.offsetY],
            p.initialHits = _.map(M=>M.eventObject)),
            y && !_.length && x <= 2 && (o(d, p.interaction),
            h && h(d)),
            m && s(_);
            function A(M) {
                const S = M.eventObject
                  , T = S.__r3f
                  , P = T == null ? void 0 : T.handlers;
                if (T != null && T.eventCount)
                    if (m) {
                        if (P.onPointerOver || P.onPointerEnter || P.onPointerOut || P.onPointerLeave) {
                            const R = $p(M)
                              , E = p.hovered.get(R);
                            E ? E.stopped && M.stopPropagation() : (p.hovered.set(R, M),
                            P.onPointerOver == null || P.onPointerOver(M),
                            P.onPointerEnter == null || P.onPointerEnter(M))
                        }
                        P.onPointerMove == null || P.onPointerMove(M)
                    } else {
                        const R = P[l];
                        R ? (!y || p.initialHits.includes(S)) && (o(d, p.interaction.filter(E=>!p.initialHits.includes(E))),
                        R(M)) : y && p.initialHits.includes(S) && o(d, p.interaction.filter(E=>!p.initialHits.includes(E)))
                    }
            }
            r(_, d, x, A)
        }
    }
    return {
        handlePointer: a
    }
}
let W1 = {}
  , $H = n=>void (W1 = {
    ...W1,
    ...n
});
function e6(n, e) {
    function t(d, {args: h=[], attach: p, ...m}, y) {
        let v = `${d[0].toUpperCase()}${d.slice(1)}`, _;
        if (d === "primitive") {
            if (m.object === void 0)
                throw new Error("R3F: Primitives without 'object' are invalid!");
            const x = m.object;
            _ = $l(x, {
                type: d,
                root: y,
                attach: p,
                primitive: !0
            })
        } else {
            const x = W1[v];
            if (!x)
                throw new Error(`R3F: ${v} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
            if (!Array.isArray(h))
                throw new Error("R3F: The args prop must be an array!");
            _ = $l(new x(...h), {
                type: d,
                root: y,
                attach: p,
                memoizedProps: {
                    args: h
                }
            })
        }
        return _.__r3f.attach === void 0 && (_ instanceof ct ? _.__r3f.attach = "geometry" : _ instanceof Sn && (_.__r3f.attach = "material")),
        v !== "inject" && Lv(_, m),
        _
    }
    function i(d, h) {
        let p = !1;
        if (h) {
            var m, y;
            (m = h.__r3f) != null && m.attach ? Rv(d, h, h.__r3f.attach) : h.isObject3D && d.isObject3D && (d.add(h),
            p = !0),
            p || (y = d.__r3f) == null || y.objects.push(h),
            h.__r3f || $l(h, {}),
            h.__r3f.parent = d,
            V1(h),
            eu(h)
        }
    }
    function r(d, h, p) {
        let m = !1;
        if (h) {
            var y, v;
            if ((y = h.__r3f) != null && y.attach)
                Rv(d, h, h.__r3f.attach);
            else if (h.isObject3D && d.isObject3D) {
                h.parent = d,
                h.dispatchEvent({
                    type: "added"
                });
                const _ = d.children.filter(A=>A !== h)
                  , x = _.indexOf(p);
                d.children = [..._.slice(0, x), h, ..._.slice(x)],
                m = !0
            }
            m || (v = d.__r3f) == null || v.objects.push(h),
            h.__r3f || $l(h, {}),
            h.__r3f.parent = d,
            V1(h),
            eu(h)
        }
    }
    function s(d, h, p=!1) {
        d && [...d].forEach(m=>o(h, m, p))
    }
    function o(d, h, p) {
        if (h) {
            var m, y, v;
            if (h.__r3f && (h.__r3f.parent = null),
            (m = d.__r3f) != null && m.objects && (d.__r3f.objects = d.__r3f.objects.filter(S=>S !== h)),
            (y = h.__r3f) != null && y.attach)
                cT(d, h, h.__r3f.attach);
            else if (h.isObject3D && d.isObject3D) {
                var _;
                d.remove(h),
                (_ = h.__r3f) != null && _.root && ZH(h.__r3f.root, h)
            }
            const A = (v = h.__r3f) == null ? void 0 : v.primitive
              , M = p === void 0 ? h.dispose !== null && !A : p;
            if (!A) {
                var x;
                s((x = h.__r3f) == null ? void 0 : x.objects, h, M),
                s(h.children, h, M)
            }
            h.__r3f && (delete h.__r3f.root,
            delete h.__r3f.objects,
            delete h.__r3f.handlers,
            delete h.__r3f.memoizedProps,
            A || delete h.__r3f),
            M && h.dispose && h.type !== "Scene" && cd.unstable_scheduleCallback(cd.unstable_IdlePriority, ()=>{
                try {
                    h.dispose()
                } catch {}
            }
            ),
            eu(d)
        }
    }
    function a(d, h, p, m) {
        var y;
        const v = (y = d.__r3f) == null ? void 0 : y.parent;
        if (!v)
            return;
        const _ = t(h, p, d.__r3f.root);
        if (d.children) {
            for (const x of d.children)
                x.__r3f && i(_, x);
            d.children = d.children.filter(x=>!x.__r3f)
        }
        d.__r3f.objects.forEach(x=>i(_, x)),
        d.__r3f.objects = [],
        d.__r3f.autoRemovedBeforeAppend || o(v, d),
        _.parent && (_.__r3f.autoRemovedBeforeAppend = !0),
        i(v, _),
        _.raycast && _.__r3f.eventCount && _.__r3f.root.getState().internal.interaction.push(_),
        [m, m.alternate].forEach(x=>{
            x !== null && (x.stateNode = _,
            x.ref && (typeof x.ref == "function" ? x.ref(_) : x.ref.current = _))
        }
        )
    }
    const l = ()=>console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");
    return {
        reconciler: UH({
            createInstance: t,
            removeChild: o,
            appendChild: i,
            appendInitialChild: i,
            insertBefore: r,
            supportsMutation: !0,
            isPrimaryRenderer: !1,
            supportsPersistence: !1,
            supportsHydration: !1,
            noTimeout: -1,
            appendChildToContainer: (d,h)=>{
                if (!h)
                    return;
                const p = d.getState().scene;
                p.__r3f && (p.__r3f.root = d,
                i(p, h))
            }
            ,
            removeChildFromContainer: (d,h)=>{
                h && o(d.getState().scene, h)
            }
            ,
            insertInContainerBefore: (d,h,p)=>{
                if (!h || !p)
                    return;
                const m = d.getState().scene;
                m.__r3f && r(m, h, p)
            }
            ,
            getRootHostContext: ()=>null,
            getChildHostContext: d=>d,
            finalizeInitialChildren(d) {
                var h;
                const p = (h = d == null ? void 0 : d.__r3f) != null ? h : {};
                return Boolean(p.handlers)
            },
            prepareUpdate(d, h, p, m) {
                if (d.__r3f.primitive && m.object && m.object !== d)
                    return [!0];
                {
                    const {args: y=[], children: v, ..._} = m
                      , {args: x=[], children: A, ...M} = p;
                    if (!Array.isArray(y))
                        throw new Error("R3F: the args prop must be an array!");
                    if (y.some((T,P)=>T !== x[P]))
                        return [!0];
                    const S = vR(d, _, M, !0);
                    return S.changes.length ? [!1, S] : null
                }
            },
            commitUpdate(d, [h,p], m, y, v, _) {
                h ? a(d, m, v, _) : Lv(d, p)
            },
            commitMount(d, h, p, m) {
                var y;
                const v = (y = d.__r3f) != null ? y : {};
                d.raycast && v.handlers && v.eventCount && d.__r3f.root.getState().internal.interaction.push(d)
            },
            getPublicInstance: d=>d,
            prepareForCommit: ()=>null,
            preparePortalMount: d=>$l(d.getState().scene),
            resetAfterCommit: ()=>{}
            ,
            shouldSetTextContent: ()=>!1,
            clearContainer: ()=>!1,
            hideInstance(d) {
                var h;
                const {attach: p, parent: m} = (h = d.__r3f) != null ? h : {};
                p && m && cT(m, d, p),
                d.isObject3D && (d.visible = !1),
                eu(d)
            },
            unhideInstance(d, h) {
                var p;
                const {attach: m, parent: y} = (p = d.__r3f) != null ? p : {};
                m && y && Rv(y, d, m),
                (d.isObject3D && h.visible == null || h.visible) && (d.visible = !0),
                eu(d)
            },
            createTextInstance: l,
            hideTextInstance: l,
            unhideTextInstance: l,
            getCurrentEventPriority: ()=>e ? e() : Po.DefaultEventPriority,
            beforeActiveInstanceBlur: ()=>{}
            ,
            afterActiveInstanceBlur: ()=>{}
            ,
            detachDeletedInstance: ()=>{}
            ,
            now: typeof performance < "u" && en.fun(performance.now) ? performance.now : en.fun(Date.now) ? Date.now : ()=>0,
            scheduleTimeout: en.fun(setTimeout) ? setTimeout : void 0,
            cancelTimeout: en.fun(clearTimeout) ? clearTimeout : void 0
        }),
        applyProps: Lv
    }
}
const _R = n=>!!(n != null && n.render)
  , AR = O.createContext(null)
  , t6 = (n,e)=>{
    const t = uR((a,l)=>{
        const c = new D
          , d = new D
          , h = new D;
        function p(x=l().camera, A=d, M=l().size) {
            const {width: S, height: T, top: P, left: R} = M
              , E = S / T;
            A instanceof D ? h.copy(A) : h.set(...A);
            const B = x.getWorldPosition(c).distanceTo(h);
            if (hR(x))
                return {
                    width: S / x.zoom,
                    height: T / x.zoom,
                    top: P,
                    left: R,
                    factor: 1,
                    distance: B,
                    aspect: E
                };
            {
                const L = x.fov * Math.PI / 180
                  , z = 2 * Math.tan(L / 2) * B
                  , Z = z * (S / T);
                return {
                    width: Z,
                    height: z,
                    top: P,
                    left: R,
                    factor: S / Z,
                    distance: B,
                    aspect: E
                }
            }
        }
        let m;
        const y = x=>a(A=>({
            performance: {
                ...A.performance,
                current: x
            }
        }))
          , v = new pe;
        return {
            set: a,
            get: l,
            gl: null,
            camera: null,
            raycaster: null,
            events: {
                priority: 1,
                enabled: !0,
                connected: !1
            },
            xr: null,
            invalidate: (x=1)=>n(l(), x),
            advance: (x,A)=>e(x, A, l()),
            legacy: !1,
            linear: !1,
            flat: !1,
            scene: $l(new PA),
            controls: null,
            clock: new ZA,
            pointer: v,
            mouse: v,
            frameloop: "always",
            onPointerMissed: void 0,
            performance: {
                current: 1,
                min: .5,
                max: 1,
                debounce: 200,
                regress: ()=>{
                    const x = l();
                    m && clearTimeout(m),
                    x.performance.current !== x.performance.min && y(x.performance.min),
                    m = setTimeout(()=>y(l().performance.max), x.performance.debounce)
                }
            },
            size: {
                width: 0,
                height: 0,
                top: 0,
                left: 0,
                updateStyle: !1
            },
            viewport: {
                initialDpr: 0,
                dpr: 0,
                width: 0,
                height: 0,
                top: 0,
                left: 0,
                aspect: 0,
                distance: 0,
                factor: 0,
                getCurrentViewport: p
            },
            setEvents: x=>a(A=>({
                ...A,
                events: {
                    ...A.events,
                    ...x
                }
            })),
            setSize: (x,A,M,S,T)=>{
                const P = l().camera
                  , R = {
                    width: x,
                    height: A,
                    top: S || 0,
                    left: T || 0,
                    updateStyle: M
                };
                a(E=>({
                    size: R,
                    viewport: {
                        ...E.viewport,
                        ...p(P, d, R)
                    }
                }))
            }
            ,
            setDpr: x=>a(A=>{
                const M = yR(x);
                return {
                    viewport: {
                        ...A.viewport,
                        dpr: M,
                        initialDpr: A.viewport.initialDpr || M
                    }
                }
            }
            ),
            setFrameloop: (x="always")=>{
                const A = l().clock;
                A.stop(),
                A.elapsedTime = 0,
                x !== "never" && (A.start(),
                A.elapsedTime = 0),
                a(()=>({
                    frameloop: x
                }))
            }
            ,
            previousRoot: void 0,
            internal: {
                active: !1,
                priority: 0,
                frames: 0,
                lastEvent: O.createRef(),
                interaction: [],
                hovered: new Map,
                subscribers: [],
                initialClick: [0, 0],
                initialHits: [],
                capturedMap: new Map,
                subscribe: (x,A,M)=>{
                    const S = l().internal;
                    return S.priority = S.priority + (A > 0 ? 1 : 0),
                    S.subscribers.push({
                        ref: x,
                        priority: A,
                        store: M
                    }),
                    S.subscribers = S.subscribers.sort((T,P)=>T.priority - P.priority),
                    ()=>{
                        const T = l().internal;
                        T != null && T.subscribers && (T.priority = T.priority - (A > 0 ? 1 : 0),
                        T.subscribers = T.subscribers.filter(P=>P.ref !== x))
                    }
                }
            }
        }
    }
    )
      , i = t.getState();
    let r = i.size
      , s = i.viewport.dpr
      , o = i.camera;
    return t.subscribe(()=>{
        const {camera: a, size: l, viewport: c, gl: d, set: h} = t.getState();
        if (l !== r || c.dpr !== s) {
            var p;
            r = l,
            s = c.dpr,
            YH(a, l),
            d.setPixelRatio(c.dpr);
            const m = (p = l.updateStyle) != null ? p : typeof HTMLCanvasElement < "u" && d.domElement instanceof HTMLCanvasElement;
            d.setSize(l.width, l.height, m)
        }
        a !== o && (o = a,
        h(m=>({
            viewport: {
                ...m.viewport,
                ...m.viewport.getCurrentViewport(a)
            }
        })))
    }
    ),
    t.subscribe(a=>n(a)),
    t
}
;
let em, n6 = new Set, i6 = new Set, r6 = new Set;
function Iv(n, e) {
    if (n.size)
        for (const {callback: t} of n.values())
            t(e)
}
function Xc(n, e) {
    switch (n) {
    case "before":
        return Iv(n6, e);
    case "after":
        return Iv(i6, e);
    case "tail":
        return Iv(r6, e)
    }
}
let Dv, Fv;
function kv(n, e, t) {
    let i = e.clock.getDelta();
    for (e.frameloop === "never" && typeof n == "number" && (i = n - e.clock.elapsedTime,
    e.clock.oldTime = e.clock.elapsedTime,
    e.clock.elapsedTime = n),
    Dv = e.internal.subscribers,
    em = 0; em < Dv.length; em++)
        Fv = Dv[em],
        Fv.ref.current(Fv.store.getState(), i, t);
    return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    e.internal.frames = Math.max(0, e.internal.frames - 1),
    e.frameloop === "always" ? 1 : e.internal.frames
}
function s6(n) {
    let e = !1, t, i, r;
    function s(l) {
        i = requestAnimationFrame(s),
        e = !0,
        t = 0,
        Xc("before", l);
        for (const d of n.values()) {
            var c;
            r = d.store.getState(),
            r.internal.active && (r.frameloop === "always" || r.internal.frames > 0) && !((c = r.gl.xr) != null && c.isPresenting) && (t += kv(l, r))
        }
        if (Xc("after", l),
        t === 0)
            return Xc("tail", l),
            e = !1,
            cancelAnimationFrame(i)
    }
    function o(l, c=1) {
        var d;
        if (!l)
            return n.forEach(h=>o(h.store.getState()), c);
        (d = l.gl.xr) != null && d.isPresenting || !l.internal.active || l.frameloop === "never" || (l.internal.frames = Math.min(60, l.internal.frames + c),
        e || (e = !0,
        requestAnimationFrame(s)))
    }
    function a(l, c=!0, d, h) {
        if (c && Xc("before", l),
        d)
            kv(l, d, h);
        else
            for (const p of n.values())
                kv(l, p.store.getState());
        c && Xc("after", l)
    }
    return {
        loop: s,
        invalidate: o,
        advance: a
    }
}
function MR() {
    const n = O.useContext(AR);
    if (!n)
        throw new Error("R3F: Hooks can only be used within the Canvas component!");
    return n
}
function fr(n=t=>t, e) {
    return MR()(n, e)
}
function Jd(n, e=0) {
    const t = MR()
      , i = t.getState().internal.subscribe
      , r = pR(n);
    return jd(()=>i(r, e, t), [e, i, t]),
    null
}
function wR(n, e) {
    return function(t, ...i) {
        const r = new t;
        return n && n(r),
        Promise.all(i.map(s=>new Promise((o,a)=>r.load(s, l=>{
            l.scene && Object.assign(l, XH(l.scene)),
            o(l)
        }
        , e, l=>a(new Error(`Could not load ${s}: ${l.message})`))))))
    }
}
function Xd(n, e, t, i) {
    const r = Array.isArray(e) ? e : [e]
      , s = zH(wR(t, i), [n, ...r], {
        equal: en.equ
    });
    return Array.isArray(e) ? s : s[0]
}
Xd.preload = function(n, e, t) {
    const i = Array.isArray(e) ? e : [e];
    return GH(wR(t), [n, ...i])
}
;
Xd.clear = function(n, e) {
    const t = Array.isArray(e) ? e : [e];
    return HH([n, ...t])
}
;
const ju = new Map
  , {invalidate: fT, advance: dT} = s6(ju)
  , {reconciler: fg, applyProps: tm} = e6(ju, QH)
  , Kc = {
    objects: "shallow",
    strict: !1
}
  , o6 = (n,e)=>{
    const t = typeof n == "function" ? n(e) : n;
    return _R(t) ? t : new bA({
        powerPreference: "high-performance",
        canvas: e,
        antialias: !0,
        alpha: !0,
        ...n
    })
}
;
function a6(n, e) {
    if (e)
        return e;
    if (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement && n.parentElement) {
        const {width: t, height: i, top: r, left: s} = n.parentElement.getBoundingClientRect();
        return {
            width: t,
            height: i,
            top: r,
            left: s
        }
    } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas)
        return {
            width: n.width,
            height: n.height,
            top: 0,
            left: 0
        };
    return {
        width: 0,
        height: 0,
        top: 0,
        left: 0
    }
}
function l6(n) {
    const e = ju.get(n)
      , t = e == null ? void 0 : e.fiber
      , i = e == null ? void 0 : e.store;
    e && console.warn("R3F.createRoot should only be called once!");
    const r = typeof reportError == "function" ? reportError : console.error
      , s = i || t6(fT, dT)
      , o = t || fg.createContainer(s, Po.ConcurrentRoot, null, !1, null, "", r, null);
    e || ju.set(n, {
        fiber: o,
        store: s
    });
    let a, l = !1;
    return {
        configure(c={}) {
            let {gl: d, size: h, events: p, onCreated: m, shadows: y=!1, linear: v=!1, flat: _=!1, legacy: x=!1, orthographic: A=!1, frameloop: M="always", dpr: S=[1, 2], performance: T, raycaster: P, camera: R, onPointerMissed: E} = c
              , B = s.getState()
              , L = B.gl;
            B.gl || B.set({
                gl: L = o6(d, n)
            });
            let z = B.raycaster;
            z || B.set({
                raycaster: z = new aR
            });
            const {params: Z, ...J} = P || {};
            if (en.equ(J, z, Kc) || tm(z, {
                ...J
            }),
            en.equ(Z, z.params, Kc) || tm(z, {
                params: {
                    ...z.params,
                    ...Z
                }
            }),
            !B.camera) {
                const F = R instanceof bd
                  , V = F ? R : A ? new Nr(0,0,0,0,.1,1e3) : new Ht(75,0,.1,1e3);
                F || (V.position.z = 5,
                R && tm(V, R),
                R != null && R.rotation || V.lookAt(0, 0, 0)),
                B.set({
                    camera: V
                })
            }
            if (!B.xr) {
                const F = (re,H)=>{
                    const se = s.getState();
                    se.frameloop !== "never" && dT(re, !0, se, H)
                }
                  , V = ()=>{
                    const re = s.getState();
                    re.gl.xr.enabled = re.gl.xr.isPresenting,
                    re.gl.xr.setAnimationLoop(re.gl.xr.isPresenting ? F : null),
                    re.gl.xr.isPresenting || fT(re)
                }
                  , j = {
                    connect() {
                        const re = s.getState().gl;
                        re.xr.addEventListener("sessionstart", V),
                        re.xr.addEventListener("sessionend", V)
                    },
                    disconnect() {
                        const re = s.getState().gl;
                        re.xr.removeEventListener("sessionstart", V),
                        re.xr.removeEventListener("sessionend", V)
                    }
                };
                L.xr && j.connect(),
                B.set({
                    xr: j
                })
            }
            if (L.shadowMap) {
                const F = L.shadowMap.enabled
                  , V = L.shadowMap.type;
                if (L.shadowMap.enabled = !!y,
                en.boo(y))
                    L.shadowMap.type = Af;
                else if (en.str(y)) {
                    var G;
                    const j = {
                        basic: m3,
                        percentage: Jg,
                        soft: Af,
                        variance: Ua
                    };
                    L.shadowMap.type = (G = j[y]) != null ? G : Af
                } else
                    en.obj(y) && Object.assign(L.shadowMap, y);
                (F !== L.shadowMap.enabled || V !== L.shadowMap.type) && (L.shadowMap.needsUpdate = !0)
            }
            ql && ("enabled"in ql ? ql.enabled = !x : "legacyMode"in ql && (ql.legacyMode = x));
            const X = v ? Xs : Et
              , ee = _ ? kr : pA;
            L.outputEncoding !== X && (L.outputEncoding = X),
            L.toneMapping !== ee && (L.toneMapping = ee),
            B.legacy !== x && B.set(()=>({
                legacy: x
            })),
            B.linear !== v && B.set(()=>({
                linear: v
            })),
            B.flat !== _ && B.set(()=>({
                flat: _
            })),
            d && !en.fun(d) && !_R(d) && !en.equ(d, L, Kc) && tm(L, d),
            p && !B.events.handlers && B.set({
                events: p(s)
            });
            const ie = a6(n, h);
            return en.equ(ie, B.size, Kc) || B.setSize(ie.width, ie.height, ie.updateStyle, ie.top, ie.left),
            S && B.viewport.dpr !== yR(S) && B.setDpr(S),
            B.frameloop !== M && B.setFrameloop(M),
            B.onPointerMissed || B.set({
                onPointerMissed: E
            }),
            T && !en.equ(T, B.performance, Kc) && B.set(F=>({
                performance: {
                    ...F.performance,
                    ...T
                }
            })),
            a = m,
            l = !0,
            this
        },
        render(c) {
            return l || this.configure(),
            fg.updateContainer(O.createElement(u6, {
                store: s,
                children: c,
                onCreated: a,
                rootElement: n
            }), o, null, ()=>{}
            ),
            s
        },
        unmount() {
            SR(n)
        }
    }
}
function u6({store: n, children: e, onCreated: t, rootElement: i}) {
    return jd(()=>{
        const r = n.getState();
        r.set(s=>({
            internal: {
                ...s.internal,
                active: !0
            }
        })),
        t && t(r),
        n.getState().events.connected || r.events.connect == null || r.events.connect(i)
    }
    , []),
    O.createElement(AR.Provider, {
        value: n
    }, e)
}
function SR(n, e) {
    const t = ju.get(n)
      , i = t == null ? void 0 : t.fiber;
    if (i) {
        const r = t == null ? void 0 : t.store.getState();
        r && (r.internal.active = !1),
        fg.updateContainer(null, i, null, ()=>{
            r && setTimeout(()=>{
                try {
                    var s, o, a, l;
                    r.events.disconnect == null || r.events.disconnect(),
                    (s = r.gl) == null || (o = s.renderLists) == null || o.dispose == null || o.dispose(),
                    (a = r.gl) == null || a.forceContextLoss == null || a.forceContextLoss(),
                    (l = r.gl) != null && l.xr && r.xr.disconnect(),
                    KH(r),
                    ju.delete(n),
                    e && e(n)
                } catch {}
            }
            , 500)
        }
        )
    }
}
fg.injectIntoDevTools({
    bundleType: 0,
    rendererPackageName: "@react-three/fiber",
    version: O.version
});
function zr() {
    return zr = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }
    ,
    zr.apply(this, arguments)
}
function j1(n, e, t) {
    var i, r, s, o, a;
    e == null && (e = 100);
    function l() {
        var d = Date.now() - o;
        d < e && d >= 0 ? i = setTimeout(l, e - d) : (i = null,
        t || (a = n.apply(s, r),
        s = r = null))
    }
    var c = function() {
        s = this,
        r = arguments,
        o = Date.now();
        var d = t && !i;
        return i || (i = setTimeout(l, e)),
        d && (a = n.apply(s, r),
        s = r = null),
        a
    };
    return c.clear = function() {
        i && (clearTimeout(i),
        i = null)
    }
    ,
    c.flush = function() {
        i && (a = n.apply(s, r),
        s = r = null,
        clearTimeout(i),
        i = null)
    }
    ,
    c
}
j1.debounce = j1;
var hT = j1;
function c6(n) {
    let {debounce: e, scroll: t, polyfill: i, offsetSize: r} = n === void 0 ? {
        debounce: 0,
        scroll: !1,
        offsetSize: !1
    } : n;
    const s = i || (typeof window > "u" ? class {
    }
    : window.ResizeObserver);
    if (!s)
        throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
    const [o,a] = O.useState({
        left: 0,
        top: 0,
        width: 0,
        height: 0,
        bottom: 0,
        right: 0,
        x: 0,
        y: 0
    })
      , l = O.useRef({
        element: null,
        scrollContainers: null,
        resizeObserver: null,
        lastBounds: o
    })
      , c = e ? typeof e == "number" ? e : e.scroll : null
      , d = e ? typeof e == "number" ? e : e.resize : null
      , h = O.useRef(!1);
    O.useEffect(()=>(h.current = !0,
    ()=>void (h.current = !1)));
    const [p,m,y] = O.useMemo(()=>{
        const A = ()=>{
            if (!l.current.element)
                return;
            const {left: M, top: S, width: T, height: P, bottom: R, right: E, x: B, y: L} = l.current.element.getBoundingClientRect()
              , z = {
                left: M,
                top: S,
                width: T,
                height: P,
                bottom: R,
                right: E,
                x: B,
                y: L
            };
            l.current.element instanceof HTMLElement && r && (z.height = l.current.element.offsetHeight,
            z.width = l.current.element.offsetWidth),
            Object.freeze(z),
            h.current && !p6(l.current.lastBounds, z) && a(l.current.lastBounds = z)
        }
        ;
        return [A, d ? hT(A, d) : A, c ? hT(A, c) : A]
    }
    , [a, r, c, d]);
    function v() {
        l.current.scrollContainers && (l.current.scrollContainers.forEach(A=>A.removeEventListener("scroll", y, !0)),
        l.current.scrollContainers = null),
        l.current.resizeObserver && (l.current.resizeObserver.disconnect(),
        l.current.resizeObserver = null)
    }
    function _() {
        l.current.element && (l.current.resizeObserver = new s(y),
        l.current.resizeObserver.observe(l.current.element),
        t && l.current.scrollContainers && l.current.scrollContainers.forEach(A=>A.addEventListener("scroll", y, {
            capture: !0,
            passive: !0
        })))
    }
    const x = A=>{
        !A || A === l.current.element || (v(),
        l.current.element = A,
        l.current.scrollContainers = CR(A),
        _())
    }
    ;
    return d6(y, Boolean(t)),
    f6(m),
    O.useEffect(()=>{
        v(),
        _()
    }
    , [t, y, m]),
    O.useEffect(()=>v, []),
    [x, o, p]
}
function f6(n) {
    O.useEffect(()=>{
        const e = n;
        return window.addEventListener("resize", e),
        ()=>void window.removeEventListener("resize", e)
    }
    , [n])
}
function d6(n, e) {
    O.useEffect(()=>{
        if (e) {
            const t = n;
            return window.addEventListener("scroll", t, {
                capture: !0,
                passive: !0
            }),
            ()=>void window.removeEventListener("scroll", t, !0)
        }
    }
    , [n, e])
}
function CR(n) {
    const e = [];
    if (!n || n === document.body)
        return e;
    const {overflow: t, overflowX: i, overflowY: r} = window.getComputedStyle(n);
    return [t, i, r].some(s=>s === "auto" || s === "scroll") && e.push(n),
    [...e, ...CR(n.parentElement)]
}
const h6 = ["x", "y", "top", "bottom", "left", "right", "width", "height"]
  , p6 = (n,e)=>h6.every(t=>n[t] === e[t]);
var m6 = Object.defineProperty
  , g6 = Object.defineProperties
  , y6 = Object.getOwnPropertyDescriptors
  , pT = Object.getOwnPropertySymbols
  , v6 = Object.prototype.hasOwnProperty
  , x6 = Object.prototype.propertyIsEnumerable
  , mT = (n,e,t)=>e in n ? m6(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , gT = (n,e)=>{
    for (var t in e || (e = {}))
        v6.call(e, t) && mT(n, t, e[t]);
    if (pT)
        for (var t of pT(e))
            x6.call(e, t) && mT(n, t, e[t]);
    return n
}
  , _6 = (n,e)=>g6(n, y6(e));
function ER(n, e, t) {
    if (!n)
        return;
    if (t(n) === !0)
        return n;
    let i = e ? n.return : n.child;
    for (; i; ) {
        const r = ER(i, e, t);
        if (r)
            return r;
        i = e ? null : i.sibling
    }
}
function TR(n) {
    try {
        return Object.defineProperties(n, {
            _currentRenderer: {
                get() {
                    return null
                },
                set() {}
            },
            _currentRenderer2: {
                get() {
                    return null
                },
                set() {}
            }
        })
    } catch {
        return n
    }
}
const tM = TR(O.createContext(null));
class bR extends O.Component {
    render() {
        return O.createElement(tM.Provider, {
            value: this._reactInternals
        }, this.props.children)
    }
}
const {ReactCurrentOwner: A6, ReactCurrentDispatcher: M6} = O.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
function w6() {
    const n = O.useContext(tM);
    if (!n)
        throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
    const e = O.useId();
    return O.useMemo(()=>{
        var i;
        return (i = A6.current) != null ? i : ER(n, !1, r=>{
            let s = r.memoizedState;
            for (; s; ) {
                if (s.memoizedState === e)
                    return !0;
                s = s.next
            }
        }
        )
    }
    , [n, e])
}
function S6() {
    var n, e;
    const t = w6()
      , [i] = O.useState(()=>new Map);
    i.clear();
    let r = t;
    for (; r; ) {
        const s = (n = r.type) == null ? void 0 : n._context;
        s && s !== tM && !i.has(s) && i.set(s, (e = M6.current) == null ? void 0 : e.readContext(TR(s))),
        r = r.return
    }
    return O.useMemo(()=>Array.from(i.keys()).reduce((s,o)=>a=>O.createElement(s, null, O.createElement(o.Provider, _6(gT({}, a), {
        value: i.get(o)
    }))), s=>O.createElement(bR, gT({}, s))), [i])
}
const Nv = {
    onClick: ["click", !1],
    onContextMenu: ["contextmenu", !1],
    onDoubleClick: ["dblclick", !1],
    onWheel: ["wheel", !0],
    onPointerDown: ["pointerdown", !0],
    onPointerUp: ["pointerup", !0],
    onPointerLeave: ["pointerleave", !0],
    onPointerMove: ["pointermove", !0],
    onPointerCancel: ["pointercancel", !0],
    onLostPointerCapture: ["lostpointercapture", !0]
};
function C6(n) {
    const {handlePointer: e} = qH(n);
    return {
        priority: 1,
        enabled: !0,
        compute(t, i, r) {
            i.pointer.set(t.offsetX / i.size.width * 2 - 1, -(t.offsetY / i.size.height) * 2 + 1),
            i.raycaster.setFromCamera(i.pointer, i.camera)
        },
        connected: void 0,
        handlers: Object.keys(Nv).reduce((t,i)=>({
            ...t,
            [i]: e(i)
        }), {}),
        update: ()=>{
            var t;
            const {events: i, internal: r} = n.getState();
            (t = r.lastEvent) != null && t.current && i.handlers && i.handlers.onPointerMove(r.lastEvent.current)
        }
        ,
        connect: t=>{
            var i;
            const {set: r, events: s} = n.getState();
            s.disconnect == null || s.disconnect(),
            r(o=>({
                events: {
                    ...o.events,
                    connected: t
                }
            })),
            Object.entries((i = s.handlers) != null ? i : []).forEach(([o,a])=>{
                const [l,c] = Nv[o];
                t.addEventListener(l, a, {
                    passive: c
                })
            }
            )
        }
        ,
        disconnect: ()=>{
            const {set: t, events: i} = n.getState();
            if (i.connected) {
                var r;
                Object.entries((r = i.handlers) != null ? r : []).forEach(([s,o])=>{
                    if (i && i.connected instanceof HTMLElement) {
                        const [a] = Nv[s];
                        i.connected.removeEventListener(a, o)
                    }
                }
                ),
                t(s=>({
                    events: {
                        ...s.events,
                        connected: void 0
                    }
                }))
            }
        }
    }
}
const E6 = O.forwardRef(function({children: e, fallback: t, resize: i, style: r, gl: s, events: o=C6, eventSource: a, eventPrefix: l, shadows: c, linear: d, flat: h, legacy: p, orthographic: m, frameloop: y, dpr: v, performance: _, raycaster: x, camera: A, onPointerMissed: M, onCreated: S, ...T}, P) {
    O.useMemo(()=>$H(z1), []);
    const R = S6()
      , [E,B] = c6({
        scroll: !0,
        debounce: {
            scroll: 50,
            resize: 0
        },
        ...i
    })
      , L = O.useRef(null)
      , z = O.useRef(null)
      , [Z,J] = O.useState(null);
    O.useImperativeHandle(P, ()=>L.current);
    const G = pR(M)
      , [X,ee] = O.useState(!1)
      , [ie,F] = O.useState(!1);
    if (X)
        throw X;
    if (ie)
        throw ie;
    const V = O.useRef(null);
    B.width > 0 && B.height > 0 && Z && (V.current || (V.current = l6(Z)),
    V.current.configure({
        gl: s,
        events: o,
        shadows: c,
        linear: d,
        flat: h,
        legacy: p,
        orthographic: m,
        frameloop: y,
        dpr: v,
        performance: _,
        raycaster: x,
        camera: A,
        size: B,
        onPointerMissed: (...re)=>G.current == null ? void 0 : G.current(...re),
        onCreated: re=>{
            re.events.connect == null || re.events.connect(a ? WH(a) ? a.current : a : z.current),
            l && re.setEvents({
                compute: (H,se)=>{
                    const ye = H[l + "X"]
                      , ve = H[l + "Y"];
                    se.pointer.set(ye / se.size.width * 2 - 1, -(ve / se.size.height) * 2 + 1),
                    se.raycaster.setFromCamera(se.pointer, se.camera)
                }
            }),
            S == null || S(re)
        }
    }),
    V.current.render(O.createElement(R, null, O.createElement(mR, {
        set: F
    }, O.createElement(O.Suspense, {
        fallback: O.createElement(jH, {
            set: ee
        })
    }, e))))),
    jd(()=>{
        J(L.current)
    }
    , []),
    O.useEffect(()=>{
        if (Z)
            return ()=>SR(Z)
    }
    , [Z]);
    const j = a ? "none" : "auto";
    return O.createElement("div", zr({
        ref: z,
        style: {
            position: "relative",
            width: "100%",
            height: "100%",
            overflow: "hidden",
            pointerEvents: j,
            ...r
        }
    }, T), O.createElement("div", {
        ref: E,
        style: {
            width: "100%",
            height: "100%"
        }
    }, O.createElement("canvas", {
        ref: L,
        style: {
            display: "block"
        }
    }, t)))
})
  , PR = O.forwardRef(function(e, t) {
    return O.createElement(bR, null, O.createElement(E6, zr({}, e, {
        ref: t
    })))
})
  , Kd = new D
  , nM = new D
  , T6 = new D;
function b6(n, e, t) {
    const i = Kd.setFromMatrixPosition(n.matrixWorld);
    i.project(e);
    const r = t.width / 2
      , s = t.height / 2;
    return [i.x * r + r, -(i.y * s) + s]
}
function P6(n, e) {
    const t = Kd.setFromMatrixPosition(n.matrixWorld)
      , i = nM.setFromMatrixPosition(e.matrixWorld)
      , r = t.sub(i)
      , s = e.getWorldDirection(T6);
    return r.angleTo(s) > Math.PI / 2
}
function B6(n, e, t, i) {
    const r = Kd.setFromMatrixPosition(n.matrixWorld)
      , s = r.clone();
    s.project(e),
    t.setFromCamera(s, e);
    const o = t.intersectObjects(i, !0);
    if (o.length) {
        const a = o[0].distance;
        return r.distanceTo(t.ray.origin) < a
    }
    return !0
}
function R6(n, e) {
    if (e instanceof Nr)
        return e.zoom;
    if (e instanceof Ht) {
        const t = Kd.setFromMatrixPosition(n.matrixWorld)
          , i = nM.setFromMatrixPosition(e.matrixWorld)
          , r = e.fov * Math.PI / 180
          , s = t.distanceTo(i);
        return 1 / (2 * Math.tan(r / 2) * s)
    } else
        return 1
}
function L6(n, e, t) {
    if (e instanceof Ht || e instanceof Nr) {
        const i = Kd.setFromMatrixPosition(n.matrixWorld)
          , r = nM.setFromMatrixPosition(e.matrixWorld)
          , s = i.distanceTo(r)
          , o = (t[1] - t[0]) / (e.far - e.near)
          , a = t[1] - o * e.far;
        return Math.round(o * s + a)
    }
}
const J1 = n=>Math.abs(n) < 1e-10 ? 0 : n;
function BR(n, e, t="") {
    let i = "matrix3d(";
    for (let r = 0; r !== 16; r++)
        i += J1(e[r] * n.elements[r]) + (r !== 15 ? "," : ")");
    return t + i
}
const I6 = (n=>e=>BR(e, n))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1])
  , D6 = (n=>(e,t)=>BR(e, n(t), "translate(-50%,-50%)"))(n=>[1 / n, 1 / n, 1 / n, 1, -1 / n, -1 / n, -1 / n, -1, 1 / n, 1 / n, 1 / n, 1, 1, 1, 1, 1]);
function F6(n) {
    return n && typeof n == "object" && "current"in n
}
const k6 = O.forwardRef(({children: n, eps: e=.001, style: t, className: i, prepend: r, center: s, fullscreen: o, portal: a, distanceFactor: l, sprite: c=!1, transform: d=!1, occlude: h, onOcclude: p, castShadow: m, receiveShadow: y, material: v, geometry: _, zIndexRange: x=[16777271, 0], calculatePosition: A=b6, as: M="div", wrapperClass: S, pointerEvents: T="auto", ...P},R)=>{
    const {gl: E, camera: B, scene: L, size: z, raycaster: Z, events: J, viewport: G} = fr()
      , [X] = O.useState(()=>document.createElement(M))
      , ee = O.useRef()
      , ie = O.useRef(null)
      , F = O.useRef(0)
      , V = O.useRef([0, 0])
      , j = O.useRef(null)
      , re = O.useRef(null)
      , H = (a == null ? void 0 : a.current) || J.connected || E.domElement.parentNode
      , se = O.useRef(null)
      , ye = O.useRef(!1)
      , ve = O.useMemo(()=>h && h !== "blending" || Array.isArray(h) && h.length && F6(h[0]), [h]);
    O.useLayoutEffect(()=>{
        const Me = E.domElement;
        h && h === "blending" ? (Me.style.zIndex = `${Math.floor(x[0] / 2)}`,
        Me.style.position = "absolute",
        Me.style.pointerEvents = "none") : (Me.style.zIndex = null,
        Me.style.position = null,
        Me.style.pointerEvents = null)
    }
    , [h]),
    O.useLayoutEffect(()=>{
        if (ie.current) {
            const Me = ee.current = YP(X);
            if (L.updateMatrixWorld(),
            d)
                X.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
            else {
                const De = A(ie.current, B, z);
                X.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${De[0]}px,${De[1]}px,0);transform-origin:0 0;`
            }
            return H && (r ? H.prepend(X) : H.appendChild(X)),
            ()=>{
                H && H.removeChild(X),
                Me.unmount()
            }
        }
    }
    , [H, d]),
    O.useLayoutEffect(()=>{
        S && (X.className = S)
    }
    , [S]);
    const q = O.useMemo(()=>d ? {
        position: "absolute",
        top: 0,
        left: 0,
        width: z.width,
        height: z.height,
        transformStyle: "preserve-3d",
        pointerEvents: "none"
    } : {
        position: "absolute",
        transform: s ? "translate3d(-50%,-50%,0)" : "none",
        ...o && {
            top: -z.height / 2,
            left: -z.width / 2,
            width: z.width,
            height: z.height
        },
        ...t
    }, [t, s, o, z, d])
      , Ie = O.useMemo(()=>({
        position: "absolute",
        pointerEvents: T
    }), [T]);
    O.useLayoutEffect(()=>{
        if (ye.current = !1,
        d) {
            var Me;
            (Me = ee.current) == null || Me.render(O.createElement("div", {
                ref: j,
                style: q
            }, O.createElement("div", {
                ref: re,
                style: Ie
            }, O.createElement("div", {
                ref: R,
                className: i,
                style: t,
                children: n
            }))))
        } else {
            var De;
            (De = ee.current) == null || De.render(O.createElement("div", {
                ref: R,
                style: q,
                className: i,
                children: n
            }))
        }
    }
    );
    const Ne = O.useRef(!0);
    Jd(Me=>{
        if (ie.current) {
            B.updateMatrixWorld(),
            ie.current.updateWorldMatrix(!0, !1);
            const De = d ? V.current : A(ie.current, B, z);
            if (d || Math.abs(F.current - B.zoom) > e || Math.abs(V.current[0] - De[0]) > e || Math.abs(V.current[1] - De[1]) > e) {
                const de = P6(ie.current, B);
                let ae = !1;
                ve && (h !== "blending" ? ae = [L] : Array.isArray(h) && (ae = h.map(Ze=>Ze.current)));
                const Ce = Ne.current;
                if (ae) {
                    const Ze = B6(ie.current, B, Z, ae);
                    Ne.current = Ze && !de
                } else
                    Ne.current = !de;
                Ce !== Ne.current && (p ? p(!Ne.current) : X.style.display = Ne.current ? "block" : "none");
                const ze = Math.floor(x[0] / 2)
                  , Be = h ? ve ? [x[0], ze] : [ze - 1, 0] : x;
                if (X.style.zIndex = `${L6(ie.current, B, Be)}`,
                d) {
                    const [Ze,Je] = [z.width / 2, z.height / 2]
                      , We = B.projectionMatrix.elements[5] * Je
                      , {isOrthographicCamera: xt, top: St, left: U, bottom: I, right: oe} = B
                      , we = I6(B.matrixWorldInverse)
                      , Ee = xt ? `scale(${We})translate(${J1(-(oe + U) / 2)}px,${J1((St + I) / 2)}px)` : `translateZ(${We}px)`;
                    let Pe = ie.current.matrixWorld;
                    c && (Pe = B.matrixWorldInverse.clone().transpose().copyPosition(Pe).scale(ie.current.scale),
                    Pe.elements[3] = Pe.elements[7] = Pe.elements[11] = 0,
                    Pe.elements[15] = 1),
                    X.style.width = z.width + "px",
                    X.style.height = z.height + "px",
                    X.style.perspective = xt ? "" : `${We}px`,
                    j.current && re.current && (j.current.style.transform = `${Ee}${we}translate(${Ze}px,${Je}px)`,
                    re.current.style.transform = D6(Pe, 1 / ((l || 10) / 400)))
                } else {
                    const Ze = l === void 0 ? 1 : R6(ie.current, B) * l;
                    X.style.transform = `translate3d(${De[0]}px,${De[1]}px,0) scale(${Ze})`
                }
                V.current = De,
                F.current = B.zoom
            }
        }
        if (!ve && se.current && !ye.current)
            if (d) {
                if (j.current) {
                    const De = j.current.children[0];
                    if (De != null && De.clientWidth && De != null && De.clientHeight) {
                        const {isOrthographicCamera: de} = B;
                        if (de || _)
                            P.scale && (Array.isArray(P.scale) ? P.scale instanceof D ? se.current.scale.copy(P.scale.clone().divideScalar(1)) : se.current.scale.set(1 / P.scale[0], 1 / P.scale[1], 1 / P.scale[2]) : se.current.scale.setScalar(1 / P.scale));
                        else {
                            const ae = (l || 10) / 400
                              , Ce = De.clientWidth * ae
                              , ze = De.clientHeight * ae;
                            se.current.scale.set(Ce, ze, 1)
                        }
                        ye.current = !0
                    }
                }
            } else {
                const De = X.children[0];
                if (De != null && De.clientWidth && De != null && De.clientHeight) {
                    const de = 1 / G.factor
                      , ae = De.clientWidth * de
                      , Ce = De.clientHeight * de;
                    se.current.scale.set(ae, Ce, 1),
                    ye.current = !0
                }
                se.current.lookAt(Me.camera.position)
            }
    }
    );
    const He = O.useMemo(()=>({
        vertexShader: d ? void 0 : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,
        fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `
    }), [d]);
    return O.createElement("group", zr({}, P, {
        ref: ie
    }), h && !ve && O.createElement("mesh", {
        castShadow: m,
        receiveShadow: y,
        ref: se
    }, _ || O.createElement("planeGeometry", null), v || O.createElement("shaderMaterial", {
        side: Ir,
        vertexShader: He.vertexShader,
        fragmentShader: He.fragmentShader
    })))
}
);
let Yc = 0;
const N6 = uR(n=>(gu.onStart = (e,t,i)=>{
    n({
        active: !0,
        item: e,
        loaded: t,
        total: i,
        progress: (t - Yc) / (i - Yc) * 100
    })
}
,
gu.onLoad = ()=>{
    n({
        active: !1
    })
}
,
gu.onError = e=>n(t=>({
    errors: [...t.errors, e]
})),
gu.onProgress = (e,t,i)=>{
    t === i && (Yc = i),
    n({
        active: !0,
        item: e,
        loaded: t,
        total: i,
        progress: (t - Yc) / (i - Yc) * 100 || 100
    })
}
,
{
    errors: [],
    active: !1,
    progress: 0,
    item: "",
    loaded: 0,
    total: 0
}));
function RR(n) {
    return function(e) {
        n.forEach(function(t) {
            typeof t == "function" ? t(e) : t != null && (t.current = e)
        })
    }
}
function bu(n, e, t) {
    return e in n ? Object.defineProperty(n, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : n[e] = t,
    n
}
function yT(n, e) {
    var t = Object.keys(n);
    if (Object.getOwnPropertySymbols) {
        var i = Object.getOwnPropertySymbols(n);
        e && (i = i.filter(function(r) {
            return Object.getOwnPropertyDescriptor(n, r).enumerable
        })),
        t.push.apply(t, i)
    }
    return t
}
function vT(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? yT(Object(t), !0).forEach(function(i) {
            bu(n, i, t[i])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : yT(Object(t)).forEach(function(i) {
            Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i))
        })
    }
    return n
}
new pe;
new pe;
function LR(n, e) {
    if (!(n instanceof e))
        throw new TypeError("Cannot call a class as a function")
}
var lr = function n(e, t, i) {
    var r = this;
    LR(this, n),
    bu(this, "dot2", function(s, o) {
        return r.x * s + r.y * o
    }),
    bu(this, "dot3", function(s, o, a) {
        return r.x * s + r.y * o + r.z * a
    }),
    this.x = e,
    this.y = t,
    this.z = i
}
  , O6 = [new lr(1,1,0), new lr(-1,1,0), new lr(1,-1,0), new lr(-1,-1,0), new lr(1,0,1), new lr(-1,0,1), new lr(1,0,-1), new lr(-1,0,-1), new lr(0,1,1), new lr(0,-1,1), new lr(0,1,-1), new lr(0,-1,-1)]
  , xT = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180]
  , _T = new Array(512)
  , AT = new Array(512)
  , U6 = function(e) {
    e > 0 && e < 1 && (e *= 65536),
    e = Math.floor(e),
    e < 256 && (e |= e << 8);
    for (var t = 0; t < 256; t++) {
        var i;
        t & 1 ? i = xT[t] ^ e & 255 : i = xT[t] ^ e >> 8 & 255,
        _T[t] = _T[t + 256] = i,
        AT[t] = AT[t + 256] = O6[i % 12]
    }
};
U6(0);
function z6(n) {
    if (typeof n == "number")
        n = Math.abs(n);
    else if (typeof n == "string") {
        var e = n;
        n = 0;
        for (var t = 0; t < e.length; t++)
            n = (n + (t + 1) * (e.charCodeAt(t) % 96)) % 2147483647
    }
    return n === 0 && (n = 311),
    n
}
function MT(n) {
    var e = z6(n);
    return function() {
        var t = e * 48271 % 2147483647;
        return e = t,
        t / 2147483647
    }
}
var G6 = function n(e) {
    var t = this;
    LR(this, n),
    bu(this, "seed", 0),
    bu(this, "init", function(i) {
        t.seed = i,
        t.value = MT(i)
    }),
    bu(this, "value", MT(this.seed)),
    this.init(e)
}
  , H6 = new G6(Math.random())
  , V6 = {
    radius: 1,
    center: [0, 0, 0]
};
function W6(n, e) {
    for (var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : H6, i = vT(vT({}, V6), e), r = i.radius, s = i.center, o = 0; o < n.length; o += 3) {
        var a = Math.pow(t.value(), .3333333333333333)
          , l = t.value() * 2 - 1
          , c = t.value() * 2 - 1
          , d = t.value() * 2 - 1
          , h = Math.sqrt(l * l + c * c + d * d);
        l = a * l / h,
        c = a * c / h,
        d = a * d / h,
        n[o] = l * r + s[0],
        n[o + 1] = c * r + s[1],
        n[o + 2] = d * r + s[2]
    }
    return n
}
function fd(n) {
    return fd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    ,
    fd(n)
}
function j6(n, e) {
    if (fd(n) !== "object" || n === null)
        return n;
    var t = n[Symbol.toPrimitive];
    if (t !== void 0) {
        var i = t.call(n, e || "default");
        if (fd(i) !== "object")
            return i;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(n)
}
function J6(n) {
    var e = j6(n, "string");
    return fd(e) === "symbol" ? e : String(e)
}
function at(n, e, t) {
    return e = J6(e),
    e in n ? Object.defineProperty(n, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : n[e] = t,
    n
}
const wT = (n,e)=>(n % e + e) % e;
let X6 = class extends cs {
    constructor(e, t) {
        super(),
        at(this, "object", void 0),
        at(this, "domElement", void 0),
        at(this, "enabled", !0),
        at(this, "target", new D),
        at(this, "minDistance", 0),
        at(this, "maxDistance", 1 / 0),
        at(this, "minZoom", 0),
        at(this, "maxZoom", 1 / 0),
        at(this, "minPolarAngle", 0),
        at(this, "maxPolarAngle", Math.PI),
        at(this, "minAzimuthAngle", -1 / 0),
        at(this, "maxAzimuthAngle", 1 / 0),
        at(this, "enableDamping", !1),
        at(this, "dampingFactor", .05),
        at(this, "enableZoom", !0),
        at(this, "zoomSpeed", 1),
        at(this, "enableRotate", !0),
        at(this, "rotateSpeed", 1),
        at(this, "enablePan", !0),
        at(this, "panSpeed", 1),
        at(this, "screenSpacePanning", !0),
        at(this, "keyPanSpeed", 7),
        at(this, "autoRotate", !1),
        at(this, "autoRotateSpeed", 2),
        at(this, "reverseOrbit", !1),
        at(this, "keys", {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
        }),
        at(this, "mouseButtons", {
            LEFT: ba.ROTATE,
            MIDDLE: ba.DOLLY,
            RIGHT: ba.PAN
        }),
        at(this, "touches", {
            ONE: Pa.ROTATE,
            TWO: Pa.DOLLY_PAN
        }),
        at(this, "target0", void 0),
        at(this, "position0", void 0),
        at(this, "zoom0", void 0),
        at(this, "_domElementKeyEvents", null),
        at(this, "getPolarAngle", void 0),
        at(this, "getAzimuthalAngle", void 0),
        at(this, "setPolarAngle", void 0),
        at(this, "setAzimuthalAngle", void 0),
        at(this, "getDistance", void 0),
        at(this, "listenToKeyEvents", void 0),
        at(this, "saveState", void 0),
        at(this, "reset", void 0),
        at(this, "update", void 0),
        at(this, "connect", void 0),
        at(this, "dispose", void 0),
        this.object = e,
        this.domElement = t,
        this.target0 = this.target.clone(),
        this.position0 = this.object.position.clone(),
        this.zoom0 = this.object instanceof Ht ? this.object.zoom : 1,
        this.getPolarAngle = ()=>d.phi,
        this.getAzimuthalAngle = ()=>d.theta,
        this.setPolarAngle = W=>{
            let le = wT(W, 2 * Math.PI)
              , Ae = d.phi;
            Ae < 0 && (Ae += 2 * Math.PI),
            le < 0 && (le += 2 * Math.PI);
            let be = Math.abs(le - Ae);
            2 * Math.PI - be < be && (le < Ae ? le += 2 * Math.PI : Ae += 2 * Math.PI),
            h.phi = le - Ae,
            i.update()
        }
        ,
        this.setAzimuthalAngle = W=>{
            let le = wT(W, 2 * Math.PI)
              , Ae = d.theta;
            Ae < 0 && (Ae += 2 * Math.PI),
            le < 0 && (le += 2 * Math.PI);
            let be = Math.abs(le - Ae);
            2 * Math.PI - be < be && (le < Ae ? le += 2 * Math.PI : Ae += 2 * Math.PI),
            h.theta = le - Ae,
            i.update()
        }
        ,
        this.getDistance = ()=>i.object.position.distanceTo(i.target),
        this.listenToKeyEvents = W=>{
            W.addEventListener("keydown", oe),
            this._domElementKeyEvents = W
        }
        ,
        this.saveState = ()=>{
            i.target0.copy(i.target),
            i.position0.copy(i.object.position),
            i.zoom0 = i.object instanceof Ht ? i.object.zoom : 1
        }
        ,
        this.reset = ()=>{
            i.target.copy(i.target0),
            i.object.position.copy(i.position0),
            i.object instanceof Ht && (i.object.zoom = i.zoom0,
            i.object.updateProjectionMatrix()),
            i.dispatchEvent(r),
            i.update(),
            l = a.NONE
        }
        ,
        this.update = (()=>{
            const W = new D
              , le = new jn().setFromUnitVectors(e.up, new D(0,1,0))
              , Ae = le.clone().invert()
              , be = new D
              , $e = new jn
              , vt = 2 * Math.PI;
            return function() {
                const Y = i.object.position;
                W.copy(Y).sub(i.target),
                W.applyQuaternion(le),
                d.setFromVector3(W),
                i.autoRotate && l === a.NONE && Z(L()),
                i.enableDamping ? (d.theta += h.theta * i.dampingFactor,
                d.phi += h.phi * i.dampingFactor) : (d.theta += h.theta,
                d.phi += h.phi);
                let ce = i.minAzimuthAngle
                  , _e = i.maxAzimuthAngle;
                return isFinite(ce) && isFinite(_e) && (ce < -Math.PI ? ce += vt : ce > Math.PI && (ce -= vt),
                _e < -Math.PI ? _e += vt : _e > Math.PI && (_e -= vt),
                ce <= _e ? d.theta = Math.max(ce, Math.min(_e, d.theta)) : d.theta = d.theta > (ce + _e) / 2 ? Math.max(ce, d.theta) : Math.min(_e, d.theta)),
                d.phi = Math.max(i.minPolarAngle, Math.min(i.maxPolarAngle, d.phi)),
                d.makeSafe(),
                d.radius *= p,
                d.radius = Math.max(i.minDistance, Math.min(i.maxDistance, d.radius)),
                i.enableDamping === !0 ? i.target.addScaledVector(m, i.dampingFactor) : i.target.add(m),
                W.setFromSpherical(d),
                W.applyQuaternion(Ae),
                Y.copy(i.target).add(W),
                i.object.lookAt(i.target),
                i.enableDamping === !0 ? (h.theta *= 1 - i.dampingFactor,
                h.phi *= 1 - i.dampingFactor,
                m.multiplyScalar(1 - i.dampingFactor)) : (h.set(0, 0, 0),
                m.set(0, 0, 0)),
                p = 1,
                y || be.distanceToSquared(i.object.position) > c || 8 * (1 - $e.dot(i.object.quaternion)) > c ? (i.dispatchEvent(r),
                be.copy(i.object.position),
                $e.copy(i.object.quaternion),
                y = !1,
                !0) : !1
            }
        }
        )(),
        this.connect = W=>{
            W === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),
            i.domElement = W,
            i.domElement.style.touchAction = "none",
            i.domElement.addEventListener("contextmenu", Pe),
            i.domElement.addEventListener("pointerdown", Ze),
            i.domElement.addEventListener("pointercancel", xt),
            i.domElement.addEventListener("wheel", I)
        }
        ,
        this.dispose = ()=>{
            var W, le, Ae, be, $e, vt;
            (W = i.domElement) === null || W === void 0 || W.removeEventListener("contextmenu", Pe),
            (le = i.domElement) === null || le === void 0 || le.removeEventListener("pointerdown", Ze),
            (Ae = i.domElement) === null || Ae === void 0 || Ae.removeEventListener("pointercancel", xt),
            (be = i.domElement) === null || be === void 0 || be.removeEventListener("wheel", I),
            ($e = i.domElement) === null || $e === void 0 || $e.ownerDocument.removeEventListener("pointermove", Je),
            (vt = i.domElement) === null || vt === void 0 || vt.ownerDocument.removeEventListener("pointerup", We),
            i._domElementKeyEvents !== null && i._domElementKeyEvents.removeEventListener("keydown", oe)
        }
        ;
        const i = this
          , r = {
            type: "change"
        }
          , s = {
            type: "start"
        }
          , o = {
            type: "end"
        }
          , a = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_PAN: 4,
            TOUCH_DOLLY_PAN: 5,
            TOUCH_DOLLY_ROTATE: 6
        };
        let l = a.NONE;
        const c = 1e-6
          , d = new U1
          , h = new U1;
        let p = 1;
        const m = new D;
        let y = !1;
        const v = new pe
          , _ = new pe
          , x = new pe
          , A = new pe
          , M = new pe
          , S = new pe
          , T = new pe
          , P = new pe
          , R = new pe
          , E = []
          , B = {};
        function L() {
            return 2 * Math.PI / 60 / 60 * i.autoRotateSpeed
        }
        function z() {
            return Math.pow(.95, i.zoomSpeed)
        }
        function Z(W) {
            i.reverseOrbit ? h.theta += W : h.theta -= W
        }
        function J(W) {
            i.reverseOrbit ? h.phi += W : h.phi -= W
        }
        const G = (()=>{
            const W = new D;
            return function(Ae, be) {
                W.setFromMatrixColumn(be, 0),
                W.multiplyScalar(-Ae),
                m.add(W)
            }
        }
        )()
          , X = (()=>{
            const W = new D;
            return function(Ae, be) {
                i.screenSpacePanning === !0 ? W.setFromMatrixColumn(be, 1) : (W.setFromMatrixColumn(be, 0),
                W.crossVectors(i.object.up, W)),
                W.multiplyScalar(Ae),
                m.add(W)
            }
        }
        )()
          , ee = (()=>{
            const W = new D;
            return function(Ae, be) {
                const $e = i.domElement;
                if ($e && i.object instanceof Ht && i.object.isPerspectiveCamera) {
                    const vt = i.object.position;
                    W.copy(vt).sub(i.target);
                    let Wt = W.length();
                    Wt *= Math.tan(i.object.fov / 2 * Math.PI / 180),
                    G(2 * Ae * Wt / $e.clientHeight, i.object.matrix),
                    X(2 * be * Wt / $e.clientHeight, i.object.matrix)
                } else
                    $e && i.object instanceof Nr && i.object.isOrthographicCamera ? (G(Ae * (i.object.right - i.object.left) / i.object.zoom / $e.clientWidth, i.object.matrix),
                    X(be * (i.object.top - i.object.bottom) / i.object.zoom / $e.clientHeight, i.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
                    i.enablePan = !1)
            }
        }
        )();
        function ie(W) {
            i.object instanceof Ht && i.object.isPerspectiveCamera ? p /= W : i.object instanceof Nr && i.object.isOrthographicCamera ? (i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom * W)),
            i.object.updateProjectionMatrix(),
            y = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            i.enableZoom = !1)
        }
        function F(W) {
            i.object instanceof Ht && i.object.isPerspectiveCamera ? p *= W : i.object instanceof Nr && i.object.isOrthographicCamera ? (i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / W)),
            i.object.updateProjectionMatrix(),
            y = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            i.enableZoom = !1)
        }
        function V(W) {
            v.set(W.clientX, W.clientY)
        }
        function j(W) {
            T.set(W.clientX, W.clientY)
        }
        function re(W) {
            A.set(W.clientX, W.clientY)
        }
        function H(W) {
            _.set(W.clientX, W.clientY),
            x.subVectors(_, v).multiplyScalar(i.rotateSpeed);
            const le = i.domElement;
            le && (Z(2 * Math.PI * x.x / le.clientHeight),
            J(2 * Math.PI * x.y / le.clientHeight)),
            v.copy(_),
            i.update()
        }
        function se(W) {
            P.set(W.clientX, W.clientY),
            R.subVectors(P, T),
            R.y > 0 ? ie(z()) : R.y < 0 && F(z()),
            T.copy(P),
            i.update()
        }
        function ye(W) {
            M.set(W.clientX, W.clientY),
            S.subVectors(M, A).multiplyScalar(i.panSpeed),
            ee(S.x, S.y),
            A.copy(M),
            i.update()
        }
        function ve(W) {
            W.deltaY < 0 ? F(z()) : W.deltaY > 0 && ie(z()),
            i.update()
        }
        function q(W) {
            let le = !1;
            switch (W.code) {
            case i.keys.UP:
                ee(0, i.keyPanSpeed),
                le = !0;
                break;
            case i.keys.BOTTOM:
                ee(0, -i.keyPanSpeed),
                le = !0;
                break;
            case i.keys.LEFT:
                ee(i.keyPanSpeed, 0),
                le = !0;
                break;
            case i.keys.RIGHT:
                ee(-i.keyPanSpeed, 0),
                le = !0;
                break
            }
            le && (W.preventDefault(),
            i.update())
        }
        function Ie() {
            if (E.length == 1)
                v.set(E[0].pageX, E[0].pageY);
            else {
                const W = .5 * (E[0].pageX + E[1].pageX)
                  , le = .5 * (E[0].pageY + E[1].pageY);
                v.set(W, le)
            }
        }
        function Ne() {
            if (E.length == 1)
                A.set(E[0].pageX, E[0].pageY);
            else {
                const W = .5 * (E[0].pageX + E[1].pageX)
                  , le = .5 * (E[0].pageY + E[1].pageY);
                A.set(W, le)
            }
        }
        function He() {
            const W = E[0].pageX - E[1].pageX
              , le = E[0].pageY - E[1].pageY
              , Ae = Math.sqrt(W * W + le * le);
            T.set(0, Ae)
        }
        function Me() {
            i.enableZoom && He(),
            i.enablePan && Ne()
        }
        function De() {
            i.enableZoom && He(),
            i.enableRotate && Ie()
        }
        function de(W) {
            if (E.length == 1)
                _.set(W.pageX, W.pageY);
            else {
                const Ae = Xe(W)
                  , be = .5 * (W.pageX + Ae.x)
                  , $e = .5 * (W.pageY + Ae.y);
                _.set(be, $e)
            }
            x.subVectors(_, v).multiplyScalar(i.rotateSpeed);
            const le = i.domElement;
            le && (Z(2 * Math.PI * x.x / le.clientHeight),
            J(2 * Math.PI * x.y / le.clientHeight)),
            v.copy(_)
        }
        function ae(W) {
            if (E.length == 1)
                M.set(W.pageX, W.pageY);
            else {
                const le = Xe(W)
                  , Ae = .5 * (W.pageX + le.x)
                  , be = .5 * (W.pageY + le.y);
                M.set(Ae, be)
            }
            S.subVectors(M, A).multiplyScalar(i.panSpeed),
            ee(S.x, S.y),
            A.copy(M)
        }
        function Ce(W) {
            const le = Xe(W)
              , Ae = W.pageX - le.x
              , be = W.pageY - le.y
              , $e = Math.sqrt(Ae * Ae + be * be);
            P.set(0, $e),
            R.set(0, Math.pow(P.y / T.y, i.zoomSpeed)),
            ie(R.y),
            T.copy(P)
        }
        function ze(W) {
            i.enableZoom && Ce(W),
            i.enablePan && ae(W)
        }
        function Be(W) {
            i.enableZoom && Ce(W),
            i.enableRotate && de(W)
        }
        function Ze(W) {
            if (i.enabled !== !1) {
                if (E.length === 0) {
                    var le, Ae;
                    (le = i.domElement) === null || le === void 0 || le.ownerDocument.addEventListener("pointermove", Je),
                    (Ae = i.domElement) === null || Ae === void 0 || Ae.ownerDocument.addEventListener("pointerup", We)
                }
                tt(W),
                W.pointerType === "touch" ? we(W) : St(W)
            }
        }
        function Je(W) {
            i.enabled !== !1 && (W.pointerType === "touch" ? Ee(W) : U(W))
        }
        function We(W) {
            if (Fe(W),
            E.length === 0) {
                var le, Ae, be;
                (le = i.domElement) === null || le === void 0 || le.releasePointerCapture(W.pointerId),
                (Ae = i.domElement) === null || Ae === void 0 || Ae.ownerDocument.removeEventListener("pointermove", Je),
                (be = i.domElement) === null || be === void 0 || be.ownerDocument.removeEventListener("pointerup", We)
            }
            i.dispatchEvent(o),
            l = a.NONE
        }
        function xt(W) {
            Fe(W)
        }
        function St(W) {
            let le;
            switch (W.button) {
            case 0:
                le = i.mouseButtons.LEFT;
                break;
            case 1:
                le = i.mouseButtons.MIDDLE;
                break;
            case 2:
                le = i.mouseButtons.RIGHT;
                break;
            default:
                le = -1
            }
            switch (le) {
            case ba.DOLLY:
                if (i.enableZoom === !1)
                    return;
                j(W),
                l = a.DOLLY;
                break;
            case ba.ROTATE:
                if (W.ctrlKey || W.metaKey || W.shiftKey) {
                    if (i.enablePan === !1)
                        return;
                    re(W),
                    l = a.PAN
                } else {
                    if (i.enableRotate === !1)
                        return;
                    V(W),
                    l = a.ROTATE
                }
                break;
            case ba.PAN:
                if (W.ctrlKey || W.metaKey || W.shiftKey) {
                    if (i.enableRotate === !1)
                        return;
                    V(W),
                    l = a.ROTATE
                } else {
                    if (i.enablePan === !1)
                        return;
                    re(W),
                    l = a.PAN
                }
                break;
            default:
                l = a.NONE
            }
            l !== a.NONE && i.dispatchEvent(s)
        }
        function U(W) {
            if (i.enabled !== !1)
                switch (l) {
                case a.ROTATE:
                    if (i.enableRotate === !1)
                        return;
                    H(W);
                    break;
                case a.DOLLY:
                    if (i.enableZoom === !1)
                        return;
                    se(W);
                    break;
                case a.PAN:
                    if (i.enablePan === !1)
                        return;
                    ye(W);
                    break
                }
        }
        function I(W) {
            i.enabled === !1 || i.enableZoom === !1 || l !== a.NONE && l !== a.ROTATE || (W.preventDefault(),
            i.dispatchEvent(s),
            ve(W),
            i.dispatchEvent(o))
        }
        function oe(W) {
            i.enabled === !1 || i.enablePan === !1 || q(W)
        }
        function we(W) {
            switch (me(W),
            E.length) {
            case 1:
                switch (i.touches.ONE) {
                case Pa.ROTATE:
                    if (i.enableRotate === !1)
                        return;
                    Ie(),
                    l = a.TOUCH_ROTATE;
                    break;
                case Pa.PAN:
                    if (i.enablePan === !1)
                        return;
                    Ne(),
                    l = a.TOUCH_PAN;
                    break;
                default:
                    l = a.NONE
                }
                break;
            case 2:
                switch (i.touches.TWO) {
                case Pa.DOLLY_PAN:
                    if (i.enableZoom === !1 && i.enablePan === !1)
                        return;
                    Me(),
                    l = a.TOUCH_DOLLY_PAN;
                    break;
                case Pa.DOLLY_ROTATE:
                    if (i.enableZoom === !1 && i.enableRotate === !1)
                        return;
                    De(),
                    l = a.TOUCH_DOLLY_ROTATE;
                    break;
                default:
                    l = a.NONE
                }
                break;
            default:
                l = a.NONE
            }
            l !== a.NONE && i.dispatchEvent(s)
        }
        function Ee(W) {
            switch (me(W),
            l) {
            case a.TOUCH_ROTATE:
                if (i.enableRotate === !1)
                    return;
                de(W),
                i.update();
                break;
            case a.TOUCH_PAN:
                if (i.enablePan === !1)
                    return;
                ae(W),
                i.update();
                break;
            case a.TOUCH_DOLLY_PAN:
                if (i.enableZoom === !1 && i.enablePan === !1)
                    return;
                ze(W),
                i.update();
                break;
            case a.TOUCH_DOLLY_ROTATE:
                if (i.enableZoom === !1 && i.enableRotate === !1)
                    return;
                Be(W),
                i.update();
                break;
            default:
                l = a.NONE
            }
        }
        function Pe(W) {
            i.enabled !== !1 && W.preventDefault()
        }
        function tt(W) {
            E.push(W)
        }
        function Fe(W) {
            delete B[W.pointerId];
            for (let le = 0; le < E.length; le++)
                if (E[le].pointerId == W.pointerId) {
                    E.splice(le, 1);
                    return
                }
        }
        function me(W) {
            let le = B[W.pointerId];
            le === void 0 && (le = new pe,
            B[W.pointerId] = le),
            le.set(W.pageX, W.pageY)
        }
        function Xe(W) {
            const le = W.pointerId === E[0].pointerId ? E[1] : E[0];
            return B[le.pointerId]
        }
        t !== void 0 && this.connect(t),
        this.update()
    }
}
;
class iM extends vi {
    constructor(e) {
        super(e),
        this.dracoLoader = null,
        this.ktx2Loader = null,
        this.meshoptDecoder = null,
        this.pluginCallbacks = [],
        this.register(function(t) {
            return new q6(t)
        }),
        this.register(function(t) {
            return new sV(t)
        }),
        this.register(function(t) {
            return new oV(t)
        }),
        this.register(function(t) {
            return new eV(t)
        }),
        this.register(function(t) {
            return new tV(t)
        }),
        this.register(function(t) {
            return new nV(t)
        }),
        this.register(function(t) {
            return new iV(t)
        }),
        this.register(function(t) {
            return new Z6(t)
        }),
        this.register(function(t) {
            return new rV(t)
        }),
        this.register(function(t) {
            return new $6(t)
        }),
        this.register(function(t) {
            return new Y6(t)
        }),
        this.register(function(t) {
            return new aV(t)
        })
    }
    load(e, t, i, r) {
        const s = this;
        let o;
        this.resourcePath !== "" ? o = this.resourcePath : this.path !== "" ? o = this.path : o = ss.extractUrlBase(e),
        this.manager.itemStart(e);
        const a = function(c) {
            r ? r(c) : console.error(c),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }
          , l = new ji(this.manager);
        l.setPath(this.path),
        l.setResponseType("arraybuffer"),
        l.setRequestHeader(this.requestHeader),
        l.setWithCredentials(this.withCredentials),
        l.load(e, function(c) {
            try {
                s.parse(c, o, function(d) {
                    t(d),
                    s.manager.itemEnd(e)
                }, a)
            } catch (d) {
                a(d)
            }
        }, i, a)
    }
    setDRACOLoader(e) {
        return this.dracoLoader = e,
        this
    }
    setDDSLoader() {
        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
    }
    setKTX2Loader(e) {
        return this.ktx2Loader = e,
        this
    }
    setMeshoptDecoder(e) {
        return this.meshoptDecoder = e,
        this
    }
    register(e) {
        return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
        this
    }
    unregister(e) {
        return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
        this
    }
    parse(e, t, i, r) {
        let s;
        const o = {}
          , a = {};
        if (typeof e == "string")
            s = e;
        else if (ss.decodeText(new Uint8Array(e,0,4)) === IR) {
            try {
                o[_t.KHR_BINARY_GLTF] = new lV(e)
            } catch (h) {
                r && r(h);
                return
            }
            s = o[_t.KHR_BINARY_GLTF].content
        } else
            s = ss.decodeText(new Uint8Array(e));
        const l = JSON.parse(s);
        if (l.asset === void 0 || l.asset.version[0] < 2) {
            r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return
        }
        const c = new AV(l,{
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        c.fileLoader.setRequestHeader(this.requestHeader);
        for (let d = 0; d < this.pluginCallbacks.length; d++) {
            const h = this.pluginCallbacks[d](c);
            a[h.name] = h,
            o[h.name] = !0
        }
        if (l.extensionsUsed)
            for (let d = 0; d < l.extensionsUsed.length; ++d) {
                const h = l.extensionsUsed[d]
                  , p = l.extensionsRequired || [];
                switch (h) {
                case _t.KHR_MATERIALS_UNLIT:
                    o[h] = new Q6;
                    break;
                case _t.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                    o[h] = new fV;
                    break;
                case _t.KHR_DRACO_MESH_COMPRESSION:
                    o[h] = new uV(l,this.dracoLoader);
                    break;
                case _t.KHR_TEXTURE_TRANSFORM:
                    o[h] = new cV;
                    break;
                case _t.KHR_MESH_QUANTIZATION:
                    o[h] = new dV;
                    break;
                default:
                    p.indexOf(h) >= 0 && a[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".')
                }
            }
        c.setExtensions(o),
        c.setPlugins(a),
        c.parse(i, r)
    }
    parseAsync(e, t) {
        const i = this;
        return new Promise(function(r, s) {
            i.parse(e, t, r, s)
        }
        )
    }
}
function K6() {
    let n = {};
    return {
        get: function(e) {
            return n[e]
        },
        add: function(e, t) {
            n[e] = t
        },
        remove: function(e) {
            delete n[e]
        },
        removeAll: function() {
            n = {}
        }
    }
}
const _t = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
};
class Y6 {
    constructor(e) {
        this.parser = e,
        this.name = _t.KHR_LIGHTS_PUNCTUAL,
        this.cache = {
            refs: {},
            uses: {}
        }
    }
    _markDefs() {
        const e = this.parser
          , t = this.parser.json.nodes || [];
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light)
        }
    }
    _loadLight(e) {
        const t = this.parser
          , i = "light:" + e;
        let r = t.cache.get(i);
        if (r)
            return r;
        const s = t.json
          , l = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
        let c;
        const d = new Le(16777215);
        l.color !== void 0 && d.fromArray(l.color);
        const h = l.range !== void 0 ? l.range : 0;
        switch (l.type) {
        case "directional":
            c = new YA(d),
            c.target.position.set(0, 0, -1),
            c.add(c.target);
            break;
        case "point":
            c = new KA(d),
            c.distance = h;
            break;
        case "spot":
            c = new XA(d),
            c.distance = h,
            l.spot = l.spot || {},
            l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0,
            l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4,
            c.angle = l.spot.outerConeAngle,
            c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle,
            c.target.position.set(0, 0, -1),
            c.add(c.target);
            break;
        default:
            throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type)
        }
        return c.position.set(0, 0, 0),
        c.decay = 2,
        l.intensity !== void 0 && (c.intensity = l.intensity),
        c.name = t.createUniqueName(l.name || "light_" + e),
        r = Promise.resolve(c),
        t.cache.add(i, r),
        r
    }
    createNodeAttachment(e) {
        const t = this
          , i = this.parser
          , s = i.json.nodes[e]
          , a = (s.extensions && s.extensions[this.name] || {}).light;
        return a === void 0 ? null : this._loadLight(a).then(function(l) {
            return i._getNodeRef(t.cache, a, l)
        })
    }
}
class Q6 {
    constructor() {
        this.name = _t.KHR_MATERIALS_UNLIT
    }
    getMaterialType() {
        return Gi
    }
    extendParams(e, t, i) {
        const r = [];
        e.color = new Le(1,1,1),
        e.opacity = 1;
        const s = t.pbrMetallicRoughness;
        if (s) {
            if (Array.isArray(s.baseColorFactor)) {
                const o = s.baseColorFactor;
                e.color.fromArray(o),
                e.opacity = o[3]
            }
            s.baseColorTexture !== void 0 && r.push(i.assignTexture(e, "map", s.baseColorTexture, Et))
        }
        return Promise.all(r)
    }
}
class Z6 {
    constructor(e) {
        this.parser = e,
        this.name = _t.KHR_MATERIALS_EMISSIVE_STRENGTH
    }
    extendMaterialParams(e, t) {
        const r = this.parser.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = r.extensions[this.name].emissiveStrength;
        return s !== void 0 && (t.emissiveIntensity = s),
        Promise.resolve()
    }
}
class q6 {
    constructor(e) {
        this.parser = e,
        this.name = _t.KHR_MATERIALS_CLEARCOAT
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : qs
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = r.extensions[this.name];
        if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
        o.clearcoatTexture !== void 0 && s.push(i.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
        o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
        o.clearcoatRoughnessTexture !== void 0 && s.push(i.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)),
        o.clearcoatNormalTexture !== void 0 && (s.push(i.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)),
        o.clearcoatNormalTexture.scale !== void 0)) {
            const a = o.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new pe(a,a)
        }
        return Promise.all(s)
    }
}
class $6 {
    constructor(e) {
        this.parser = e,
        this.name = _t.KHR_MATERIALS_IRIDESCENCE
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : qs
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = r.extensions[this.name];
        return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor),
        o.iridescenceTexture !== void 0 && s.push(i.assignTexture(t, "iridescenceMap", o.iridescenceTexture)),
        o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor),
        t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]),
        o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
        o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
        o.iridescenceThicknessTexture !== void 0 && s.push(i.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)),
        Promise.all(s)
    }
}
class eV {
    constructor(e) {
        this.parser = e,
        this.name = _t.KHR_MATERIALS_SHEEN
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : qs
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = [];
        t.sheenColor = new Le(0,0,0),
        t.sheenRoughness = 0,
        t.sheen = 1;
        const o = r.extensions[this.name];
        return o.sheenColorFactor !== void 0 && t.sheenColor.fromArray(o.sheenColorFactor),
        o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor),
        o.sheenColorTexture !== void 0 && s.push(i.assignTexture(t, "sheenColorMap", o.sheenColorTexture, Et)),
        o.sheenRoughnessTexture !== void 0 && s.push(i.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)),
        Promise.all(s)
    }
}
class tV {
    constructor(e) {
        this.parser = e,
        this.name = _t.KHR_MATERIALS_TRANSMISSION
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : qs
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = r.extensions[this.name];
        return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor),
        o.transmissionTexture !== void 0 && s.push(i.assignTexture(t, "transmissionMap", o.transmissionTexture)),
        Promise.all(s)
    }
}
class nV {
    constructor(e) {
        this.parser = e,
        this.name = _t.KHR_MATERIALS_VOLUME
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : qs
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = r.extensions[this.name];
        t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0,
        o.thicknessTexture !== void 0 && s.push(i.assignTexture(t, "thicknessMap", o.thicknessTexture)),
        t.attenuationDistance = o.attenuationDistance || 1 / 0;
        const a = o.attenuationColor || [1, 1, 1];
        return t.attenuationColor = new Le(a[0],a[1],a[2]),
        Promise.all(s)
    }
}
class iV {
    constructor(e) {
        this.parser = e,
        this.name = _t.KHR_MATERIALS_IOR
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : qs
    }
    extendMaterialParams(e, t) {
        const r = this.parser.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = r.extensions[this.name];
        return t.ior = s.ior !== void 0 ? s.ior : 1.5,
        Promise.resolve()
    }
}
class rV {
    constructor(e) {
        this.parser = e,
        this.name = _t.KHR_MATERIALS_SPECULAR
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : qs
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = r.extensions[this.name];
        t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1,
        o.specularTexture !== void 0 && s.push(i.assignTexture(t, "specularIntensityMap", o.specularTexture));
        const a = o.specularColorFactor || [1, 1, 1];
        return t.specularColor = new Le(a[0],a[1],a[2]),
        o.specularColorTexture !== void 0 && s.push(i.assignTexture(t, "specularColorMap", o.specularColorTexture, Et)),
        Promise.all(s)
    }
}
class sV {
    constructor(e) {
        this.parser = e,
        this.name = _t.KHR_TEXTURE_BASISU
    }
    loadTexture(e) {
        const t = this.parser
          , i = t.json
          , r = i.textures[e];
        if (!r.extensions || !r.extensions[this.name])
            return null;
        const s = r.extensions[this.name]
          , o = t.options.ktx2Loader;
        if (!o) {
            if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
                throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null
        }
        return t.loadTextureImage(e, s.source, o)
    }
}
class oV {
    constructor(e) {
        this.parser = e,
        this.name = _t.EXT_TEXTURE_WEBP,
        this.isSupported = null
    }
    loadTexture(e) {
        const t = this.name
          , i = this.parser
          , r = i.json
          , s = r.textures[e];
        if (!s.extensions || !s.extensions[t])
            return null;
        const o = s.extensions[t]
          , a = r.images[o.source];
        let l = i.textureLoader;
        if (a.uri) {
            const c = i.options.manager.getHandler(a.uri);
            c !== null && (l = c)
        }
        return this.detectSupport().then(function(c) {
            if (c)
                return i.loadTextureImage(e, o.source, l);
            if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
                throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return i.loadTexture(e)
        })
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(e) {
            const t = new Image;
            t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
            t.onload = t.onerror = function() {
                e(t.height === 1)
            }
        }
        )),
        this.isSupported
    }
}
class aV {
    constructor(e) {
        this.name = _t.EXT_MESHOPT_COMPRESSION,
        this.parser = e
    }
    loadBufferView(e) {
        const t = this.parser.json
          , i = t.bufferViews[e];
        if (i.extensions && i.extensions[this.name]) {
            const r = i.extensions[this.name]
              , s = this.parser.getDependency("buffer", r.buffer)
              , o = this.parser.options.meshoptDecoder;
            if (!o || !o.supported) {
                if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
                    throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null
            }
            return s.then(function(a) {
                const l = r.byteOffset || 0
                  , c = r.byteLength || 0
                  , d = r.count
                  , h = r.byteStride
                  , p = new Uint8Array(a,l,c);
                return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(d, h, p, r.mode, r.filter).then(function(m) {
                    return m.buffer
                }) : o.ready.then(function() {
                    const m = new ArrayBuffer(d * h);
                    return o.decodeGltfBuffer(new Uint8Array(m), d, h, p, r.mode, r.filter),
                    m
                })
            })
        } else
            return null
    }
}
const IR = "glTF"
  , Qc = 12
  , ST = {
    JSON: 1313821514,
    BIN: 5130562
};
class lV {
    constructor(e) {
        this.name = _t.KHR_BINARY_GLTF,
        this.content = null,
        this.body = null;
        const t = new DataView(e,0,Qc);
        if (this.header = {
            magic: ss.decodeText(new Uint8Array(e.slice(0, 4))),
            version: t.getUint32(4, !0),
            length: t.getUint32(8, !0)
        },
        this.header.magic !== IR)
            throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const i = this.header.length - Qc
          , r = new DataView(e,Qc);
        let s = 0;
        for (; s < i; ) {
            const o = r.getUint32(s, !0);
            s += 4;
            const a = r.getUint32(s, !0);
            if (s += 4,
            a === ST.JSON) {
                const l = new Uint8Array(e,Qc + s,o);
                this.content = ss.decodeText(l)
            } else if (a === ST.BIN) {
                const l = Qc + s;
                this.body = e.slice(l, l + o)
            }
            s += o
        }
        if (this.content === null)
            throw new Error("THREE.GLTFLoader: JSON content not found.")
    }
}
class uV {
    constructor(e, t) {
        if (!t)
            throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = _t.KHR_DRACO_MESH_COMPRESSION,
        this.json = e,
        this.dracoLoader = t,
        this.dracoLoader.preload()
    }
    decodePrimitive(e, t) {
        const i = this.json
          , r = this.dracoLoader
          , s = e.extensions[this.name].bufferView
          , o = e.extensions[this.name].attributes
          , a = {}
          , l = {}
          , c = {};
        for (const d in o) {
            const h = K1[d] || d.toLowerCase();
            a[h] = o[d]
        }
        for (const d in e.attributes) {
            const h = K1[d] || d.toLowerCase();
            if (o[d] !== void 0) {
                const p = i.accessors[e.attributes[d]]
                  , m = dd[p.componentType];
                c[h] = m.name,
                l[h] = p.normalized === !0
            }
        }
        return t.getDependency("bufferView", s).then(function(d) {
            return new Promise(function(h) {
                r.decodeDracoFile(d, function(p) {
                    for (const m in p.attributes) {
                        const y = p.attributes[m]
                          , v = l[m];
                        v !== void 0 && (y.normalized = v)
                    }
                    h(p)
                }, a, c)
            }
            )
        })
    }
}
class cV {
    constructor() {
        this.name = _t.KHR_TEXTURE_TRANSFORM
    }
    extendTexture(e, t) {
        return t.texCoord !== void 0 && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'),
        t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        e.needsUpdate = !0),
        e
    }
}
class X1 extends rc {
    constructor(e) {
        super(),
        this.isGLTFSpecularGlossinessMaterial = !0;
        const t = ["#ifdef USE_SPECULARMAP", "	uniform sampler2D specularMap;", "#endif"].join(`
`)
          , i = ["#ifdef USE_GLOSSINESSMAP", "	uniform sampler2D glossinessMap;", "#endif"].join(`
`)
          , r = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "	vec4 texelSpecular = texture2D( specularMap, vUv );", "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "	specularFactor *= texelSpecular.rgb;", "#endif"].join(`
`)
          , s = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );", "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "	glossinessFactor *= texelGlossiness.a;", "#endif"].join(`
`)
          , o = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join(`
`)
          , a = {
            specular: {
                value: new Le().setHex(16777215)
            },
            glossiness: {
                value: 1
            },
            specularMap: {
                value: null
            },
            glossinessMap: {
                value: null
            }
        };
        this._extraUniforms = a,
        this.onBeforeCompile = function(l) {
            for (const c in a)
                l.uniforms[c] = a[c];
            l.fragmentShader = l.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", i).replace("#include <roughnessmap_fragment>", r).replace("#include <metalnessmap_fragment>", s).replace("#include <lights_physical_fragment>", o)
        }
        ,
        Object.defineProperties(this, {
            specular: {
                get: function() {
                    return a.specular.value
                },
                set: function(l) {
                    a.specular.value = l
                }
            },
            specularMap: {
                get: function() {
                    return a.specularMap.value
                },
                set: function(l) {
                    a.specularMap.value = l,
                    l ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                }
            },
            glossiness: {
                get: function() {
                    return a.glossiness.value
                },
                set: function(l) {
                    a.glossiness.value = l
                }
            },
            glossinessMap: {
                get: function() {
                    return a.glossinessMap.value
                },
                set: function(l) {
                    a.glossinessMap.value = l,
                    l ? (this.defines.USE_GLOSSINESSMAP = "",
                    this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP,
                    delete this.defines.USE_UV)
                }
            }
        }),
        delete this.metalness,
        delete this.roughness,
        delete this.metalnessMap,
        delete this.roughnessMap,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.specularMap = e.specularMap,
        this.specular.copy(e.specular),
        this.glossinessMap = e.glossinessMap,
        this.glossiness = e.glossiness,
        delete this.metalness,
        delete this.roughness,
        delete this.metalnessMap,
        delete this.roughnessMap,
        this
    }
}
class fV {
    constructor() {
        this.name = _t.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
        this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"]
    }
    getMaterialType() {
        return X1
    }
    extendParams(e, t, i) {
        const r = t.extensions[this.name];
        e.color = new Le(1,1,1),
        e.opacity = 1;
        const s = [];
        if (Array.isArray(r.diffuseFactor)) {
            const o = r.diffuseFactor;
            e.color.fromArray(o),
            e.opacity = o[3]
        }
        if (r.diffuseTexture !== void 0 && s.push(i.assignTexture(e, "map", r.diffuseTexture, Et)),
        e.emissive = new Le(0,0,0),
        e.glossiness = r.glossinessFactor !== void 0 ? r.glossinessFactor : 1,
        e.specular = new Le(1,1,1),
        Array.isArray(r.specularFactor) && e.specular.fromArray(r.specularFactor),
        r.specularGlossinessTexture !== void 0) {
            const o = r.specularGlossinessTexture;
            s.push(i.assignTexture(e, "glossinessMap", o)),
            s.push(i.assignTexture(e, "specularMap", o, Et))
        }
        return Promise.all(s)
    }
    createMaterial(e) {
        const t = new X1(e);
        return t.fog = !0,
        t.color = e.color,
        t.map = e.map === void 0 ? null : e.map,
        t.lightMap = null,
        t.lightMapIntensity = 1,
        t.aoMap = e.aoMap === void 0 ? null : e.aoMap,
        t.aoMapIntensity = 1,
        t.emissive = e.emissive,
        t.emissiveIntensity = e.emissiveIntensity === void 0 ? 1 : e.emissiveIntensity,
        t.emissiveMap = e.emissiveMap === void 0 ? null : e.emissiveMap,
        t.bumpMap = e.bumpMap === void 0 ? null : e.bumpMap,
        t.bumpScale = 1,
        t.normalMap = e.normalMap === void 0 ? null : e.normalMap,
        t.normalMapType = Qs,
        e.normalScale && (t.normalScale = e.normalScale),
        t.displacementMap = null,
        t.displacementScale = 1,
        t.displacementBias = 0,
        t.specularMap = e.specularMap === void 0 ? null : e.specularMap,
        t.specular = e.specular,
        t.glossinessMap = e.glossinessMap === void 0 ? null : e.glossinessMap,
        t.glossiness = e.glossiness,
        t.alphaMap = null,
        t.envMap = e.envMap === void 0 ? null : e.envMap,
        t.envMapIntensity = 1,
        t.refractionRatio = .98,
        t
    }
}
class dV {
    constructor() {
        this.name = _t.KHR_MESH_QUANTIZATION
    }
}
class DR extends sc {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , i = this.sampleValues
          , r = this.valueSize
          , s = e * r * 3 + r;
        for (let o = 0; o !== r; o++)
            t[o] = i[s + o];
        return t
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = a * 2
          , c = a * 3
          , d = r - t
          , h = (i - t) / d
          , p = h * h
          , m = p * h
          , y = e * c
          , v = y - c
          , _ = -2 * m + 3 * p
          , x = m - p
          , A = 1 - _
          , M = x - p + h;
        for (let S = 0; S !== a; S++) {
            const T = o[v + S + a]
              , P = o[v + S + l] * d
              , R = o[y + S + a]
              , E = o[y + S] * d;
            s[S] = A * T + M * P + _ * R + x * E
        }
        return s
    }
}
const hV = new jn;
class pV extends DR {
    interpolate_(e, t, i, r) {
        const s = super.interpolate_(e, t, i, r);
        return hV.fromArray(s).normalize().toArray(s),
        s
    }
}
const Ts = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
}
  , dd = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
}
  , CT = {
    9728: hn,
    9729: nn,
    9984: ed,
    9985: Kg,
    9986: Eu,
    9987: ls
}
  , ET = {
    33071: Vn,
    33648: ku,
    10497: jo
}
  , TT = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
}
  , K1 = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
}
  , po = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
}
  , mV = {
    CUBICSPLINE: void 0,
    LINEAR: al,
    STEP: Ou
}
  , Ov = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
};
function gV(n) {
    return n.DefaultMaterial === void 0 && (n.DefaultMaterial = new rc({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: as
    })),
    n.DefaultMaterial
}
function Zc(n, e, t) {
    for (const i in t.extensions)
        n[i] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {},
        e.userData.gltfExtensions[i] = t.extensions[i])
}
function Ra(n, e) {
    e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(n.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
}
function yV(n, e, t) {
    let i = !1
      , r = !1
      , s = !1;
    for (let c = 0, d = e.length; c < d; c++) {
        const h = e[c];
        if (h.POSITION !== void 0 && (i = !0),
        h.NORMAL !== void 0 && (r = !0),
        h.COLOR_0 !== void 0 && (s = !0),
        i && r && s)
            break
    }
    if (!i && !r && !s)
        return Promise.resolve(n);
    const o = []
      , a = []
      , l = [];
    for (let c = 0, d = e.length; c < d; c++) {
        const h = e[c];
        if (i) {
            const p = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : n.attributes.position;
            o.push(p)
        }
        if (r) {
            const p = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : n.attributes.normal;
            a.push(p)
        }
        if (s) {
            const p = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : n.attributes.color;
            l.push(p)
        }
    }
    return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function(c) {
        const d = c[0]
          , h = c[1]
          , p = c[2];
        return i && (n.morphAttributes.position = d),
        r && (n.morphAttributes.normal = h),
        s && (n.morphAttributes.color = p),
        n.morphTargetsRelative = !0,
        n
    })
}
function vV(n, e) {
    if (n.updateMorphTargets(),
    e.weights !== void 0)
        for (let t = 0, i = e.weights.length; t < i; t++)
            n.morphTargetInfluences[t] = e.weights[t];
    if (e.extras && Array.isArray(e.extras.targetNames)) {
        const t = e.extras.targetNames;
        if (n.morphTargetInfluences.length === t.length) {
            n.morphTargetDictionary = {};
            for (let i = 0, r = t.length; i < r; i++)
                n.morphTargetDictionary[t[i]] = i
        } else
            console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
    }
}
function xV(n) {
    const e = n.extensions && n.extensions[_t.KHR_DRACO_MESH_COMPRESSION];
    let t;
    return e ? t = "draco:" + e.bufferView + ":" + e.indices + ":" + bT(e.attributes) : t = n.indices + ":" + bT(n.attributes) + ":" + n.mode,
    t
}
function bT(n) {
    let e = "";
    const t = Object.keys(n).sort();
    for (let i = 0, r = t.length; i < r; i++)
        e += t[i] + ":" + n[t[i]] + ";";
    return e
}
function Y1(n) {
    switch (n) {
    case Int8Array:
        return 1 / 127;
    case Uint8Array:
        return 1 / 255;
    case Int16Array:
        return 1 / 32767;
    case Uint16Array:
        return 1 / 65535;
    default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
    }
}
function _V(n) {
    return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png"
}
class AV {
    constructor(e={}, t={}) {
        var i, r;
        this.json = e,
        this.extensions = {},
        this.plugins = {},
        this.options = t,
        this.cache = new K6,
        this.associations = new Map,
        this.primitiveCache = {},
        this.meshCache = {
            refs: {},
            uses: {}
        },
        this.cameraCache = {
            refs: {},
            uses: {}
        },
        this.lightCache = {
            refs: {},
            uses: {}
        },
        this.sourceCache = {},
        this.textureCache = {},
        this.nodeNamesUsed = {};
        const s = typeof navigator < "u" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0
          , o = typeof navigator < "u" && ((i = navigator.userAgent) === null || i === void 0 ? void 0 : i.indexOf("Firefox")) > -1
          , a = typeof navigator < "u" && o ? (r = navigator.userAgent) === null || r === void 0 ? void 0 : r.match(/Firefox\/([0-9]+)\./)[1] : -1;
        typeof createImageBitmap > "u" || s || o && a < 98 ? this.textureLoader = new ZB(this.options.manager) : this.textureLoader = new rR(this.options.manager),
        this.textureLoader.setCrossOrigin(this.options.crossOrigin),
        this.textureLoader.setRequestHeader(this.options.requestHeader),
        this.fileLoader = new ji(this.options.manager),
        this.fileLoader.setResponseType("arraybuffer"),
        this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
    }
    setExtensions(e) {
        this.extensions = e
    }
    setPlugins(e) {
        this.plugins = e
    }
    parse(e, t) {
        const i = this
          , r = this.json
          , s = this.extensions;
        this.cache.removeAll(),
        this._invokeAll(function(o) {
            return o._markDefs && o._markDefs()
        }),
        Promise.all(this._invokeAll(function(o) {
            return o.beforeRoot && o.beforeRoot()
        })).then(function() {
            return Promise.all([i.getDependencies("scene"), i.getDependencies("animation"), i.getDependencies("camera")])
        }).then(function(o) {
            const a = {
                scene: o[0][r.scene || 0],
                scenes: o[0],
                animations: o[1],
                cameras: o[2],
                asset: r.asset,
                parser: i,
                userData: {}
            };
            Zc(s, a, r),
            Ra(a, r),
            Promise.all(i._invokeAll(function(l) {
                return l.afterRoot && l.afterRoot(a)
            })).then(function() {
                e(a)
            })
        }).catch(t)
    }
    _markDefs() {
        const e = this.json.nodes || []
          , t = this.json.skins || []
          , i = this.json.meshes || [];
        for (let r = 0, s = t.length; r < s; r++) {
            const o = t[r].joints;
            for (let a = 0, l = o.length; a < l; a++)
                e[o[a]].isBone = !0
        }
        for (let r = 0, s = e.length; r < s; r++) {
            const o = e[r];
            o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh),
            o.skin !== void 0 && (i[o.mesh].isSkinnedMesh = !0)),
            o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera)
        }
    }
    _addNodeRef(e, t) {
        t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0),
        e.refs[t]++)
    }
    _getNodeRef(e, t, i) {
        if (e.refs[t] <= 1)
            return i;
        const r = i.clone()
          , s = (o,a)=>{
            const l = this.associations.get(o);
            l != null && this.associations.set(a, l);
            for (const [c,d] of o.children.entries())
                s(d, a.children[c])
        }
        ;
        return s(i, r),
        r.name += "_instance_" + e.uses[t]++,
        r
    }
    _invokeOne(e) {
        const t = Object.values(this.plugins);
        t.push(this);
        for (let i = 0; i < t.length; i++) {
            const r = e(t[i]);
            if (r)
                return r
        }
        return null
    }
    _invokeAll(e) {
        const t = Object.values(this.plugins);
        t.unshift(this);
        const i = [];
        for (let r = 0; r < t.length; r++) {
            const s = e(t[r]);
            s && i.push(s)
        }
        return i
    }
    getDependency(e, t) {
        const i = e + ":" + t;
        let r = this.cache.get(i);
        if (!r) {
            switch (e) {
            case "scene":
                r = this.loadScene(t);
                break;
            case "node":
                r = this.loadNode(t);
                break;
            case "mesh":
                r = this._invokeOne(function(s) {
                    return s.loadMesh && s.loadMesh(t)
                });
                break;
            case "accessor":
                r = this.loadAccessor(t);
                break;
            case "bufferView":
                r = this._invokeOne(function(s) {
                    return s.loadBufferView && s.loadBufferView(t)
                });
                break;
            case "buffer":
                r = this.loadBuffer(t);
                break;
            case "material":
                r = this._invokeOne(function(s) {
                    return s.loadMaterial && s.loadMaterial(t)
                });
                break;
            case "texture":
                r = this._invokeOne(function(s) {
                    return s.loadTexture && s.loadTexture(t)
                });
                break;
            case "skin":
                r = this.loadSkin(t);
                break;
            case "animation":
                r = this._invokeOne(function(s) {
                    return s.loadAnimation && s.loadAnimation(t)
                });
                break;
            case "camera":
                r = this.loadCamera(t);
                break;
            default:
                throw new Error("Unknown type: " + e)
            }
            this.cache.add(i, r)
        }
        return r
    }
    getDependencies(e) {
        let t = this.cache.get(e);
        if (!t) {
            const i = this
              , r = this.json[e + (e === "mesh" ? "es" : "s")] || [];
            t = Promise.all(r.map(function(s, o) {
                return i.getDependency(e, o)
            })),
            this.cache.add(e, t)
        }
        return t
    }
    loadBuffer(e) {
        const t = this.json.buffers[e]
          , i = this.fileLoader;
        if (t.type && t.type !== "arraybuffer")
            throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
        if (t.uri === void 0 && e === 0)
            return Promise.resolve(this.extensions[_t.KHR_BINARY_GLTF].body);
        const r = this.options;
        return new Promise(function(s, o) {
            i.load(ss.resolveURL(t.uri, r.path), s, void 0, function() {
                o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
            })
        }
        )
    }
    loadBufferView(e) {
        const t = this.json.bufferViews[e];
        return this.getDependency("buffer", t.buffer).then(function(i) {
            const r = t.byteLength || 0
              , s = t.byteOffset || 0;
            return i.slice(s, s + r)
        })
    }
    loadAccessor(e) {
        const t = this
          , i = this.json
          , r = this.json.accessors[e];
        if (r.bufferView === void 0 && r.sparse === void 0)
            return Promise.resolve(null);
        const s = [];
        return r.bufferView !== void 0 ? s.push(this.getDependency("bufferView", r.bufferView)) : s.push(null),
        r.sparse !== void 0 && (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)),
        s.push(this.getDependency("bufferView", r.sparse.values.bufferView))),
        Promise.all(s).then(function(o) {
            const a = o[0]
              , l = TT[r.type]
              , c = dd[r.componentType]
              , d = c.BYTES_PER_ELEMENT
              , h = d * l
              , p = r.byteOffset || 0
              , m = r.bufferView !== void 0 ? i.bufferViews[r.bufferView].byteStride : void 0
              , y = r.normalized === !0;
            let v, _;
            if (m && m !== h) {
                const x = Math.floor(p / m)
                  , A = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + x + ":" + r.count;
                let M = t.cache.get(A);
                M || (v = new c(a,x * m,r.count * m / d),
                M = new Bd(v,m / d),
                t.cache.add(A, M)),
                _ = new Jo(M,l,p % m / d,y)
            } else
                a === null ? v = new c(r.count * l) : v = new c(a,p,r.count * l),
                _ = new Ft(v,l,y);
            if (r.sparse !== void 0) {
                const x = TT.SCALAR
                  , A = dd[r.sparse.indices.componentType]
                  , M = r.sparse.indices.byteOffset || 0
                  , S = r.sparse.values.byteOffset || 0
                  , T = new A(o[1],M,r.sparse.count * x)
                  , P = new c(o[2],S,r.sparse.count * l);
                a !== null && (_ = new Ft(_.array.slice(),_.itemSize,_.normalized));
                for (let R = 0, E = T.length; R < E; R++) {
                    const B = T[R];
                    if (_.setX(B, P[R * l]),
                    l >= 2 && _.setY(B, P[R * l + 1]),
                    l >= 3 && _.setZ(B, P[R * l + 2]),
                    l >= 4 && _.setW(B, P[R * l + 3]),
                    l >= 5)
                        throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                }
            }
            return _
        })
    }
    loadTexture(e) {
        const t = this.json
          , i = this.options
          , s = t.textures[e].source
          , o = t.images[s];
        let a = this.textureLoader;
        if (o.uri) {
            const l = i.manager.getHandler(o.uri);
            l !== null && (a = l)
        }
        return this.loadTextureImage(e, s, a)
    }
    loadTextureImage(e, t, i) {
        const r = this
          , s = this.json
          , o = s.textures[e]
          , a = s.images[t]
          , l = (a.uri || a.bufferView) + ":" + o.sampler;
        if (this.textureCache[l])
            return this.textureCache[l];
        const c = this.loadImageSource(t, i).then(function(d) {
            d.flipY = !1,
            o.name && (d.name = o.name);
            const p = (s.samplers || {})[o.sampler] || {};
            return d.magFilter = CT[p.magFilter] || nn,
            d.minFilter = CT[p.minFilter] || ls,
            d.wrapS = ET[p.wrapS] || jo,
            d.wrapT = ET[p.wrapT] || jo,
            r.associations.set(d, {
                textures: e
            }),
            d
        }).catch(function() {
            return null
        });
        return this.textureCache[l] = c,
        c
    }
    loadImageSource(e, t) {
        const i = this
          , r = this.json
          , s = this.options;
        if (this.sourceCache[e] !== void 0)
            return this.sourceCache[e].then(h=>h.clone());
        const o = r.images[e]
          , a = self.URL || self.webkitURL;
        let l = o.uri || ""
          , c = !1;
        if (o.bufferView !== void 0)
            l = i.getDependency("bufferView", o.bufferView).then(function(h) {
                c = !0;
                const p = new Blob([h],{
                    type: o.mimeType
                });
                return l = a.createObjectURL(p),
                l
            });
        else if (o.uri === void 0)
            throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
        const d = Promise.resolve(l).then(function(h) {
            return new Promise(function(p, m) {
                let y = p;
                t.isImageBitmapLoader === !0 && (y = function(v) {
                    const _ = new qt(v);
                    _.needsUpdate = !0,
                    p(_)
                }
                ),
                t.load(ss.resolveURL(h, s.path), y, void 0, m)
            }
            )
        }).then(function(h) {
            return c === !0 && a.revokeObjectURL(l),
            h.userData.mimeType = o.mimeType || _V(o.uri),
            h
        }).catch(function(h) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", l),
            h
        });
        return this.sourceCache[e] = d,
        d
    }
    assignTexture(e, t, i, r) {
        const s = this;
        return this.getDependency("texture", i.index).then(function(o) {
            if (i.texCoord !== void 0 && i.texCoord != 0 && !(t === "aoMap" && i.texCoord == 1) && console.warn("THREE.GLTFLoader: Custom UV set " + i.texCoord + " for texture " + t + " not yet supported."),
            s.extensions[_t.KHR_TEXTURE_TRANSFORM]) {
                const a = i.extensions !== void 0 ? i.extensions[_t.KHR_TEXTURE_TRANSFORM] : void 0;
                if (a) {
                    const l = s.associations.get(o);
                    o = s.extensions[_t.KHR_TEXTURE_TRANSFORM].extendTexture(o, a),
                    s.associations.set(o, l)
                }
            }
            return r !== void 0 && (o.encoding = r),
            e[t] = o,
            o
        })
    }
    assignFinalMaterial(e) {
        const t = e.geometry;
        let i = e.material;
        const r = t.attributes.tangent === void 0
          , s = t.attributes.color !== void 0
          , o = t.attributes.normal === void 0;
        if (e.isPoints) {
            const a = "PointsMaterial:" + i.uuid;
            let l = this.cache.get(a);
            l || (l = new Ld,
            Sn.prototype.copy.call(l, i),
            l.color.copy(i.color),
            l.map = i.map,
            l.sizeAttenuation = !1,
            this.cache.add(a, l)),
            i = l
        } else if (e.isLine) {
            const a = "LineBasicMaterial:" + i.uuid;
            let l = this.cache.get(a);
            l || (l = new ri,
            Sn.prototype.copy.call(l, i),
            l.color.copy(i.color),
            this.cache.add(a, l)),
            i = l
        }
        if (r || s || o) {
            let a = "ClonedMaterial:" + i.uuid + ":";
            i.isGLTFSpecularGlossinessMaterial && (a += "specular-glossiness:"),
            r && (a += "derivative-tangents:"),
            s && (a += "vertex-colors:"),
            o && (a += "flat-shading:");
            let l = this.cache.get(a);
            l || (l = i.clone(),
            s && (l.vertexColors = !0),
            o && (l.flatShading = !0),
            r && (l.normalScale && (l.normalScale.y *= -1),
            l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
            this.cache.add(a, l),
            this.associations.set(l, this.associations.get(i))),
            i = l
        }
        i.aoMap && t.attributes.uv2 === void 0 && t.attributes.uv !== void 0 && t.setAttribute("uv2", t.attributes.uv),
        e.material = i
    }
    getMaterialType() {
        return rc
    }
    loadMaterial(e) {
        const t = this
          , i = this.json
          , r = this.extensions
          , s = i.materials[e];
        let o;
        const a = {}
          , l = s.extensions || {}
          , c = [];
        if (l[_t.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
            const h = r[_t.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
            o = h.getMaterialType(),
            c.push(h.extendParams(a, s, t))
        } else if (l[_t.KHR_MATERIALS_UNLIT]) {
            const h = r[_t.KHR_MATERIALS_UNLIT];
            o = h.getMaterialType(),
            c.push(h.extendParams(a, s, t))
        } else {
            const h = s.pbrMetallicRoughness || {};
            if (a.color = new Le(1,1,1),
            a.opacity = 1,
            Array.isArray(h.baseColorFactor)) {
                const p = h.baseColorFactor;
                a.color.fromArray(p),
                a.opacity = p[3]
            }
            h.baseColorTexture !== void 0 && c.push(t.assignTexture(a, "map", h.baseColorTexture, Et)),
            a.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1,
            a.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1,
            h.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(a, "metalnessMap", h.metallicRoughnessTexture)),
            c.push(t.assignTexture(a, "roughnessMap", h.metallicRoughnessTexture))),
            o = this._invokeOne(function(p) {
                return p.getMaterialType && p.getMaterialType(e)
            }),
            c.push(Promise.all(this._invokeAll(function(p) {
                return p.extendMaterialParams && p.extendMaterialParams(e, a)
            })))
        }
        s.doubleSided === !0 && (a.side = Ir);
        const d = s.alphaMode || Ov.OPAQUE;
        if (d === Ov.BLEND ? (a.transparent = !0,
        a.depthWrite = !1) : (a.transparent = !1,
        d === Ov.MASK && (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : .5)),
        s.normalTexture !== void 0 && o !== Gi && (c.push(t.assignTexture(a, "normalMap", s.normalTexture)),
        a.normalScale = new pe(1,1),
        s.normalTexture.scale !== void 0)) {
            const h = s.normalTexture.scale;
            a.normalScale.set(h, h)
        }
        return s.occlusionTexture !== void 0 && o !== Gi && (c.push(t.assignTexture(a, "aoMap", s.occlusionTexture)),
        s.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = s.occlusionTexture.strength)),
        s.emissiveFactor !== void 0 && o !== Gi && (a.emissive = new Le().fromArray(s.emissiveFactor)),
        s.emissiveTexture !== void 0 && o !== Gi && c.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, Et)),
        Promise.all(c).then(function() {
            let h;
            return o === X1 ? h = r[_t.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : h = new o(a),
            s.name && (h.name = s.name),
            Ra(h, s),
            t.associations.set(h, {
                materials: e
            }),
            s.extensions && Zc(r, h, s),
            h
        })
    }
    createUniqueName(e) {
        const t = bt.sanitizeNodeName(e || "");
        let i = t;
        for (let r = 1; this.nodeNamesUsed[i]; ++r)
            i = t + "_" + r;
        return this.nodeNamesUsed[i] = !0,
        i
    }
    loadGeometries(e) {
        const t = this
          , i = this.extensions
          , r = this.primitiveCache;
        function s(a) {
            return i[_t.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(l) {
                return PT(l, a, t)
            })
        }
        const o = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a]
              , d = xV(c)
              , h = r[d];
            if (h)
                o.push(h.promise);
            else {
                let p;
                c.extensions && c.extensions[_t.KHR_DRACO_MESH_COMPRESSION] ? p = s(c) : p = PT(new ct, c, t),
                r[d] = {
                    primitive: c,
                    promise: p
                },
                o.push(p)
            }
        }
        return Promise.all(o)
    }
    loadMesh(e) {
        const t = this
          , i = this.json
          , r = this.extensions
          , s = i.meshes[e]
          , o = s.primitives
          , a = [];
        for (let l = 0, c = o.length; l < c; l++) {
            const d = o[l].material === void 0 ? gV(this.cache) : this.getDependency("material", o[l].material);
            a.push(d)
        }
        return a.push(t.loadGeometries(o)),
        Promise.all(a).then(function(l) {
            const c = l.slice(0, l.length - 1)
              , d = l[l.length - 1]
              , h = [];
            for (let m = 0, y = d.length; m < y; m++) {
                const v = d[m]
                  , _ = o[m];
                let x;
                const A = c[m];
                if (_.mode === Ts.TRIANGLES || _.mode === Ts.TRIANGLE_STRIP || _.mode === Ts.TRIANGLE_FAN || _.mode === void 0)
                    x = s.isSkinnedMesh === !0 ? new RA(v,A) : new Un(v,A),
                    x.isSkinnedMesh === !0 && !x.geometry.attributes.skinWeight.normalized && x.normalizeSkinWeights(),
                    _.mode === Ts.TRIANGLE_STRIP ? x.geometry = BT(x.geometry, sB) : _.mode === Ts.TRIANGLE_FAN && (x.geometry = BT(x.geometry, yA));
                else if (_.mode === Ts.LINES)
                    x = new Gr(v,A);
                else if (_.mode === Ts.LINE_STRIP)
                    x = new Ks(v,A);
                else if (_.mode === Ts.LINE_LOOP)
                    x = new LA(v,A);
                else if (_.mode === Ts.POINTS)
                    x = new IA(v,A);
                else
                    throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + _.mode);
                Object.keys(x.geometry.morphAttributes).length > 0 && vV(x, s),
                x.name = t.createUniqueName(s.name || "mesh_" + e),
                Ra(x, s),
                _.extensions && Zc(r, x, _),
                t.assignFinalMaterial(x),
                h.push(x)
            }
            for (let m = 0, y = h.length; m < y; m++)
                t.associations.set(h[m], {
                    meshes: e,
                    primitives: m
                });
            if (h.length === 1)
                return h[0];
            const p = new ks;
            t.associations.set(p, {
                meshes: e
            });
            for (let m = 0, y = h.length; m < y; m++)
                p.add(h[m]);
            return p
        })
    }
    loadCamera(e) {
        let t;
        const i = this.json.cameras[e]
          , r = i[i.type];
        if (!r) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return
        }
        return i.type === "perspective" ? t = new Ht(fB.radToDeg(r.yfov),r.aspectRatio || 1,r.znear || 1,r.zfar || 2e6) : i.type === "orthographic" && (t = new Nr(-r.xmag,r.xmag,r.ymag,-r.ymag,r.znear,r.zfar)),
        i.name && (t.name = this.createUniqueName(i.name)),
        Ra(t, i),
        Promise.resolve(t)
    }
    loadSkin(e) {
        const t = this.json.skins[e]
          , i = {
            joints: t.joints
        };
        return t.inverseBindMatrices === void 0 ? Promise.resolve(i) : this.getDependency("accessor", t.inverseBindMatrices).then(function(r) {
            return i.inverseBindMatrices = r,
            i
        })
    }
    loadAnimation(e) {
        const i = this.json.animations[e]
          , r = []
          , s = []
          , o = []
          , a = []
          , l = [];
        for (let c = 0, d = i.channels.length; c < d; c++) {
            const h = i.channels[c]
              , p = i.samplers[h.sampler]
              , m = h.target
              , y = m.node
              , v = i.parameters !== void 0 ? i.parameters[p.input] : p.input
              , _ = i.parameters !== void 0 ? i.parameters[p.output] : p.output;
            r.push(this.getDependency("node", y)),
            s.push(this.getDependency("accessor", v)),
            o.push(this.getDependency("accessor", _)),
            a.push(p),
            l.push(m)
        }
        return Promise.all([Promise.all(r), Promise.all(s), Promise.all(o), Promise.all(a), Promise.all(l)]).then(function(c) {
            const d = c[0]
              , h = c[1]
              , p = c[2]
              , m = c[3]
              , y = c[4]
              , v = [];
            for (let x = 0, A = d.length; x < A; x++) {
                const M = d[x]
                  , S = h[x]
                  , T = p[x]
                  , P = m[x]
                  , R = y[x];
                if (M === void 0)
                    continue;
                M.updateMatrix();
                let E;
                switch (po[R.path]) {
                case po.weights:
                    E = Hu;
                    break;
                case po.rotation:
                    E = Xo;
                    break;
                case po.position:
                case po.scale:
                default:
                    E = Vu;
                    break
                }
                const B = M.name ? M.name : M.uuid
                  , L = P.interpolation !== void 0 ? mV[P.interpolation] : al
                  , z = [];
                po[R.path] === po.weights ? M.traverse(function(J) {
                    J.morphTargetInfluences && z.push(J.name ? J.name : J.uuid)
                }) : z.push(B);
                let Z = T.array;
                if (T.normalized) {
                    const J = Y1(Z.constructor)
                      , G = new Float32Array(Z.length);
                    for (let X = 0, ee = Z.length; X < ee; X++)
                        G[X] = Z[X] * J;
                    Z = G
                }
                for (let J = 0, G = z.length; J < G; J++) {
                    const X = new E(z[J] + "." + po[R.path],S.array,Z,L);
                    P.interpolation === "CUBICSPLINE" && (X.createInterpolant = function(ie) {
                        const F = this instanceof Xo ? pV : DR;
                        return new F(this.times,this.values,this.getValueSize() / 3,ie)
                    }
                    ,
                    X.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0),
                    v.push(X)
                }
            }
            const _ = i.name ? i.name : "animation_" + e;
            return new Wu(_,void 0,v)
        })
    }
    createNodeMesh(e) {
        const t = this.json
          , i = this
          , r = t.nodes[e];
        return r.mesh === void 0 ? null : i.getDependency("mesh", r.mesh).then(function(s) {
            const o = i._getNodeRef(i.meshCache, r.mesh, s);
            return r.weights !== void 0 && o.traverse(function(a) {
                if (a.isMesh)
                    for (let l = 0, c = r.weights.length; l < c; l++)
                        a.morphTargetInfluences[l] = r.weights[l]
            }),
            o
        })
    }
    loadNode(e) {
        const t = this.json
          , i = this.extensions
          , r = this
          , s = t.nodes[e]
          , o = s.name ? r.createUniqueName(s.name) : "";
        return function() {
            const a = []
              , l = r._invokeOne(function(c) {
                return c.createNodeMesh && c.createNodeMesh(e)
            });
            return l && a.push(l),
            s.camera !== void 0 && a.push(r.getDependency("camera", s.camera).then(function(c) {
                return r._getNodeRef(r.cameraCache, s.camera, c)
            })),
            r._invokeAll(function(c) {
                return c.createNodeAttachment && c.createNodeAttachment(e)
            }).forEach(function(c) {
                a.push(c)
            }),
            Promise.all(a)
        }().then(function(a) {
            let l;
            if (s.isBone === !0 ? l = new t0 : a.length > 1 ? l = new ks : a.length === 1 ? l = a[0] : l = new Rt,
            l !== a[0])
                for (let c = 0, d = a.length; c < d; c++)
                    l.add(a[c]);
            if (s.name && (l.userData.name = s.name,
            l.name = o),
            Ra(l, s),
            s.extensions && Zc(i, l, s),
            s.matrix !== void 0) {
                const c = new rt;
                c.fromArray(s.matrix),
                l.applyMatrix4(c)
            } else
                s.translation !== void 0 && l.position.fromArray(s.translation),
                s.rotation !== void 0 && l.quaternion.fromArray(s.rotation),
                s.scale !== void 0 && l.scale.fromArray(s.scale);
            return r.associations.has(l) || r.associations.set(l, {}),
            r.associations.get(l).nodes = e,
            l
        })
    }
    loadScene(e) {
        const t = this.json
          , i = this.extensions
          , r = this.json.scenes[e]
          , s = this
          , o = new ks;
        r.name && (o.name = s.createUniqueName(r.name)),
        Ra(o, r),
        r.extensions && Zc(i, o, r);
        const a = r.nodes || []
          , l = [];
        for (let c = 0, d = a.length; c < d; c++)
            l.push(FR(a[c], o, t, s));
        return Promise.all(l).then(function() {
            const c = d=>{
                const h = new Map;
                for (const [p,m] of s.associations)
                    (p instanceof Sn || p instanceof qt) && h.set(p, m);
                return d.traverse(p=>{
                    const m = s.associations.get(p);
                    m != null && h.set(p, m)
                }
                ),
                h
            }
            ;
            return s.associations = c(o),
            o
        })
    }
}
function FR(n, e, t, i) {
    const r = t.nodes[n];
    return i.getDependency("node", n).then(function(s) {
        if (r.skin === void 0)
            return s;
        let o;
        return i.getDependency("skin", r.skin).then(function(a) {
            o = a;
            const l = [];
            for (let c = 0, d = o.joints.length; c < d; c++)
                l.push(i.getDependency("node", o.joints[c]));
            return Promise.all(l)
        }).then(function(a) {
            return s.traverse(function(l) {
                if (!l.isMesh)
                    return;
                const c = []
                  , d = [];
                for (let h = 0, p = a.length; h < p; h++) {
                    const m = a[h];
                    if (m) {
                        c.push(m);
                        const y = new rt;
                        o.inverseBindMatrices !== void 0 && y.fromArray(o.inverseBindMatrices.array, h * 16),
                        d.push(y)
                    } else
                        console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', o.joints[h])
                }
                l.bind(new Rd(c,d), l.matrixWorld)
            }),
            s
        })
    }).then(function(s) {
        e.add(s);
        const o = [];
        if (r.children) {
            const a = r.children;
            for (let l = 0, c = a.length; l < c; l++) {
                const d = a[l];
                o.push(FR(d, s, t, i))
            }
        }
        return Promise.all(o)
    })
}
function MV(n, e, t) {
    const i = e.attributes
      , r = new ta;
    if (i.POSITION !== void 0) {
        const a = t.json.accessors[i.POSITION]
          , l = a.min
          , c = a.max;
        if (l !== void 0 && c !== void 0) {
            if (r.set(new D(l[0],l[1],l[2]), new D(c[0],c[1],c[2])),
            a.normalized) {
                const d = Y1(dd[a.componentType]);
                r.min.multiplyScalar(d),
                r.max.multiplyScalar(d)
            }
        } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return
        }
    } else
        return;
    const s = e.targets;
    if (s !== void 0) {
        const a = new D
          , l = new D;
        for (let c = 0, d = s.length; c < d; c++) {
            const h = s[c];
            if (h.POSITION !== void 0) {
                const p = t.json.accessors[h.POSITION]
                  , m = p.min
                  , y = p.max;
                if (m !== void 0 && y !== void 0) {
                    if (l.setX(Math.max(Math.abs(m[0]), Math.abs(y[0]))),
                    l.setY(Math.max(Math.abs(m[1]), Math.abs(y[1]))),
                    l.setZ(Math.max(Math.abs(m[2]), Math.abs(y[2]))),
                    p.normalized) {
                        const v = Y1(dd[p.componentType]);
                        l.multiplyScalar(v)
                    }
                    a.max(l)
                } else
                    console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
            }
        }
        r.expandByVector(a)
    }
    n.boundingBox = r;
    const o = new na;
    r.getCenter(o.center),
    o.radius = r.min.distanceTo(r.max) / 2,
    n.boundingSphere = o
}
function PT(n, e, t) {
    const i = e.attributes
      , r = [];
    function s(o, a) {
        return t.getDependency("accessor", o).then(function(l) {
            n.setAttribute(a, l)
        })
    }
    for (const o in i) {
        const a = K1[o] || o.toLowerCase();
        a in n.attributes || r.push(s(i[o], a))
    }
    if (e.indices !== void 0 && !n.index) {
        const o = t.getDependency("accessor", e.indices).then(function(a) {
            n.setIndex(a)
        });
        r.push(o)
    }
    return Ra(n, e),
    MV(n, e, t),
    Promise.all(r).then(function() {
        return e.targets !== void 0 ? yV(n, e.targets, t) : n
    })
}
function BT(n, e) {
    let t = n.getIndex();
    if (t === null) {
        const o = []
          , a = n.getAttribute("position");
        if (a !== void 0) {
            for (let l = 0; l < a.count; l++)
                o.push(l);
            n.setIndex(o),
            t = n.getIndex()
        } else
            return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
            n
    }
    const i = t.count - 2
      , r = [];
    if (e === yA)
        for (let o = 1; o <= i; o++)
            r.push(t.getX(0)),
            r.push(t.getX(o)),
            r.push(t.getX(o + 1));
    else
        for (let o = 0; o < i; o++)
            o % 2 === 0 ? (r.push(t.getX(o)),
            r.push(t.getX(o + 1)),
            r.push(t.getX(o + 2))) : (r.push(t.getX(o + 2)),
            r.push(t.getX(o + 1)),
            r.push(t.getX(o)));
    r.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const s = n.clone();
    return s.setIndex(r),
    s
}
const Uv = new WeakMap;
class wV extends vi {
    constructor(e) {
        super(e),
        this.decoderPath = "",
        this.decoderConfig = {},
        this.decoderBinary = null,
        this.decoderPending = null,
        this.workerLimit = 4,
        this.workerPool = [],
        this.workerNextTaskID = 1,
        this.workerSourceURL = "",
        this.defaultAttributeIDs = {
            position: "POSITION",
            normal: "NORMAL",
            color: "COLOR",
            uv: "TEX_COORD"
        },
        this.defaultAttributeTypes = {
            position: "Float32Array",
            normal: "Float32Array",
            color: "Float32Array",
            uv: "Float32Array"
        }
    }
    setDecoderPath(e) {
        return this.decoderPath = e,
        this
    }
    setDecoderConfig(e) {
        return this.decoderConfig = e,
        this
    }
    setWorkerLimit(e) {
        return this.workerLimit = e,
        this
    }
    load(e, t, i, r) {
        const s = new ji(this.manager);
        s.setPath(this.path),
        s.setResponseType("arraybuffer"),
        s.setRequestHeader(this.requestHeader),
        s.setWithCredentials(this.withCredentials),
        s.load(e, o=>{
            const a = {
                attributeIDs: this.defaultAttributeIDs,
                attributeTypes: this.defaultAttributeTypes,
                useUniqueIDs: !1
            };
            this.decodeGeometry(o, a).then(t).catch(r)
        }
        , i, r)
    }
    decodeDracoFile(e, t, i, r) {
        const s = {
            attributeIDs: i || this.defaultAttributeIDs,
            attributeTypes: r || this.defaultAttributeTypes,
            useUniqueIDs: !!i
        };
        this.decodeGeometry(e, s).then(t)
    }
    decodeGeometry(e, t) {
        for (const l in t.attributeTypes) {
            const c = t.attributeTypes[l];
            c.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = c.name)
        }
        const i = JSON.stringify(t);
        if (Uv.has(e)) {
            const l = Uv.get(e);
            if (l.key === i)
                return l.promise;
            if (e.byteLength === 0)
                throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
        }
        let r;
        const s = this.workerNextTaskID++
          , o = e.byteLength
          , a = this._getWorker(s, o).then(l=>(r = l,
        new Promise((c,d)=>{
            r._callbacks[s] = {
                resolve: c,
                reject: d
            },
            r.postMessage({
                type: "decode",
                id: s,
                taskConfig: t,
                buffer: e
            }, [e])
        }
        ))).then(l=>this._createGeometry(l.geometry));
        return a.catch(()=>!0).then(()=>{
            r && s && this._releaseTask(r, s)
        }
        ),
        Uv.set(e, {
            key: i,
            promise: a
        }),
        a
    }
    _createGeometry(e) {
        const t = new ct;
        e.index && t.setIndex(new Ft(e.index.array,1));
        for (let i = 0; i < e.attributes.length; i++) {
            const r = e.attributes[i]
              , s = r.name
              , o = r.array
              , a = r.itemSize;
            t.setAttribute(s, new Ft(o,a))
        }
        return t
    }
    _loadLibrary(e, t) {
        const i = new ji(this.manager);
        return i.setPath(this.decoderPath),
        i.setResponseType(t),
        i.setWithCredentials(this.withCredentials),
        new Promise((r,s)=>{
            i.load(e, r, void 0, s)
        }
        )
    }
    preload() {
        return this._initDecoder(),
        this
    }
    _initDecoder() {
        if (this.decoderPending)
            return this.decoderPending;
        const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js"
          , t = [];
        return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
        t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
        this.decoderPending = Promise.all(t).then(i=>{
            const r = i[0];
            e || (this.decoderConfig.wasmBinary = i[1]);
            const s = SV.toString()
              , o = ["/* draco decoder */", r, "", "/* worker */", s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))].join(`
`);
            this.workerSourceURL = URL.createObjectURL(new Blob([o]))
        }
        ),
        this.decoderPending
    }
    _getWorker(e, t) {
        return this._initDecoder().then(()=>{
            if (this.workerPool.length < this.workerLimit) {
                const r = new Worker(this.workerSourceURL);
                r._callbacks = {},
                r._taskCosts = {},
                r._taskLoad = 0,
                r.postMessage({
                    type: "init",
                    decoderConfig: this.decoderConfig
                }),
                r.onmessage = function(s) {
                    const o = s.data;
                    switch (o.type) {
                    case "decode":
                        r._callbacks[o.id].resolve(o);
                        break;
                    case "error":
                        r._callbacks[o.id].reject(o);
                        break;
                    default:
                        console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"')
                    }
                }
                ,
                this.workerPool.push(r)
            } else
                this.workerPool.sort(function(r, s) {
                    return r._taskLoad > s._taskLoad ? -1 : 1
                });
            const i = this.workerPool[this.workerPool.length - 1];
            return i._taskCosts[e] = t,
            i._taskLoad += t,
            i
        }
        )
    }
    _releaseTask(e, t) {
        e._taskLoad -= e._taskCosts[t],
        delete e._callbacks[t],
        delete e._taskCosts[t]
    }
    debug() {
        console.log("Task load: ", this.workerPool.map(e=>e._taskLoad))
    }
    dispose() {
        for (let e = 0; e < this.workerPool.length; ++e)
            this.workerPool[e].terminate();
        return this.workerPool.length = 0,
        this
    }
}
function SV() {
    let n, e;
    onmessage = function(o) {
        const a = o.data;
        switch (a.type) {
        case "init":
            n = a.decoderConfig,
            e = new Promise(function(d) {
                n.onModuleLoaded = function(h) {
                    d({
                        draco: h
                    })
                }
                ,
                DracoDecoderModule(n)
            }
            );
            break;
        case "decode":
            const l = a.buffer
              , c = a.taskConfig;
            e.then(d=>{
                const h = d.draco
                  , p = new h.Decoder
                  , m = new h.DecoderBuffer;
                m.Init(new Int8Array(l), l.byteLength);
                try {
                    const y = t(h, p, m, c)
                      , v = y.attributes.map(_=>_.array.buffer);
                    y.index && v.push(y.index.array.buffer),
                    self.postMessage({
                        type: "decode",
                        id: a.id,
                        geometry: y
                    }, v)
                } catch (y) {
                    console.error(y),
                    self.postMessage({
                        type: "error",
                        id: a.id,
                        error: y.message
                    })
                } finally {
                    h.destroy(m),
                    h.destroy(p)
                }
            }
            );
            break
        }
    }
    ;
    function t(o, a, l, c) {
        const d = c.attributeIDs
          , h = c.attributeTypes;
        let p, m;
        const y = a.GetEncodedGeometryType(l);
        if (y === o.TRIANGULAR_MESH)
            p = new o.Mesh,
            m = a.DecodeBufferToMesh(l, p);
        else if (y === o.POINT_CLOUD)
            p = new o.PointCloud,
            m = a.DecodeBufferToPointCloud(l, p);
        else
            throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
        if (!m.ok() || p.ptr === 0)
            throw new Error("THREE.DRACOLoader: Decoding failed: " + m.error_msg());
        const v = {
            index: null,
            attributes: []
        };
        for (const _ in d) {
            const x = self[h[_]];
            let A, M;
            if (c.useUniqueIDs)
                M = d[_],
                A = a.GetAttributeByUniqueId(p, M);
            else {
                if (M = a.GetAttributeId(p, o[d[_]]),
                M === -1)
                    continue;
                A = a.GetAttribute(p, M)
            }
            v.attributes.push(r(o, a, p, _, x, A))
        }
        return y === o.TRIANGULAR_MESH && (v.index = i(o, a, p)),
        o.destroy(p),
        v
    }
    function i(o, a, l) {
        const d = l.num_faces() * 3
          , h = d * 4
          , p = o._malloc(h);
        a.GetTrianglesUInt32Array(l, h, p);
        const m = new Uint32Array(o.HEAPF32.buffer,p,d).slice();
        return o._free(p),
        {
            array: m,
            itemSize: 1
        }
    }
    function r(o, a, l, c, d, h) {
        const p = h.num_components()
          , y = l.num_points() * p
          , v = y * d.BYTES_PER_ELEMENT
          , _ = s(o, d)
          , x = o._malloc(v);
        a.GetAttributeDataArrayForAllPoints(l, h, _, v, x);
        const A = new d(o.HEAPF32.buffer,x,y).slice();
        return o._free(x),
        {
            name: c,
            array: A,
            itemSize: p
        }
    }
    function s(o, a) {
        switch (a) {
        case Float32Array:
            return o.DT_FLOAT32;
        case Int8Array:
            return o.DT_INT8;
        case Int16Array:
            return o.DT_INT16;
        case Int32Array:
            return o.DT_INT32;
        case Uint8Array:
            return o.DT_UINT8;
        case Uint16Array:
            return o.DT_UINT16;
        case Uint32Array:
            return o.DT_UINT32
        }
    }
}
let nm;
const zv = ()=>{
    if (nm)
        return nm;
    const n = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB"
      , e = "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB"
      , t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11])
      , i = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]);
    if (typeof WebAssembly != "object")
        return {
            supported: !1
        };
    let r = n;
    WebAssembly.validate(t) && (r = e);
    let s;
    const o = WebAssembly.instantiate(a(r), {}).then(h=>{
        s = h.instance,
        s.exports.__wasm_call_ctors()
    }
    );
    function a(h) {
        const p = new Uint8Array(h.length);
        for (let y = 0; y < h.length; ++y) {
            const v = h.charCodeAt(y);
            p[y] = v > 96 ? v - 71 : v > 64 ? v - 65 : v > 47 ? v + 4 : v > 46 ? 63 : 62
        }
        let m = 0;
        for (let y = 0; y < h.length; ++y)
            p[m++] = p[y] < 60 ? i[p[y]] : (p[y] - 60) * 64 + p[++y];
        return p.buffer.slice(0, m)
    }
    function l(h, p, m, y, v, _) {
        const x = s.exports.sbrk
          , A = m + 3 & -4
          , M = x(A * y)
          , S = x(v.length)
          , T = new Uint8Array(s.exports.memory.buffer);
        T.set(v, S);
        const P = h(M, m, y, S, v.length);
        if (P === 0 && _ && _(M, A, y),
        p.set(T.subarray(M, M + m * y)),
        x(M - x(0)),
        P !== 0)
            throw new Error(`Malformed buffer data: ${P}`)
    }
    const c = {
        0: "",
        1: "meshopt_decodeFilterOct",
        2: "meshopt_decodeFilterQuat",
        3: "meshopt_decodeFilterExp",
        NONE: "",
        OCTAHEDRAL: "meshopt_decodeFilterOct",
        QUATERNION: "meshopt_decodeFilterQuat",
        EXPONENTIAL: "meshopt_decodeFilterExp"
    }
      , d = {
        0: "meshopt_decodeVertexBuffer",
        1: "meshopt_decodeIndexBuffer",
        2: "meshopt_decodeIndexSequence",
        ATTRIBUTES: "meshopt_decodeVertexBuffer",
        TRIANGLES: "meshopt_decodeIndexBuffer",
        INDICES: "meshopt_decodeIndexSequence"
    };
    return nm = {
        ready: o,
        supported: !0,
        decodeVertexBuffer(h, p, m, y, v) {
            l(s.exports.meshopt_decodeVertexBuffer, h, p, m, y, s.exports[c[v]])
        },
        decodeIndexBuffer(h, p, m, y) {
            l(s.exports.meshopt_decodeIndexBuffer, h, p, m, y)
        },
        decodeIndexSequence(h, p, m, y) {
            l(s.exports.meshopt_decodeIndexSequence, h, p, m, y)
        },
        decodeGltfBuffer(h, p, m, y, v, _) {
            l(s.exports[d[v]], h, p, m, y, s.exports[c[_]])
        }
    },
    nm
}
;
let im = null;
function kR(n, e, t) {
    return i=>{
        t && t(i),
        n && (im || (im = new wV),
        im.setDecoderPath(typeof n == "string" ? n : "https://www.gstatic.com/draco/versioned/decoders/1.5.5/"),
        i.setDRACOLoader(im)),
        e && i.setMeshoptDecoder(typeof zv == "function" ? zv() : zv)
    }
}
function rM(n, e=!0, t=!0, i) {
    return Xd(iM, n, kR(e, t, i))
}
rM.preload = (n,e=!0,t=!0,i)=>Xd.preload(iM, n, kR(e, t, i));
rM.clear = n=>Xd.clear(iM, n);
const CV = O.forwardRef(({makeDefault: n, camera: e, regress: t, domElement: i, enableDamping: r=!0, onChange: s, onStart: o, onEnd: a, ...l},c)=>{
    const d = fr(T=>T.invalidate)
      , h = fr(T=>T.camera)
      , p = fr(T=>T.gl)
      , m = fr(T=>T.events)
      , y = fr(T=>T.setEvents)
      , v = fr(T=>T.set)
      , _ = fr(T=>T.get)
      , x = fr(T=>T.performance)
      , A = e || h
      , M = i || m.connected || p.domElement
      , S = O.useMemo(()=>new X6(A), [A]);
    return Jd(()=>{
        S.enabled && S.update()
    }
    , -1),
    O.useEffect(()=>(S.connect(M),
    ()=>void S.dispose()), [M, t, S, d]),
    O.useEffect(()=>{
        const T = E=>{
            d(),
            t && x.regress(),
            s && s(E)
        }
          , P = E=>{
            o && o(E)
        }
          , R = E=>{
            a && a(E)
        }
        ;
        return S.addEventListener("change", T),
        S.addEventListener("start", P),
        S.addEventListener("end", R),
        ()=>{
            S.removeEventListener("start", P),
            S.removeEventListener("end", R),
            S.removeEventListener("change", T)
        }
    }
    , [s, o, a, S, d, y]),
    O.useEffect(()=>{
        if (n) {
            const T = _().controls;
            return v({
                controls: S
            }),
            ()=>v({
                controls: T
            })
        }
    }
    , [n, S]),
    O.createElement("primitive", zr({
        ref: c,
        object: S,
        enableDamping: r
    }, l))
}
);
class EV extends Ld {
    constructor(e) {
        super(e),
        this.onBeforeCompile = (t,i)=>{
            const {isWebGL2: r} = i.capabilities;
            t.fragmentShader = t.fragmentShader.replace("#include <output_fragment>", `
        ${r ? "#include <output_fragment>" : `#extension GL_OES_standard_derivatives : enable
#include <output_fragment>`}
      vec2 cxy = 2.0 * gl_PointCoord - 1.0;
      float r = dot(cxy, cxy);
      float delta = fwidth(r);     
      float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);
      gl_FragColor = vec4(gl_FragColor.rgb, mask * gl_FragColor.a );
      #include <tonemapping_fragment>
      #include <encodings_fragment>
      `)
        }
    }
}
const TV = O.forwardRef((n,e)=>{
    const [t] = O.useState(()=>new EV(null));
    return O.createElement("primitive", zr({}, n, {
        object: t,
        ref: e,
        attach: "material"
    }))
}
);
let Sa, qc;
const bV = O.createContext(null)
  , RT = new rt
  , LT = new D
  , PV = O.forwardRef(({children: n, range: e, limit: t=1e3, ...i},r)=>{
    const s = O.useRef(null)
      , [o,a] = O.useState([])
      , [[l,c,d]] = O.useState(()=>[new Float32Array(t * 3), Float32Array.from({
        length: t * 3
    }, ()=>1), Float32Array.from({
        length: t
    }, ()=>1)]);
    O.useEffect(()=>{
        s.current.geometry.attributes.position.needsUpdate = !0
    }
    ),
    Jd(()=>{
        for (s.current.updateMatrix(),
        s.current.updateMatrixWorld(),
        RT.copy(s.current.matrixWorld).invert(),
        s.current.geometry.drawRange.count = Math.min(t, e !== void 0 ? e : t, o.length),
        Sa = 0; Sa < o.length; Sa++)
            qc = o[Sa].current,
            qc.getWorldPosition(LT).applyMatrix4(RT),
            LT.toArray(l, Sa * 3),
            s.current.geometry.attributes.position.needsUpdate = !0,
            qc.matrixWorldNeedsUpdate = !0,
            qc.color.toArray(c, Sa * 3),
            s.current.geometry.attributes.color.needsUpdate = !0,
            d.set([qc.size], Sa),
            s.current.geometry.attributes.size.needsUpdate = !0
    }
    );
    const h = O.useMemo(()=>({
        getParent: ()=>s,
        subscribe: p=>(a(m=>[...m, p]),
        ()=>a(m=>m.filter(y=>y.current !== p.current)))
    }), []);
    return O.createElement("points", zr({
        userData: {
            instances: o
        },
        matrixAutoUpdate: !1,
        ref: RR([r, s]),
        raycast: ()=>null
    }, i), O.createElement("bufferGeometry", null, O.createElement("bufferAttribute", {
        attach: "attributes-position",
        count: l.length / 3,
        array: l,
        itemSize: 3,
        usage: Qa
    }), O.createElement("bufferAttribute", {
        attach: "attributes-color",
        count: c.length / 3,
        array: c,
        itemSize: 3,
        usage: Qa
    }), O.createElement("bufferAttribute", {
        attach: "attributes-size",
        count: d.length,
        array: d,
        itemSize: 1,
        usage: Qa
    })), O.createElement(bV.Provider, {
        value: h
    }, n))
}
)
  , BV = O.forwardRef(({children: n, positions: e, colors: t, sizes: i, stride: r=3, ...s},o)=>{
    const a = O.useRef(null);
    return Jd(()=>{
        const l = a.current.geometry.attributes;
        l.position.needsUpdate = !0,
        t && (l.color.needsUpdate = !0),
        i && (l.size.needsUpdate = !0)
    }
    ),
    O.createElement("points", zr({
        ref: RR([o, a])
    }, s), O.createElement("bufferGeometry", null, O.createElement("bufferAttribute", {
        attach: "attributes-position",
        count: e.length / r,
        array: e,
        itemSize: r,
        usage: Qa
    }), t && O.createElement("bufferAttribute", {
        attach: "attributes-color",
        count: t.length / r,
        array: t,
        itemSize: 3,
        usage: Qa
    }), i && O.createElement("bufferAttribute", {
        attach: "attributes-size",
        count: i.length / r,
        array: i,
        itemSize: 1,
        usage: Qa
    })), n)
}
)
  , RV = O.forwardRef((n,e)=>n.positions instanceof Float32Array ? O.createElement(BV, zr({}, n, {
    ref: e
})) : O.createElement(PV, zr({}, n, {
    ref: e
})));
var dg = {}
  , LV = {
    get exports() {
        return dg
    },
    set exports(n) {
        dg = n
    }
}
  , IV = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
  , DV = IV
  , FV = DV;
function NR() {}
function OR() {}
OR.resetWarningCache = NR;
var kV = function() {
    function n(i, r, s, o, a, l) {
        if (l !== FV) {
            var c = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
            throw c.name = "Invariant Violation",
            c
        }
    }
    n.isRequired = n;
    function e() {
        return n
    }
    var t = {
        array: n,
        bigint: n,
        bool: n,
        func: n,
        number: n,
        object: n,
        string: n,
        symbol: n,
        any: n,
        arrayOf: e,
        element: n,
        elementType: n,
        instanceOf: e,
        node: n,
        objectOf: e,
        oneOf: e,
        oneOfType: e,
        shape: e,
        exact: e,
        checkPropTypes: OR,
        resetWarningCache: NR
    };
    return t.PropTypes = t,
    t
};
LV.exports = kV();
function UR({all: n, scene: e, camera: t}) {
    const i = fr(({gl: o})=>o)
      , r = fr(({camera: o})=>o)
      , s = fr(({scene: o})=>o);
    return O.useLayoutEffect(()=>{
        const o = [];
        n && (e || s).traverse(c=>{
            c.visible === !1 && (o.push(c),
            c.visible = !0)
        }
        ),
        i.compile(e || s, t || r);
        const a = new SA(128);
        new wA(.01,1e5,a).update(i, e || s),
        a.dispose(),
        o.forEach(c=>c.visible = !1)
    }
    , []),
    null
}
const NV = ()=>{
    const {progress: n} = N6();
    return ut(k6, {
        as: "div",
        center: !0,
        style: {
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            flexDirection: "column"
        },
        children: [xe("span", {
            className: "canvas-loader"
        }), ut("p", {
            style: {
                fontSize: 14,
                color: "#F1F1F1",
                fontWeight: 800,
                marginTop: 40
            },
            children: [n.toFixed(2), "%"]
        })]
    })
}
  , OV = ({isMobile: n})=>{
    const e = rM("./desktop_pc/scene.gltf");
    return ut("mesh", {
        children: [xe("hemisphereLight", {
            intensity: .15,
            groundColor: "black"
        }), xe("spotLight", {
            position: [-20, 50, 10],
            angle: .12,
            penumbra: 1,
            intensity: 1,
            castShadow: !0,
            "shadow-mapSize": 1024
        }), xe("pointLight", {
            intensity: 1
        }), xe("primitive", {
            object: e.scene,
            scale: n ? .7 : .75,
            position: n ? [0, -3, -2.2] : [0, -3.25, -1.5],
            rotation: [-.01, -.2, -.1]
        })]
    })
}
  , UV = ()=>{
    const [n,e] = O.useState(!1);
    return O.useEffect(()=>{
        const t = window.matchMedia("(max-width: 500px)");
        e(t.matches);
        const i = r=>{
            e(r.matches)
        }
        ;
        return t.addEventListener("change", i),
        ()=>{
            t.removeEventListener("change", i)
        }
    }
    , []),
    ut(PR, {
        frameloop: "demand",
        shadows: !0,
        dpr: [1, 2],
        camera: {
            position: [20, 3, 5],
            fov: 25
        },
        gl: {
            preserveDrawingBuffer: !0
        },
        children: [ut(O.Suspense, {
            fallback: xe(NV, {}),
            children: [xe(CV, {
                autoRotate: !0,
                autoRotateSpeed: 5,
                enableZoom: !1,
                maxPolarAngle: Math.PI / 2,
                minPolarAngle: Math.PI / 2
            }), xe(OV, {
                isMobile: n
            })]
        }), xe(UR, {
            all: !0
        })]
    })
}
  , zV = n=>{
    const e = O.useRef()
      , [t] = O.useState(()=>W6(new Float32Array(5e3), {
        radius: 1.02
    }));
    return Jd((i,r)=>{
        e.current.rotation.x -= r / 10,
        e.current.rotation.y -= r / 15
    }
    ),
    xe("group", {
        rotation: [0, 0, Math.PI / 4],
        children: xe(RV, {
            ref: e,
            positions: t,
            stride: 3,
            frustumCulled: !0,
            ...n,
            children: xe(TV, {
                transparent: !0,
                color: "#f272c8",
                size: .002,
                sizeAttenuation: !0,
                depthWrite: !1
            })
        })
    })
}
  , GV = ()=>xe("div", {
    className: "w-full h-auto absolute inset-0 z-[-1]",
    children: ut(PR, {
        camera: {
            position: [0, 0, 1]
        },
        children: [xe(O.Suspense, {
            fallback: null,
            children: xe(zV, {})
        }), xe(UR, {
            all: !0
        })]
    })
})
  , zR = O.createContext({
    transformPagePoint: n=>n,
    isStatic: !1,
    reducedMotion: "never"
})
  , a0 = O.createContext({});
function HV() {
    return O.useContext(a0).visualElement
}
const sM = O.createContext(null)
  , l0 = typeof document < "u"
  , IT = l0 ? O.useLayoutEffect : O.useEffect
  , GR = O.createContext({
    strict: !1
});
function VV(n, e, t, i) {
    const r = HV()
      , s = O.useContext(GR)
      , o = O.useContext(sM)
      , a = O.useContext(zR).reducedMotion
      , l = O.useRef();
    i = i || s.renderer,
    !l.current && i && (l.current = i(n, {
        visualState: e,
        parent: r,
        props: t,
        presenceContext: o,
        blockInitialAnimation: o ? o.initial === !1 : !1,
        reducedMotionConfig: a
    }));
    const c = l.current;
    return O.useInsertionEffect(()=>{
        c && c.update(t, o)
    }
    ),
    IT(()=>{
        c && c.render()
    }
    ),
    O.useEffect(()=>{
        c && c.updateFeatures()
    }
    ),
    (window.HandoffAppearAnimations ? IT : O.useEffect)(()=>{
        c && c.animationState && c.animationState.animateChanges()
    }
    ),
    c
}
function yu(n) {
    return typeof n == "object" && Object.prototype.hasOwnProperty.call(n, "current")
}
function WV(n, e, t) {
    return O.useCallback(i=>{
        i && n.mount && n.mount(i),
        e && (i ? e.mount(i) : e.unmount()),
        t && (typeof t == "function" ? t(i) : yu(t) && (t.current = i))
    }
    , [e])
}
function hd(n) {
    return typeof n == "string" || Array.isArray(n)
}
function u0(n) {
    return typeof n == "object" && typeof n.start == "function"
}
const oM = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"]
  , aM = ["initial", ...oM];
function c0(n) {
    return u0(n.animate) || aM.some(e=>hd(n[e]))
}
function HR(n) {
    return Boolean(c0(n) || n.variants)
}
function jV(n, e) {
    if (c0(n)) {
        const {initial: t, animate: i} = n;
        return {
            initial: t === !1 || hd(t) ? t : void 0,
            animate: hd(i) ? i : void 0
        }
    }
    return n.inherit !== !1 ? e : {}
}
function JV(n) {
    const {initial: e, animate: t} = jV(n, O.useContext(a0));
    return O.useMemo(()=>({
        initial: e,
        animate: t
    }), [DT(e), DT(t)])
}
function DT(n) {
    return Array.isArray(n) ? n.join(" ") : n
}
const FT = {
    animation: ["animate", "exit", "variants", "whileHover", "whileTap", "whileFocus", "whileDrag", "whileInView"],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
}
  , pd = {};
for (const n in FT)
    pd[n] = {
        isEnabled: e=>FT[n].some(t=>!!e[t])
    };
function XV(n) {
    for (const e in n)
        pd[e] = {
            ...pd[e],
            ...n[e]
        }
}
function VR(n) {
    const e = O.useRef(null);
    return e.current === null && (e.current = n()),
    e.current
}
const Cf = {
    hasAnimatedSinceResize: !0,
    hasEverUpdated: !1
};
let KV = 1;
function YV() {
    return VR(()=>{
        if (Cf.hasEverUpdated)
            return KV++
    }
    )
}
const WR = O.createContext({})
  , jR = O.createContext({})
  , QV = Symbol.for("motionComponentSymbol");
function ZV({preloadedFeatures: n, createVisualElement: e, useRender: t, useVisualState: i, Component: r}) {
    n && XV(n);
    function s(a, l) {
        let c;
        const d = {
            ...O.useContext(zR),
            ...a,
            layoutId: qV(a)
        }
          , {isStatic: h} = d
          , p = JV(a)
          , m = h ? void 0 : YV()
          , y = i(a, h);
        if (!h && l0) {
            p.visualElement = VV(r, y, d, e);
            const v = O.useContext(jR)
              , _ = O.useContext(GR).strict;
            p.visualElement && (c = p.visualElement.loadFeatures(d, _, n, m, v))
        }
        return O.createElement(a0.Provider, {
            value: p
        }, c && p.visualElement ? O.createElement(c, {
            visualElement: p.visualElement,
            ...d
        }) : null, t(r, a, m, WV(y, p.visualElement, l), y, h, p.visualElement))
    }
    const o = O.forwardRef(s);
    return o[QV] = r,
    o
}
function qV({layoutId: n}) {
    const e = O.useContext(WR).id;
    return e && n !== void 0 ? e + "-" + n : n
}
function $V(n) {
    function e(i, r={}) {
        return ZV(n(i, r))
    }
    if (typeof Proxy > "u")
        return e;
    const t = new Map;
    return new Proxy(e,{
        get: (i,r)=>(t.has(r) || t.set(r, e(r)),
        t.get(r))
    })
}
const eW = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];
function lM(n) {
    return typeof n != "string" || n.includes("-") ? !1 : !!(eW.indexOf(n) > -1 || /[A-Z]/.test(n))
}
const hg = {};
function tW(n) {
    Object.assign(hg, n)
}
const f0 = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"]
  , yl = new Set(f0);
function JR(n, {layout: e, layoutId: t}) {
    return yl.has(n) || n.startsWith("origin") || (e || t !== void 0) && (!!hg[n] || n === "opacity")
}
const Ri = n=>Boolean(n && n.getVelocity)
  , nW = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
}
  , iW = f0.length;
function rW(n, {enableHardwareAcceleration: e=!0, allowTransformNone: t=!0}, i, r) {
    let s = "";
    for (let o = 0; o < iW; o++) {
        const a = f0[o];
        if (n[a] !== void 0) {
            const l = nW[a] || a;
            s += `${l}(${n[a]}) `
        }
    }
    return e && !n.z && (s += "translateZ(0)"),
    s = s.trim(),
    r ? s = r(n, i ? "" : s) : t && i && (s = "none"),
    s
}
const XR = n=>e=>typeof e == "string" && e.startsWith(n)
  , KR = XR("--")
  , Q1 = XR("var(--")
  , sW = (n,e)=>e && typeof n == "number" ? e.transform(n) : n
  , Ju = (n,e,t)=>Math.min(Math.max(t, n), e)
  , vl = {
    test: n=>typeof n == "number",
    parse: parseFloat,
    transform: n=>n
}
  , Ef = {
    ...vl,
    transform: n=>Ju(0, 1, n)
}
  , rm = {
    ...vl,
    default: 1
}
  , Tf = n=>Math.round(n * 1e5) / 1e5
  , md = /(-)?([\d]*\.?[\d])+/g
  , Z1 = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi
  , oW = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function Yd(n) {
    return typeof n == "string"
}
const Qd = n=>({
    test: e=>Yd(e) && e.endsWith(n) && e.split(" ").length === 1,
    parse: parseFloat,
    transform: e=>`${e}${n}`
})
  , yo = Qd("deg")
  , os = Qd("%")
  , nt = Qd("px")
  , aW = Qd("vh")
  , lW = Qd("vw")
  , kT = {
    ...os,
    parse: n=>os.parse(n) / 100,
    transform: n=>os.transform(n * 100)
}
  , NT = {
    ...vl,
    transform: Math.round
}
  , YR = {
    borderWidth: nt,
    borderTopWidth: nt,
    borderRightWidth: nt,
    borderBottomWidth: nt,
    borderLeftWidth: nt,
    borderRadius: nt,
    radius: nt,
    borderTopLeftRadius: nt,
    borderTopRightRadius: nt,
    borderBottomRightRadius: nt,
    borderBottomLeftRadius: nt,
    width: nt,
    maxWidth: nt,
    height: nt,
    maxHeight: nt,
    size: nt,
    top: nt,
    right: nt,
    bottom: nt,
    left: nt,
    padding: nt,
    paddingTop: nt,
    paddingRight: nt,
    paddingBottom: nt,
    paddingLeft: nt,
    margin: nt,
    marginTop: nt,
    marginRight: nt,
    marginBottom: nt,
    marginLeft: nt,
    rotate: yo,
    rotateX: yo,
    rotateY: yo,
    rotateZ: yo,
    scale: rm,
    scaleX: rm,
    scaleY: rm,
    scaleZ: rm,
    skew: yo,
    skewX: yo,
    skewY: yo,
    distance: nt,
    translateX: nt,
    translateY: nt,
    translateZ: nt,
    x: nt,
    y: nt,
    z: nt,
    perspective: nt,
    transformPerspective: nt,
    opacity: Ef,
    originX: kT,
    originY: kT,
    originZ: nt,
    zIndex: NT,
    fillOpacity: Ef,
    strokeOpacity: Ef,
    numOctaves: NT
};
function uM(n, e, t, i) {
    const {style: r, vars: s, transform: o, transformOrigin: a} = n;
    let l = !1
      , c = !1
      , d = !0;
    for (const h in e) {
        const p = e[h];
        if (KR(h)) {
            s[h] = p;
            continue
        }
        const m = YR[h]
          , y = sW(p, m);
        if (yl.has(h)) {
            if (l = !0,
            o[h] = y,
            !d)
                continue;
            p !== (m.default || 0) && (d = !1)
        } else
            h.startsWith("origin") ? (c = !0,
            a[h] = y) : r[h] = y
    }
    if (e.transform || (l || i ? r.transform = rW(n.transform, t, d, i) : r.transform && (r.transform = "none")),
    c) {
        const {originX: h="50%", originY: p="50%", originZ: m=0} = a;
        r.transformOrigin = `${h} ${p} ${m}`
    }
}
const cM = ()=>({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
});
function QR(n, e, t) {
    for (const i in e)
        !Ri(e[i]) && !JR(i, t) && (n[i] = e[i])
}
function uW({transformTemplate: n}, e, t) {
    return O.useMemo(()=>{
        const i = cM();
        return uM(i, e, {
            enableHardwareAcceleration: !t
        }, n),
        Object.assign({}, i.vars, i.style)
    }
    , [e])
}
function cW(n, e, t) {
    const i = n.style || {}
      , r = {};
    return QR(r, i, n),
    Object.assign(r, uW(n, e, t)),
    n.transformValues ? n.transformValues(r) : r
}
function fW(n, e, t) {
    const i = {}
      , r = cW(n, e, t);
    return n.drag && n.dragListener !== !1 && (i.draggable = !1,
    r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none",
    r.touchAction = n.drag === !0 ? "none" : `pan-${n.drag === "x" ? "y" : "x"}`),
    n.tabIndex === void 0 && (n.onTap || n.onTapStart || n.whileTap) && (i.tabIndex = 0),
    i.style = r,
    i
}
const dW = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "transformValues", "custom", "inherit", "onLayoutAnimationStart", "onLayoutAnimationComplete", "onLayoutMeasure", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "ignoreStrict", "viewport"]);
function pg(n) {
    return n.startsWith("while") || n.startsWith("drag") && n !== "draggable" || n.startsWith("layout") || n.startsWith("onTap") || n.startsWith("onPan") || dW.has(n)
}
let ZR = n=>!pg(n);
function hW(n) {
    n && (ZR = e=>e.startsWith("on") ? !pg(e) : n(e))
}
try {
    hW(require("@emotion/is-prop-valid").default)
} catch {}
function pW(n, e, t) {
    const i = {};
    for (const r in n)
        r === "values" && typeof n.values == "object" || (ZR(r) || t === !0 && pg(r) || !e && !pg(r) || n.draggable && r.startsWith("onDrag")) && (i[r] = n[r]);
    return i
}
function OT(n, e, t) {
    return typeof n == "string" ? n : nt.transform(e + t * n)
}
function mW(n, e, t) {
    const i = OT(e, n.x, n.width)
      , r = OT(t, n.y, n.height);
    return `${i} ${r}`
}
const gW = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
}
  , yW = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
};
function vW(n, e, t=1, i=0, r=!0) {
    n.pathLength = 1;
    const s = r ? gW : yW;
    n[s.offset] = nt.transform(-i);
    const o = nt.transform(e)
      , a = nt.transform(t);
    n[s.array] = `${o} ${a}`
}
function fM(n, {attrX: e, attrY: t, originX: i, originY: r, pathLength: s, pathSpacing: o=1, pathOffset: a=0, ...l}, c, d, h) {
    if (uM(n, l, c, h),
    d) {
        n.style.viewBox && (n.attrs.viewBox = n.style.viewBox);
        return
    }
    n.attrs = n.style,
    n.style = {};
    const {attrs: p, style: m, dimensions: y} = n;
    p.transform && (y && (m.transform = p.transform),
    delete p.transform),
    y && (i !== void 0 || r !== void 0 || m.transform) && (m.transformOrigin = mW(y, i !== void 0 ? i : .5, r !== void 0 ? r : .5)),
    e !== void 0 && (p.x = e),
    t !== void 0 && (p.y = t),
    s !== void 0 && vW(p, s, o, a, !1)
}
const qR = ()=>({
    ...cM(),
    attrs: {}
})
  , dM = n=>typeof n == "string" && n.toLowerCase() === "svg";
function xW(n, e, t, i) {
    const r = O.useMemo(()=>{
        const s = qR();
        return fM(s, e, {
            enableHardwareAcceleration: !1
        }, dM(i), n.transformTemplate),
        {
            ...s.attrs,
            style: {
                ...s.style
            }
        }
    }
    , [e]);
    if (n.style) {
        const s = {};
        QR(s, n.style, n),
        r.style = {
            ...s,
            ...r.style
        }
    }
    return r
}
function _W(n=!1) {
    return (t,i,r,s,{latestValues: o},a)=>{
        const c = (lM(t) ? xW : fW)(i, o, a, t)
          , h = {
            ...pW(i, typeof t == "string", n),
            ...c,
            ref: s
        }
          , {children: p} = i
          , m = O.useMemo(()=>Ri(p) ? p.get() : p, [p]);
        return r && (h["data-projection-id"] = r),
        O.createElement(t, {
            ...h,
            children: m
        })
    }
}
const hM = n=>n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
function $R(n, {style: e, vars: t}, i, r) {
    Object.assign(n.style, e, r && r.getProjectionStyles(i));
    for (const s in t)
        n.style.setProperty(s, t[s])
}
const eL = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
function tL(n, e, t, i) {
    $R(n, e, void 0, i);
    for (const r in e.attrs)
        n.setAttribute(eL.has(r) ? r : hM(r), e.attrs[r])
}
function pM(n, e) {
    const {style: t} = n
      , i = {};
    for (const r in t)
        (Ri(t[r]) || e.style && Ri(e.style[r]) || JR(r, n)) && (i[r] = t[r]);
    return i
}
function nL(n, e) {
    const t = pM(n, e);
    for (const i in n)
        if (Ri(n[i]) || Ri(e[i])) {
            const r = i === "x" || i === "y" ? "attr" + i.toUpperCase() : i;
            t[r] = n[i]
        }
    return t
}
function mM(n, e, t, i={}, r={}) {
    return typeof e == "function" && (e = e(t !== void 0 ? t : n.custom, i, r)),
    typeof e == "string" && (e = n.variants && n.variants[e]),
    typeof e == "function" && (e = e(t !== void 0 ? t : n.custom, i, r)),
    e
}
const mg = n=>Array.isArray(n)
  , AW = n=>Boolean(n && typeof n == "object" && n.mix && n.toValue)
  , MW = n=>mg(n) ? n[n.length - 1] || 0 : n;
function Rm(n) {
    const e = Ri(n) ? n.get() : n;
    return AW(e) ? e.toValue() : e
}
function wW({scrapeMotionValuesFromProps: n, createRenderState: e, onMount: t}, i, r, s) {
    const o = {
        latestValues: SW(i, r, s, n),
        renderState: e()
    };
    return t && (o.mount = a=>t(i, a, o)),
    o
}
const iL = n=>(e,t)=>{
    const i = O.useContext(a0)
      , r = O.useContext(sM)
      , s = ()=>wW(n, e, i, r);
    return t ? s() : VR(s)
}
;
function SW(n, e, t, i) {
    const r = {}
      , s = i(n, {});
    for (const p in s)
        r[p] = Rm(s[p]);
    let {initial: o, animate: a} = n;
    const l = c0(n)
      , c = HR(n);
    e && c && !l && n.inherit !== !1 && (o === void 0 && (o = e.initial),
    a === void 0 && (a = e.animate));
    let d = t ? t.initial === !1 : !1;
    d = d || o === !1;
    const h = d ? a : o;
    return h && typeof h != "boolean" && !u0(h) && (Array.isArray(h) ? h : [h]).forEach(m=>{
        const y = mM(n, m);
        if (!y)
            return;
        const {transitionEnd: v, transition: _, ...x} = y;
        for (const A in x) {
            let M = x[A];
            if (Array.isArray(M)) {
                const S = d ? M.length - 1 : 0;
                M = M[S]
            }
            M !== null && (r[A] = M)
        }
        for (const A in v)
            r[A] = v[A]
    }
    ),
    r
}
const CW = {
    useVisualState: iL({
        scrapeMotionValuesFromProps: nL,
        createRenderState: qR,
        onMount: (n,e,{renderState: t, latestValues: i})=>{
            try {
                t.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect()
            } catch {
                t.dimensions = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                }
            }
            fM(t, i, {
                enableHardwareAcceleration: !1
            }, dM(e.tagName), n.transformTemplate),
            tL(e, t)
        }
    })
}
  , EW = {
    useVisualState: iL({
        scrapeMotionValuesFromProps: pM,
        createRenderState: cM
    })
};
function TW(n, {forwardMotionProps: e=!1}, t, i) {
    return {
        ...lM(n) ? CW : EW,
        preloadedFeatures: t,
        useRender: _W(e),
        createVisualElement: i,
        Component: n
    }
}
function Ns(n, e, t, i={
    passive: !0
}) {
    return n.addEventListener(e, t, i),
    ()=>n.removeEventListener(e, t)
}
const rL = n=>n.pointerType === "mouse" ? typeof n.button != "number" || n.button <= 0 : n.isPrimary !== !1;
function d0(n, e="page") {
    return {
        point: {
            x: n[e + "X"],
            y: n[e + "Y"]
        }
    }
}
const bW = n=>e=>rL(e) && n(e, d0(e));
function zs(n, e, t, i) {
    return Ns(n, e, bW(t), i)
}
const PW = (n,e)=>t=>e(n(t))
  , zo = (...n)=>n.reduce(PW);
function sL(n) {
    let e = null;
    return ()=>{
        const t = ()=>{
            e = null
        }
        ;
        return e === null ? (e = n,
        t) : !1
    }
}
const UT = sL("dragHorizontal")
  , zT = sL("dragVertical");
function oL(n) {
    let e = !1;
    if (n === "y")
        e = zT();
    else if (n === "x")
        e = UT();
    else {
        const t = UT()
          , i = zT();
        t && i ? e = ()=>{
            t(),
            i()
        }
        : (t && t(),
        i && i())
    }
    return e
}
function aL() {
    const n = oL(!0);
    return n ? (n(),
    !1) : !0
}
class sa {
    constructor(e) {
        this.isMounted = !1,
        this.node = e
    }
    update() {}
}
function GT(n, e) {
    const t = "pointer" + (e ? "enter" : "leave")
      , i = "onHover" + (e ? "Start" : "End")
      , r = (s,o)=>{
        if (s.type === "touch" || aL())
            return;
        const a = n.getProps();
        n.animationState && a.whileHover && n.animationState.setActive("whileHover", e),
        a[i] && a[i](s, o)
    }
    ;
    return zs(n.current, t, r, {
        passive: !n.getProps()[i]
    })
}
class BW extends sa {
    mount() {
        this.unmount = zo(GT(this.node, !0), GT(this.node, !1))
    }
    unmount() {}
}
class RW extends sa {
    constructor() {
        super(...arguments),
        this.isActive = !1
    }
    onFocus() {
        let e = !1;
        try {
            e = this.node.current.matches(":focus-visible")
        } catch {
            e = !0
        }
        !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0),
        this.isActive = !0)
    }
    onBlur() {
        !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1),
        this.isActive = !1)
    }
    mount() {
        this.unmount = zo(Ns(this.node.current, "focus", ()=>this.onFocus()), Ns(this.node.current, "blur", ()=>this.onBlur()))
    }
    unmount() {}
}
const lL = (n,e)=>e ? n === e ? !0 : lL(n, e.parentElement) : !1
  , yr = n=>n;
function Gv(n, e) {
    if (!e)
        return;
    const t = new PointerEvent("pointer" + n);
    e(t, d0(t))
}
class LW extends sa {
    constructor() {
        super(...arguments),
        this.removeStartListeners = yr,
        this.removeEndListeners = yr,
        this.removeAccessibleListeners = yr,
        this.startPointerPress = (e,t)=>{
            if (this.removeEndListeners(),
            this.isPressing)
                return;
            const i = this.node.getProps()
              , s = zs(window, "pointerup", (a,l)=>{
                if (!this.checkPressEnd())
                    return;
                const {onTap: c, onTapCancel: d} = this.node.getProps();
                lL(this.node.current, a.target) ? c && c(a, l) : d && d(a, l)
            }
            , {
                passive: !(i.onTap || i.onPointerUp)
            })
              , o = zs(window, "pointercancel", (a,l)=>this.cancelPress(a, l), {
                passive: !(i.onTapCancel || i.onPointerCancel)
            });
            this.removeEndListeners = zo(s, o),
            this.startPress(e, t)
        }
        ,
        this.startAccessiblePress = ()=>{
            const e = s=>{
                if (s.key !== "Enter" || this.isPressing)
                    return;
                const o = a=>{
                    a.key !== "Enter" || !this.checkPressEnd() || Gv("up", this.node.getProps().onTap)
                }
                ;
                this.removeEndListeners(),
                this.removeEndListeners = Ns(this.node.current, "keyup", o),
                Gv("down", (a,l)=>{
                    this.startPress(a, l)
                }
                )
            }
              , t = Ns(this.node.current, "keydown", e)
              , i = ()=>{
                this.isPressing && Gv("cancel", (s,o)=>this.cancelPress(s, o))
            }
              , r = Ns(this.node.current, "blur", i);
            this.removeAccessibleListeners = zo(t, r)
        }
    }
    startPress(e, t) {
        this.isPressing = !0;
        const {onTapStart: i, whileTap: r} = this.node.getProps();
        r && this.node.animationState && this.node.animationState.setActive("whileTap", !0),
        i && i(e, t)
    }
    checkPressEnd() {
        return this.removeEndListeners(),
        this.isPressing = !1,
        this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1),
        !aL()
    }
    cancelPress(e, t) {
        if (!this.checkPressEnd())
            return;
        const {onTapCancel: i} = this.node.getProps();
        i && i(e, t)
    }
    mount() {
        const e = this.node.getProps()
          , t = zs(this.node.current, "pointerdown", this.startPointerPress, {
            passive: !(e.onTapStart || e.onPointerStart)
        })
          , i = Ns(this.node.current, "focus", this.startAccessiblePress);
        this.removeStartListeners = zo(t, i)
    }
    unmount() {
        this.removeStartListeners(),
        this.removeEndListeners(),
        this.removeAccessibleListeners()
    }
}
const q1 = new WeakMap
  , Hv = new WeakMap
  , IW = n=>{
    const e = q1.get(n.target);
    e && e(n)
}
  , DW = n=>{
    n.forEach(IW)
}
;
function FW({root: n, ...e}) {
    const t = n || document;
    Hv.has(t) || Hv.set(t, {});
    const i = Hv.get(t)
      , r = JSON.stringify(e);
    return i[r] || (i[r] = new IntersectionObserver(DW,{
        root: n,
        ...e
    })),
    i[r]
}
function kW(n, e, t) {
    const i = FW(e);
    return q1.set(n, t),
    i.observe(n),
    ()=>{
        q1.delete(n),
        i.unobserve(n)
    }
}
const NW = {
    some: 0,
    all: 1
};
class OW extends sa {
    constructor() {
        super(...arguments),
        this.hasEnteredView = !1,
        this.isInView = !1
    }
    viewportFallback() {
        requestAnimationFrame(()=>{
            this.hasEnteredView = !0;
            const {onViewportEnter: e} = this.node.getProps();
            e && e(null),
            this.node.animationState && this.node.animationState.setActive("whileInView", !0)
        }
        )
    }
    startObserver() {
        this.unmount();
        const {viewport: e={}} = this.node.getProps()
          , {root: t, margin: i, amount: r="some", once: s, fallback: o=!0} = e;
        if (typeof IntersectionObserver > "u") {
            o && this.viewportFallback();
            return
        }
        const a = {
            root: t ? t.current : void 0,
            rootMargin: i,
            threshold: typeof r == "number" ? r : NW[r]
        }
          , l = c=>{
            const {isIntersecting: d} = c;
            if (this.isInView === d || (this.isInView = d,
            s && !d && this.hasEnteredView))
                return;
            d && (this.hasEnteredView = !0),
            this.node.animationState && this.node.animationState.setActive("whileInView", d);
            const {onViewportEnter: h, onViewportLeave: p} = this.node.getProps()
              , m = d ? h : p;
            m && m(c)
        }
        ;
        return kW(this.node.current, a, l)
    }
    mount() {
        this.startObserver()
    }
    update() {
        if (typeof IntersectionObserver > "u")
            return;
        const {props: e, prevProps: t} = this.node;
        ["amount", "margin", "root"].some(UW(e, t)) && this.startObserver()
    }
    unmount() {}
}
function UW({viewport: n={}}, {viewport: e={}}={}) {
    return t=>n[t] !== e[t]
}
const zW = {
    inView: {
        Feature: OW
    },
    tap: {
        Feature: LW
    },
    focus: {
        Feature: RW
    },
    hover: {
        Feature: BW
    }
};
function uL(n, e) {
    if (!Array.isArray(e))
        return !1;
    const t = e.length;
    if (t !== n.length)
        return !1;
    for (let i = 0; i < t; i++)
        if (e[i] !== n[i])
            return !1;
    return !0
}
const GW = n=>/^\-?\d*\.?\d+$/.test(n)
  , HW = n=>/^0[^.\s]+$/.test(n)
  , Gs = {
    delta: 0,
    timestamp: 0
}
  , cL = 1 / 60 * 1e3
  , VW = typeof performance < "u" ? ()=>performance.now() : ()=>Date.now()
  , fL = typeof window < "u" ? n=>window.requestAnimationFrame(n) : n=>setTimeout(()=>n(VW()), cL);
function WW(n) {
    let e = []
      , t = []
      , i = 0
      , r = !1
      , s = !1;
    const o = new WeakSet
      , a = {
        schedule: (l,c=!1,d=!1)=>{
            const h = d && r
              , p = h ? e : t;
            return c && o.add(l),
            p.indexOf(l) === -1 && (p.push(l),
            h && r && (i = e.length)),
            l
        }
        ,
        cancel: l=>{
            const c = t.indexOf(l);
            c !== -1 && t.splice(c, 1),
            o.delete(l)
        }
        ,
        process: l=>{
            if (r) {
                s = !0;
                return
            }
            if (r = !0,
            [e,t] = [t, e],
            t.length = 0,
            i = e.length,
            i)
                for (let c = 0; c < i; c++) {
                    const d = e[c];
                    d(l),
                    o.has(d) && (a.schedule(d),
                    n())
                }
            r = !1,
            s && (s = !1,
            a.process(l))
        }
    };
    return a
}
const jW = 40;
let $1 = !0
  , gd = !1
  , e_ = !1;
const Zd = ["read", "update", "preRender", "render", "postRender"]
  , h0 = Zd.reduce((n,e)=>(n[e] = WW(()=>gd = !0),
n), {})
  , mi = Zd.reduce((n,e)=>{
    const t = h0[e];
    return n[e] = (i,r=!1,s=!1)=>(gd || XW(),
    t.schedule(i, r, s)),
    n
}
, {})
  , Ko = Zd.reduce((n,e)=>(n[e] = h0[e].cancel,
n), {})
  , Vv = Zd.reduce((n,e)=>(n[e] = ()=>h0[e].process(Gs),
n), {})
  , JW = n=>h0[n].process(Gs)
  , dL = n=>{
    gd = !1,
    Gs.delta = $1 ? cL : Math.max(Math.min(n - Gs.timestamp, jW), 1),
    Gs.timestamp = n,
    e_ = !0,
    Zd.forEach(JW),
    e_ = !1,
    gd && ($1 = !1,
    fL(dL))
}
  , XW = ()=>{
    gd = !0,
    $1 = !0,
    e_ || fL(dL)
}
;
function gM(n, e) {
    n.indexOf(e) === -1 && n.push(e)
}
function yM(n, e) {
    const t = n.indexOf(e);
    t > -1 && n.splice(t, 1)
}
class vM {
    constructor() {
        this.subscriptions = []
    }
    add(e) {
        return gM(this.subscriptions, e),
        ()=>yM(this.subscriptions, e)
    }
    notify(e, t, i) {
        const r = this.subscriptions.length;
        if (r)
            if (r === 1)
                this.subscriptions[0](e, t, i);
            else
                for (let s = 0; s < r; s++) {
                    const o = this.subscriptions[s];
                    o && o(e, t, i)
                }
    }
    getSize() {
        return this.subscriptions.length
    }
    clear() {
        this.subscriptions.length = 0
    }
}
function xM(n, e) {
    return e ? n * (1e3 / e) : 0
}
const KW = n=>!isNaN(parseFloat(n));
class YW {
    constructor(e, t={}) {
        this.version = "9.1.7",
        this.timeDelta = 0,
        this.lastUpdated = 0,
        this.canTrackVelocity = !1,
        this.events = {},
        this.updateAndNotify = (i,r=!0)=>{
            this.prev = this.current,
            this.current = i;
            const {delta: s, timestamp: o} = Gs;
            this.lastUpdated !== o && (this.timeDelta = s,
            this.lastUpdated = o,
            mi.postRender(this.scheduleVelocityCheck)),
            this.prev !== this.current && this.events.change && this.events.change.notify(this.current),
            this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()),
            r && this.events.renderRequest && this.events.renderRequest.notify(this.current)
        }
        ,
        this.scheduleVelocityCheck = ()=>mi.postRender(this.velocityCheck),
        this.velocityCheck = ({timestamp: i})=>{
            i !== this.lastUpdated && (this.prev = this.current,
            this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()))
        }
        ,
        this.hasAnimated = !1,
        this.prev = this.current = e,
        this.canTrackVelocity = KW(this.current),
        this.owner = t.owner
    }
    onChange(e) {
        return this.on("change", e)
    }
    on(e, t) {
        this.events[e] || (this.events[e] = new vM);
        const i = this.events[e].add(t);
        return e === "change" ? ()=>{
            i(),
            mi.read(()=>{
                this.events.change.getSize() || this.stop()
            }
            )
        }
        : i
    }
    clearListeners() {
        for (const e in this.events)
            this.events[e].clear()
    }
    attach(e, t) {
        this.passiveEffect = e,
        this.stopPassiveEffect = t
    }
    set(e, t=!0) {
        !t || !this.passiveEffect ? this.updateAndNotify(e, t) : this.passiveEffect(e, this.updateAndNotify)
    }
    setWithVelocity(e, t, i) {
        this.set(t),
        this.prev = e,
        this.timeDelta = i
    }
    jump(e) {
        this.updateAndNotify(e),
        this.prev = e,
        this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
    get() {
        return this.current
    }
    getPrevious() {
        return this.prev
    }
    getVelocity() {
        return this.canTrackVelocity ? xM(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0
    }
    start(e) {
        return this.stop(),
        new Promise(t=>{
            this.hasAnimated = !0,
            this.animation = e(t) || null,
            this.events.animationStart && this.events.animationStart.notify()
        }
        ).then(()=>{
            this.events.animationComplete && this.events.animationComplete.notify(),
            this.clearAnimation()
        }
        )
    }
    stop() {
        this.animation && (this.animation.stop(),
        this.events.animationCancel && this.events.animationCancel.notify()),
        this.clearAnimation()
    }
    isAnimating() {
        return !!this.animation
    }
    clearAnimation() {
        this.animation = null
    }
    destroy() {
        this.clearListeners(),
        this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
}
function Xu(n, e) {
    return new YW(n,e)
}
const _M = (n,e)=>t=>Boolean(Yd(t) && oW.test(t) && t.startsWith(n) || e && Object.prototype.hasOwnProperty.call(t, e))
  , hL = (n,e,t)=>i=>{
    if (!Yd(i))
        return i;
    const [r,s,o,a] = i.match(md);
    return {
        [n]: parseFloat(r),
        [e]: parseFloat(s),
        [t]: parseFloat(o),
        alpha: a !== void 0 ? parseFloat(a) : 1
    }
}
  , QW = n=>Ju(0, 255, n)
  , Wv = {
    ...vl,
    transform: n=>Math.round(QW(n))
}
  , Wa = {
    test: _M("rgb", "red"),
    parse: hL("red", "green", "blue"),
    transform: ({red: n, green: e, blue: t, alpha: i=1})=>"rgba(" + Wv.transform(n) + ", " + Wv.transform(e) + ", " + Wv.transform(t) + ", " + Tf(Ef.transform(i)) + ")"
};
function ZW(n) {
    let e = ""
      , t = ""
      , i = ""
      , r = "";
    return n.length > 5 ? (e = n.substring(1, 3),
    t = n.substring(3, 5),
    i = n.substring(5, 7),
    r = n.substring(7, 9)) : (e = n.substring(1, 2),
    t = n.substring(2, 3),
    i = n.substring(3, 4),
    r = n.substring(4, 5),
    e += e,
    t += t,
    i += i,
    r += r),
    {
        red: parseInt(e, 16),
        green: parseInt(t, 16),
        blue: parseInt(i, 16),
        alpha: r ? parseInt(r, 16) / 255 : 1
    }
}
const t_ = {
    test: _M("#"),
    parse: ZW,
    transform: Wa.transform
}
  , vu = {
    test: _M("hsl", "hue"),
    parse: hL("hue", "saturation", "lightness"),
    transform: ({hue: n, saturation: e, lightness: t, alpha: i=1})=>"hsla(" + Math.round(n) + ", " + os.transform(Tf(e)) + ", " + os.transform(Tf(t)) + ", " + Tf(Ef.transform(i)) + ")"
}
  , ci = {
    test: n=>Wa.test(n) || t_.test(n) || vu.test(n),
    parse: n=>Wa.test(n) ? Wa.parse(n) : vu.test(n) ? vu.parse(n) : t_.parse(n),
    transform: n=>Yd(n) ? n : n.hasOwnProperty("red") ? Wa.transform(n) : vu.transform(n)
}
  , pL = "${c}"
  , mL = "${n}";
function qW(n) {
    var e, t;
    return isNaN(n) && Yd(n) && (((e = n.match(md)) === null || e === void 0 ? void 0 : e.length) || 0) + (((t = n.match(Z1)) === null || t === void 0 ? void 0 : t.length) || 0) > 0
}
function gg(n) {
    typeof n == "number" && (n = `${n}`);
    const e = [];
    let t = 0
      , i = 0;
    const r = n.match(Z1);
    r && (t = r.length,
    n = n.replace(Z1, pL),
    e.push(...r.map(ci.parse)));
    const s = n.match(md);
    return s && (i = s.length,
    n = n.replace(md, mL),
    e.push(...s.map(vl.parse))),
    {
        values: e,
        numColors: t,
        numNumbers: i,
        tokenised: n
    }
}
function gL(n) {
    return gg(n).values
}
function yL(n) {
    const {values: e, numColors: t, tokenised: i} = gg(n)
      , r = e.length;
    return s=>{
        let o = i;
        for (let a = 0; a < r; a++)
            o = o.replace(a < t ? pL : mL, a < t ? ci.transform(s[a]) : Tf(s[a]));
        return o
    }
}
const $W = n=>typeof n == "number" ? 0 : n;
function e7(n) {
    const e = gL(n);
    return yL(n)(e.map($W))
}
const Yo = {
    test: qW,
    parse: gL,
    createTransformer: yL,
    getAnimatableNone: e7
}
  , t7 = new Set(["brightness", "contrast", "saturate", "opacity"]);
function n7(n) {
    const [e,t] = n.slice(0, -1).split("(");
    if (e === "drop-shadow")
        return n;
    const [i] = t.match(md) || [];
    if (!i)
        return n;
    const r = t.replace(i, "");
    let s = t7.has(e) ? 1 : 0;
    return i !== t && (s *= 100),
    e + "(" + s + r + ")"
}
const i7 = /([a-z-]*)\(.*?\)/g
  , n_ = {
    ...Yo,
    getAnimatableNone: n=>{
        const e = n.match(i7);
        return e ? e.map(n7).join(" ") : n
    }
}
  , r7 = {
    ...YR,
    color: ci,
    backgroundColor: ci,
    outlineColor: ci,
    fill: ci,
    stroke: ci,
    borderColor: ci,
    borderTopColor: ci,
    borderRightColor: ci,
    borderBottomColor: ci,
    borderLeftColor: ci,
    filter: n_,
    WebkitFilter: n_
}
  , AM = n=>r7[n];
function MM(n, e) {
    let t = AM(n);
    return t !== n_ && (t = Yo),
    t.getAnimatableNone ? t.getAnimatableNone(e) : void 0
}
const vL = n=>e=>e.test(n)
  , s7 = {
    test: n=>n === "auto",
    parse: n=>n
}
  , xL = [vl, nt, os, yo, lW, aW, s7]
  , $c = n=>xL.find(vL(n))
  , o7 = [...xL, ci, Yo]
  , a7 = n=>o7.find(vL(n));
function l7(n) {
    const e = {};
    return n.values.forEach((t,i)=>e[i] = t.get()),
    e
}
function u7(n) {
    const e = {};
    return n.values.forEach((t,i)=>e[i] = t.getVelocity()),
    e
}
function p0(n, e, t) {
    const i = n.getProps();
    return mM(i, e, t !== void 0 ? t : i.custom, l7(n), u7(n))
}
function c7(n, e, t) {
    n.hasValue(e) ? n.getValue(e).set(t) : n.addValue(e, Xu(t))
}
function f7(n, e) {
    const t = p0(n, e);
    let {transitionEnd: i={}, transition: r={}, ...s} = t ? n.makeTargetAnimatable(t, !1) : {};
    s = {
        ...s,
        ...i
    };
    for (const o in s) {
        const a = MW(s[o]);
        c7(n, o, a)
    }
}
function d7(n, e, t) {
    var i, r;
    const s = Object.keys(e).filter(a=>!n.hasValue(a))
      , o = s.length;
    if (o)
        for (let a = 0; a < o; a++) {
            const l = s[a]
              , c = e[l];
            let d = null;
            Array.isArray(c) && (d = c[0]),
            d === null && (d = (r = (i = t[l]) !== null && i !== void 0 ? i : n.readValue(l)) !== null && r !== void 0 ? r : e[l]),
            d != null && (typeof d == "string" && (GW(d) || HW(d)) ? d = parseFloat(d) : !a7(d) && Yo.test(c) && (d = MM(l, c)),
            n.addValue(l, Xu(d, {
                owner: n
            })),
            t[l] === void 0 && (t[l] = d),
            d !== null && n.setBaseTarget(l, d))
        }
}
function h7(n, e) {
    return e ? (e[n] || e.default || e).from : void 0
}
function p7(n, e, t) {
    const i = {};
    for (const r in n) {
        const s = h7(r, e);
        if (s !== void 0)
            i[r] = s;
        else {
            const o = t.getValue(r);
            o && (i[r] = o.get())
        }
    }
    return i
}
function yg(n) {
    return Boolean(Ri(n) && n.add)
}
const m7 = "framerAppearId"
  , g7 = "data-" + hM(m7);
let y7 = yr
  , vg = yr;
const Lm = n=>n * 1e3
  , v7 = {
    current: !1
}
  , wM = n=>e=>e <= .5 ? n(2 * e) / 2 : (2 - n(2 * (1 - e))) / 2
  , SM = n=>e=>1 - n(1 - e)
  , CM = n=>n * n
  , x7 = SM(CM)
  , EM = wM(CM)
  , sn = (n,e,t)=>-t * n + t * e + n;
function jv(n, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * (2 / 3 - t) * 6 : n
}
function _7({hue: n, saturation: e, lightness: t, alpha: i}) {
    n /= 360,
    e /= 100,
    t /= 100;
    let r = 0
      , s = 0
      , o = 0;
    if (!e)
        r = s = o = t;
    else {
        const a = t < .5 ? t * (1 + e) : t + e - t * e
          , l = 2 * t - a;
        r = jv(l, a, n + 1 / 3),
        s = jv(l, a, n),
        o = jv(l, a, n - 1 / 3)
    }
    return {
        red: Math.round(r * 255),
        green: Math.round(s * 255),
        blue: Math.round(o * 255),
        alpha: i
    }
}
const Jv = (n,e,t)=>{
    const i = n * n;
    return Math.sqrt(Math.max(0, t * (e * e - i) + i))
}
  , A7 = [t_, Wa, vu]
  , M7 = n=>A7.find(e=>e.test(n));
function HT(n) {
    const e = M7(n);
    let t = e.parse(n);
    return e === vu && (t = _7(t)),
    t
}
const _L = (n,e)=>{
    const t = HT(n)
      , i = HT(e)
      , r = {
        ...t
    };
    return s=>(r.red = Jv(t.red, i.red, s),
    r.green = Jv(t.green, i.green, s),
    r.blue = Jv(t.blue, i.blue, s),
    r.alpha = sn(t.alpha, i.alpha, s),
    Wa.transform(r))
}
;
function AL(n, e) {
    return typeof n == "number" ? t=>sn(n, e, t) : ci.test(n) ? _L(n, e) : wL(n, e)
}
const ML = (n,e)=>{
    const t = [...n]
      , i = t.length
      , r = n.map((s,o)=>AL(s, e[o]));
    return s=>{
        for (let o = 0; o < i; o++)
            t[o] = r[o](s);
        return t
    }
}
  , w7 = (n,e)=>{
    const t = {
        ...n,
        ...e
    }
      , i = {};
    for (const r in t)
        n[r] !== void 0 && e[r] !== void 0 && (i[r] = AL(n[r], e[r]));
    return r=>{
        for (const s in i)
            t[s] = i[s](r);
        return t
    }
}
  , wL = (n,e)=>{
    const t = Yo.createTransformer(e)
      , i = gg(n)
      , r = gg(e);
    return i.numColors === r.numColors && i.numNumbers >= r.numNumbers ? zo(ML(i.values, r.values), t) : o=>`${o > 0 ? e : n}`
}
  , yd = (n,e,t)=>{
    const i = e - n;
    return i === 0 ? 1 : (t - n) / i
}
  , VT = (n,e)=>t=>sn(n, e, t);
function S7(n) {
    return typeof n == "number" ? VT : typeof n == "string" ? ci.test(n) ? _L : wL : Array.isArray(n) ? ML : typeof n == "object" ? w7 : VT
}
function C7(n, e, t) {
    const i = []
      , r = t || S7(n[0])
      , s = n.length - 1;
    for (let o = 0; o < s; o++) {
        let a = r(n[o], n[o + 1]);
        if (e) {
            const l = Array.isArray(e) ? e[o] : e;
            a = zo(l, a)
        }
        i.push(a)
    }
    return i
}
function SL(n, e, {clamp: t=!0, ease: i, mixer: r}={}) {
    const s = n.length;
    vg(s === e.length),
    vg(!i || !Array.isArray(i) || i.length === s - 1),
    n[0] > n[s - 1] && (n = [...n].reverse(),
    e = [...e].reverse());
    const o = C7(e, i, r)
      , a = o.length
      , l = c=>{
        let d = 0;
        if (a > 1)
            for (; d < n.length - 2 && !(c < n[d + 1]); d++)
                ;
        const h = yd(n[d], n[d + 1], c);
        return o[d](h)
    }
    ;
    return t ? c=>l(Ju(n[0], n[s - 1], c)) : l
}
function E7(n, e) {
    const t = n[n.length - 1];
    for (let i = 1; i <= e; i++) {
        const r = yd(0, e, i);
        n.push(sn(t, 1, r))
    }
}
function T7(n) {
    const e = [0];
    return E7(e, n.length - 1),
    e
}
function b7(n, e) {
    return n.map(t=>t * e)
}
const CL = (n,e,t)=>(((1 - 3 * t + 3 * e) * n + (3 * t - 6 * e)) * n + 3 * e) * n
  , P7 = 1e-7
  , B7 = 12;
function R7(n, e, t, i, r) {
    let s, o, a = 0;
    do
        o = e + (t - e) / 2,
        s = CL(o, i, r) - n,
        s > 0 ? t = o : e = o;
    while (Math.abs(s) > P7 && ++a < B7);
    return o
}
function EL(n, e, t, i) {
    if (n === e && t === i)
        return yr;
    const r = s=>R7(s, 0, 1, n, t);
    return s=>s === 0 || s === 1 ? s : CL(r(s), e, i)
}
const TL = n=>1 - Math.sin(Math.acos(n))
  , TM = SM(TL)
  , L7 = wM(TM)
  , bL = EL(.33, 1.53, .69, .99)
  , bM = SM(bL)
  , I7 = wM(bM)
  , D7 = n=>(n *= 2) < 1 ? .5 * bM(n) : .5 * (2 - Math.pow(2, -10 * (n - 1)))
  , F7 = {
    linear: yr,
    easeIn: CM,
    easeInOut: EM,
    easeOut: x7,
    circIn: TL,
    circInOut: L7,
    circOut: TM,
    backIn: bM,
    backInOut: I7,
    backOut: bL,
    anticipate: D7
}
  , WT = n=>{
    if (Array.isArray(n)) {
        vg(n.length === 4);
        const [e,t,i,r] = n;
        return EL(e, t, i, r)
    } else if (typeof n == "string")
        return F7[n];
    return n
}
  , k7 = n=>Array.isArray(n) && typeof n[0] != "number";
function N7(n, e) {
    return n.map(()=>e || EM).splice(0, n.length - 1)
}
function i_({keyframes: n, ease: e=EM, times: t, duration: i=300}) {
    n = [...n];
    const r = k7(e) ? e.map(WT) : WT(e)
      , s = {
        done: !1,
        value: n[0]
    }
      , o = b7(t && t.length === n.length ? t : T7(n), i);
    function a() {
        return SL(o, n, {
            ease: Array.isArray(r) ? r : N7(n, r)
        })
    }
    let l = a();
    return {
        next: c=>(s.value = l(c),
        s.done = c >= i,
        s),
        flipTarget: ()=>{
            n.reverse(),
            l = a()
        }
    }
}
const Xv = .001
  , O7 = .01
  , jT = 10
  , U7 = .05
  , z7 = 1;
function G7({duration: n=800, bounce: e=.25, velocity: t=0, mass: i=1}) {
    let r, s;
    y7(n <= jT * 1e3);
    let o = 1 - e;
    o = Ju(U7, z7, o),
    n = Ju(O7, jT, n / 1e3),
    o < 1 ? (r = c=>{
        const d = c * o
          , h = d * n
          , p = d - t
          , m = r_(c, o)
          , y = Math.exp(-h);
        return Xv - p / m * y
    }
    ,
    s = c=>{
        const h = c * o * n
          , p = h * t + t
          , m = Math.pow(o, 2) * Math.pow(c, 2) * n
          , y = Math.exp(-h)
          , v = r_(Math.pow(c, 2), o);
        return (-r(c) + Xv > 0 ? -1 : 1) * ((p - m) * y) / v
    }
    ) : (r = c=>{
        const d = Math.exp(-c * n)
          , h = (c - t) * n + 1;
        return -Xv + d * h
    }
    ,
    s = c=>{
        const d = Math.exp(-c * n)
          , h = (t - c) * (n * n);
        return d * h
    }
    );
    const a = 5 / n
      , l = V7(r, s, a);
    if (n = n * 1e3,
    isNaN(l))
        return {
            stiffness: 100,
            damping: 10,
            duration: n
        };
    {
        const c = Math.pow(l, 2) * i;
        return {
            stiffness: c,
            damping: o * 2 * Math.sqrt(i * c),
            duration: n
        }
    }
}
const H7 = 12;
function V7(n, e, t) {
    let i = t;
    for (let r = 1; r < H7; r++)
        i = i - n(i) / e(i);
    return i
}
function r_(n, e) {
    return n * Math.sqrt(1 - e * e)
}
const W7 = ["duration", "bounce"]
  , j7 = ["stiffness", "damping", "mass"];
function JT(n, e) {
    return e.some(t=>n[t] !== void 0)
}
function J7(n) {
    let e = {
        velocity: 0,
        stiffness: 100,
        damping: 10,
        mass: 1,
        isResolvedFromDuration: !1,
        ...n
    };
    if (!JT(n, j7) && JT(n, W7)) {
        const t = G7(n);
        e = {
            ...e,
            ...t,
            velocity: 0,
            mass: 1
        },
        e.isResolvedFromDuration = !0
    }
    return e
}
const X7 = 5;
function PL({keyframes: n, restDelta: e, restSpeed: t, ...i}) {
    let r = n[0]
      , s = n[n.length - 1];
    const o = {
        done: !1,
        value: r
    }
      , {stiffness: a, damping: l, mass: c, velocity: d, duration: h, isResolvedFromDuration: p} = J7(i);
    let m = K7
      , y = d ? -(d / 1e3) : 0;
    const v = l / (2 * Math.sqrt(a * c));
    function _() {
        const x = s - r
          , A = Math.sqrt(a / c) / 1e3
          , M = Math.abs(x) < 5;
        if (t || (t = M ? .01 : 2),
        e || (e = M ? .005 : .5),
        v < 1) {
            const S = r_(A, v);
            m = T=>{
                const P = Math.exp(-v * A * T);
                return s - P * ((y + v * A * x) / S * Math.sin(S * T) + x * Math.cos(S * T))
            }
        } else if (v === 1)
            m = S=>s - Math.exp(-A * S) * (x + (y + A * x) * S);
        else {
            const S = A * Math.sqrt(v * v - 1);
            m = T=>{
                const P = Math.exp(-v * A * T)
                  , R = Math.min(S * T, 300);
                return s - P * ((y + v * A * x) * Math.sinh(R) + S * x * Math.cosh(R)) / S
            }
        }
    }
    return _(),
    {
        next: x=>{
            const A = m(x);
            if (p)
                o.done = x >= h;
            else {
                let M = y;
                if (x !== 0)
                    if (v < 1) {
                        const P = Math.max(0, x - X7);
                        M = xM(A - m(P), x - P)
                    } else
                        M = 0;
                const S = Math.abs(M) <= t
                  , T = Math.abs(s - A) <= e;
                o.done = S && T
            }
            return o.value = o.done ? s : A,
            o
        }
        ,
        flipTarget: ()=>{
            y = -y,
            [r,s] = [s, r],
            _()
        }
    }
}
PL.needsInterpolation = (n,e)=>typeof n == "string" || typeof e == "string";
const K7 = n=>0;
function Y7({keyframes: n=[0], velocity: e=0, power: t=.8, timeConstant: i=350, restDelta: r=.5, modifyTarget: s}) {
    const o = n[0]
      , a = {
        done: !1,
        value: o
    };
    let l = t * e;
    const c = o + l
      , d = s === void 0 ? c : s(c);
    return d !== c && (l = d - o),
    {
        next: h=>{
            const p = -l * Math.exp(-h / i);
            return a.done = !(p > r || p < -r),
            a.value = a.done ? d : d + p,
            a
        }
        ,
        flipTarget: ()=>{}
    }
}
const Q7 = {
    decay: Y7,
    keyframes: i_,
    tween: i_,
    spring: PL
};
function BL(n, e, t=0) {
    return n - e - t
}
function Z7(n, e=0, t=0, i=!0) {
    return i ? BL(e + -n, e, t) : e - (n - e) + t
}
function q7(n, e, t, i) {
    return i ? n >= e + t : n <= -t
}
const $7 = n=>{
    const e = ({delta: t})=>n(t);
    return {
        start: ()=>mi.update(e, !0),
        stop: ()=>Ko.update(e)
    }
}
;
function xg({duration: n, driver: e=$7, elapsed: t=0, repeat: i=0, repeatType: r="loop", repeatDelay: s=0, keyframes: o, autoplay: a=!0, onPlay: l, onStop: c, onComplete: d, onRepeat: h, onUpdate: p, type: m="keyframes", ...y}) {
    const v = t;
    let _, x = 0, A = n, M = !1, S = !0, T;
    const P = Q7[o.length > 2 ? "keyframes" : m] || i_
      , R = o[0]
      , E = o[o.length - 1];
    let B = {
        done: !1,
        value: R
    };
    const {needsInterpolation: L} = P;
    L && L(R, E) && (T = SL([0, 100], [R, E], {
        clamp: !1
    }),
    o = [0, 100]);
    const z = P({
        ...y,
        duration: n,
        keyframes: o
    });
    function Z() {
        x++,
        r === "reverse" ? (S = x % 2 === 0,
        t = Z7(t, A, s, S)) : (t = BL(t, A, s),
        r === "mirror" && z.flipTarget()),
        M = !1,
        h && h()
    }
    function J() {
        _ && _.stop(),
        d && d()
    }
    function G(ee) {
        S || (ee = -ee),
        t += ee,
        M || (B = z.next(Math.max(0, t)),
        T && (B.value = T(B.value)),
        M = S ? B.done : t <= 0),
        p && p(B.value),
        M && (x === 0 && (A = A !== void 0 ? A : t),
        x < i ? q7(t, A, s, S) && Z() : J())
    }
    function X() {
        l && l(),
        _ = e(G),
        _.start()
    }
    return a && X(),
    {
        stop: ()=>{
            c && c(),
            _ && _.stop()
        }
        ,
        set currentTime(ee) {
            t = v,
            G(ee)
        },
        sample: ee=>{
            t = v;
            const ie = n && typeof n == "number" ? Math.max(n * .5, 50) : 50;
            let F = 0;
            for (G(0); F <= ee; ) {
                const V = ee - F;
                G(Math.min(V, ie)),
                F += ie
            }
            return B
        }
    }
}
function ej(n) {
    return !n || Array.isArray(n) || typeof n == "string" && RL[n]
}
const cf = ([n,e,t,i])=>`cubic-bezier(${n}, ${e}, ${t}, ${i})`
  , RL = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: cf([0, .65, .55, 1]),
    circOut: cf([.55, 0, 1, .45]),
    backIn: cf([.31, .01, .66, -.59]),
    backOut: cf([.33, 1.53, .69, .99])
};
function tj(n) {
    if (n)
        return Array.isArray(n) ? cf(n) : RL[n]
}
function nj(n, e, t, {delay: i=0, duration: r, repeat: s=0, repeatType: o="loop", ease: a, times: l}={}) {
    return n.animate({
        [e]: t,
        offset: l
    }, {
        delay: i,
        duration: r,
        easing: tj(a),
        fill: "both",
        iterations: s + 1,
        direction: o === "reverse" ? "alternate" : "normal"
    })
}
const XT = {
    waapi: ()=>Object.hasOwnProperty.call(Element.prototype, "animate")
}
  , Kv = {}
  , LL = {};
for (const n in XT)
    LL[n] = ()=>(Kv[n] === void 0 && (Kv[n] = XT[n]()),
    Kv[n]);
function ij(n, {repeat: e, repeatType: t="loop"}) {
    const i = e && t !== "loop" && e % 2 === 1 ? 0 : n.length - 1;
    return n[i]
}
const rj = new Set(["opacity", "clipPath", "filter", "transform"])
  , sm = 10;
function sj(n, e, {onUpdate: t, onComplete: i, ...r}) {
    if (!(LL.waapi() && rj.has(e) && !r.repeatDelay && r.repeatType !== "mirror" && r.damping !== 0))
        return !1;
    let {keyframes: o, duration: a=300, elapsed: l=0, ease: c} = r;
    if (r.type === "spring" || !ej(r.ease)) {
        if (r.repeat === 1 / 0)
            return;
        const h = xg({
            ...r,
            elapsed: 0
        });
        let p = {
            done: !1,
            value: o[0]
        };
        const m = [];
        let y = 0;
        for (; !p.done && y < 2e4; )
            p = h.sample(y),
            m.push(p.value),
            y += sm;
        o = m,
        a = y - sm,
        c = "linear"
    }
    const d = nj(n.owner.current, e, o, {
        ...r,
        delay: -l,
        duration: a,
        ease: c
    });
    return d.onfinish = ()=>{
        n.set(ij(o, r)),
        mi.update(()=>d.cancel()),
        i && i()
    }
    ,
    {
        get currentTime() {
            return d.currentTime || 0
        },
        set currentTime(h) {
            d.currentTime = h
        },
        stop: ()=>{
            const {currentTime: h} = d;
            if (h) {
                const p = xg({
                    ...r,
                    autoplay: !1
                });
                n.setWithVelocity(p.sample(h - sm).value, p.sample(h).value, sm)
            }
            mi.update(()=>d.cancel())
        }
    }
}
function IL(n, e) {
    const t = performance.now()
      , i = ({timestamp: r})=>{
        const s = r - t;
        s >= e && (Ko.read(i),
        n(s - e))
    }
    ;
    return mi.read(i, !0),
    ()=>Ko.read(i)
}
function oj({keyframes: n, elapsed: e, onUpdate: t, onComplete: i}) {
    const r = ()=>{
        t && t(n[n.length - 1]),
        i && i()
    }
    ;
    return e ? {
        stop: IL(r, -e)
    } : r()
}
function aj({keyframes: n, velocity: e=0, min: t, max: i, power: r=.8, timeConstant: s=750, bounceStiffness: o=500, bounceDamping: a=10, restDelta: l=1, modifyTarget: c, driver: d, onUpdate: h, onComplete: p, onStop: m}) {
    const y = n[0];
    let v;
    function _(S) {
        return t !== void 0 && S < t || i !== void 0 && S > i
    }
    function x(S) {
        return t === void 0 ? i : i === void 0 || Math.abs(t - S) < Math.abs(i - S) ? t : i
    }
    function A(S) {
        v && v.stop(),
        v = xg({
            keyframes: [0, 1],
            velocity: 0,
            ...S,
            driver: d,
            onUpdate: T=>{
                h && h(T),
                S.onUpdate && S.onUpdate(T)
            }
            ,
            onComplete: p,
            onStop: m
        })
    }
    function M(S) {
        A({
            type: "spring",
            stiffness: o,
            damping: a,
            restDelta: l,
            ...S
        })
    }
    if (_(y))
        M({
            velocity: e,
            keyframes: [y, x(y)]
        });
    else {
        let S = r * e + y;
        typeof c < "u" && (S = c(S));
        const T = x(S)
          , P = T === t ? -1 : 1;
        let R, E;
        const B = L=>{
            R = E,
            E = L,
            e = xM(L - R, Gs.delta),
            (P === 1 && L > T || P === -1 && L < T) && M({
                keyframes: [L, T],
                velocity: e
            })
        }
        ;
        A({
            type: "decay",
            keyframes: [y, 0],
            velocity: e,
            timeConstant: s,
            power: r,
            restDelta: l,
            modifyTarget: c,
            onUpdate: _(S) ? B : void 0
        })
    }
    return {
        stop: ()=>v && v.stop()
    }
}
const lj = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
}
  , uj = n=>({
    type: "spring",
    stiffness: 550,
    damping: n === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
})
  , cj = {
    type: "keyframes",
    duration: .8
}
  , fj = {
    type: "keyframes",
    ease: [.25, .1, .35, 1],
    duration: .3
}
  , dj = (n,{keyframes: e})=>e.length > 2 ? cj : yl.has(n) ? n.startsWith("scale") ? uj(e[1]) : lj : fj
  , s_ = (n,e)=>n === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && Yo.test(e) && !e.startsWith("url("));
function hj({when: n, delay: e, delayChildren: t, staggerChildren: i, staggerDirection: r, repeat: s, repeatType: o, repeatDelay: a, from: l, elapsed: c, ...d}) {
    return !!Object.keys(d).length
}
function KT(n) {
    return n === 0 || typeof n == "string" && parseFloat(n) === 0 && n.indexOf(" ") === -1
}
function YT(n) {
    return typeof n == "number" ? 0 : MM("", n)
}
function DL(n, e) {
    return n[e] || n.default || n
}
function pj(n, e, t, i) {
    const r = s_(e, t);
    let s = i.from !== void 0 ? i.from : n.get();
    return s === "none" && r && typeof t == "string" ? s = MM(e, t) : KT(s) && typeof t == "string" ? s = YT(t) : !Array.isArray(t) && KT(t) && typeof s == "string" && (t = YT(s)),
    Array.isArray(t) ? (t[0] === null && (t[0] = s),
    t) : [s, t]
}
const PM = (n,e,t,i={})=>r=>{
    const s = DL(i, n) || {}
      , o = s.delay || i.delay || 0;
    let {elapsed: a=0} = i;
    a = a - Lm(o);
    const l = pj(e, n, t, s)
      , c = l[0]
      , d = l[l.length - 1]
      , h = s_(n, c)
      , p = s_(n, d);
    let m = {
        keyframes: l,
        velocity: e.getVelocity(),
        ...s,
        elapsed: a,
        onUpdate: y=>{
            e.set(y),
            s.onUpdate && s.onUpdate(y)
        }
        ,
        onComplete: ()=>{
            r(),
            s.onComplete && s.onComplete()
        }
    };
    if (!h || !p || v7.current || s.type === !1)
        return oj(m);
    if (s.type === "inertia")
        return aj(m);
    if (hj(s) || (m = {
        ...m,
        ...dj(n, m)
    }),
    m.duration && (m.duration = Lm(m.duration)),
    m.repeatDelay && (m.repeatDelay = Lm(m.repeatDelay)),
    e.owner && e.owner.current instanceof HTMLElement && !e.owner.getProps().onUpdate) {
        const y = sj(e, n, m);
        if (y)
            return y
    }
    return xg(m)
}
;
function mj(n, e, t={}) {
    n.notify("AnimationStart", e);
    let i;
    if (Array.isArray(e)) {
        const r = e.map(s=>o_(n, s, t));
        i = Promise.all(r)
    } else if (typeof e == "string")
        i = o_(n, e, t);
    else {
        const r = typeof e == "function" ? p0(n, e, t.custom) : e;
        i = FL(n, r, t)
    }
    return i.then(()=>n.notify("AnimationComplete", e))
}
function o_(n, e, t={}) {
    const i = p0(n, e, t.custom);
    let {transition: r=n.getDefaultTransition() || {}} = i || {};
    t.transitionOverride && (r = t.transitionOverride);
    const s = i ? ()=>FL(n, i, t) : ()=>Promise.resolve()
      , o = n.variantChildren && n.variantChildren.size ? (l=0)=>{
        const {delayChildren: c=0, staggerChildren: d, staggerDirection: h} = r;
        return gj(n, e, c + l, d, h, t)
    }
    : ()=>Promise.resolve()
      , {when: a} = r;
    if (a) {
        const [l,c] = a === "beforeChildren" ? [s, o] : [o, s];
        return l().then(c)
    } else
        return Promise.all([s(), o(t.delay)])
}
function FL(n, e, {delay: t=0, transitionOverride: i, type: r}={}) {
    let {transition: s=n.getDefaultTransition(), transitionEnd: o, ...a} = n.makeTargetAnimatable(e);
    const l = n.getValue("willChange");
    i && (s = i);
    const c = []
      , d = r && n.animationState && n.animationState.getState()[r];
    for (const h in a) {
        const p = n.getValue(h)
          , m = a[h];
        if (!p || m === void 0 || d && vj(d, h))
            continue;
        const y = {
            delay: t,
            elapsed: 0,
            ...s
        };
        if (window.HandoffAppearAnimations && !p.hasAnimated) {
            const _ = n.getProps()[g7];
            _ && (y.elapsed = window.HandoffAppearAnimations(_, h, p, mi))
        }
        let v = p.start(PM(h, p, m, n.shouldReduceMotion && yl.has(h) ? {
            type: !1
        } : y));
        yg(l) && (l.add(h),
        v = v.then(()=>l.remove(h))),
        c.push(v)
    }
    return Promise.all(c).then(()=>{
        o && f7(n, o)
    }
    )
}
function gj(n, e, t=0, i=0, r=1, s) {
    const o = []
      , a = (n.variantChildren.size - 1) * i
      , l = r === 1 ? (c=0)=>c * i : (c=0)=>a - c * i;
    return Array.from(n.variantChildren).sort(yj).forEach((c,d)=>{
        c.notify("AnimationStart", e),
        o.push(o_(c, e, {
            ...s,
            delay: t + l(d)
        }).then(()=>c.notify("AnimationComplete", e)))
    }
    ),
    Promise.all(o)
}
function yj(n, e) {
    return n.sortNodePosition(e)
}
function vj({protectedKeys: n, needsAnimating: e}, t) {
    const i = n.hasOwnProperty(t) && e[t] !== !0;
    return e[t] = !1,
    i
}
const xj = [...oM].reverse()
  , _j = oM.length;
function Aj(n) {
    return e=>Promise.all(e.map(({animation: t, options: i})=>mj(n, t, i)))
}
function Mj(n) {
    let e = Aj(n);
    const t = Sj();
    let i = !0;
    const r = (l,c)=>{
        const d = p0(n, c);
        if (d) {
            const {transition: h, transitionEnd: p, ...m} = d;
            l = {
                ...l,
                ...m,
                ...p
            }
        }
        return l
    }
    ;
    function s(l) {
        e = l(n)
    }
    function o(l, c) {
        const d = n.getProps()
          , h = n.getVariantContext(!0) || {}
          , p = []
          , m = new Set;
        let y = {}
          , v = 1 / 0;
        for (let x = 0; x < _j; x++) {
            const A = xj[x]
              , M = t[A]
              , S = d[A] !== void 0 ? d[A] : h[A]
              , T = hd(S)
              , P = A === c ? M.isActive : null;
            P === !1 && (v = x);
            let R = S === h[A] && S !== d[A] && T;
            if (R && i && n.manuallyAnimateOnMount && (R = !1),
            M.protectedKeys = {
                ...y
            },
            !M.isActive && P === null || !S && !M.prevProp || u0(S) || typeof S == "boolean")
                continue;
            const E = wj(M.prevProp, S);
            let B = E || A === c && M.isActive && !R && T || x > v && T;
            const L = Array.isArray(S) ? S : [S];
            let z = L.reduce(r, {});
            P === !1 && (z = {});
            const {prevResolvedValues: Z={}} = M
              , J = {
                ...Z,
                ...z
            }
              , G = X=>{
                B = !0,
                m.delete(X),
                M.needsAnimating[X] = !0
            }
            ;
            for (const X in J) {
                const ee = z[X]
                  , ie = Z[X];
                y.hasOwnProperty(X) || (ee !== ie ? mg(ee) && mg(ie) ? !uL(ee, ie) || E ? G(X) : M.protectedKeys[X] = !0 : ee !== void 0 ? G(X) : m.add(X) : ee !== void 0 && m.has(X) ? G(X) : M.protectedKeys[X] = !0)
            }
            M.prevProp = S,
            M.prevResolvedValues = z,
            M.isActive && (y = {
                ...y,
                ...z
            }),
            i && n.blockInitialAnimation && (B = !1),
            B && !R && p.push(...L.map(X=>({
                animation: X,
                options: {
                    type: A,
                    ...l
                }
            })))
        }
        if (m.size) {
            const x = {};
            m.forEach(A=>{
                const M = n.getBaseTarget(A);
                M !== void 0 && (x[A] = M)
            }
            ),
            p.push({
                animation: x
            })
        }
        let _ = Boolean(p.length);
        return i && d.initial === !1 && !n.manuallyAnimateOnMount && (_ = !1),
        i = !1,
        _ ? e(p) : Promise.resolve()
    }
    function a(l, c, d) {
        var h;
        if (t[l].isActive === c)
            return Promise.resolve();
        (h = n.variantChildren) === null || h === void 0 || h.forEach(m=>{
            var y;
            return (y = m.animationState) === null || y === void 0 ? void 0 : y.setActive(l, c)
        }
        ),
        t[l].isActive = c;
        const p = o(d, l);
        for (const m in t)
            t[m].protectedKeys = {};
        return p
    }
    return {
        animateChanges: o,
        setActive: a,
        setAnimateFunction: s,
        getState: ()=>t
    }
}
function wj(n, e) {
    return typeof e == "string" ? e !== n : Array.isArray(e) ? !uL(e, n) : !1
}
function Ca(n=!1) {
    return {
        isActive: n,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
    }
}
function Sj() {
    return {
        animate: Ca(!0),
        whileInView: Ca(),
        whileHover: Ca(),
        whileTap: Ca(),
        whileDrag: Ca(),
        whileFocus: Ca(),
        exit: Ca()
    }
}
class Cj extends sa {
    constructor(e) {
        super(e),
        e.animationState || (e.animationState = Mj(e))
    }
    updateAnimationControlsSubscription() {
        const {animate: e} = this.node.getProps();
        this.unmount(),
        u0(e) && (this.unmount = e.subscribe(this.node))
    }
    mount() {
        this.updateAnimationControlsSubscription()
    }
    update() {
        const {animate: e} = this.node.getProps()
          , {animate: t} = this.node.prevProps || {};
        e !== t && this.updateAnimationControlsSubscription()
    }
    unmount() {}
}
let Ej = 0;
class Tj extends sa {
    constructor() {
        super(...arguments),
        this.id = Ej++
    }
    update() {
        if (!this.node.presenceContext)
            return;
        const {isPresent: e, onExitComplete: t, custom: i} = this.node.presenceContext
          , {isPresent: r} = this.node.prevPresenceContext || {};
        if (!this.node.animationState || e === r)
            return;
        const s = this.node.animationState.setActive("exit", !e, {
            custom: i ?? this.node.getProps().custom
        });
        t && !e && s.then(()=>t(this.id))
    }
    mount() {
        const {register: e} = this.node.presenceContext || {};
        e && (this.unmount = e(this.id))
    }
    unmount() {}
}
const bj = {
    animation: {
        Feature: Cj
    },
    exit: {
        Feature: Tj
    }
}
  , QT = (n,e)=>Math.abs(n - e);
function Pj(n, e) {
    const t = QT(n.x, e.x)
      , i = QT(n.y, e.y);
    return Math.sqrt(t ** 2 + i ** 2)
}
class kL {
    constructor(e, t, {transformPagePoint: i}={}) {
        if (this.startEvent = null,
        this.lastMoveEvent = null,
        this.lastMoveEventInfo = null,
        this.handlers = {},
        this.updatePoint = ()=>{
            if (!(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const c = Qv(this.lastMoveEventInfo, this.history)
              , d = this.startEvent !== null
              , h = Pj(c.offset, {
                x: 0,
                y: 0
            }) >= 3;
            if (!d && !h)
                return;
            const {point: p} = c
              , {timestamp: m} = Gs;
            this.history.push({
                ...p,
                timestamp: m
            });
            const {onStart: y, onMove: v} = this.handlers;
            d || (y && y(this.lastMoveEvent, c),
            this.startEvent = this.lastMoveEvent),
            v && v(this.lastMoveEvent, c)
        }
        ,
        this.handlePointerMove = (c,d)=>{
            this.lastMoveEvent = c,
            this.lastMoveEventInfo = Yv(d, this.transformPagePoint),
            mi.update(this.updatePoint, !0)
        }
        ,
        this.handlePointerUp = (c,d)=>{
            if (this.end(),
            !(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const {onEnd: h, onSessionEnd: p} = this.handlers
              , m = Qv(c.type === "pointercancel" ? this.lastMoveEventInfo : Yv(d, this.transformPagePoint), this.history);
            this.startEvent && h && h(c, m),
            p && p(c, m)
        }
        ,
        !rL(e))
            return;
        this.handlers = t,
        this.transformPagePoint = i;
        const r = d0(e)
          , s = Yv(r, this.transformPagePoint)
          , {point: o} = s
          , {timestamp: a} = Gs;
        this.history = [{
            ...o,
            timestamp: a
        }];
        const {onSessionStart: l} = t;
        l && l(e, Qv(s, this.history)),
        this.removeListeners = zo(zs(window, "pointermove", this.handlePointerMove), zs(window, "pointerup", this.handlePointerUp), zs(window, "pointercancel", this.handlePointerUp))
    }
    updateHandlers(e) {
        this.handlers = e
    }
    end() {
        this.removeListeners && this.removeListeners(),
        Ko.update(this.updatePoint)
    }
}
function Yv(n, e) {
    return e ? {
        point: e(n.point)
    } : n
}
function ZT(n, e) {
    return {
        x: n.x - e.x,
        y: n.y - e.y
    }
}
function Qv({point: n}, e) {
    return {
        point: n,
        delta: ZT(n, NL(e)),
        offset: ZT(n, Bj(e)),
        velocity: Rj(e, .1)
    }
}
function Bj(n) {
    return n[0]
}
function NL(n) {
    return n[n.length - 1]
}
function Rj(n, e) {
    if (n.length < 2)
        return {
            x: 0,
            y: 0
        };
    let t = n.length - 1
      , i = null;
    const r = NL(n);
    for (; t >= 0 && (i = n[t],
    !(r.timestamp - i.timestamp > Lm(e))); )
        t--;
    if (!i)
        return {
            x: 0,
            y: 0
        };
    const s = (r.timestamp - i.timestamp) / 1e3;
    if (s === 0)
        return {
            x: 0,
            y: 0
        };
    const o = {
        x: (r.x - i.x) / s,
        y: (r.y - i.y) / s
    };
    return o.x === 1 / 0 && (o.x = 0),
    o.y === 1 / 0 && (o.y = 0),
    o
}
function Ji(n) {
    return n.max - n.min
}
function a_(n, e=0, t=.01) {
    return Math.abs(n - e) <= t
}
function qT(n, e, t, i=.5) {
    n.origin = i,
    n.originPoint = sn(e.min, e.max, n.origin),
    n.scale = Ji(t) / Ji(e),
    (a_(n.scale, 1, 1e-4) || isNaN(n.scale)) && (n.scale = 1),
    n.translate = sn(t.min, t.max, n.origin) - n.originPoint,
    (a_(n.translate) || isNaN(n.translate)) && (n.translate = 0)
}
function bf(n, e, t, i) {
    qT(n.x, e.x, t.x, i ? i.originX : void 0),
    qT(n.y, e.y, t.y, i ? i.originY : void 0)
}
function $T(n, e, t) {
    n.min = t.min + e.min,
    n.max = n.min + Ji(e)
}
function Lj(n, e, t) {
    $T(n.x, e.x, t.x),
    $T(n.y, e.y, t.y)
}
function eb(n, e, t) {
    n.min = e.min - t.min,
    n.max = n.min + Ji(e)
}
function Pf(n, e, t) {
    eb(n.x, e.x, t.x),
    eb(n.y, e.y, t.y)
}
function Ij(n, {min: e, max: t}, i) {
    return e !== void 0 && n < e ? n = i ? sn(e, n, i.min) : Math.max(n, e) : t !== void 0 && n > t && (n = i ? sn(t, n, i.max) : Math.min(n, t)),
    n
}
function tb(n, e, t) {
    return {
        min: e !== void 0 ? n.min + e : void 0,
        max: t !== void 0 ? n.max + t - (n.max - n.min) : void 0
    }
}
function Dj(n, {top: e, left: t, bottom: i, right: r}) {
    return {
        x: tb(n.x, t, r),
        y: tb(n.y, e, i)
    }
}
function nb(n, e) {
    let t = e.min - n.min
      , i = e.max - n.max;
    return e.max - e.min < n.max - n.min && ([t,i] = [i, t]),
    {
        min: t,
        max: i
    }
}
function Fj(n, e) {
    return {
        x: nb(n.x, e.x),
        y: nb(n.y, e.y)
    }
}
function kj(n, e) {
    let t = .5;
    const i = Ji(n)
      , r = Ji(e);
    return r > i ? t = yd(e.min, e.max - i, n.min) : i > r && (t = yd(n.min, n.max - r, e.min)),
    Ju(0, 1, t)
}
function Nj(n, e) {
    const t = {};
    return e.min !== void 0 && (t.min = e.min - n.min),
    e.max !== void 0 && (t.max = e.max - n.min),
    t
}
const l_ = .35;
function Oj(n=l_) {
    return n === !1 ? n = 0 : n === !0 && (n = l_),
    {
        x: ib(n, "left", "right"),
        y: ib(n, "top", "bottom")
    }
}
function ib(n, e, t) {
    return {
        min: rb(n, e),
        max: rb(n, t)
    }
}
function rb(n, e) {
    return typeof n == "number" ? n : n[e] || 0
}
const sb = ()=>({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
})
  , Bf = ()=>({
    x: sb(),
    y: sb()
})
  , ob = ()=>({
    min: 0,
    max: 0
})
  , Mn = ()=>({
    x: ob(),
    y: ob()
});
function es(n) {
    return [n("x"), n("y")]
}
function OL({top: n, left: e, right: t, bottom: i}) {
    return {
        x: {
            min: e,
            max: t
        },
        y: {
            min: n,
            max: i
        }
    }
}
function Uj({x: n, y: e}) {
    return {
        top: e.min,
        right: n.max,
        bottom: e.max,
        left: n.min
    }
}
function zj(n, e) {
    if (!e)
        return n;
    const t = e({
        x: n.left,
        y: n.top
    })
      , i = e({
        x: n.right,
        y: n.bottom
    });
    return {
        top: t.y,
        left: t.x,
        bottom: i.y,
        right: i.x
    }
}
function Zv(n) {
    return n === void 0 || n === 1
}
function u_({scale: n, scaleX: e, scaleY: t}) {
    return !Zv(n) || !Zv(e) || !Zv(t)
}
function La(n) {
    return u_(n) || UL(n) || n.z || n.rotate || n.rotateX || n.rotateY
}
function UL(n) {
    return ab(n.x) || ab(n.y)
}
function ab(n) {
    return n && n !== "0%"
}
function _g(n, e, t) {
    const i = n - t
      , r = e * i;
    return t + r
}
function lb(n, e, t, i, r) {
    return r !== void 0 && (n = _g(n, r, i)),
    _g(n, t, i) + e
}
function c_(n, e=0, t=1, i, r) {
    n.min = lb(n.min, e, t, i, r),
    n.max = lb(n.max, e, t, i, r)
}
function zL(n, {x: e, y: t}) {
    c_(n.x, e.translate, e.scale, e.originPoint),
    c_(n.y, t.translate, t.scale, t.originPoint)
}
function Gj(n, e, t, i=!1) {
    const r = t.length;
    if (!r)
        return;
    e.x = e.y = 1;
    let s, o;
    for (let a = 0; a < r; a++) {
        s = t[a],
        o = s.projectionDelta;
        const l = s.instance;
        l && l.style && l.style.display === "contents" || (i && s.options.layoutScroll && s.scroll && s !== s.root && xu(n, {
            x: -s.scroll.offset.x,
            y: -s.scroll.offset.y
        }),
        o && (e.x *= o.x.scale,
        e.y *= o.y.scale,
        zL(n, o)),
        i && La(s.latestValues) && xu(n, s.latestValues))
    }
    e.x = ub(e.x),
    e.y = ub(e.y)
}
function ub(n) {
    return Number.isInteger(n) || n > 1.0000000000001 || n < .999999999999 ? n : 1
}
function Ao(n, e) {
    n.min = n.min + e,
    n.max = n.max + e
}
function cb(n, e, [t,i,r]) {
    const s = e[r] !== void 0 ? e[r] : .5
      , o = sn(n.min, n.max, s);
    c_(n, e[t], e[i], o, e.scale)
}
const Hj = ["x", "scaleX", "originX"]
  , Vj = ["y", "scaleY", "originY"];
function xu(n, e) {
    cb(n.x, e, Hj),
    cb(n.y, e, Vj)
}
function GL(n, e) {
    return OL(zj(n.getBoundingClientRect(), e))
}
function Wj(n, e, t) {
    const i = GL(n, t)
      , {scroll: r} = e;
    return r && (Ao(i.x, r.offset.x),
    Ao(i.y, r.offset.y)),
    i
}
const jj = new WeakMap;
class Jj {
    constructor(e) {
        this.openGlobalLock = null,
        this.isDragging = !1,
        this.currentDirection = null,
        this.originPoint = {
            x: 0,
            y: 0
        },
        this.constraints = !1,
        this.hasMutatedConstraints = !1,
        this.elastic = Mn(),
        this.visualElement = e
    }
    start(e, {snapToCursor: t=!1}={}) {
        const {presenceContext: i} = this.visualElement;
        if (i && i.isPresent === !1)
            return;
        const r = l=>{
            this.stopAnimation(),
            t && this.snapToCursor(d0(l, "page").point)
        }
          , s = (l,c)=>{
            const {drag: d, dragPropagation: h, onDragStart: p} = this.getProps();
            if (d && !h && (this.openGlobalLock && this.openGlobalLock(),
            this.openGlobalLock = oL(d),
            !this.openGlobalLock))
                return;
            this.isDragging = !0,
            this.currentDirection = null,
            this.resolveConstraints(),
            this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0,
            this.visualElement.projection.target = void 0),
            es(y=>{
                let v = this.getAxisMotionValue(y).get() || 0;
                if (os.test(v)) {
                    const {projection: _} = this.visualElement;
                    if (_ && _.layout) {
                        const x = _.layout.layoutBox[y];
                        x && (v = Ji(x) * (parseFloat(v) / 100))
                    }
                }
                this.originPoint[y] = v
            }
            ),
            p && p(l, c);
            const {animationState: m} = this.visualElement;
            m && m.setActive("whileDrag", !0)
        }
          , o = (l,c)=>{
            const {dragPropagation: d, dragDirectionLock: h, onDirectionLock: p, onDrag: m} = this.getProps();
            if (!d && !this.openGlobalLock)
                return;
            const {offset: y} = c;
            if (h && this.currentDirection === null) {
                this.currentDirection = Xj(y),
                this.currentDirection !== null && p && p(this.currentDirection);
                return
            }
            this.updateAxis("x", c.point, y),
            this.updateAxis("y", c.point, y),
            this.visualElement.render(),
            m && m(l, c)
        }
          , a = (l,c)=>this.stop(l, c);
        this.panSession = new kL(e,{
            onSessionStart: r,
            onStart: s,
            onMove: o,
            onSessionEnd: a
        },{
            transformPagePoint: this.visualElement.getTransformPagePoint()
        })
    }
    stop(e, t) {
        const i = this.isDragging;
        if (this.cancel(),
        !i)
            return;
        const {velocity: r} = t;
        this.startAnimation(r);
        const {onDragEnd: s} = this.getProps();
        s && s(e, t)
    }
    cancel() {
        this.isDragging = !1;
        const {projection: e, animationState: t} = this.visualElement;
        e && (e.isAnimationBlocked = !1),
        this.panSession && this.panSession.end(),
        this.panSession = void 0;
        const {dragPropagation: i} = this.getProps();
        !i && this.openGlobalLock && (this.openGlobalLock(),
        this.openGlobalLock = null),
        t && t.setActive("whileDrag", !1)
    }
    updateAxis(e, t, i) {
        const {drag: r} = this.getProps();
        if (!i || !om(e, r, this.currentDirection))
            return;
        const s = this.getAxisMotionValue(e);
        let o = this.originPoint[e] + i[e];
        this.constraints && this.constraints[e] && (o = Ij(o, this.constraints[e], this.elastic[e])),
        s.set(o)
    }
    resolveConstraints() {
        const {dragConstraints: e, dragElastic: t} = this.getProps()
          , {layout: i} = this.visualElement.projection || {}
          , r = this.constraints;
        e && yu(e) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : e && i ? this.constraints = Dj(i.layoutBox, e) : this.constraints = !1,
        this.elastic = Oj(t),
        r !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && es(s=>{
            this.getAxisMotionValue(s) && (this.constraints[s] = Nj(i.layoutBox[s], this.constraints[s]))
        }
        )
    }
    resolveRefConstraints() {
        const {dragConstraints: e, onMeasureDragConstraints: t} = this.getProps();
        if (!e || !yu(e))
            return !1;
        const i = e.current
          , {projection: r} = this.visualElement;
        if (!r || !r.layout)
            return !1;
        const s = Wj(i, r.root, this.visualElement.getTransformPagePoint());
        let o = Fj(r.layout.layoutBox, s);
        if (t) {
            const a = t(Uj(o));
            this.hasMutatedConstraints = !!a,
            a && (o = OL(a))
        }
        return o
    }
    startAnimation(e) {
        const {drag: t, dragMomentum: i, dragElastic: r, dragTransition: s, dragSnapToOrigin: o, onDragTransitionEnd: a} = this.getProps()
          , l = this.constraints || {}
          , c = es(d=>{
            if (!om(d, t, this.currentDirection))
                return;
            let h = l && l[d] || {};
            o && (h = {
                min: 0,
                max: 0
            });
            const p = r ? 200 : 1e6
              , m = r ? 40 : 1e7
              , y = {
                type: "inertia",
                velocity: i ? e[d] : 0,
                bounceStiffness: p,
                bounceDamping: m,
                timeConstant: 750,
                restDelta: 1,
                restSpeed: 10,
                ...s,
                ...h
            };
            return this.startAxisValueAnimation(d, y)
        }
        );
        return Promise.all(c).then(a)
    }
    startAxisValueAnimation(e, t) {
        const i = this.getAxisMotionValue(e);
        return i.start(PM(e, i, 0, t))
    }
    stopAnimation() {
        es(e=>this.getAxisMotionValue(e).stop())
    }
    getAxisMotionValue(e) {
        const t = "_drag" + e.toUpperCase()
          , i = this.visualElement.getProps()
          , r = i[t];
        return r || this.visualElement.getValue(e, (i.initial ? i.initial[e] : void 0) || 0)
    }
    snapToCursor(e) {
        es(t=>{
            const {drag: i} = this.getProps();
            if (!om(t, i, this.currentDirection))
                return;
            const {projection: r} = this.visualElement
              , s = this.getAxisMotionValue(t);
            if (r && r.layout) {
                const {min: o, max: a} = r.layout.layoutBox[t];
                s.set(e[t] - sn(o, a, .5))
            }
        }
        )
    }
    scalePositionWithinConstraints() {
        if (!this.visualElement.current)
            return;
        const {drag: e, dragConstraints: t} = this.getProps()
          , {projection: i} = this.visualElement;
        if (!yu(t) || !i || !this.constraints)
            return;
        this.stopAnimation();
        const r = {
            x: 0,
            y: 0
        };
        es(o=>{
            const a = this.getAxisMotionValue(o);
            if (a) {
                const l = a.get();
                r[o] = kj({
                    min: l,
                    max: l
                }, this.constraints[o])
            }
        }
        );
        const {transformTemplate: s} = this.visualElement.getProps();
        this.visualElement.current.style.transform = s ? s({}, "") : "none",
        i.root && i.root.updateScroll(),
        i.updateLayout(),
        this.resolveConstraints(),
        es(o=>{
            if (!om(o, e, null))
                return;
            const a = this.getAxisMotionValue(o)
              , {min: l, max: c} = this.constraints[o];
            a.set(sn(l, c, r[o]))
        }
        )
    }
    addListeners() {
        if (!this.visualElement.current)
            return;
        jj.set(this.visualElement, this);
        const e = this.visualElement.current
          , t = zs(e, "pointerdown", l=>{
            const {drag: c, dragListener: d=!0} = this.getProps();
            c && d && this.start(l)
        }
        )
          , i = ()=>{
            const {dragConstraints: l} = this.getProps();
            yu(l) && (this.constraints = this.resolveRefConstraints())
        }
          , {projection: r} = this.visualElement
          , s = r.addEventListener("measure", i);
        r && !r.layout && (r.root && r.root.updateScroll(),
        r.updateLayout()),
        i();
        const o = Ns(window, "resize", ()=>this.scalePositionWithinConstraints())
          , a = r.addEventListener("didUpdate", ({delta: l, hasLayoutChanged: c})=>{
            this.isDragging && c && (es(d=>{
                const h = this.getAxisMotionValue(d);
                h && (this.originPoint[d] += l[d].translate,
                h.set(h.get() + l[d].translate))
            }
            ),
            this.visualElement.render())
        }
        );
        return ()=>{
            o(),
            t(),
            s(),
            a && a()
        }
    }
    getProps() {
        const e = this.visualElement.getProps()
          , {drag: t=!1, dragDirectionLock: i=!1, dragPropagation: r=!1, dragConstraints: s=!1, dragElastic: o=l_, dragMomentum: a=!0} = e;
        return {
            ...e,
            drag: t,
            dragDirectionLock: i,
            dragPropagation: r,
            dragConstraints: s,
            dragElastic: o,
            dragMomentum: a
        }
    }
}
function om(n, e, t) {
    return (e === !0 || e === n) && (t === null || t === n)
}
function Xj(n, e=10) {
    let t = null;
    return Math.abs(n.y) > e ? t = "y" : Math.abs(n.x) > e && (t = "x"),
    t
}
class Kj extends sa {
    constructor(e) {
        super(e),
        this.removeGroupControls = yr,
        this.removeListeners = yr,
        this.controls = new Jj(e)
    }
    mount() {
        const {dragControls: e} = this.node.getProps();
        e && (this.removeGroupControls = e.subscribe(this.controls)),
        this.removeListeners = this.controls.addListeners() || yr
    }
    unmount() {
        this.removeGroupControls(),
        this.removeListeners()
    }
}
class Yj extends sa {
    constructor() {
        super(...arguments),
        this.removePointerDownListener = yr
    }
    onPointerDown(e) {
        this.session = new kL(e,this.createPanHandlers(),{
            transformPagePoint: this.node.getTransformPagePoint()
        })
    }
    createPanHandlers() {
        const {onPanSessionStart: e, onPanStart: t, onPan: i, onPanEnd: r} = this.node.getProps();
        return {
            onSessionStart: e,
            onStart: t,
            onMove: i,
            onEnd: (s,o)=>{
                delete this.session,
                r && r(s, o)
            }
        }
    }
    mount() {
        this.removePointerDownListener = zs(this.node.current, "pointerdown", e=>this.onPointerDown(e))
    }
    update() {
        this.session && this.session.updateHandlers(this.createPanHandlers())
    }
    unmount() {
        this.removePointerDownListener(),
        this.session && this.session.end()
    }
}
function Qj() {
    const n = O.useContext(sM);
    if (n === null)
        return [!0, null];
    const {isPresent: e, onExitComplete: t, register: i} = n
      , r = O.useId();
    return O.useEffect(()=>i(r), []),
    !e && t ? [!1, ()=>t && t(r)] : [!0]
}
function fb(n, e) {
    return e.max === e.min ? 0 : n / (e.max - e.min) * 100
}
const ef = {
    correct: (n,e)=>{
        if (!e.target)
            return n;
        if (typeof n == "string")
            if (nt.test(n))
                n = parseFloat(n);
            else
                return n;
        const t = fb(n, e.target.x)
          , i = fb(n, e.target.y);
        return `${t}% ${i}%`
    }
}
  , HL = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function Zj(n) {
    const e = HL.exec(n);
    if (!e)
        return [, ];
    const [,t,i] = e;
    return [t, i]
}
function f_(n, e, t=1) {
    const [i,r] = Zj(n);
    if (!i)
        return;
    const s = window.getComputedStyle(e).getPropertyValue(i);
    return s ? s.trim() : Q1(r) ? f_(r, e, t + 1) : r
}
function qj(n, {...e}, t) {
    const i = n.current;
    if (!(i instanceof Element))
        return {
            target: e,
            transitionEnd: t
        };
    t && (t = {
        ...t
    }),
    n.values.forEach(r=>{
        const s = r.get();
        if (!Q1(s))
            return;
        const o = f_(s, i);
        o && r.set(o)
    }
    );
    for (const r in e) {
        const s = e[r];
        if (!Q1(s))
            continue;
        const o = f_(s, i);
        o && (e[r] = o,
        t && t[r] === void 0 && (t[r] = s))
    }
    return {
        target: e,
        transitionEnd: t
    }
}
const db = "_$css"
  , $j = {
    correct: (n,{treeScale: e, projectionDelta: t})=>{
        const i = n
          , r = n.includes("var(")
          , s = [];
        r && (n = n.replace(HL, m=>(s.push(m),
        db)));
        const o = Yo.parse(n);
        if (o.length > 5)
            return i;
        const a = Yo.createTransformer(n)
          , l = typeof o[0] != "number" ? 1 : 0
          , c = t.x.scale * e.x
          , d = t.y.scale * e.y;
        o[0 + l] /= c,
        o[1 + l] /= d;
        const h = sn(c, d, .5);
        typeof o[2 + l] == "number" && (o[2 + l] /= h),
        typeof o[3 + l] == "number" && (o[3 + l] /= h);
        let p = a(o);
        if (r) {
            let m = 0;
            p = p.replace(db, ()=>{
                const y = s[m];
                return m++,
                y
            }
            )
        }
        return p
    }
};
class eJ extends lt.Component {
    componentDidMount() {
        const {visualElement: e, layoutGroup: t, switchLayoutGroup: i, layoutId: r} = this.props
          , {projection: s} = e;
        tW(tJ),
        s && (t.group && t.group.add(s),
        i && i.register && r && i.register(s),
        s.root.didUpdate(),
        s.addEventListener("animationComplete", ()=>{
            this.safeToRemove()
        }
        ),
        s.setOptions({
            ...s.options,
            onExitComplete: ()=>this.safeToRemove()
        })),
        Cf.hasEverUpdated = !0
    }
    getSnapshotBeforeUpdate(e) {
        const {layoutDependency: t, visualElement: i, drag: r, isPresent: s} = this.props
          , o = i.projection;
        return o && (o.isPresent = s,
        r || e.layoutDependency !== t || t === void 0 ? o.willUpdate() : this.safeToRemove(),
        e.isPresent !== s && (s ? o.promote() : o.relegate() || mi.postRender(()=>{
            const a = o.getStack();
            (!a || !a.members.length) && this.safeToRemove()
        }
        ))),
        null
    }
    componentDidUpdate() {
        const {projection: e} = this.props.visualElement;
        e && (e.root.didUpdate(),
        !e.currentAnimation && e.isLead() && this.safeToRemove())
    }
    componentWillUnmount() {
        const {visualElement: e, layoutGroup: t, switchLayoutGroup: i} = this.props
          , {projection: r} = e;
        r && (r.scheduleCheckAfterUnmount(),
        t && t.group && t.group.remove(r),
        i && i.deregister && i.deregister(r))
    }
    safeToRemove() {
        const {safeToRemove: e} = this.props;
        e && e()
    }
    render() {
        return null
    }
}
function VL(n) {
    const [e,t] = Qj()
      , i = O.useContext(WR);
    return lt.createElement(eJ, {
        ...n,
        layoutGroup: i,
        switchLayoutGroup: O.useContext(jR),
        isPresent: e,
        safeToRemove: t
    })
}
const tJ = {
    borderRadius: {
        ...ef,
        applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
    },
    borderTopLeftRadius: ef,
    borderTopRightRadius: ef,
    borderBottomLeftRadius: ef,
    borderBottomRightRadius: ef,
    boxShadow: $j
};
function nJ(n, e, t={}) {
    const i = Ri(n) ? n : Xu(n);
    return i.start(PM("", i, e, t)),
    {
        stop: ()=>i.stop(),
        isAnimating: ()=>i.isAnimating()
    }
}
const WL = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"]
  , iJ = WL.length
  , hb = n=>typeof n == "string" ? parseFloat(n) : n
  , pb = n=>typeof n == "number" || nt.test(n);
function rJ(n, e, t, i, r, s) {
    r ? (n.opacity = sn(0, t.opacity !== void 0 ? t.opacity : 1, sJ(i)),
    n.opacityExit = sn(e.opacity !== void 0 ? e.opacity : 1, 0, oJ(i))) : s && (n.opacity = sn(e.opacity !== void 0 ? e.opacity : 1, t.opacity !== void 0 ? t.opacity : 1, i));
    for (let o = 0; o < iJ; o++) {
        const a = `border${WL[o]}Radius`;
        let l = mb(e, a)
          , c = mb(t, a);
        if (l === void 0 && c === void 0)
            continue;
        l || (l = 0),
        c || (c = 0),
        l === 0 || c === 0 || pb(l) === pb(c) ? (n[a] = Math.max(sn(hb(l), hb(c), i), 0),
        (os.test(c) || os.test(l)) && (n[a] += "%")) : n[a] = c
    }
    (e.rotate || t.rotate) && (n.rotate = sn(e.rotate || 0, t.rotate || 0, i))
}
function mb(n, e) {
    return n[e] !== void 0 ? n[e] : n.borderRadius
}
const sJ = jL(0, .5, TM)
  , oJ = jL(.5, .95, yr);
function jL(n, e, t) {
    return i=>i < n ? 0 : i > e ? 1 : t(yd(n, e, i))
}
function gb(n, e) {
    n.min = e.min,
    n.max = e.max
}
function ur(n, e) {
    gb(n.x, e.x),
    gb(n.y, e.y)
}
function yb(n, e, t, i, r) {
    return n -= e,
    n = _g(n, 1 / t, i),
    r !== void 0 && (n = _g(n, 1 / r, i)),
    n
}
function aJ(n, e=0, t=1, i=.5, r, s=n, o=n) {
    if (os.test(e) && (e = parseFloat(e),
    e = sn(o.min, o.max, e / 100) - o.min),
    typeof e != "number")
        return;
    let a = sn(s.min, s.max, i);
    n === s && (a -= e),
    n.min = yb(n.min, e, t, a, r),
    n.max = yb(n.max, e, t, a, r)
}
function vb(n, e, [t,i,r], s, o) {
    aJ(n, e[t], e[i], e[r], e.scale, s, o)
}
const lJ = ["x", "scaleX", "originX"]
  , uJ = ["y", "scaleY", "originY"];
function xb(n, e, t, i) {
    vb(n.x, e, lJ, t ? t.x : void 0, i ? i.x : void 0),
    vb(n.y, e, uJ, t ? t.y : void 0, i ? i.y : void 0)
}
function _b(n) {
    return n.translate === 0 && n.scale === 1
}
function JL(n) {
    return _b(n.x) && _b(n.y)
}
function d_(n, e) {
    return n.x.min === e.x.min && n.x.max === e.x.max && n.y.min === e.y.min && n.y.max === e.y.max
}
function Ab(n) {
    return Ji(n.x) / Ji(n.y)
}
class cJ {
    constructor() {
        this.members = []
    }
    add(e) {
        gM(this.members, e),
        e.scheduleRender()
    }
    remove(e) {
        if (yM(this.members, e),
        e === this.prevLead && (this.prevLead = void 0),
        e === this.lead) {
            const t = this.members[this.members.length - 1];
            t && this.promote(t)
        }
    }
    relegate(e) {
        const t = this.members.findIndex(r=>e === r);
        if (t === 0)
            return !1;
        let i;
        for (let r = t; r >= 0; r--) {
            const s = this.members[r];
            if (s.isPresent !== !1) {
                i = s;
                break
            }
        }
        return i ? (this.promote(i),
        !0) : !1
    }
    promote(e, t) {
        const i = this.lead;
        if (e !== i && (this.prevLead = i,
        this.lead = e,
        e.show(),
        i)) {
            i.instance && i.scheduleRender(),
            e.scheduleRender(),
            e.resumeFrom = i,
            t && (e.resumeFrom.preserveOpacity = !0),
            i.snapshot && (e.snapshot = i.snapshot,
            e.snapshot.latestValues = i.animationValues || i.latestValues),
            e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
            const {crossfade: r} = e.options;
            r === !1 && i.hide()
        }
    }
    exitAnimationComplete() {
        this.members.forEach(e=>{
            const {options: t, resumingFrom: i} = e;
            t.onExitComplete && t.onExitComplete(),
            i && i.options.onExitComplete && i.options.onExitComplete()
        }
        )
    }
    scheduleRender() {
        this.members.forEach(e=>{
            e.instance && e.scheduleRender(!1)
        }
        )
    }
    removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
    }
}
function Mb(n, e, t) {
    let i = "";
    const r = n.x.translate / e.x
      , s = n.y.translate / e.y;
    if ((r || s) && (i = `translate3d(${r}px, ${s}px, 0) `),
    (e.x !== 1 || e.y !== 1) && (i += `scale(${1 / e.x}, ${1 / e.y}) `),
    t) {
        const {rotate: l, rotateX: c, rotateY: d} = t;
        l && (i += `rotate(${l}deg) `),
        c && (i += `rotateX(${c}deg) `),
        d && (i += `rotateY(${d}deg) `)
    }
    const o = n.x.scale * e.x
      , a = n.y.scale * e.y;
    return (o !== 1 || a !== 1) && (i += `scale(${o}, ${a})`),
    i || "none"
}
const fJ = (n,e)=>n.depth - e.depth;
class dJ {
    constructor() {
        this.children = [],
        this.isDirty = !1
    }
    add(e) {
        gM(this.children, e),
        this.isDirty = !0
    }
    remove(e) {
        yM(this.children, e),
        this.isDirty = !0
    }
    forEach(e) {
        this.isDirty && this.children.sort(fJ),
        this.isDirty = !1,
        this.children.forEach(e)
    }
}
function hJ(n) {
    window.MotionDebug && window.MotionDebug.record(n)
}
const wb = ["", "X", "Y", "Z"]
  , Sb = 1e3;
let pJ = 0;
const Ia = {
    type: "projectionFrame",
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0
};
function XL({attachResizeListener: n, defaultParent: e, measureScroll: t, checkIsScrollRoot: i, resetTransform: r}) {
    return class {
        constructor(o, a={}, l=e == null ? void 0 : e()) {
            this.id = pJ++,
            this.animationId = 0,
            this.children = new Set,
            this.options = {},
            this.isTreeAnimating = !1,
            this.isAnimationBlocked = !1,
            this.isLayoutDirty = !1,
            this.isProjectionDirty = !1,
            this.isSharedProjectionDirty = !1,
            this.isTransformDirty = !1,
            this.updateManuallyBlocked = !1,
            this.updateBlockedByResize = !1,
            this.isUpdating = !1,
            this.isSVG = !1,
            this.needsReset = !1,
            this.shouldResetTransform = !1,
            this.treeScale = {
                x: 1,
                y: 1
            },
            this.eventHandlers = new Map,
            this.potentialNodes = new Map,
            this.checkUpdateFailed = ()=>{
                this.isUpdating && (this.isUpdating = !1,
                this.clearAllSnapshots())
            }
            ,
            this.updateProjection = ()=>{
                Ia.totalNodes = Ia.resolvedTargetDeltas = Ia.recalculatedProjection = 0,
                this.nodes.forEach(yJ),
                this.nodes.forEach(AJ),
                this.nodes.forEach(MJ),
                this.nodes.forEach(vJ),
                hJ(Ia)
            }
            ,
            this.hasProjected = !1,
            this.isVisible = !0,
            this.animationProgress = 0,
            this.sharedNodes = new Map,
            this.elementId = o,
            this.latestValues = a,
            this.root = l ? l.root || l : this,
            this.path = l ? [...l.path, l] : [],
            this.parent = l,
            this.depth = l ? l.depth + 1 : 0,
            o && this.root.registerPotentialNode(o, this);
            for (let c = 0; c < this.path.length; c++)
                this.path[c].shouldResetTransform = !0;
            this.root === this && (this.nodes = new dJ)
        }
        addEventListener(o, a) {
            return this.eventHandlers.has(o) || this.eventHandlers.set(o, new vM),
            this.eventHandlers.get(o).add(a)
        }
        notifyListeners(o, ...a) {
            const l = this.eventHandlers.get(o);
            l && l.notify(...a)
        }
        hasListeners(o) {
            return this.eventHandlers.has(o)
        }
        registerPotentialNode(o, a) {
            this.potentialNodes.set(o, a)
        }
        mount(o, a=!1) {
            if (this.instance)
                return;
            this.isSVG = o instanceof SVGElement && o.tagName !== "svg",
            this.instance = o;
            const {layoutId: l, layout: c, visualElement: d} = this.options;
            if (d && !d.current && d.mount(o),
            this.root.nodes.add(this),
            this.parent && this.parent.children.add(this),
            this.elementId && this.root.potentialNodes.delete(this.elementId),
            a && (c || l) && (this.isLayoutDirty = !0),
            n) {
                let h;
                const p = ()=>this.root.updateBlockedByResize = !1;
                n(o, ()=>{
                    this.root.updateBlockedByResize = !0,
                    h && h(),
                    h = IL(p, 250),
                    Cf.hasAnimatedSinceResize && (Cf.hasAnimatedSinceResize = !1,
                    this.nodes.forEach(Eb))
                }
                )
            }
            l && this.root.registerSharedNode(l, this),
            this.options.animate !== !1 && d && (l || c) && this.addEventListener("didUpdate", ({delta: h, hasLayoutChanged: p, hasRelativeTargetChanged: m, layout: y})=>{
                if (this.isTreeAnimationBlocked()) {
                    this.target = void 0,
                    this.relativeTarget = void 0;
                    return
                }
                const v = this.options.transition || d.getDefaultTransition() || TJ
                  , {onLayoutAnimationStart: _, onLayoutAnimationComplete: x} = d.getProps()
                  , A = !this.targetLayout || !d_(this.targetLayout, y) || m
                  , M = !p && m;
                if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || M || p && (A || !this.currentAnimation)) {
                    this.resumeFrom && (this.resumingFrom = this.resumeFrom,
                    this.resumingFrom.resumingFrom = void 0),
                    this.setAnimationOrigin(h, M);
                    const S = {
                        ...DL(v, "layout"),
                        onPlay: _,
                        onComplete: x
                    };
                    (d.shouldReduceMotion || this.options.layoutRoot) && (S.delay = 0,
                    S.type = !1),
                    this.startAnimation(S)
                } else
                    !p && this.animationProgress === 0 && Eb(this),
                    this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                this.targetLayout = y
            }
            )
        }
        unmount() {
            this.options.layoutId && this.willUpdate(),
            this.root.nodes.remove(this);
            const o = this.getStack();
            o && o.remove(this),
            this.parent && this.parent.children.delete(this),
            this.instance = void 0,
            Ko.preRender(this.updateProjection)
        }
        blockUpdate() {
            this.updateManuallyBlocked = !0
        }
        unblockUpdate() {
            this.updateManuallyBlocked = !1
        }
        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize
        }
        isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
        }
        startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = !0,
            this.nodes && this.nodes.forEach(wJ),
            this.animationId++)
        }
        getTransformTemplate() {
            const {visualElement: o} = this.options;
            return o && o.getProps().transformTemplate
        }
        willUpdate(o=!0) {
            if (this.root.isUpdateBlocked()) {
                this.options.onExitComplete && this.options.onExitComplete();
                return
            }
            if (!this.root.isUpdating && this.root.startUpdate(),
            this.isLayoutDirty)
                return;
            this.isLayoutDirty = !0;
            for (let d = 0; d < this.path.length; d++) {
                const h = this.path[d];
                h.shouldResetTransform = !0,
                h.updateScroll("snapshot"),
                h.options.layoutRoot && h.willUpdate(!1)
            }
            const {layoutId: a, layout: l} = this.options;
            if (a === void 0 && !l)
                return;
            const c = this.getTransformTemplate();
            this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0,
            this.updateSnapshot(),
            o && this.notifyListeners("willUpdate")
        }
        didUpdate() {
            if (this.isUpdateBlocked()) {
                this.unblockUpdate(),
                this.clearAllSnapshots(),
                this.nodes.forEach(Cb);
                return
            }
            this.isUpdating && (this.isUpdating = !1,
            this.potentialNodes.size && (this.potentialNodes.forEach(bJ),
            this.potentialNodes.clear()),
            this.nodes.forEach(_J),
            this.nodes.forEach(mJ),
            this.nodes.forEach(gJ),
            this.clearAllSnapshots(),
            Vv.update(),
            Vv.preRender(),
            Vv.render())
        }
        clearAllSnapshots() {
            this.nodes.forEach(xJ),
            this.sharedNodes.forEach(SJ)
        }
        scheduleUpdateProjection() {
            mi.preRender(this.updateProjection, !1, !0)
        }
        scheduleCheckAfterUnmount() {
            mi.postRender(()=>{
                this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
            }
            )
        }
        updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure())
        }
        updateLayout() {
            if (!this.instance || (this.updateScroll(),
            !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
                return;
            if (this.resumeFrom && !this.resumeFrom.instance)
                for (let l = 0; l < this.path.length; l++)
                    this.path[l].updateScroll();
            const o = this.layout;
            this.layout = this.measure(!1),
            this.layoutCorrected = Mn(),
            this.isLayoutDirty = !1,
            this.projectionDelta = void 0,
            this.notifyListeners("measure", this.layout.layoutBox);
            const {visualElement: a} = this.options;
            a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0)
        }
        updateScroll(o="measure") {
            let a = Boolean(this.options.layoutScroll && this.instance);
            this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1),
            a && (this.scroll = {
                animationId: this.root.animationId,
                phase: o,
                isRoot: i(this.instance),
                offset: t(this.instance)
            })
        }
        resetTransform() {
            if (!r)
                return;
            const o = this.isLayoutDirty || this.shouldResetTransform
              , a = this.projectionDelta && !JL(this.projectionDelta)
              , l = this.getTransformTemplate()
              , c = l ? l(this.latestValues, "") : void 0
              , d = c !== this.prevTransformTemplateValue;
            o && (a || La(this.latestValues) || d) && (r(this.instance, c),
            this.shouldResetTransform = !1,
            this.scheduleRender())
        }
        measure(o=!0) {
            const a = this.measurePageBox();
            let l = this.removeElementScroll(a);
            return o && (l = this.removeTransform(l)),
            PJ(l),
            {
                animationId: this.root.animationId,
                measuredBox: a,
                layoutBox: l,
                latestValues: {},
                source: this.id
            }
        }
        measurePageBox() {
            const {visualElement: o} = this.options;
            if (!o)
                return Mn();
            const a = o.measureViewportBox()
              , {scroll: l} = this.root;
            return l && (Ao(a.x, l.offset.x),
            Ao(a.y, l.offset.y)),
            a
        }
        removeElementScroll(o) {
            const a = Mn();
            ur(a, o);
            for (let l = 0; l < this.path.length; l++) {
                const c = this.path[l]
                  , {scroll: d, options: h} = c;
                if (c !== this.root && d && h.layoutScroll) {
                    if (d.isRoot) {
                        ur(a, o);
                        const {scroll: p} = this.root;
                        p && (Ao(a.x, -p.offset.x),
                        Ao(a.y, -p.offset.y))
                    }
                    Ao(a.x, d.offset.x),
                    Ao(a.y, d.offset.y)
                }
            }
            return a
        }
        applyTransform(o, a=!1) {
            const l = Mn();
            ur(l, o);
            for (let c = 0; c < this.path.length; c++) {
                const d = this.path[c];
                !a && d.options.layoutScroll && d.scroll && d !== d.root && xu(l, {
                    x: -d.scroll.offset.x,
                    y: -d.scroll.offset.y
                }),
                La(d.latestValues) && xu(l, d.latestValues)
            }
            return La(this.latestValues) && xu(l, this.latestValues),
            l
        }
        removeTransform(o) {
            const a = Mn();
            ur(a, o);
            for (let l = 0; l < this.path.length; l++) {
                const c = this.path[l];
                if (!c.instance || !La(c.latestValues))
                    continue;
                u_(c.latestValues) && c.updateSnapshot();
                const d = Mn()
                  , h = c.measurePageBox();
                ur(d, h),
                xb(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, d)
            }
            return La(this.latestValues) && xb(a, this.latestValues),
            a
        }
        setTargetDelta(o) {
            this.targetDelta = o,
            this.root.scheduleUpdateProjection(),
            this.isProjectionDirty = !0
        }
        setOptions(o) {
            this.options = {
                ...this.options,
                ...o,
                crossfade: o.crossfade !== void 0 ? o.crossfade : !0
            }
        }
        clearMeasurements() {
            this.scroll = void 0,
            this.layout = void 0,
            this.snapshot = void 0,
            this.prevTransformTemplateValue = void 0,
            this.targetDelta = void 0,
            this.target = void 0,
            this.isLayoutDirty = !1
        }
        resolveTargetDelta() {
            var o;
            const a = this.getLead();
            if (this.isProjectionDirty || (this.isProjectionDirty = a.isProjectionDirty),
            this.isTransformDirty || (this.isTransformDirty = a.isTransformDirty),
            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = a.isSharedProjectionDirty),
            !((Boolean(this.resumingFrom) || this !== a) && this.isSharedProjectionDirty || this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty || this.attemptToResolveRelativeTarget))
                return;
            const {layout: d, layoutId: h} = this.options;
            if (!(!this.layout || !(d || h))) {
                if (!this.targetDelta && !this.relativeTarget) {
                    const p = this.getClosestProjectingParent();
                    p && p.layout ? (this.relativeParent = p,
                    this.relativeTarget = Mn(),
                    this.relativeTargetOrigin = Mn(),
                    Pf(this.relativeTargetOrigin, this.layout.layoutBox, p.layout.layoutBox),
                    ur(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
                if (!(!this.relativeTarget && !this.targetDelta)) {
                    if (this.target || (this.target = Mn(),
                    this.targetWithTransforms = Mn()),
                    this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? Lj(this.target, this.relativeTarget, this.relativeParent.target) : this.targetDelta ? (Boolean(this.resumingFrom) ? this.target = this.applyTransform(this.layout.layoutBox) : ur(this.target, this.layout.layoutBox),
                    zL(this.target, this.targetDelta)) : ur(this.target, this.layout.layoutBox),
                    this.attemptToResolveRelativeTarget) {
                        this.attemptToResolveRelativeTarget = !1;
                        const p = this.getClosestProjectingParent();
                        p && Boolean(p.resumingFrom) === Boolean(this.resumingFrom) && !p.options.layoutScroll && p.target ? (this.relativeParent = p,
                        this.relativeTarget = Mn(),
                        this.relativeTargetOrigin = Mn(),
                        Pf(this.relativeTargetOrigin, this.target, p.target),
                        ur(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                    }
                    Ia.resolvedTargetDeltas++
                }
            }
        }
        getClosestProjectingParent() {
            if (!(!this.parent || u_(this.parent.latestValues) || UL(this.parent.latestValues)))
                return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
        }
        isProjecting() {
            return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
        }
        calcProjection() {
            var o;
            const a = this.getLead()
              , l = Boolean(this.resumingFrom) || this !== a;
            let c = !0;
            if ((this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty) && (c = !1),
            l && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1),
            c)
                return;
            const {layout: d, layoutId: h} = this.options;
            if (this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation),
            this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
            !this.layout || !(d || h))
                return;
            ur(this.layoutCorrected, this.layout.layoutBox),
            Gj(this.layoutCorrected, this.treeScale, this.path, l);
            const {target: p} = a;
            if (!p)
                return;
            this.projectionDelta || (this.projectionDelta = Bf(),
            this.projectionDeltaWithTransform = Bf());
            const m = this.treeScale.x
              , y = this.treeScale.y
              , v = this.projectionTransform;
            bf(this.projectionDelta, this.layoutCorrected, p, this.latestValues),
            this.projectionTransform = Mb(this.projectionDelta, this.treeScale),
            (this.projectionTransform !== v || this.treeScale.x !== m || this.treeScale.y !== y) && (this.hasProjected = !0,
            this.scheduleRender(),
            this.notifyListeners("projectionUpdate", p)),
            Ia.recalculatedProjection++
        }
        hide() {
            this.isVisible = !1
        }
        show() {
            this.isVisible = !0
        }
        scheduleRender(o=!0) {
            if (this.options.scheduleRender && this.options.scheduleRender(),
            o) {
                const a = this.getStack();
                a && a.scheduleRender()
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
        }
        setAnimationOrigin(o, a=!1) {
            const l = this.snapshot
              , c = l ? l.latestValues : {}
              , d = {
                ...this.latestValues
            }
              , h = Bf();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0),
            this.attemptToResolveRelativeTarget = !a;
            const p = Mn()
              , m = l ? l.source : void 0
              , y = this.layout ? this.layout.source : void 0
              , v = m !== y
              , _ = this.getStack()
              , x = !_ || _.members.length <= 1
              , A = Boolean(v && !x && this.options.crossfade === !0 && !this.path.some(EJ));
            this.animationProgress = 0;
            let M;
            this.mixTargetDelta = S=>{
                const T = S / 1e3;
                Tb(h.x, o.x, T),
                Tb(h.y, o.y, T),
                this.setTargetDelta(h),
                this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Pf(p, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
                CJ(this.relativeTarget, this.relativeTargetOrigin, p, T),
                M && d_(this.relativeTarget, M) && (this.isProjectionDirty = !1),
                M || (M = Mn()),
                ur(M, this.relativeTarget)),
                v && (this.animationValues = d,
                rJ(d, c, this.latestValues, T, A, x)),
                this.root.scheduleUpdateProjection(),
                this.scheduleRender(),
                this.animationProgress = T
            }
            ,
            this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
        }
        startAnimation(o) {
            this.notifyListeners("animationStart"),
            this.currentAnimation && this.currentAnimation.stop(),
            this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(),
            this.pendingAnimation && (Ko.update(this.pendingAnimation),
            this.pendingAnimation = void 0),
            this.pendingAnimation = mi.update(()=>{
                Cf.hasAnimatedSinceResize = !0,
                this.currentAnimation = nJ(0, Sb, {
                    ...o,
                    onUpdate: a=>{
                        this.mixTargetDelta(a),
                        o.onUpdate && o.onUpdate(a)
                    }
                    ,
                    onComplete: ()=>{
                        o.onComplete && o.onComplete(),
                        this.completeAnimation()
                    }
                }),
                this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
                this.pendingAnimation = void 0
            }
            )
        }
        completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0,
            this.resumingFrom.preserveOpacity = void 0);
            const o = this.getStack();
            o && o.exitAnimationComplete(),
            this.resumingFrom = this.currentAnimation = this.animationValues = void 0,
            this.notifyListeners("animationComplete")
        }
        finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Sb),
            this.currentAnimation.stop()),
            this.completeAnimation()
        }
        applyTransformsToTarget() {
            const o = this.getLead();
            let {targetWithTransforms: a, target: l, layout: c, latestValues: d} = o;
            if (!(!a || !l || !c)) {
                if (this !== o && this.layout && c && KL(this.options.animationType, this.layout.layoutBox, c.layoutBox)) {
                    l = this.target || Mn();
                    const h = Ji(this.layout.layoutBox.x);
                    l.x.min = o.target.x.min,
                    l.x.max = l.x.min + h;
                    const p = Ji(this.layout.layoutBox.y);
                    l.y.min = o.target.y.min,
                    l.y.max = l.y.min + p
                }
                ur(a, l),
                xu(a, d),
                bf(this.projectionDeltaWithTransform, this.layoutCorrected, a, d)
            }
        }
        registerSharedNode(o, a) {
            this.sharedNodes.has(o) || this.sharedNodes.set(o, new cJ),
            this.sharedNodes.get(o).add(a);
            const c = a.options.initialPromotionConfig;
            a.promote({
                transition: c ? c.transition : void 0,
                preserveFollowOpacity: c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0
            })
        }
        isLead() {
            const o = this.getStack();
            return o ? o.lead === this : !0
        }
        getLead() {
            var o;
            const {layoutId: a} = this.options;
            return a ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this
        }
        getPrevLead() {
            var o;
            const {layoutId: a} = this.options;
            return a ? (o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead : void 0
        }
        getStack() {
            const {layoutId: o} = this.options;
            if (o)
                return this.root.sharedNodes.get(o)
        }
        promote({needsReset: o, transition: a, preserveFollowOpacity: l}={}) {
            const c = this.getStack();
            c && c.promote(this, l),
            o && (this.projectionDelta = void 0,
            this.needsReset = !0),
            a && this.setOptions({
                transition: a
            })
        }
        relegate() {
            const o = this.getStack();
            return o ? o.relegate(this) : !1
        }
        resetRotation() {
            const {visualElement: o} = this.options;
            if (!o)
                return;
            let a = !1;
            const {latestValues: l} = o;
            if ((l.rotate || l.rotateX || l.rotateY || l.rotateZ) && (a = !0),
            !a)
                return;
            const c = {};
            for (let d = 0; d < wb.length; d++) {
                const h = "rotate" + wb[d];
                l[h] && (c[h] = l[h],
                o.setStaticValue(h, 0))
            }
            o.render();
            for (const d in c)
                o.setStaticValue(d, c[d]);
            o.scheduleRender()
        }
        getProjectionStyles(o={}) {
            var a, l;
            const c = {};
            if (!this.instance || this.isSVG)
                return c;
            if (this.isVisible)
                c.visibility = "";
            else
                return {
                    visibility: "hidden"
                };
            const d = this.getTransformTemplate();
            if (this.needsReset)
                return this.needsReset = !1,
                c.opacity = "",
                c.pointerEvents = Rm(o.pointerEvents) || "",
                c.transform = d ? d(this.latestValues, "") : "none",
                c;
            const h = this.getLead();
            if (!this.projectionDelta || !this.layout || !h.target) {
                const v = {};
                return this.options.layoutId && (v.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1,
                v.pointerEvents = Rm(o.pointerEvents) || ""),
                this.hasProjected && !La(this.latestValues) && (v.transform = d ? d({}, "") : "none",
                this.hasProjected = !1),
                v
            }
            const p = h.animationValues || h.latestValues;
            this.applyTransformsToTarget(),
            c.transform = Mb(this.projectionDeltaWithTransform, this.treeScale, p),
            d && (c.transform = d(p, c.transform));
            const {x: m, y} = this.projectionDelta;
            c.transformOrigin = `${m.origin * 100}% ${y.origin * 100}% 0`,
            h.animationValues ? c.opacity = h === this ? (l = (a = p.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : p.opacityExit : c.opacity = h === this ? p.opacity !== void 0 ? p.opacity : "" : p.opacityExit !== void 0 ? p.opacityExit : 0;
            for (const v in hg) {
                if (p[v] === void 0)
                    continue;
                const {correct: _, applyTo: x} = hg[v]
                  , A = c.transform === "none" ? p[v] : _(p[v], h);
                if (x) {
                    const M = x.length;
                    for (let S = 0; S < M; S++)
                        c[x[S]] = A
                } else
                    c[v] = A
            }
            return this.options.layoutId && (c.pointerEvents = h === this ? Rm(o.pointerEvents) || "" : "none"),
            c
        }
        clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0
        }
        resetTree() {
            this.root.nodes.forEach(o=>{
                var a;
                return (a = o.currentAnimation) === null || a === void 0 ? void 0 : a.stop()
            }
            ),
            this.root.nodes.forEach(Cb),
            this.root.sharedNodes.clear()
        }
    }
}
function mJ(n) {
    n.updateLayout()
}
function gJ(n) {
    var e;
    const t = ((e = n.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || n.snapshot;
    if (n.isLead() && n.layout && t && n.hasListeners("didUpdate")) {
        const {layoutBox: i, measuredBox: r} = n.layout
          , {animationType: s} = n.options
          , o = t.source !== n.layout.source;
        s === "size" ? es(h=>{
            const p = o ? t.measuredBox[h] : t.layoutBox[h]
              , m = Ji(p);
            p.min = i[h].min,
            p.max = p.min + m
        }
        ) : KL(s, t.layoutBox, i) && es(h=>{
            const p = o ? t.measuredBox[h] : t.layoutBox[h]
              , m = Ji(i[h]);
            p.max = p.min + m
        }
        );
        const a = Bf();
        bf(a, i, t.layoutBox);
        const l = Bf();
        o ? bf(l, n.applyTransform(r, !0), t.measuredBox) : bf(l, i, t.layoutBox);
        const c = !JL(a);
        let d = !1;
        if (!n.resumeFrom) {
            const h = n.getClosestProjectingParent();
            if (h && !h.resumeFrom) {
                const {snapshot: p, layout: m} = h;
                if (p && m) {
                    const y = Mn();
                    Pf(y, t.layoutBox, p.layoutBox);
                    const v = Mn();
                    Pf(v, i, m.layoutBox),
                    d_(y, v) || (d = !0),
                    h.options.layoutRoot && (n.relativeTarget = v,
                    n.relativeTargetOrigin = y,
                    n.relativeParent = h)
                }
            }
        }
        n.notifyListeners("didUpdate", {
            layout: i,
            snapshot: t,
            delta: l,
            layoutDelta: a,
            hasLayoutChanged: c,
            hasRelativeTargetChanged: d
        })
    } else if (n.isLead()) {
        const {onExitComplete: i} = n.options;
        i && i()
    }
    n.options.transition = void 0
}
function yJ(n) {
    Ia.totalNodes++,
    n.parent && (n.isProjecting() || (n.isProjectionDirty = n.parent.isProjectionDirty),
    n.isSharedProjectionDirty || (n.isSharedProjectionDirty = Boolean(n.isProjectionDirty || n.parent.isProjectionDirty || n.parent.isSharedProjectionDirty)),
    n.isTransformDirty || (n.isTransformDirty = n.parent.isTransformDirty))
}
function vJ(n) {
    n.isProjectionDirty = n.isSharedProjectionDirty = n.isTransformDirty = !1
}
function xJ(n) {
    n.clearSnapshot()
}
function Cb(n) {
    n.clearMeasurements()
}
function _J(n) {
    const {visualElement: e} = n.options;
    e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"),
    n.resetTransform()
}
function Eb(n) {
    n.finishAnimation(),
    n.targetDelta = n.relativeTarget = n.target = void 0
}
function AJ(n) {
    n.resolveTargetDelta()
}
function MJ(n) {
    n.calcProjection()
}
function wJ(n) {
    n.resetRotation()
}
function SJ(n) {
    n.removeLeadSnapshot()
}
function Tb(n, e, t) {
    n.translate = sn(e.translate, 0, t),
    n.scale = sn(e.scale, 1, t),
    n.origin = e.origin,
    n.originPoint = e.originPoint
}
function bb(n, e, t, i) {
    n.min = sn(e.min, t.min, i),
    n.max = sn(e.max, t.max, i)
}
function CJ(n, e, t, i) {
    bb(n.x, e.x, t.x, i),
    bb(n.y, e.y, t.y, i)
}
function EJ(n) {
    return n.animationValues && n.animationValues.opacityExit !== void 0
}
const TJ = {
    duration: .45,
    ease: [.4, 0, .1, 1]
};
function bJ(n, e) {
    let t = n.root;
    for (let s = n.path.length - 1; s >= 0; s--)
        if (Boolean(n.path[s].instance)) {
            t = n.path[s];
            break
        }
    const r = (t && t !== n.root ? t.instance : document).querySelector(`[data-projection-id="${e}"]`);
    r && n.mount(r, !0)
}
function Pb(n) {
    n.min = Math.round(n.min),
    n.max = Math.round(n.max)
}
function PJ(n) {
    Pb(n.x),
    Pb(n.y)
}
function KL(n, e, t) {
    return n === "position" || n === "preserve-aspect" && !a_(Ab(e), Ab(t), .2)
}
const BJ = XL({
    attachResizeListener: (n,e)=>Ns(n, "resize", e),
    measureScroll: ()=>({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: ()=>!0
})
  , qv = {
    current: void 0
}
  , YL = XL({
    measureScroll: n=>({
        x: n.scrollLeft,
        y: n.scrollTop
    }),
    defaultParent: ()=>{
        if (!qv.current) {
            const n = new BJ(0,{});
            n.mount(window),
            n.setOptions({
                layoutScroll: !0
            }),
            qv.current = n
        }
        return qv.current
    }
    ,
    resetTransform: (n,e)=>{
        n.style.transform = e !== void 0 ? e : "none"
    }
    ,
    checkIsScrollRoot: n=>Boolean(window.getComputedStyle(n).position === "fixed")
})
  , RJ = {
    pan: {
        Feature: Yj
    },
    drag: {
        Feature: Kj,
        ProjectionNode: YL,
        MeasureLayout: VL
    }
}
  , LJ = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y"])
  , QL = n=>LJ.has(n)
  , IJ = n=>Object.keys(n).some(QL)
  , Bb = n=>n === vl || n === nt
  , Rb = (n,e)=>parseFloat(n.split(", ")[e])
  , Lb = (n,e)=>(t,{transform: i})=>{
    if (i === "none" || !i)
        return 0;
    const r = i.match(/^matrix3d\((.+)\)$/);
    if (r)
        return Rb(r[1], e);
    {
        const s = i.match(/^matrix\((.+)\)$/);
        return s ? Rb(s[1], n) : 0
    }
}
  , DJ = new Set(["x", "y", "z"])
  , FJ = f0.filter(n=>!DJ.has(n));
function kJ(n) {
    const e = [];
    return FJ.forEach(t=>{
        const i = n.getValue(t);
        i !== void 0 && (e.push([t, i.get()]),
        i.set(t.startsWith("scale") ? 1 : 0))
    }
    ),
    e.length && n.render(),
    e
}
const Ib = {
    width: ({x: n},{paddingLeft: e="0", paddingRight: t="0"})=>n.max - n.min - parseFloat(e) - parseFloat(t),
    height: ({y: n},{paddingTop: e="0", paddingBottom: t="0"})=>n.max - n.min - parseFloat(e) - parseFloat(t),
    top: (n,{top: e})=>parseFloat(e),
    left: (n,{left: e})=>parseFloat(e),
    bottom: ({y: n},{top: e})=>parseFloat(e) + (n.max - n.min),
    right: ({x: n},{left: e})=>parseFloat(e) + (n.max - n.min),
    x: Lb(4, 13),
    y: Lb(5, 14)
}
  , NJ = (n,e,t)=>{
    const i = e.measureViewportBox()
      , r = e.current
      , s = getComputedStyle(r)
      , {display: o} = s
      , a = {};
    o === "none" && e.setStaticValue("display", n.display || "block"),
    t.forEach(c=>{
        a[c] = Ib[c](i, s)
    }
    ),
    e.render();
    const l = e.measureViewportBox();
    return t.forEach(c=>{
        const d = e.getValue(c);
        d && d.jump(a[c]),
        n[c] = Ib[c](l, s)
    }
    ),
    n
}
  , OJ = (n,e,t={},i={})=>{
    e = {
        ...e
    },
    i = {
        ...i
    };
    const r = Object.keys(e).filter(QL);
    let s = []
      , o = !1;
    const a = [];
    if (r.forEach(l=>{
        const c = n.getValue(l);
        if (!n.hasValue(l))
            return;
        let d = t[l]
          , h = $c(d);
        const p = e[l];
        let m;
        if (mg(p)) {
            const y = p.length
              , v = p[0] === null ? 1 : 0;
            d = p[v],
            h = $c(d);
            for (let _ = v; _ < y; _++)
                m ? vg($c(p[_]) === m) : m = $c(p[_])
        } else
            m = $c(p);
        if (h !== m)
            if (Bb(h) && Bb(m)) {
                const y = c.get();
                typeof y == "string" && c.set(parseFloat(y)),
                typeof p == "string" ? e[l] = parseFloat(p) : Array.isArray(p) && m === nt && (e[l] = p.map(parseFloat))
            } else
                h != null && h.transform && (m != null && m.transform) && (d === 0 || p === 0) ? d === 0 ? c.set(m.transform(d)) : e[l] = h.transform(p) : (o || (s = kJ(n),
                o = !0),
                a.push(l),
                i[l] = i[l] !== void 0 ? i[l] : e[l],
                c.jump(p))
    }
    ),
    a.length) {
        const l = a.indexOf("height") >= 0 ? window.pageYOffset : null
          , c = NJ(e, n, a);
        return s.length && s.forEach(([d,h])=>{
            n.getValue(d).set(h)
        }
        ),
        n.render(),
        l0 && l !== null && window.scrollTo({
            top: l
        }),
        {
            target: c,
            transitionEnd: i
        }
    } else
        return {
            target: e,
            transitionEnd: i
        }
}
;
function UJ(n, e, t, i) {
    return IJ(e) ? OJ(n, e, t, i) : {
        target: e,
        transitionEnd: i
    }
}
const zJ = (n,e,t,i)=>{
    const r = qj(n, e, i);
    return e = r.target,
    i = r.transitionEnd,
    UJ(n, e, t, i)
}
  , h_ = {
    current: null
}
  , ZL = {
    current: !1
};
function GJ() {
    if (ZL.current = !0,
    !!l0)
        if (window.matchMedia) {
            const n = window.matchMedia("(prefers-reduced-motion)")
              , e = ()=>h_.current = n.matches;
            n.addListener(e),
            e()
        } else
            h_.current = !1
}
function HJ(n, e, t) {
    const {willChange: i} = e;
    for (const r in e) {
        const s = e[r]
          , o = t[r];
        if (Ri(s))
            n.addValue(r, s),
            yg(i) && i.add(r);
        else if (Ri(o))
            n.addValue(r, Xu(s, {
                owner: n
            })),
            yg(i) && i.remove(r);
        else if (o !== s)
            if (n.hasValue(r)) {
                const a = n.getValue(r);
                !a.hasAnimated && a.set(s)
            } else {
                const a = n.getStaticValue(r);
                n.addValue(r, Xu(a !== void 0 ? a : s, {
                    owner: n
                }))
            }
    }
    for (const r in t)
        e[r] === void 0 && n.removeValue(r);
    return e
}
const qL = Object.keys(pd)
  , VJ = qL.length
  , Db = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]
  , WJ = aM.length;
class jJ {
    constructor({parent: e, props: t, presenceContext: i, reducedMotionConfig: r, visualState: s}, o={}) {
        this.current = null,
        this.children = new Set,
        this.isVariantNode = !1,
        this.isControllingVariants = !1,
        this.shouldReduceMotion = null,
        this.values = new Map,
        this.features = {},
        this.valueSubscriptions = new Map,
        this.prevMotionValues = {},
        this.events = {},
        this.propEventSubscriptions = {},
        this.notifyUpdate = ()=>this.notify("Update", this.latestValues),
        this.render = ()=>{
            this.current && (this.triggerBuild(),
            this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
        }
        ,
        this.scheduleRender = ()=>mi.render(this.render, !1, !0);
        const {latestValues: a, renderState: l} = s;
        this.latestValues = a,
        this.baseTarget = {
            ...a
        },
        this.initialValues = t.initial ? {
            ...a
        } : {},
        this.renderState = l,
        this.parent = e,
        this.props = t,
        this.presenceContext = i,
        this.depth = e ? e.depth + 1 : 0,
        this.reducedMotionConfig = r,
        this.options = o,
        this.isControllingVariants = c0(t),
        this.isVariantNode = HR(t),
        this.isVariantNode && (this.variantChildren = new Set),
        this.manuallyAnimateOnMount = Boolean(e && e.current);
        const {willChange: c, ...d} = this.scrapeMotionValuesFromProps(t, {});
        for (const h in d) {
            const p = d[h];
            a[h] !== void 0 && Ri(p) && (p.set(a[h], !1),
            yg(c) && c.add(h))
        }
    }
    scrapeMotionValuesFromProps(e, t) {
        return {}
    }
    mount(e) {
        this.current = e,
        this.projection && this.projection.mount(e),
        this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)),
        this.values.forEach((t,i)=>this.bindToMotionValue(i, t)),
        ZL.current || GJ(),
        this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : h_.current,
        this.parent && this.parent.children.add(this),
        this.update(this.props, this.presenceContext)
    }
    unmount() {
        this.projection && this.projection.unmount(),
        Ko.update(this.notifyUpdate),
        Ko.render(this.render),
        this.valueSubscriptions.forEach(e=>e()),
        this.removeFromVariantTree && this.removeFromVariantTree(),
        this.parent && this.parent.children.delete(this);
        for (const e in this.events)
            this.events[e].clear();
        for (const e in this.features)
            this.features[e].unmount();
        this.current = null
    }
    bindToMotionValue(e, t) {
        const i = yl.has(e)
          , r = t.on("change", o=>{
            this.latestValues[e] = o,
            this.props.onUpdate && mi.update(this.notifyUpdate, !1, !0),
            i && this.projection && (this.projection.isTransformDirty = !0)
        }
        )
          , s = t.on("renderRequest", this.scheduleRender);
        this.valueSubscriptions.set(e, ()=>{
            r(),
            s()
        }
        )
    }
    sortNodePosition(e) {
        return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current)
    }
    loadFeatures({children: e, ...t}, i, r, s, o) {
        let a, l;
        for (let c = 0; c < VJ; c++) {
            const d = qL[c]
              , {isEnabled: h, Feature: p, ProjectionNode: m, MeasureLayout: y} = pd[d];
            m && (a = m),
            h(t) && (!this.features[d] && p && (this.features[d] = new p(this)),
            y && (l = y))
        }
        if (!this.projection && a) {
            this.projection = new a(s,this.latestValues,this.parent && this.parent.projection);
            const {layoutId: c, layout: d, drag: h, dragConstraints: p, layoutScroll: m, layoutRoot: y} = t;
            this.projection.setOptions({
                layoutId: c,
                layout: d,
                alwaysMeasureLayout: Boolean(h) || p && yu(p),
                visualElement: this,
                scheduleRender: ()=>this.scheduleRender(),
                animationType: typeof d == "string" ? d : "both",
                initialPromotionConfig: o,
                layoutScroll: m,
                layoutRoot: y
            })
        }
        return l
    }
    updateFeatures() {
        for (const e in this.features) {
            const t = this.features[e];
            t.isMounted ? t.update(this.props, this.prevProps) : (t.mount(),
            t.isMounted = !0)
        }
    }
    triggerBuild() {
        this.build(this.renderState, this.latestValues, this.options, this.props)
    }
    measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Mn()
    }
    getStaticValue(e) {
        return this.latestValues[e]
    }
    setStaticValue(e, t) {
        this.latestValues[e] = t
    }
    makeTargetAnimatable(e, t=!0) {
        return this.makeTargetAnimatableFromInstance(e, this.props, t)
    }
    update(e, t) {
        (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
        this.prevProps = this.props,
        this.props = e,
        this.prevPresenceContext = this.presenceContext,
        this.presenceContext = t;
        for (let i = 0; i < Db.length; i++) {
            const r = Db[i];
            this.propEventSubscriptions[r] && (this.propEventSubscriptions[r](),
            delete this.propEventSubscriptions[r]);
            const s = e["on" + r];
            s && (this.propEventSubscriptions[r] = this.on(r, s))
        }
        this.prevMotionValues = HJ(this, this.scrapeMotionValuesFromProps(e, this.prevProps), this.prevMotionValues),
        this.handleChildMotionValue && this.handleChildMotionValue()
    }
    getProps() {
        return this.props
    }
    getVariant(e) {
        return this.props.variants ? this.props.variants[e] : void 0
    }
    getDefaultTransition() {
        return this.props.transition
    }
    getTransformPagePoint() {
        return this.props.transformPagePoint
    }
    getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
    }
    getVariantContext(e=!1) {
        if (e)
            return this.parent ? this.parent.getVariantContext() : void 0;
        if (!this.isControllingVariants) {
            const i = this.parent ? this.parent.getVariantContext() || {} : {};
            return this.props.initial !== void 0 && (i.initial = this.props.initial),
            i
        }
        const t = {};
        for (let i = 0; i < WJ; i++) {
            const r = aM[i]
              , s = this.props[r];
            (hd(s) || s === !1) && (t[r] = s)
        }
        return t
    }
    addVariantChild(e) {
        const t = this.getClosestVariantNode();
        if (t)
            return t.variantChildren && t.variantChildren.add(e),
            ()=>t.variantChildren.delete(e)
    }
    addValue(e, t) {
        t !== this.values.get(e) && (this.removeValue(e),
        this.bindToMotionValue(e, t)),
        this.values.set(e, t),
        this.latestValues[e] = t.get()
    }
    removeValue(e) {
        this.values.delete(e);
        const t = this.valueSubscriptions.get(e);
        t && (t(),
        this.valueSubscriptions.delete(e)),
        delete this.latestValues[e],
        this.removeValueFromRenderState(e, this.renderState)
    }
    hasValue(e) {
        return this.values.has(e)
    }
    getValue(e, t) {
        if (this.props.values && this.props.values[e])
            return this.props.values[e];
        let i = this.values.get(e);
        return i === void 0 && t !== void 0 && (i = Xu(t, {
            owner: this
        }),
        this.addValue(e, i)),
        i
    }
    readValue(e) {
        return this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : this.readValueFromInstance(this.current, e, this.options)
    }
    setBaseTarget(e, t) {
        this.baseTarget[e] = t
    }
    getBaseTarget(e) {
        var t;
        const {initial: i} = this.props
          , r = typeof i == "string" || typeof i == "object" ? (t = mM(this.props, i)) === null || t === void 0 ? void 0 : t[e] : void 0;
        if (i && r !== void 0)
            return r;
        const s = this.getBaseTargetFromProps(this.props, e);
        return s !== void 0 && !Ri(s) ? s : this.initialValues[e] !== void 0 && r === void 0 ? void 0 : this.baseTarget[e]
    }
    on(e, t) {
        return this.events[e] || (this.events[e] = new vM),
        this.events[e].add(t)
    }
    notify(e, ...t) {
        this.events[e] && this.events[e].notify(...t)
    }
}
class $L extends jJ {
    sortInstanceNodePosition(e, t) {
        return e.compareDocumentPosition(t) & 2 ? 1 : -1
    }
    getBaseTargetFromProps(e, t) {
        return e.style ? e.style[t] : void 0
    }
    removeValueFromRenderState(e, {vars: t, style: i}) {
        delete t[e],
        delete i[e]
    }
    makeTargetAnimatableFromInstance({transition: e, transitionEnd: t, ...i}, {transformValues: r}, s) {
        let o = p7(i, e || {}, this);
        if (r && (t && (t = r(t)),
        i && (i = r(i)),
        o && (o = r(o))),
        s) {
            d7(this, i, o);
            const a = zJ(this, i, o, t);
            t = a.transitionEnd,
            i = a.target
        }
        return {
            transition: e,
            transitionEnd: t,
            ...i
        }
    }
}
function JJ(n) {
    return window.getComputedStyle(n)
}
class XJ extends $L {
    readValueFromInstance(e, t) {
        if (yl.has(t)) {
            const i = AM(t);
            return i && i.default || 0
        } else {
            const i = JJ(e)
              , r = (KR(t) ? i.getPropertyValue(t) : i[t]) || 0;
            return typeof r == "string" ? r.trim() : r
        }
    }
    measureInstanceViewportBox(e, {transformPagePoint: t}) {
        return GL(e, t)
    }
    build(e, t, i, r) {
        uM(e, t, i, r.transformTemplate)
    }
    scrapeMotionValuesFromProps(e, t) {
        return pM(e, t)
    }
    handleChildMotionValue() {
        this.childSubscription && (this.childSubscription(),
        delete this.childSubscription);
        const {children: e} = this.props;
        Ri(e) && (this.childSubscription = e.on("change", t=>{
            this.current && (this.current.textContent = `${t}`)
        }
        ))
    }
    renderInstance(e, t, i, r) {
        $R(e, t, i, r)
    }
}
class KJ extends $L {
    constructor() {
        super(...arguments),
        this.isSVGTag = !1
    }
    getBaseTargetFromProps(e, t) {
        return e[t]
    }
    readValueFromInstance(e, t) {
        if (yl.has(t)) {
            const i = AM(t);
            return i && i.default || 0
        }
        return t = eL.has(t) ? t : hM(t),
        e.getAttribute(t)
    }
    measureInstanceViewportBox() {
        return Mn()
    }
    scrapeMotionValuesFromProps(e, t) {
        return nL(e, t)
    }
    build(e, t, i, r) {
        fM(e, t, i, this.isSVGTag, r.transformTemplate)
    }
    renderInstance(e, t, i, r) {
        tL(e, t, i, r)
    }
    mount(e) {
        this.isSVGTag = dM(e.tagName),
        super.mount(e)
    }
}
const YJ = (n,e)=>lM(n) ? new KJ(e,{
    enableHardwareAcceleration: !1
}) : new XJ(e,{
    enableHardwareAcceleration: !0
})
  , QJ = {
    layout: {
        ProjectionNode: YL,
        MeasureLayout: VL
    }
}
  , ZJ = {
    ...bj,
    ...zW,
    ...RJ,
    ...QJ
}
  , Qo = $V((n,e)=>TW(n, e, ZJ, YJ))
  , ni = {
    paddingX: "sm:px-16 px-6",
    paddingY: "sm:py-16 py-6",
    padding: "sm:px-16 px-6 sm:py-16 py-10",
    heroHeadText: "font-black text-white lg:text-[60px] sm:text-[30px] xs:text-[20px] text-[20px] lg:leading-[58px] mt-2",
    heroSubText: "text-[#dfd9ff] font-medium lg:text-[20px] sm:text-[16px] xs:text-[10px] text-[10px] lg:leading-[30px]",
    sectionHeadText: "text-white font-black md:text-[60px] sm:text-[50px] xs:text-[40px] text-[30px]",
    sectionSubText: "sm:text-[18px] text-[14px] text-secondary uppercase tracking-wider"
}
  , lK = [{
    id: "about",
    title: "About"
}, {
    id: "projects",
    title: "Projects"
}, {
    id: "contact",
    title: "Contact"
}]
  , uK = {
    web: "https://programmerdatch.000webhostapp.com/",
    ig: "https://www.instagram.com/programmerdatch/",
    linkedin: "https://www.linkedin.com/in/programmerdatch/",
    github: "https://github.com/ProgrammerDATCH",
    youtube: "https://www.youtube.com/@ProgrammerDATCH",
    twitter: "https://twitter.com/ProgrammerDATCH",
    whatsapp: "https://wa.me/+250735177666",
    whatsappJob: "https://wa.me/+250735177666?text=Greetings%20Programmer%20DATCH%2C%0A%0AI%20discovered%20your%20portfolio%20and%20I%27m%20interested%20in%20offering%20you%20a%20coding%20opportunity%20for%20my%20project.",
    facebook: "https://www.facebook.com/profile.php?id=100068532707087",
    email: "mailto:programmerdatch@gmail.com",
    tiktok: "https://tiktok.com/@programmerdatch",
    play: "https://play.google.com/store/apps/dev?id=7881383766588193746",
    telegram: "https://t.me/programmerdatch",
    snap: "https://www.snapchat.com/add/datch1502?share_id=NZq-VlCB6p4&locale=en-US",
    call: "tel:+250735177666"
}
  , qJ = [{
    title: "Full-Stack Web Developer",
    icon: c3
}, {
    title: "Android Apps Developer",
    icon: aO
}, {
    title: "iPhone Apps Developer",
    icon: oO
}, {
    title: "Windows, MacOS & Linux App Developer",
    icon: lO
}, {
    title: "Backend Developer",
    icon: uO
}, {
    title: "Web Server Monitoring Specialist",
    icon: sO
}, {
    title: "MetaTrader 5 Expert Advisor Programmer",
    icon: fO
}, {
    title: "Final Year Project Programmer",
    icon: cO
}]
  , $J = [{
    name: "HTML",
    icon: YN
}, {
    name: "CSS",
    icon: XN
}, {
    name: "JavaScript",
    icon: QN
}, {
    name: "TypeScript",
    icon: eO
}, {
    name: "PHP & Laravel",
    icon: rO
}, {
    name: "Java",
    icon: ZN
}, {
    name: "MQL5",
    icon: iO
}, {
    name: "Dart & Flutter",
    icon: nO
}, {
    name: "C & C++",
    icon: tO
}, {
    name: "React",
    icon: $N
}, {
    name: "Node.js",
    icon: qN
}, {
    name: "Figma",
    icon: KN
}]
  , eX = [{
    title: "PyGame Instructor",
    company_name: "ULK-DIC BootCamp",
    icon: pO,
    iconBg: "#E6DEDD",
    date: "July 2023 - Sept 2023",
    points: ["Taught students how to code games using Pygame, enhancing their programming skills and creativity.", "Developed curriculum and course materials, ensuring effective learning outcomes.", "Learned time management skills while balancing teaching responsibilities with other commitments."]
}, {
    title: "Full Stack Developer",
    company_name: "Bakame Coders",
    icon: hO,
    iconBg: "#383E56",
    date: "Jan 2022 - Present",
    points: ["Developed and maintained web applications using React.js, Node.js, and TypeScript, ensuring high performance and scalability.", "Collaborated with cross-functional teams including designers, product managers, and other developers to create high-quality products.", "Implemented responsive design and ensured cross-browser compatibility.", "Participated in code reviews, providing constructive feedback to improve code quality.", "Utilized Git for version control and team collaboration."]
}, {
    title: "Backend Developer",
    company_name: "Binary Hub - University of Rwanda",
    icon: dO,
    iconBg: "#E6DEDD",
    date: "Aug 2023 - Present",
    points: ["Developed and maintained RESTful APIs using Node.js to provide data access to front-end applications.", "Managed PostgreSQL database to store and retrieve data efficiently, ensuring data integrity and security.", "Integrated third-party services, such as payment gateways and authentication services, to enhance application functionality.", "Monitored server performance and conducted optimizations to improve response times and overall system efficiency."]
}]
  , tX = [{
    testimonial: "Working with Programmer DATCH on my final year project was a pleasure. His expertise and guidance were evident from the start of the project, and he exceeded my expectations in every aspects.",
    name: "Elie NIZEYIMANA",
    designation: "Formal Student",
    company: "IPRC Huye",
    image: gO
}, {
    testimonial: "Programmer DATCH's dedication and commitment to delivering high-quality work are truly exceptional. I've never met a web developer who cares about their clients' success like he does.",
    name: "Moses IRAKOZE",
    designation: "Formal Student",
    company: "IPRC Huye",
    image: mO
}, {
    testimonial: "I had the pleasure of working with Programmer DATCH on a project, and I was amazed by his dedication to quality and client satisfaction. He truly goes above and beyond the project expectation.",
    name: "Kevine Gasaro",
    designation: "Business Woman",
    company: "",
    image: yO
}]
  , tf = [{
    name: "HTML",
    color: "blue-text-gradient"
}, {
    name: "CSS",
    color: "pink-text-gradient"
}, {
    name: "PHP",
    color: "green-text-gradient"
}, {
    name: "Javascript",
    color: "text-yellow-400"
}]
  , nX = [{
    name: "MERN",
    color: "text-red-400"
}, {
    name: "MongoDB",
    color: "green-text-gradient"
}, {
    name: "ExpressJS",
    color: "green-text-gradient"
}, {
    name: "ReactJS",
    color: "blue-text-gradient"
}, {
    name: "NodeJS",
    color: "green-text-gradient"
}, {
    name: "Tailwind CSS",
    color: "text-yellow-400"
}]
  , iX = [{
    name: "ReactJS",
    color: "blue-text-gradient"
}, {
    name: "Apex-Chart",
    color: "text-purple-400"
}, {
    name: "Tailwind CSS",
    color: "text-yellow-400"
}]
  , Fb = [{
    name: "PERN",
    color: "text-red-400"
}, {
    name: "PostgreSQL",
    color: "blue-text-gradient"
}, {
    name: "ExpressJS",
    color: "green-text-gradient"
}, {
    name: "ReactJS",
    color: "blue-text-gradient"
}, {
    name: "NodeJS",
    color: "green-text-gradient"
}, {
    name: "Tailwind CSS",
    color: "text-yellow-400"
}]
  , rX = [{
    name: "Bakame Coders Website",
    description: "Portfolio for Bakame Coders group, that shows their projects and their services in good UI/UX",
    tags: tf,
    image: xO,
    source_code_link: "https://github.com/bakamecoders/bakamecoders-website",
    project_link: "https://bakamecoders.000webhostapp.com/"
}, {
    name: "Drivers Hiring System",
    description: "Web based App to connect Drivers with Job offers",
    tags: tf,
    image: AO,
    source_code_link: "",
    project_link: "https://driverhiringsystem.000webhostapp.com/"
}, {
    name: "Ntakomisiyo",
    description: "E-Portal for connecting buyers and sellers of used products without commission.",
    tags: tf,
    image: MO,
    source_code_link: "",
    project_link: "https://gurantakomisiyo.000webhostapp.com/"
}, {
    name: "Coach-Connect",
    description: "Web based system for connecting students with Coach, also Parents participate.",
    tags: tf,
    image: _O,
    source_code_link: "",
    project_link: "https://coachconnectweb.000webhostapp.com/"
}, {
    name: "Save-Street-Children",
    description: "Website to allow everyone report info for street children and Districts connect those children to NGOs.",
    tags: tf,
    image: wO,
    source_code_link: "",
    project_link: "https://savestreetchildren.000webhostapp.com/"
}, {
    name: "Tera Brain Bot",
    description: "Artificial Intelligent Android App that respond to every prompt with additional capabilities of OCR and Voice asking prompt.",
    tags: [{
        name: "JAVA",
        color: "blue-text-gradient"
    }, {
        name: "XML",
        color: "green-text-gradient"
    }],
    image: vO,
    source_code_link: "",
    project_link: ""
}, {
    name: "Etite-Events-Management-System",
    description: "Event management system to allow users see listed events and book tickets, then Admin Approve or deny them.",
    tags: nX,
    image: SO,
    source_code_link: "",
    project_link: "https://etite-events-management-system.netlify.app/"
}, {
    name: "Admin Dashboard",
    description: "Modern responsive Admin Dashboard that I use in many of my projects.",
    tags: iX,
    image: EO,
    source_code_link: "",
    project_link: ""
}, {
    name: "Wide Logistics",
    description: "E-Commerce for delivering food products and related products.",
    tags: Fb,
    image: TO,
    source_code_link: "",
    project_link: "https://widelogistics.online/"
}, {
    name: "Amategeko y-umuhanda Web",
    description: "Web App to teach people traffic rules and get ready to pass driving license test.",
    tags: Fb,
    image: CO,
    source_code_link: "",
    project_link: "https://amategeko-yumuhanda.netlify.app/"
}]
  , BM = {
    desc: "Full Stack Web & App Developer.",
    about: "I'm David (Programmer DATCH), a dedicated full-stack web and app developer with a passion for creating user-friendly solutions. Proficient in a variety of programming languages including HTML, CSS, JavaScript, PHP, Java, C, MQL5, Dart, and C++, I specialize in using technologies like ReactJs, ReactNative, NodeJs, PostgreSQL, Flutter, Laravel, and Firebase. My goal is to continually grow and adapt to the ever-changing tech landscape, delivering innovative solutions to my clients.",
    work: "The following projects are examples of my work, showcasing my skills and experience. Open-source projects have GitHub links to their source codes, while non-private projects have links to the actual projects. Some private projects are not listed here due to client confidentiality."
}
  , sX = ()=>ut("section", {
    className: "relative w-full h-screen mx-auto",
    children: [ut("div", {
        className: `absolute inset-0 top-[120px]  max-w-7xl mx-auto ${ni.paddingX} flex flex-row items-start gap-5`,
        children: [ut("div", {
            className: "flex flex-col justify-center items-center mt-5",
            children: [xe("div", {
                className: "w-5 h-5 rounded-full bg-[#915EFF]"
            }), xe("div", {
                className: "w-1 sm:h-80 h-40 violet-gradient"
            })]
        }), ut("div", {
            children: [ut("h1", {
                className: `${ni.heroHeadText} text-white`,
                children: ["Hi, I'm ", xe("span", {
                    className: "text-[#915EFF]",
                    children: "Programmer DATCH"
                })]
            }), xe("p", {
                className: `${ni.heroSubText} mt-2 text-white-100`,
                children: BM.desc
            })]
        })]
    }), xe(UV, {}), xe("div", {
        className: "absolute xs:bottom-10 bottom-32 w-full flex justify-center items-center",
        children: xe("a", {
            href: "#about",
            children: xe("div", {
                className: "w-[35px] h-[64px] rounded-3xl border-4 border-secondary flex justify-center items-start p-2",
                children: xe(Qo.div, {
                    animate: {
                        y: [0, 24, 0]
                    },
                    transition: {
                        duration: 1.5,
                        repeat: 1 / 0,
                        repeatType: "loop"
                    },
                    className: "w-3 h-3 rounded-full bg-secondary mb-1"
                })
            })
        })
    })]
});
var oX = Object.defineProperty
  , aX = Object.defineProperties
  , lX = Object.getOwnPropertyDescriptors
  , kb = Object.getOwnPropertySymbols
  , uX = Object.prototype.hasOwnProperty
  , cX = Object.prototype.propertyIsEnumerable
  , Nb = (n,e,t)=>e in n ? oX(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , nf = (n,e)=>{
    for (var t in e || (e = {}))
        uX.call(e, t) && Nb(n, t, e[t]);
    if (kb)
        for (var t of kb(e))
            cX.call(e, t) && Nb(n, t, e[t]);
    return n
}
  , rf = (n,e)=>aX(n, lX(e))
  , eI = class extends O.Component {
    constructor(n) {
        super(n),
        this.ref = lt.createRef(),
        this.state = {
            style: {}
        };
        const e = {
            reverse: !1,
            max: 35,
            perspective: 1e3,
            easing: "cubic-bezier(.03,.98,.52,.99)",
            scale: "1.1",
            speed: "1000",
            transition: !0,
            axis: null,
            reset: !0
        };
        this.width = null,
        this.height = null,
        this.left = null,
        this.top = null,
        this.transitionTimeout = null,
        this.updateCall = null,
        this.element = null,
        this.settings = Object.assign({}, e, this.props.options),
        this.reverse = this.settings.reverse ? -1 : 1,
        this.onMouseEnter = this.onMouseEnter.bind(this, this.props.onMouseEnter),
        this.onMouseMove = this.onMouseMove.bind(this, this.props.onMouseMove),
        this.onMouseLeave = this.onMouseLeave.bind(this, this.props.onMouseLeave)
    }
    componentDidMount() {
        this.element = this.ref.current,
        setTimeout(()=>{
            this.element.parentElement.querySelector(":hover") === this.element && this.onMouseEnter()
        }
        , 0)
    }
    componentWillUnmount() {
        clearTimeout(this.transitionTimeout),
        cancelAnimationFrame(this.updateCall)
    }
    onMouseEnter(n=()=>{}
    , e) {
        return this.updateElementPosition(),
        this.setState(Object.assign({}, this.state, {
            style: rf(nf({}, this.state.style), {
                willChange: "transform"
            })
        })),
        this.setTransition(),
        n(e)
    }
    reset() {
        window.requestAnimationFrame(()=>{
            this.setState(Object.assign({}, this.state, {
                style: rf(nf({}, this.state.style), {
                    transform: `perspective(${this.settings.perspective}px) rotateX(0deg) rotateY(0deg) scale3d(1, 1, 1)`
                })
            }))
        }
        )
    }
    onMouseMove(n=()=>{}
    , e) {
        return e.persist(),
        this.updateCall !== null && window.cancelAnimationFrame(this.updateCall),
        this.event = e,
        this.updateCall = requestAnimationFrame(this.update.bind(this, e)),
        n(e)
    }
    setTransition() {
        clearTimeout(this.transitionTimeout),
        this.setState(Object.assign({}, this.state, {
            style: rf(nf({}, this.state.style), {
                transition: `${this.settings.speed}ms ${this.settings.easing}`
            })
        })),
        this.transitionTimeout = setTimeout(()=>{
            this.setState(Object.assign({}, this.state, {
                style: rf(nf({}, this.state.style), {
                    transition: ""
                })
            }))
        }
        , this.settings.speed)
    }
    onMouseLeave(n=()=>{}
    , e) {
        return this.setTransition(),
        this.settings.reset && this.reset(),
        n(e)
    }
    getValues(n) {
        const e = (n.nativeEvent.clientX - this.left) / this.width
          , t = (n.nativeEvent.clientY - this.top) / this.height
          , i = Math.min(Math.max(e, 0), 1)
          , r = Math.min(Math.max(t, 0), 1)
          , s = (this.reverse * (this.settings.max / 2 - i * this.settings.max)).toFixed(2)
          , o = (this.reverse * (r * this.settings.max - this.settings.max / 2)).toFixed(2)
          , a = i * 100
          , l = r * 100;
        return {
            tiltX: s,
            tiltY: o,
            percentageX: a,
            percentageY: l
        }
    }
    updateElementPosition() {
        const n = this.element.getBoundingClientRect();
        this.width = this.element.offsetWidth,
        this.height = this.element.offsetHeight,
        this.left = n.left,
        this.top = n.top
    }
    update(n) {
        const e = this.getValues(n);
        this.setState(Object.assign({}, this.state, {
            style: rf(nf({}, this.state.style), {
                transform: `perspective(${this.settings.perspective}px) rotateX(${this.settings.axis === "x" ? 0 : e.tiltY}deg) rotateY(${this.settings.axis === "y" ? 0 : e.tiltX}deg) scale3d(${this.settings.scale}, ${this.settings.scale}, ${this.settings.scale})`
            })
        })),
        this.updateCall = null
    }
    render() {
        const n = Object.assign({}, this.props.style, this.state.style);
        return xe("div", {
            style: n,
            ref: this.ref,
            className: this.props.className,
            onMouseEnter: this.onMouseEnter,
            onMouseMove: this.onMouseMove,
            onMouseLeave: this.onMouseLeave,
            children: this.props.children
        })
    }
}
;
const RM = n=>({
    hidden: {
        y: -50,
        opacity: 0
    },
    show: {
        y: 0,
        opacity: 1,
        transition: {
            type: "spring",
            duration: 1.25,
            delay: n
        }
    }
})
  , LM = (n,e,t,i)=>({
    hidden: {
        x: n === "left" ? 100 : n === "right" ? -100 : 0,
        y: n === "up" ? 100 : n === "down" ? -100 : 0,
        opacity: 0
    },
    show: {
        x: 0,
        y: 0,
        opacity: 1,
        transition: {
            type: e,
            delay: t,
            duration: i,
            ease: "easeOut"
        }
    }
})
  , cK = (n,e,t,i)=>({
    hidden: {
        x: n === "left" ? "-100%" : n === "right" ? "100%" : 0,
        y: n === "up" || n === "down" ? "100%" : 0
    },
    show: {
        x: 0,
        y: 0,
        transition: {
            type: e,
            delay: t,
            duration: i,
            ease: "easeOut"
        }
    }
})
  , fX = (n,e)=>({
    hidden: {},
    show: {
        transition: {
            staggerChildren: n,
            delayChildren: e || 0
        }
    }
})
  , qd = (n,e)=>function() {
    return ut(Qo.section, {
        variants: fX(),
        initial: "hidden",
        whileInView: "show",
        viewport: {
            once: !0,
            amount: .25
        },
        className: `${ni.padding} max-w-7xl mx-auto relative z-0`,
        children: [xe("span", {
            className: "hash-span",
            id: e,
            children: " "
        }), xe(n, {})]
    })
}
  , dX = ({index: n, title: e, icon: t})=>xe(eI, {
    className: "xs:w-[250px] w-full",
    children: xe(Qo.div, {
        variants: LM("right", "spring", n * .5, .75),
        className: "w-full green-pink-gradient p-[1px] rounded-[20px] shadow-card",
        children: ut("div", {
            options: {
                max: 45,
                scale: 1,
                speed: 450
            },
            className: "bg-tertiary rounded-[20px] py-5 px-12 min-h-[200px] flex justify-evenly items-center flex-col",
            children: [xe("img", {
                src: t,
                alt: e,
                className: "w-16 h-16 object-contain"
            }), xe("h3", {
                className: "text-white text-[20px] font-bold text-center",
                children: e
            })]
        })
    })
})
  , hX = ()=>ut(xd, {
    children: [ut(Qo.div, {
        variants: RM(),
        children: [xe("p", {
            className: ni.sectionSubText,
            children: "Introduction"
        }), xe("h2", {
            className: ni.sectionHeadText,
            children: "Overview."
        })]
    }), xe(Qo.p, {
        variants: LM("", "", .1, 1),
        className: "mt-4 text-secondary text-[17px] max-w-3xl leading-[30px]",
        children: BM.about
    }), xe("div", {
        className: "mt-20 flex flex-wrap gap-10",
        children: qJ.map((n,e)=>xe(dX, {
            index: e,
            ...n
        }, n.title))
    })]
})
  , tI = qd(hX, "about")
  , pX = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: tI
}, Symbol.toStringTag, {
    value: "Module"
}))
  , mX = ({index: n, title: e, icon: t})=>xe(eI, {
    className: "xs:w-[250px] w-full",
    children: xe("div", {
        className: "w-full green-pink-gradient p-[1px] rounded-[20px] shadow-card",
        children: ut("div", {
            options: {
                max: 45,
                scale: 1,
                speed: 450
            },
            className: "bg-tertiary rounded-[20px] py-5 px-12 min-h-[200px] flex justify-evenly items-center flex-col",
            children: [xe("img", {
                src: t,
                alt: e,
                className: "w-16 h-16 object-contain"
            }), xe("h3", {
                className: "text-white text-[20px] font-bold text-center",
                children: e
            })]
        })
    })
})
  , gX = ()=>ut(xd, {
    children: [ut("div", {
        className: "animate__animated animate__fadeInRight",
        children: [xe("p", {
            className: `${ni.sectionSubText} text-center`,
            children: "Languages I frequently use."
        }), xe("h2", {
            className: `${ni.sectionHeadText} text-center`,
            children: "Skills."
        })]
    }), xe("div", {
        className: "flex flex-row flex-wrap justify-center gap-10",
        children: $J.map((n,e)=>xe(mX, {
            index: e,
            title: n.name,
            icon: n.icon
        }, n.name))
    })]
})
  , yX = qd(gX, "");
var m0 = {}
  , Ag = {}
  , vX = {
    get exports() {
        return Ag
    },
    set exports(n) {
        Ag = n
    }
};
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(n) {
    (function() {
        var e = {}.hasOwnProperty;
        function t() {
            for (var i = [], r = 0; r < arguments.length; r++) {
                var s = arguments[r];
                if (s) {
                    var o = typeof s;
                    if (o === "string" || o === "number")
                        i.push(s);
                    else if (Array.isArray(s)) {
                        if (s.length) {
                            var a = t.apply(null, s);
                            a && i.push(a)
                        }
                    } else if (o === "object") {
                        if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]")) {
                            i.push(s.toString());
                            continue
                        }
                        for (var l in s)
                            e.call(s, l) && s[l] && i.push(l)
                    }
                }
            }
            return i.join(" ")
        }
        n.exports ? (t.default = t,
        n.exports = t) : window.classNames = t
    }
    )()
}
)(vX);
m0.__esModule = !0;
m0.default = void 0;
var xX = IM(O)
  , mo = IM(dg)
  , _X = IM(Ag);
function IM(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
const nI = ({animate: n=!0, className: e="", layout: t="2-columns", lineColor: i="#FFF", children: r})=>(typeof window == "object" && document.documentElement.style.setProperty("--line-color", i),
xX.default.createElement("div", {
    className: (0,
    _X.default)(e, "vertical-timeline", {
        "vertical-timeline--animate": n,
        "vertical-timeline--two-columns": t === "2-columns",
        "vertical-timeline--one-column-left": t === "1-column" || t === "1-column-left",
        "vertical-timeline--one-column-right": t === "1-column-right"
    })
}, r));
nI.propTypes = {
    children: mo.default.oneOfType([mo.default.arrayOf(mo.default.node), mo.default.node]).isRequired,
    className: mo.default.string,
    animate: mo.default.bool,
    layout: mo.default.oneOf(["1-column-left", "1-column", "2-columns", "1-column-right"]),
    lineColor: mo.default.string
};
var AX = nI;
m0.default = AX;
var g0 = {};
function p_() {
    return p_ = Object.assign || function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }
    ,
    p_.apply(this, arguments)
}
function MX(n, e) {
    n.prototype = Object.create(e.prototype),
    n.prototype.constructor = n,
    m_(n, e)
}
function m_(n, e) {
    return m_ = Object.setPrototypeOf || function(i, r) {
        return i.__proto__ = r,
        i
    }
    ,
    m_(n, e)
}
function wX(n, e) {
    if (n == null)
        return {};
    var t = {}, i = Object.keys(n), r, s;
    for (s = 0; s < i.length; s++)
        r = i[s],
        !(e.indexOf(r) >= 0) && (t[r] = n[r]);
    return t
}
var g_ = new Map
  , am = new WeakMap
  , Ob = 0
  , iI = void 0;
function SX(n) {
    iI = n
}
function CX(n) {
    return n ? (am.has(n) || (Ob += 1,
    am.set(n, Ob.toString())),
    am.get(n)) : "0"
}
function EX(n) {
    return Object.keys(n).sort().filter(function(e) {
        return n[e] !== void 0
    }).map(function(e) {
        return e + "_" + (e === "root" ? CX(n.root) : n[e])
    }).toString()
}
function TX(n) {
    var e = EX(n)
      , t = g_.get(e);
    if (!t) {
        var i = new Map, r, s = new IntersectionObserver(function(o) {
            o.forEach(function(a) {
                var l, c = a.isIntersecting && r.some(function(d) {
                    return a.intersectionRatio >= d
                });
                n.trackVisibility && typeof a.isVisible > "u" && (a.isVisible = c),
                (l = i.get(a.target)) == null || l.forEach(function(d) {
                    d(c, a)
                })
            })
        }
        ,n);
        r = s.thresholds || (Array.isArray(n.threshold) ? n.threshold : [n.threshold || 0]),
        t = {
            id: e,
            observer: s,
            elements: i
        },
        g_.set(e, t)
    }
    return t
}
function DM(n, e, t, i) {
    if (t === void 0 && (t = {}),
    i === void 0 && (i = iI),
    typeof window.IntersectionObserver > "u" && i !== void 0) {
        var r = n.getBoundingClientRect();
        return e(i, {
            isIntersecting: i,
            target: n,
            intersectionRatio: typeof t.threshold == "number" ? t.threshold : 0,
            time: 0,
            boundingClientRect: r,
            intersectionRect: r,
            rootBounds: r
        }),
        function() {}
    }
    var s = TX(t)
      , o = s.id
      , a = s.observer
      , l = s.elements
      , c = l.get(n) || [];
    return l.has(n) || l.set(n, c),
    c.push(e),
    a.observe(n),
    function() {
        c.splice(c.indexOf(e), 1),
        c.length === 0 && (l.delete(n),
        a.unobserve(n)),
        l.size === 0 && (a.disconnect(),
        g_.delete(o))
    }
}
var bX = ["children", "as", "triggerOnce", "threshold", "root", "rootMargin", "onChange", "skip", "trackVisibility", "delay", "initialInView", "fallbackInView"];
function Ub(n) {
    return typeof n.children != "function"
}
var Mg = function(n) {
    MX(e, n);
    function e(i) {
        var r;
        return r = n.call(this, i) || this,
        r.node = null,
        r._unobserveCb = null,
        r.handleNode = function(s) {
            r.node && (r.unobserve(),
            !s && !r.props.triggerOnce && !r.props.skip && r.setState({
                inView: !!r.props.initialInView,
                entry: void 0
            })),
            r.node = s || null,
            r.observeNode()
        }
        ,
        r.handleChange = function(s, o) {
            s && r.props.triggerOnce && r.unobserve(),
            Ub(r.props) || r.setState({
                inView: s,
                entry: o
            }),
            r.props.onChange && r.props.onChange(s, o)
        }
        ,
        r.state = {
            inView: !!i.initialInView,
            entry: void 0
        },
        r
    }
    var t = e.prototype;
    return t.componentDidUpdate = function(r) {
        (r.rootMargin !== this.props.rootMargin || r.root !== this.props.root || r.threshold !== this.props.threshold || r.skip !== this.props.skip || r.trackVisibility !== this.props.trackVisibility || r.delay !== this.props.delay) && (this.unobserve(),
        this.observeNode())
    }
    ,
    t.componentWillUnmount = function() {
        this.unobserve(),
        this.node = null
    }
    ,
    t.observeNode = function() {
        if (!(!this.node || this.props.skip)) {
            var r = this.props
              , s = r.threshold
              , o = r.root
              , a = r.rootMargin
              , l = r.trackVisibility
              , c = r.delay
              , d = r.fallbackInView;
            this._unobserveCb = DM(this.node, this.handleChange, {
                threshold: s,
                root: o,
                rootMargin: a,
                trackVisibility: l,
                delay: c
            }, d)
        }
    }
    ,
    t.unobserve = function() {
        this._unobserveCb && (this._unobserveCb(),
        this._unobserveCb = null)
    }
    ,
    t.render = function() {
        if (!Ub(this.props)) {
            var r = this.state
              , s = r.inView
              , o = r.entry;
            return this.props.children({
                inView: s,
                entry: o,
                ref: this.handleNode
            })
        }
        var a = this.props
          , l = a.children
          , c = a.as
          , d = wX(a, bX);
        return O.createElement(c || "div", p_({
            ref: this.handleNode
        }, d), l)
    }
    ,
    e
}(O.Component);
Mg.displayName = "InView";
Mg.defaultProps = {
    threshold: 0,
    triggerOnce: !1,
    initialInView: !1
};
function PX(n) {
    var e = n === void 0 ? {} : n
      , t = e.threshold
      , i = e.delay
      , r = e.trackVisibility
      , s = e.rootMargin
      , o = e.root
      , a = e.triggerOnce
      , l = e.skip
      , c = e.initialInView
      , d = e.fallbackInView
      , h = O.useRef()
      , p = O.useState({
        inView: !!c
    })
      , m = p[0]
      , y = p[1]
      , v = O.useCallback(function(x) {
        h.current !== void 0 && (h.current(),
        h.current = void 0),
        !l && x && (h.current = DM(x, function(A, M) {
            y({
                inView: A,
                entry: M
            }),
            M.isIntersecting && a && h.current && (h.current(),
            h.current = void 0)
        }, {
            root: o,
            rootMargin: s,
            threshold: t,
            trackVisibility: r,
            delay: i
        }, d))
    }, [Array.isArray(t) ? t.toString() : t, o, s, a, l, r, d, i]);
    O.useEffect(function() {
        !h.current && m.entry && !a && !l && y({
            inView: !!c
        })
    });
    var _ = [v, m.inView, m.entry];
    return _.ref = _[0],
    _.inView = _[1],
    _.entry = _[2],
    _
}
const BX = Object.freeze(Object.defineProperty({
    __proto__: null,
    InView: Mg,
    default: Mg,
    defaultFallbackInView: SX,
    observe: DM,
    useInView: PX
}, Symbol.toStringTag, {
    value: "Module"
}))
  , RX = $I(BX);
g0.__esModule = !0;
g0.default = void 0;
var go = FM(O)
  , Qt = FM(dg)
  , lm = FM(Ag)
  , LX = RX;
function FM(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
const rI = ({children: n="", className: e="", contentArrowStyle: t=null, contentStyle: i=null, date: r="", dateClassName: s="", icon: o=null, iconClassName: a="", iconOnClick: l=null, onTimelineElementClick: c=null, iconStyle: d=null, id: h="", position: p="", style: m=null, textClassName: y="", intersectionObserverProps: v={
    rootMargin: "0px 0px -40px 0px",
    triggerOnce: !0
}, visible: _=!1})=>go.default.createElement(LX.InView, v, ({inView: x, ref: A})=>go.default.createElement("div", {
    ref: A,
    id: h,
    className: (0,
    lm.default)(e, "vertical-timeline-element", {
        "vertical-timeline-element--left": p === "left",
        "vertical-timeline-element--right": p === "right",
        "vertical-timeline-element--no-children": n === ""
    }),
    style: m
}, go.default.createElement(go.default.Fragment, null, go.default.createElement("span", {
    style: d,
    onClick: l,
    className: (0,
    lm.default)(a, "vertical-timeline-element-icon", {
        "bounce-in": x || _,
        "is-hidden": !(x || _)
    })
}, o), go.default.createElement("div", {
    style: i,
    onClick: c,
    className: (0,
    lm.default)(y, "vertical-timeline-element-content", {
        "bounce-in": x || _,
        "is-hidden": !(x || _)
    })
}, go.default.createElement("div", {
    style: t,
    className: "vertical-timeline-element-content-arrow"
}), n, go.default.createElement("span", {
    className: (0,
    lm.default)(s, "vertical-timeline-element-date")
}, r)))));
rI.propTypes = {
    children: Qt.default.oneOfType([Qt.default.arrayOf(Qt.default.node), Qt.default.node]),
    className: Qt.default.string,
    contentArrowStyle: Qt.default.shape({}),
    contentStyle: Qt.default.shape({}),
    date: Qt.default.node,
    dateClassName: Qt.default.string,
    icon: Qt.default.element,
    iconClassName: Qt.default.string,
    iconStyle: Qt.default.shape({}),
    iconOnClick: Qt.default.func,
    onTimelineElementClick: Qt.default.func,
    id: Qt.default.string,
    position: Qt.default.string,
    style: Qt.default.shape({}),
    textClassName: Qt.default.string,
    visible: Qt.default.bool,
    intersectionObserverProps: Qt.default.shape({
        root: Qt.default.object,
        rootMargin: Qt.default.string,
        threshold: Qt.default.number,
        triggerOnce: Qt.default.bool
    })
};
var IX = rI;
g0.default = IX;
var sI = {
    VerticalTimeline: m0.default,
    VerticalTimelineElement: g0.default
};
const DX = ({experience: n})=>ut(sI.VerticalTimelineElement, {
    contentStyle: {
        background: "#1d1836",
        color: "#fff"
    },
    contentArrowStyle: {
        borderRight: "7px solid  #232631"
    },
    date: n.date,
    iconStyle: {
        background: n.iconBg
    },
    icon: xe("div", {
        className: "flex justify-center items-center w-full h-full",
        children: xe("img", {
            src: n.icon,
            alt: n.company_name,
            className: "w-[60%] h-[60%] object-contain"
        })
    }),
    children: [ut("div", {
        children: [xe("h3", {
            className: "text-white text-[24px] font-bold",
            children: n.title
        }), xe("p", {
            className: "text-secondary text-[16px] font-semibold",
            style: {
                margin: 0
            },
            children: n.company_name
        })]
    }), xe("ul", {
        className: "mt-5 list-disc ml-5 space-y-2",
        children: n.points.map((e,t)=>xe("li", {
            className: "text-white-100 text-[14px] pl-1 tracking-wider",
            children: e
        }, `experience-point-${t}`))
    })]
})
  , FX = ()=>ut(xd, {
    children: [ut(Qo.div, {
        variants: RM(),
        children: [xe("p", {
            className: `${ni.sectionSubText} text-center`,
            children: "What I have done so far"
        }), xe("h2", {
            className: `${ni.sectionHeadText} text-center`,
            children: "Work Experience."
        })]
    }), xe("div", {
        className: "mt-20 flex flex-col",
        children: xe(sI.VerticalTimeline, {
            children: eX.map((n,e)=>xe(DX, {
                experience: n
            }, `experience-${e}`))
        })
    })]
})
  , kX = qd(FX, "work")
  , NX = ({index: n, name: e, description: t, tags: i, image: r, source_code_link: s, project_link: o})=>xe("div", {
    children: ut("div", {
        className: "bg-tertiary p-5 rounded-2xl sm:w-[360px] w-full",
        children: [ut("div", {
            className: "relative w-full h-[230px]",
            children: [xe("img", {
                src: r,
                alt: "project_image",
                className: "w-full h-full object-cover rounded-2xl"
            }), ut("div", {
                className: "absolute inset-0 flex justify-end m-3 card-img_hover",
                children: [o != "" && xe("div", {
                    onClick: ()=>window.open(o, "_blank"),
                    className: "black-gradient w-10 h-10 rounded-full flex justify-center items-center cursor-pointer mr-1",
                    children: xe("img", {
                        src: c3,
                        alt: "Project Link",
                        className: "w-1/2 h-1/2 object-contain"
                    })
                }), s != "" && xe("div", {
                    onClick: ()=>window.open(s, "_blank"),
                    className: "black-gradient w-10 h-10 rounded-full flex justify-center items-center cursor-pointer",
                    children: xe("img", {
                        src: JN,
                        alt: "source code",
                        className: "w-1/2 h-1/2 object-contain"
                    })
                })]
            })]
        }), ut("div", {
            className: "mt-5",
            children: [xe("h3", {
                className: "text-white font-bold text-[24px]",
                children: e
            }), xe("p", {
                className: "mt-2 text-secondary text-[14px]",
                children: t
            })]
        }), xe("div", {
            className: "mt-4 flex flex-wrap gap-2",
            children: i.map(a=>ut("p", {
                className: `text-[14px] ${a.color}`,
                children: ["#", a.name]
            }, `${e}-${a.name}`))
        })]
    })
})
  , OX = ()=>ut(xd, {
    children: [ut("div", {
        className: "animate__animated animate__fadeInRight",
        children: [xe("p", {
            className: `${ni.sectionSubText} text-center`,
            children: "My work"
        }), xe("h2", {
            className: `${ni.sectionHeadText} text-center`,
            children: "Projects."
        })]
    }), xe("div", {
        className: "w-full flex",
        children: xe("div", {
            className: "animate__animated animate__fadeInRight",
            children: BM.work
        })
    }), xe("div", {
        className: "mt-20 flex flex-wrap gap-7",
        children: rX.map((n,e)=>xe(NX, {
            index: e,
            ...n
        }, `project-${e}`))
    })]
})
  , oI = qd(OX, "projects")
  , UX = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: oI
}, Symbol.toStringTag, {
    value: "Module"
}))
  , zX = ({index: n, testimonial: e, name: t, designation: i, company: r, image: s})=>ut(Qo.div, {
    variants: LM("", "spring", n * .5, .75),
    className: "bg-black-200 p-10 rounded-3xl xs:w-[320px] w-full",
    children: [xe("p", {
        className: "text-white font-black text-[48px]",
        children: '"'
    }), ut("div", {
        className: "mt-1",
        children: [xe("p", {
            className: "text-white tracking-wider text-[18px]",
            children: e
        }), ut("div", {
            className: "mt-7 flex justify-between items-center gap-1",
            children: [ut("div", {
                className: "flex-1 flex flex-col",
                children: [ut("p", {
                    className: "text-white font-medium text-[16px]",
                    children: [xe("span", {
                        className: "blue-text-gradient",
                        children: "@"
                    }), " ", t]
                }), ut("p", {
                    className: "mt-1 text-secondary text-[12px]",
                    children: [i, " ", r != "" && "of", " ", r]
                })]
            }), xe("img", {
                src: s,
                alt: `feedback_by-${t}`,
                className: "w-10 h-10 rounded-full object-cover"
            })]
        })]
    })]
})
  , GX = ()=>ut("div", {
    className: "mt-12 bg-black-100 rounded-[20px]",
    children: [xe("div", {
        className: `bg-tertiary rounded-2xl ${ni.padding} min-h-[300px]`,
        children: ut(Qo.div, {
            variants: RM(),
            children: [xe("p", {
                className: ni.sectionSubText,
                children: "What others say"
            }), xe("h2", {
                className: ni.sectionHeadText,
                children: "Testimonials."
            })]
        })
    }), xe("div", {
        className: `-mt-20 pb-14 ${ni.paddingX} flex flex-wrap gap-7`,
        children: tX.map((n,e)=>xe(zX, {
            index: e,
            ...n
        }, n.name))
    })]
})
  , HX = qd(GX, "");
const VX = ()=>ut(xd, {
    children: [ut("div", {
        className: "relative z-0",
        children: [xe(sX, {}), xe(GV, {})]
    }), xe(tI, {}), xe(kX, {}), xe(yX, {}), xe(oI, {}), xe(HX, {})]
})
  , WX = lt.lazy(()=>Ug(()=>import("./User-9ab09279.js"), [], import.meta.url))
  , jX = lt.lazy(()=>Ug(()=>Promise.resolve().then(()=>pX), void 0, import.meta.url))
  , JX = lt.lazy(()=>Ug(()=>Promise.resolve().then(()=>UX), void 0, import.meta.url))
  , XX = lt.lazy(()=>Ug(()=>import("./Admin-a4b150ac.js"), [], import.meta.url));
function KX() {
    return ut(BN, {
        children: [ut(CN, {
            children: [ut(Zl, {
                path: "/",
                element: xe(O.Suspense, {
                    fallback: xe(OC, {}),
                    children: xe(WX, {})
                }),
                children: [xe(Zl, {
                    path: "",
                    element: xe(VX, {})
                }), xe(Zl, {
                    path: "about",
                    element: xe(jX, {})
                }), xe(Zl, {
                    path: "projects",
                    element: xe(JX, {})
                })]
            }), xe(Zl, {
                path: "admin",
                element: xe(O.Suspense, {
                    fallback: xe(OC, {}),
                    children: xe(XX, {})
                })
            })]
        }), xe(WN, {
            position: "bottom-right",
            stacked: !0,
            limit: 10
        })]
    })
}
ex.createRoot(document.getElementById("root")).render(xe(lt.StrictMode, {
    children: xe(KX, {})
}));
export {Jt as B, PR as C, tK as F, ea as G, QX as L, CV as O, UR as P, qd as S, ut as a, NV as b, cK as c, uK as d, nK as e, eK as f, ZX as g, $X as h, qX as i, xe as j, iK as k, YX as l, Qo as m, lK as n, GV as o, jN as p, O as r, ni as s, rM as u};
